Note also that I removed the useless default from the beginning of the switch, added it again at the end, and threw an exception for invalid values. I also simplified cases 2 and 3 ( can be phrased as ), and I combined the two continue conditions. 

If your main concern is performance, your approach seems a lot better (it doesn't create a bunch of new objects). However, when I timed it, my approach was about 3 times as fast. 

From a security standpoint, you want to regenerate the session id when the session state changes, to prevent session fixation. So you definitely want to do that when the session is created, and on subsequent writes. Additionally, you could regenerate the id in intervals of X minutes, but a regeneration on each request is not needed and causes unnecessary overhead (and may actually cause problems if requests overlap). Misc 

Your plan sounds good, I don't have much to add to it. What you may want to do is create a (UML) class diagram to help you plan out the structure of your code (even though it's a bit of extra work, it's often really helpful to get an overview first, instead of coding something, realizing that something is missing, and just putting it into the first place that fits). Structure You already have a vision of where you want to end up, which is good, as it can help you learn to plan ahead when designing your code, and make it easily extendable. However, right now, your code is not all that extendable. For example, you have a plan to accept input from different sources than the command line (in your case a GUI and an AI). If you want to add that later on, you would have to change your class. But the class shouldn't actually care where input comes from. It should manage the game logic, nothing more. Currently, it's responsible to read input, print output, create the players, etc, making it more difficult to apply changes. So a first step would be to extract that functionality. Create a and interface, and then concrete implementations of them (in your case that would be and ). Methods may be something like , , , , etc. You then want to pass those concrete implementations on to your class via the constructor. That way, you can later just pass different implementations when you want to implement an AI or a GUI. You might also want to add some more classes, such as a class to help you handle this. When doing this restructuring, always keep in mind what functionality you might want to add in the future. Would it be easy to add animation with your current structure? How about an AI? etc. 

It's not optimal, but I think that it is acceptable. You wouldn't even have to prevent the user from using those characters though, just split by the last occurrence (or from back to front if you have more than two values later on). Printing Serverside on the server doesn't make that much sense. Nobody is going to read them, and they take up resources. I'm assuming that they are debug statements, but having so many of them makes them hard to handle (will you always comment all out when deploying, and then uncomment again when debugging?) If you want to keep it simple, you could at least extract the printing to a separate method, so that you only have to change code in one place (then you could add an if based on a config file, comment/uncomment the print, or print to a file). Error Handling Why are you turning a perfectly fine exception in into a boolean return value? Malformed input seems like an exceptional case, so it can be handled with exceptions. Quite often, you catch an exception, print an error message, and that's it. That doesn't seem like a good idea. I would log the errors to a file, and I would inform the user about it (add a method). Just silently failing will make debugging later on quite difficult and it will also be frustrating for a user if they are not informed about failures and possible reasons for them (is the input malformed, or does the server have problems? this is something a user would probably like to know). should probably also log and inform the user. And an invalid integer should also throw an exception, not set the score to 0. Misc 

Apart from that, it is customary to expire forgotten-password-links. The reason for this is that an attacker who can read data from the database can get into users accounts without having to decrypt the passwords. Nesting Your code is too deeply nested, making it hard to read. If you have 6 closing elses in a row, it is really hard to see which if they actually close. You can reduce nesting by reversing your ifs: 

toString I would expect the method to print the current state of the object (the current value of the address chunks). But yours seems to always print static data (the methods name). 

Yes. (assuming it is used correctly, which means no variable input in the ever; and also assuming that this isn't an issue) 

You say that you use prepared statements, but your code doesn't actually reflect that. just executes any query, without binding or escaping anything. You really need to use prepared statements though. Your current function isn't usable in practice and it's pure existence will likely lead to vulnerabilities (other programmers will likely use it as it exists, and it can't be used securely). Apart from that: 

Not a full review, just some initial thoughts: Returning Strings Almost all of your method return strings, which makes a class hard to use and extremely hard to test. You can easily see this looking at the tests you did implement. What if the message changes? Now all your tests are broken, even though the logic didn't change at all. [and just as an aside: testing a string return value in these cases doesn't really test the correctness of the methods] In most cases, returning nothing would be the better choice. For example, why should be responsible to format and return a score string? It should only start a game. should also only add a goal, it shouldn't need to print or return anything. Misc 

I think that this would be a pretty good solution. It looks nice and uniform, but not too verbose. Here are some other format ideas, reducing the amount of lines for the comment to two or one. They are not necessarily better, but they are shorter: 

I don't have a comment regarding the algorithm right now, just the general code structure. Comments Some comments are unnecessary and those make it harder to find the actually useful comments. After a while, people will just ignore all you comments. For example: 

I wouldn't say so. I would only use a constants class for things which are not part of the state of any objects, and which do not expose the inner workings of objects (eg a debug field, database credentials, fixed strings for user output, etc). The numbers in (which should be all upper case) seem to be random numbers (as in, they are not numbers a musician would recognize, but numbers that are specific to your program). They also seem to interact with , which is not good (see below). isn't really needed at all. is the only value that I might leave in a constants class. 

[*] should be ok for , as it is very unlikely that the function will be changed to return anything else than or in the future. On the other hand, it is PHP, so who knows. And , , , , are all . 

Regarding security, this obviously doesn't matter, but regarding usability, it may be improved upon. You are currently checking very different things server- and client-side. Server-side, you are checking the extension - which is the right thing to do, PHP type checks aren't very reliable - but client-side, you are checking the type. This should be handled uniformly, to avoid the case that your client-side scripts allows an upload, but your server-side script forbids it (a valid .html file for example), or the case where your server-side script would allow an upload, but your client-side script forbids it (an audio/mp4 file for example). You may want to consider performing extension- as well as filetype-checks on both sides. You may also consider extracting your validation code, and share the same code (eg the types/extensions) across js and PHP to avoid discrepancies (some frameworks will do this for you). Misc 

Now, you currently do have a regex on the username which would make it impossible to exploit this. But what if your requirements change? What if you want to allow to sign up as well? You might change that regex, and then be vulnerable. You should really always use prepared statements, not only most of the time. Possible future XSS Same problem as above, if the regex changes and is allowed, this is vulnerable to XSS: 

Not for the password, but for the email, it can be avoided. As the problem statements says, use HTML5 email validation (it works automatically for type email, no need for a pattern; and your pattern is way too strict, disallowing a lot of valid email addresses). 

Yes. Generally, "routing" describes the process of mapping URLs to code in some form. The standard example would be mapping a URL to a method of a controller. On the other hand, "rewriting" doesn't map a URL to code, but maps a URL to a different URL. [But both terms are often not 100% clearly defined, and are sometimes used interchangably] Security: DOS If I visit your directly, without giving any parameters, I get an infinite loop in . You shouldn't need a while loop here, replacing the script path without the index.php file name in the request parameter should do the same thing. Security: Directory Traversal Your file is likely open to directory traversal and LFI in Windows (I don't have a Windows machine to test right now, but using should work). With current PHP versions, it is restricted to PHP files, but it should probably still be fixed. Correctness: URL encoding Because you use , the values you get will be URL encoded. So if I visit , I would get instead of the expected result. For the example this may be fine, but it will likely cause bugs in the future. Do note though that the URL encoding is currently all that protects you from XSS (and that the encoding happens client-side, so you should not necessarily trust it). Approach If it's just about mapping to , I would probably use Apache URL rewriting exclusively (I'm no expert, but it should certainly be possible). If you want the URL routing functionality, I would probably go with a more extended approach, which lets me define a whitelist of allowed URLs, and maps them to a controller method. 

The first step to fixing this is to find out what is causing the delay. My first assumption would be that it is the hardware on the other end of the connection, but who knows. To figure this out, you can do two things: 

Another question is if this is actually the best approach. That question really doesn't make so much sense. You could use which seems to have been written exactly for cases like this, or throw your own NullPointerException if you want to. 

Naming I think is not the only naming problem in your code. A function parameter should not be a single letter except in a very limited number of cases. But I don't think that this is not one of them; a reader does not automatically understand what actually does. I would also rename , because it is unclear what means. What I think your function does is show the first n passengers, and hide the rest. If that is the case, I would not use , because as you said, there really is no toggling going on. You could go with something like to avoid this confusion, although it's a bit unconcrete. Whatever name you do choose, I would add a comment to the function explaining what it does. Misc 

Variable Names Good variable names are important, because they make the code readable. Many of your names are good, but and could be a lot better. Formatting 

You could remove the check (which probably just checks ), as in that case, the for loop will not be entered and the exception at the end will be thrown. And I think that your cases are fine as they are. If you want to, you could pull one or more of them out of the loop: 

That is way too much. Each of these tasks should be happening in a designated class. You should definitely take a look at MVC, it might help you get an idea how you might want to structure your code. Your class doesn't seem to really route anything. I would expect it to take a route such as and call the code that is responsible to edit the user with the id 1.