By doing this we can see that they aren't really so much different methods, as they are the same method operating on different data. You could take it a step further and introduce a private class : 

I get a time of 0.36s, which I'll take as the baseline. Great, but let's assume we can't write . We can create an equivalent method dynamically. We introduce some helper methods: 

pegs the CPU. Two metronomes increases my CPU usage from ~10% to 50%; four metronomes takes it up to 100%. Take a look at for a way of getting the same sort of functionality without using up all the CPU. 

The code can be sped up, and it can also be simplified. For , there is a unique way to write a balanced string as where and are balanced strings. and must have pairs of parentheses, total. This leads us to the following solution: 

So we're looking for the longest contiguous sequence that appears in the input, and its reversal. This sounds like another problem, longest common substring (LCS). In particular, $$ maxMirror(S) = LCS(S, T) $$ where \$T\$ is \$S\$ reversed. If we can solve LCS, then we have a solution to . Using dynamic programming, we can solve LCS in \$O(n^2)\$ time, with \$O(n)\$ space. The pseudocode in that article is pretty good, so let's translate that to C#: 

It looks good! Here are some issues I found. Readability I would recommend over for readability. Naming Greatest common divisor is a more standard term for greatest common denominator. MinValue should be , not . Immutability Since your data structure is immutable, this code 

and are much easier to read than and . Consider using multiple return statements, instead of just the one. Stick to the naming conventions: change the parameter to , and the variable to . It's a good idea to document that this is relative to UTC time, otherwise users might get strange behaviour like this: 

The methods and are identical except for one variable, and could (unless you're planning on changing them) just call in to a common method. 

* Hopefully without introducing errors. ** This is a little bit nicer in C# since we have the overload of that takes an parameter: 

There seems to be a bug where is not properly recalculated after a call to . Here is the failing test: 

First of all, you have one too many parentheses and are missing some variable declarations, so let's fix that up. 

This field can (and should) be made private. We don't want strangers messing around with our rovers! While we're at it, let's change the name from to -- we don't need the name to reflect the fact that it's a list of rovers. Finally, we can make the field . 

It's clear from your code that the length of the sum is at most , so we can do away with the , copying to a , and reversing. 

Given your clarification in the comments that your are getting organizations from a database, you should let the database do the hard work for you. The code will depend upon the ORM you're using, but a relatively SQL-agnostic version of the query will look like this: 

I ran a test of printing the semi-perfect numbers under 500. On my machine, this method takes the run-time down from ~25s to ~0.9s. In practice, you can use an instead of a for your counter, since if a number has more than 32 proper divisors, you will be waiting a long, long time. 

As the digits are 1-9, there's no way to represent 'j' (10) or 't' (20). I'm guessing that's a mistake in the question. 

Great. One method to go. Finding the most frequently occurring whatever has popped up on Code Review a few times, and you have the basic solution, but I'll add this here for completeness' sake. 

There are other possible choices for , but let's stick with this for now. The original definition of looks a bit off: 

We now need to decide where each element should go. Let's look at your example: \begin{align} A &= \left\{ a, b, c, d \right\} \\ B &= \left\{ b, e, f, g \right\} \\ C &= \left\{ c, e, h, i \right\} \end{align} The resulting sets are \begin{array}{ c | c | c | c } & \in A & \in B & \in C \\ \hline a & \mbox{t} & \mbox{f} & \mbox{f} \\ d & \mbox{t} & \mbox{f} & \mbox{f} \\ \hline b & \mbox{t} & \mbox{t} & \mbox{f} \\ \hline c & \mbox{t} & \mbox{f} & \mbox{t} \\ \hline e & \mbox{f} & \mbox{t} & \mbox{t} \\ \hline f & \mbox{f} & \mbox{t} & \mbox{f} \\ g & \mbox{f} & \mbox{t} & \mbox{f} \\ \hline h & \mbox{f} & \mbox{f} & \mbox{t} \\ i & \mbox{f} & \mbox{f} & \mbox{t} \end{array} So it seems we should put into a new set based on its containment in each of the original sets. Let's use a binary string to represent this: 

(I would much prefer returning -1 if no match is found, but requirements are requirements.) Now we can build on top of this to deal with the second preference: 

First of all, I think there is an off-by-one error in your code. From my understanding of the question, the correct output for 

A more efficient way of shuffling is the Fisher-Yates shuffle aka the Knuth shuffle. An implementation might look like this: 

defers to 's , which makes no guarantees that it won't return . How unlikely is it? Well I've had a program running for fifteen minutes now to find a with a hash code of and I've only found one, but it can happen and it's good to be aware of (and fix!). One neat way to fix the bug would be 

That's not an appropriate use of , "The exception that is thrown when there is an attempt to dereference a null object reference". 

Bug fix As I mentioned in the comments, should be . API The only time you return , is when you set to . I would suggest changing the function signature to 

Your definition of is very close to this, but we can use the following trick where refers to itself, just as in the formula above: 

As @vnp stated, there is no known efficient (i.e. polynomial-time) solution to the subset sum problem. That said, your code can be made to run faster, but first I want to address a few points. 

This is a solution to CodeEval's SkyScrapers challenge. You are given a list of triples \$(l, h, r)\$. Each triple represents an axis-aligned rectangle, with top-left corner at \$(l, h)\$ and bottom-right corner at \$(r, 0)\$. You can imagine these rectangles as buildings against a skyline. The task is to "draw" the skyline, by printing a list of points \$(x, h)\$ where the line drawing of the skyline changes from horizontal to vertical, and \$h\$ is the height of the vertical line. For all heights \$h\$, \$1 \leq h \leq 100\$. For all \$x\$-coordinates, \$1 \leq x \leq 10{,}000\$. There are at most \$1{,}000\$ rectangles/buildings. Examples: 

And then create the method dynamically, using reflection to find the properties of that have the attribute. 

First up, that has to be one of the most niche functions I've ever seen :) Is there a real use case? Is this homework? The prefix seems strange. You obviously can't call it , and the definition of the function is so odd to me that I can't think of another name right now, but I would recommend thinking hard about the name. I would recommend installing . It will give you suggestions on keeping code clean, and using standard functions. For instance, 

On my machine, these changes reduced the running time of (not calling ) on an array of 1,000,000 random ints from ~2.6s to ~1s (Mono 3.10.0, Debug x86). 

This takes ~2.1s on my machine. Just for fun, let's look at what pgAdmin's EXPLAIN visualisation looks like for this query 

looks strange to me; I think would be a better name. is a good candidate for a property since we're just returning the result of a quick comparison, so let's change this 

I find the logic a bit hard to follow, especially in , so I'll just comment on some minor issues and post some recommended reading. 

Documentation This is quite a lot of code. I can tell you've put some effort into the naming of methods, but comments describing the purpose of each would go a long way. Imagine that you're looking at this code for the first time -- is it clear to you what the output of a call to should be? What conditions will hold on the result? For example, I believe the following are true (correct me if I'm wrong) and worth documenting: 

Now we need the down-left neighbours: $$ \begin{pmatrix} 0 & & 3 & & 6 & & 9 \\ & \swarrow & & \swarrow & & \swarrow \\ 1 & & 4 & & 7 & & 10 \\ & \swarrow & & \swarrow & & \swarrow \\ 2 & & 5 & & 8 & & 11 \end{pmatrix} $$ Handily, we can get down-left neighbours by adding one line