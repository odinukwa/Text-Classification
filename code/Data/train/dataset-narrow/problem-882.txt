The number of possible digits is 16 (10 - (-5) +1). After counting them, we end up with a digits array that looks like this: 

function can help you. Namespaces Unless you know what you're doing don't use . Abstractions Now let's have a look at one item exchange 

The qualified import here is good, but your module header is missing. Since there is no documentation you don't want to export some functions, for example the partial . 

That way you only have to create the mask once and then only use bitwise AND, which usually gets compiled into a single CPU instruction. When working with list, you want to add elements at the front, not at the back. Instead of 

This has the nice side-effect that has now a type. The compiler can now warn you when you try to compare it to other, signed types. Prefer references instead of pointers Not only are they easier to use, they also are harder to get wrong. Use on call-by-reference/-pointer arguments that are not changed You never change , and , yet you didn't use . We could have changed their values accidentally. A will prevent this: 

However, even then, it's not the correct property of a binary search tree. Have a look at the following tree: 

Either is prime and returns , or it isn't. There is no need to check twice. is usually called a "smart constructor", by the way. 

Using wrappers is fine. For example, the in the package is just a wrapper around . And although it doesn't export its constructor, is also just a of . Maybe it feels more natural with the helper functions: 

Note that you need to take care of the last group of numbers. Even better, traverse the vector group-wise: 

We now count down from to in . Whenever we reached , we have all elements. This removes the need for . At this point is almost the same as , so we can get rid of it: 

We lifted the part out of the function. Also, instead of a list, we return a pair. We really want two and only two values as a result. Not arbitrary many, which is modelled with a list. The implementation doesn't differ too much from yours, apart from the pair and some removed magic numbers: 

But that's more or less a personal preference. A major nitpick though is that you take the of the list in every iteration. You can get rid of that if you write another function: 

Now we only need to check \$\left\lceil \sqrt{600851475143}\right\rceil = 775147\$ numbers, which is much, much less. This variant will actually finish in under one second, whereas I didn't run my program till the end. However, you now have to sort your list, or use followed by in , whose name would be then mostly (beside the ) apt. If you rewrite so that it returns the largest prime from a given list, we would end up with the following : 

That's a lot easier to read, isn't it? Use a \$\mathcal O(1) \$ data structure with low constants for jumps We can decrease the time tremendously if we use a instead of a . We sacrifice a little bit of memory, but that's almost not noticeable. s are implemented as B-trees. Trees always have some level of indirection: you have to traverse a tree structure and compare keys or values. But and differ on a fundamental level: has do do additional comparisons to find the correct value in a local array, whereas only needs to find the correct . The additional cost in isn't noticeable if we traverse the whole tree, but it gets annoying if we look for single elements over and over, especially in a small data set. So let's use a instead and employ all other suggestions while we're at it: 

's type is a disaster. I guess its provided by HackerRank, so that's not a surprise and not your fault. This is also the reason why you get so many type errors. Your reflects that perfectly: you want to use , not . But while we're at , let's change it. First of all, the coefficients and exponents should stay together in my opinion, so let's change 's type slightly: 

You'll notice that this will only allow syntactic correct programs, e.g. those that have the right pairings of and . You can use and instead, but that could make evaluation tricky. You can then define two parsers: 

Replace with and the first with , and you have my first variant. We're done. Other functions You could rewrite in a way that returns already groups of characters, e.g. 

Since folds a list of elements into a single element, it seems like a perfect candidate to use or . However, we would need instead of . Let's have a look at first, which can be defined via : 

This is a lot easier to read. We should strive to have an algorithm in Haskell that's just as easy to read, right? By the way, both the pseudo-code as well as your original code contained an error: what happens on ? \$\sqrt{14} < 7\$, therefore we never check the second prime. We should check that too: 

src/bin/main.rs This is only a stub to check the library. I will expand it in a later version. You can review it, but I haven't really focused on it. 

Make functions easy to use and hard to misuse However, this function's type is weird. We want to get values, so why do we have to supply them first? That's error prone. Our funtion should have the type instead: 

Note that a type signature on would have been enough. Operations on are usually faster than . In you can stop at , e.g. 

Header guards Your code contains undefined behaviour since the underscores are reserved for the implementation: 

That's a nice use of and Repa. All in all there isn't much to review, it follows a common approach on Conway's Game of Life with Repa. No type signatures are missing, but with Repa it's more or less mandatory to add them. Well done. But the next time, consider adding all your code, and were probably interesting (I suspect to be the same as but using ). 

That's why I changed 's type, to ensure that the conversion has to be explicit by the user before they apply . Overall, good ideas and implementation, but try to keep the parts in your own code to a minimum. By the way, if you're interested in predicative types, have a look at Liquid Haskell. 

Less recursive calls To get the number of recursive calls down, we have to ask ourselfs "how large can get in that particular call?" Well, if we start at position and , the maximum we can get is limited by (since we may not overlap both strings) and (since there are only so many characters starting from the second position. So let's calculate the maximum length we could get for a string: 

It's a fine way to implement the dynamic approach, but it shouldn't be available to the user by default. Therefore, let's "hide" it: 

It's still the same, although now heavily inlined. Exercise: Check whether works the same as . Now we need to several times. We can generalize something like that: 

Add documentation This depends on whether you want to re-use your code in a (future) project, but what is currently clear to you might not be as clear in some days/weeks/months. While we're at it, use a code formatter. Some of your single-statement s have braces, other's dont, e.g. 

Note that the parts of our parser are now reasonably dumb. They only get things, i.e. . The logic is now in , which can be used without actually parsing, which might be handy if you want to check values from a database or similar. 

Don't use . It's considered bad practice. Consistency Use a consistent coding style. You use and , and and . first, last This is a matter of personal preference, but you are usually more interested in how you can access your class. That's why the section is usually put first, and the section is usually put last. Minimize IO in your functions Your needs user input for setup. But that's hard to test. Instead, try to provide an interface that's easy to use: 

Leaking memory You have a memory leak. In , you only move the , but you don't delete the previous head. 

Try to stay in a single character stream type Haskell has 5 types that work with strings. (lazy and strict), (lazy and strict) and (aka ). If possible try to stick to one of them and don't switch between them all the time. For example, all your functions can be written with lazy s: 

If you parse your program into a , there's no way you can accidentally end up with a superfluous , since your type does not allow that. That's a big promise, so I repeat it: if we have a , we can be certain that it's well-formed. By the way, your in can be heavily simplified: 

I've kept the variable names, but that gives you an idea. Now can be used for any kind of list, regardless of whether it's a color, a taste, or kinds of megalomaniac cybercats. Note that this is more than the exercise asks for. That being said, it should be easier, right? Let us have a look at . Now, with it's new type signature, let's rename it to : 

Feel free to use guard syntax instead. Reuse functions If you have a function , you don't need to write : 

Luckily, . Now that we got rid of the list comprehensions, we can see that we can still improve our functions if we extract : 

If the repeated digits may also not span hyphens/groups it gets a little bit more complicated, but not too much. This is left as an exercise, though. That being said: make sure to handle multiple numbers, not a single one. That way you will be able to check your code easier. But that depends. If it's a single use script, you probably don't have a need for a function. 

It's not so much the amount of bindings in your clause, but rather some other pitfalls. For example, will traverse the whole accumulated list, which is rather inefficient. Also, takes linear time. We can remove both from your by building the in reverse: 

Remember how I said that nicely written, modular code isn't often optimal? This is one of those unfortunate examples where you have to help the compiler (unless you know exactly what optimization flags you have to use or your compiler is overly aggressive). The is gone, the calls to are now in your loop. But the compiler cannot make a mistake here anymore: it's now very clear that doesn't need to be recalculated 300000*500000*500000 times. The time has come Although our code is now more verbose, there is one small piece of code that repeats itself three times throughout your : 

That won't compile. Or your compiler should yell at you, but it doesn't want to. Make suire that you enable warnings. Undefined behaviour In , your loop must not run if is empty: 

What's the big difference? Well, we're not using repeatedly, which is a big plus. needs to traverse the whole list to get its result. Also, we're not switching between lists and maps all the time, which gets rid of all intermediate lists. Running the benchmark again, we gain the following result: 

"Memory" handling Almost all of those functions concern , which isn't obvious. That's because your included all functionality into . If you follow that model, you can never use in any other context. So instead let us write some other functions: 

Alternatively, if you don't care about empty string case, we can use instead of . The former always returns a list, even if our original list was empty: 

What's nice about those functions is that we can easily check them with QuickCheck or other testing frameworks, since they are all pure. For example, we can check that 

By the way, you never implemented . Summary Don't make the move operations more expensive than the non-move ones, use features that you already have at hand (), don't lie to yourself (), don't limit your class with arbitrary constraints (unless there's a reason), add documentation, and test more thoroughly. It's good that you have tests, but they didn't catch the bug in . 

Use pattern matching to your advantage You can match on multiple elements in a list at once. That way, you can write without a helper that skips: 

While your returned on , returned . That's because it's left-biased. In order to actually reinvent the wheel, you need to get rid of duplicates on the second list: 

Note that you don't notice the bug in checks, since you do the same in Caesar knows its key In , you can just ignore the key, since you already know it: 

Which, in my opinion, is rather readable. Note that your wasn't necessary. After all, we're going to overwrite the values in with the next input. 

if you don't want to remember the formula. Note that this has the nice side-effect that we now can add additional checks for our accesses. Our allocation for and gets now easy as well: 

It would be even better to use the proper types and more functions for I/O. Performance Instead of \$\mathcal O(nm)\$, you can get \$\mathcal O((n+m) \log n)\$ if you the numbers and then use and . 

I will come to the yet unknown functions in a second. What did we gain so far? Well, is going to be a valid answer when we try to inspect it, and we can pattern match on it. Even better, the compiler can tell us that we forgot a pattern if we decide to add or something similar later. Splitting hairs and concerns Now to the functions. They are pretty much the same as yours, with a small twist: 

Type signatures You should add type signatures to all top-level bindings. 's returned value and should have the same type, which can be checked with the type checker, if you add type signatures. The following code would compile, since will have the type :