It is a bad idea for a constructor to contain non-trivial code. Constructors should assign values to fields or another simple actions. If you need complex initialization, you should use factory object or factory method 

If there is no formula to calculate shoe size from one unit to another i suggest you to put sizes in some data structure and map them together. For example in Map. Then you just query the map instead this if-else hell. Same applies to the mapping. Also i see you use Strings a lot as a constants. Consider creating enumeration of some of them. 

Do not throw NullPointerException when arguments are null. NPE is thrown when you are trying to access properties and methods of null reference. Not when you are checking on some preconditions. Throw IllegalArgumentException as you do in length validation. In other method you use assertions. Chose one method and stick with it, dont mix them. You don have to define empty constructor. It is created implicitly. 

that said: in the book "Objective-C Design Patterns for iOS", chapter 7, Carlo Chung shows an implementation of an Singleton, that is even sub-classable. But also in that chapter Chung points out the problems about singleton and advises to use the shared instance concept. Beware: that code predates ARC. 

You should definitely check out how properties can make your code shorter, by adding some standard setter/getter 

Your code with name conventions (setters of an ivar prefixed with setâ€¦, getters named as the ivar/property) 

honestly: this code should be replaced completely. you dont give any informations about how your MyCell and MyTextField look like, so I can just give you a general advice: Let MyTextField have a delegate it can call if a certain operation is triggered on it. ie it could call and the implementation would be similar to: 

I just had a look into Stephen G. Kochan's book in amazon. he is also sticking to the naming conventions, see page 96 program 6.2. as setter, as getter. Although he is not using properties in this example, he most likely will also explain and use them later in the book. 

Your method is very long. This is code smell - if method is long it maybe do a lot of thinks, but method should do one thing. I suggest you to split method into smaller peaces which defines smaller units of work and are reusable and easy to read. If you put piece of code into method you give name to the code which work as a hint to he programmer what code enclosed in method does. Also use full name of variables, not some abbreviation like . You write them once (if you are using ide) but read it multiple times so you invest the effor into the writing the proper name. I did not checked your logic. Your logic should be captured in unit test - if there is no unit test i would hesitate to refactor some code. If there is no unit test dont write them now if you dont have business requirements, but you ca try Characterization testing to capture current behavior of the method. Because without any test you cannot be sure if you did not broke something when rewriting the method. 

your image might have 111 KB compressed as an jpg or a png. But for image processing it needs to be decompressed. It will be loaded into memory with 8 or 16 bit for each color channel. With RGB it would be up to 48 bit per pixel and 8 bit for the alpha cannel in case of png. So 5MB would represent roughly 1.25 million pixel, or something like 1000*1250 pixel. 

Cocoa's name conventions suggest not to use the word in method names to indicate the setting of an object's state 

naming conventions are important in Cocoa, as higher level technologies as Key-Value-Observing depends on them. 

As this is a plain C type, you cant use it, where you need to use objects. Wrap it in a NSValue object than, for example to store it into an array: 

Now to your code. I dont see any reason to overwrite the setter. if apple says that you most likely will never be able to write as performant accessors as the provide, they probably are right. Instead you should create your own method, that will set up a object as need. you could overwrite and similar methods, or access it via a wrapper class, that will set it up for you. 

First of all name your variables properly. Name of the variable should describe what it is, but is just a random letter not a name for variable. Consider using logger instead of printing to sout. Stream closing should go to the finally block not in try. You are nesting a lot of loops and ifs. Try to separate it into methods soo you and up with 

When second dao fails to delete and you have transactional daos not service, the first entity is lost. And you method should not return boolean, but let bubble the exception up into the service layer and let service handle the exception. 

What about having generic abstract dao class which will contain these methods? You will most likely have to create some concrete dao classes anyway to have specific methods. We are using this approach in our projects (behind JPA facade) 

I would separate calculations of shoe sizes and distances into separate classes. It is called SRP Name your variables properly is just a random letter not a name for a variable. For methods with a lot of arguments you can use some wraping object 

that sounds valid and could be the wrapper class mentioned above. But make sure, you create the model objects with , as you want them in your context. 

and you also dont need to declare synthesize, as it is default now As properties generate setters7getters for you, the implementation could be 

if you are looping over a collection, you should use enumeration. This could be fast enumeration (as shown by Sulthan ) or even better block based enumeration. 

you should read the settings plist once in and save the contents as a dictionary to a property. As you are doing, it is a huge performance hit as the disk will be accessed every time a cell appears on screen during scrolling. In and you then should only work on that dictionary. Further more you could introduce a singleton-like shared object, that holds the settings and can be accessed in any class. see my example code for how to do multiple selection and keeping track of the selected contents. 

In Option #2 you cannot be sure that user of your class will pass new Object as a parameter. If you really want to create a clone of parameter you should create on yourself or implement some method on MyReferenceType 

And don't mix classes from primefeaces and dao as suggested in axels comment. When creating this wrapper convert this view classes to some custom backend classes. in some object. I have class. It is much readible and convenient to use. Instead of use CollectionUtils.isEmpty I recommend you to extract nested ifs and loops to methods. Maybe when you extract them you will find some place where you can remove duplication. 

I also think that methods like Should take a File instance as an argument - it should be responsible for writing to the file not opening it or creating some directories. Same for readFile method. 

EDIT Also do not put on your DAO classes but on Services. Service method describes unit of work which should be done whole or rollbacked. Consider this simple code 

Core Data is a great and powerful framework. but beware: if you shoot yourself in the foot, most likely both your legs will be gone. 2 Years ago I was working in a team where the Engineer responsible for persistency accidentally overwrote an internal method of NSManagedObject. It took him one week to find the cause and fix it by renaming his method. This line of code was probably the most expensive in the whole project. There-for another hint: prefix your custom methods. 

you could maintain one array with the starts of the quarters and one withe the ends. as only the months changes, you need just those. Than you iterate over them and generate the dates 

I have to make the same suggestion as for your last question: use properties and stick to name conventions Your code as it is 

will result into a nil-object for the variable . NS(Mutable)Arrays can't handle nil objects. Same for dictionaries. On the other hand my solution allows adding the errors, as it only add them once an existing objects is assigned to the variable .