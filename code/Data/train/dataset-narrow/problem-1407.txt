Generators, not lists Rather than returning a list of Fibonacci numbers, it would be much more useful to simply return an infinite generator of them. That is, them. This way, you don't even need the max: 

We can start at for , since every lower multiple of we already know isn't prime (because it's a multiple of some other number smaller than and we've already done those). With that, our function in its entirety is: 

You have a constructor but you'll never be able to use this as a core constant expression anyway, so I don't see the point. You're also incurring an unnecessary copy to construct your , and the alias isn't particularly useful. Prefer to let the function be constructed from anything: 

Let's start over. With English number words, the way to do it is to divide the number into blocks of 3 and do each one. So I would expect a helper function like; 

While I do like that in python, rather than returning a bool returns the first argument that isn't /, it's a little difficult to read. Now, the code is perfectly correct for odd numbers but would actually be wrong for even numbers - if ended up being the largest even number, we'd print the string. So I find it simpler to just be explicit: 

You'll note that I changed your variable from to . is a terrible variable name as it's very easy to mistake for . So easy to mistake that you probably didn't notice that I wrote one the first time and el the second time. 

Whenever your code adds to a Group, it always adds the next element to the back. And we always go in order. So your structure actually guarantees that each group is always sorted. Thus: 

Take the mangled name as a . We're really not concerned about performance here, and it'll make many parts of the code easier to write. Use the standard algorithms. They will the intent of your loops much clearer. For instance, you have this loop: 

The one-liners are easier to understand than the loops. Use enumerations in a switch. Where you have: 

Input your sides Make sure exactly 2 of them are valid Calculate the third Then construct your with all three sides 

Don't Repeat Yourself Your looping code appears twice. Once in the body of and once in the body of . You only need it once. In fact, the entire structure of is kind of weird and unnecessary. I also don't like how you named the function , made it , and have it take a reference... Instead, let's write a free function: 

It's better, but still verbose. I would say... just flip the loop. Instead of looping over the training set one time, and then checking N different things... loop over the set N times, checking one different thing each. That is: 

You can't call that with rvalues. If I tried to do , it wouldn't compile. Which is better than not working! But it'd be great if it could in fact be supported. If you're not going to support it, you should change the signature to make that obvious: 

Which isn't just less code, it's easier to reason about since all your bounds are visually in the same column. 

First, this avoids an unnecessary copy when users don't pass their strings in by rvalue (which seems more typical?). Secondly, this allows for copy elision on the returned object, as you can't have copy elision from a function parameter. So if I called with an lvalue, I just saved two copies. Also, note the name change. Either use or or function names, don't just . It's much harder to read. The new signature makes some of the other code easier. 

Yes, this needs a fix. Never use . The way to search for things is to use the library, specifically : 

This makes it easier to use your class and impossible to misuse. No silent failure of methods or anything, just: 

The is unnecessary. IsEmpty This function should be named for consistency with other similar container-like objects. Template Signature You are currently just listing all your types in order. However, if you look at all the other class templates that take a callable, they always take a single template argument as the signature. This makes the usage more explicit. That is: 

Counting from 5,000 to 10,000, this is roughly 11x faster than your implementation. So I suspect your professor did something along these lines. 

Finding the best ranking I said before the should yield something more complex than just an enum. But it should yield something comparable. This will let you reduce this loop: 

In addition to not really being a hash table, you're seemingly limiting the possible valid keys to exclude something like or or whatever the value of is. May be worth separating the key from the empty concept. 

Since the last container always gets -ed as one, this is a serious issue. Both have the same root cause. The overload of that takes a single argument has the wrong return type: 

signature Your function is returning 3 things: the total weight, and the two aligned sequences. So it should return 3 things. C++11 has tuples, and tuples are much better than reference out parameters: 

This expression looks much more complicated than it is. Basically we're summing the "complete" parts (where we have 5 5s in a row), and then dealing with the edge cases. The key is that we have a closed form that's just a function of , , and . And you can see how we can easily extend this out to all the other powers of 5 that I skipped. This solution is \$O(1)\$. There are only 8 powers of 5 worth considering, so we're doing the same number of operations across any range of numbers. It's possible that the above expression can be simplified, but let's see where we're at before we worry about simplifying. I rewrote your code a bit to read from a file instead of for testing purposes, but the main logic is simply: 

Initializer List constructor Would be helpful to add an constructor. Especially since you already have a two-iterator one: 

Also introducing and is very confusing there. Just use and . print Your is doing a lot of unnecessary copies. The outer loop should be: 

It's more of a guarantee-one-at-a-time container. A queue would be much more useful, so I'd consider actually implementing one. This is a pretty major design flaw. 

Overly Complicated Algorithm! I'm not sure why you have three for loops or why even division is a special case of the algorithm... Also I'm pretty sure that special case is wrong. Consider a range of size 15 dividing into 3 chunks, so it divides evenly. We'd start with , but then we decrement it to 4, and add the first range of: 

So if we're doing , as an example, we will divide by until we're no longer divisible by (that is, ). All we have to do then is multiply out all the s: 

Although would definitely be the preferred container since you're always appending and traversing in order - and never doing any of the operations for which linked list is favored: 

Using the right functions What you want to do is present the string in some order. For that, there's . Doing sampling is for taking a small number of elements from a large set (think, drawing a poker hand from a deck), and is not well suited for this particular problem. So we can start with: 

That's most of the work right there - for each available color, pick one, increment the step count, and get a new grid. The nice thing is that now our entire actual algorithm is self-contained, no global variables, is just 26-lines of code including whitespace and comments. 

Your lengths are off by 1 everywhere. An empty string has length 0 not 1, has length 5 not 6, etc. Your constructor from the can just assign every character in the loop (since we know the th character of will be , right? Even better would be to use : 

Do we really need the map lookup there? Can we just mathematically determine the right from ? Of course we can: 

So I would make a separate procedure. It's a little confusing as is, since takes a single argument - and that argument isn't the number whose factors you're summing. That is: 

Iterating over a Dict In python, iterating over a dict is the same as iterating over the keys, so we can just save that step: 

When you build up the bins, you don't need a (you know up front what the size is). You just need to iterate over the actual splits: 

where none of those names sound like iterators. seems like it should be, you know, an array. should be a buffer. What do these things even refer to? And then: 

That'll also let the user pass in the , , and independently themselves if that's what they want to do. Just makes it more usable, and you don't lose anything. Lastly, I'm not a fan of lining up the s. It takes a lot of work on the coding side to actually do that, and I find it makes the code much harder to read. You have to scan a lot further to find the important bits. Especially when you're indenting the variable names too, like: 

Either way, avoiding unnecessary variables is a plus. Spacing Don't add so many blank statements between lines. Taking up too much vertical space makes it harder to read. Proposed implementation The following addresses all of my points: 

This won't affect performance, but your return choice for is odd. Since everything in python is a reference, you don't need to return . It's unnecessary, you could just return . Then on the call side: 

In the lvalue case, will be some type , so we're referring to the passed in . In the rvalue case, will be some type , so we'll be move-constructed from . Everything checks out. What about non-member begin? This is definitely the Forgot About Dre of C++11 container programming: 

Rewriting this in Python as a generator comprehension (even if you don't know Python, hopefully this is clear): 

There's actually no reason to bring this in, since you could already make an unqualified call to thanks to ADL. Also, you don't even need since would have done the same thing ( is a reference to const in all of your functions). Too much action This is really busy: 

Just one check everywhere is sufficient. op= You are implementing and in terms of and . This is backwards and much less efficient. You want to implement in terms of , as in: 

There's a lot to dislike about this line. It horribly violates the Law of Demeter. It takes a while to figure out what it is supposed to do. It uses the wrong tool for the job. And it's inefficient. First, to start with, if the goal is to split a strict by non-alpha characters, then we should just use the correct function: : 

Note that taking an argument as an array is the same as taking an argument as a pointer - prefer the pointer. Base case The base case isn't size 1 - the base case is size zero. This is much more natural, since there isn't anything particularly special about 1 vs 2 but there is with 0 vs 1: 

When we put the grid as a copyable object, we get the very nice property that we can now return s from functions (since you cannot return a raw array for a function). That makes it so that we can just write this step: 

One simple way to accomplish such type erasure is to have a type that you keep a pointer to, with a pure virtual function to call: 

Generalizing So where do we go from here? We have aligned storage, and we have function pointers that are appropriately set for deleting and move-constructing. What if we want to support copying? Copy-assigning? Streaming? I'd suggest creating some policies: 

Refactor The whole function would read better if you factored out the inner part into its own function. That way the outer is: 

isn't comparable - but this code would still compile via the conversion, which may be surprising! We can instead write equality like so: 

runtime error checking What if the input streaming fails? How do we indicate that? Maybe we just don't and leave it as "easy". 

Of course is now pretty bad for non-random access iterators since we have to keep doing lots of distance and advance related calls, so I would simply default to the trivial comparison algorithm in that case. That is: 

Severe code readability issues Honestly, your code is extremely difficult to follow and I gave up. The most important part about code is readability. Readable code is easier to reason about, easier to maintain, easier to debug, and, especially relevant here, easier to get other people's opinions on. I would very much like to give you advice on how to improve your functions - but I can't. I have no idea what they're doing now. They're simply inscrutable. It also isn't enough that you understand what this code does right now. What if you need to go back to this code in a week? In 3 months? In a year? Will you remember what it does then? Even well-commented code with good names sometimes becomes hard to understand once you forget the context of when it was written. Poorly named, uncommented code is just setting yourself up for lots of confusion and frustration. At best. I cannot stress this enough. Read up on the python style guide, especially for its conventions for naming and comments.