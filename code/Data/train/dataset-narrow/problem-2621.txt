I guess there are many feasible design approaches. For me what has worked best is that I created two classes: GameCamera and GameInit. GameInit holds all possible resolutions and is fairly technical, but passes the essential stuff, such as the best available screen resolution, monitor ratio etc. to the one and only instance of GameCamera. Now, you may now (perhaps rightly) say: "Are you kidding me?? GameCamera, a singleton?! Nope, I dare to say there are actually few things where a singletons can be useful, and that is if you know absolutely sure that you will not need a second instance of the class and you provide an additional 'initializer' and 'updater' functions for your game objects that will collect the essential global data from the singleton(s) (and where inheritance would be rather cumbersome to implement as you just don't want your bullet to be also camera or mouse...! To make things work, you gotta be careful though. I use in all my other classes two essential functions: Simplified that's which is called only once after all classes have been initialized, and which is naturally placed in the GameLoop. instantiates all the static global data for your object. In this function, you will instantiate your member data by copying all the essential stuff from GameCamera, e.g. etc. The advantage is that, (1) if you break my rule and dare to create a second instance of GameCamera, you could exceptionally help yourself by calling again the function or its overloaded instance where you only update the new camera stuff, without worrying that somewhere in line 14291 in your collision algorithm of your 12th .cpp file there is the need to find again the edge of the universe; (2) all access to this singleton and other global data is clean and tidy in that one function and thus easy to find/modify if you ever revisit your code. The other, copies all member data that is dynamic, such as, Zoom, Scroll etc. They get updated in the Gameloop, although GameCamera may return prematurely if there is nothing to update. Hence, your collision objects that bounce around access dynamic members of GameCamera through a pointer call in UpdateData() and update their own member data through that. For example, GameCamera holds stuff like Zoom(), ScrollEdge() etc., so the bullet's object own private member myZoom is updated when needed within . Note that there is no other call to GameCamera anywhere in my class, except by the power of those two functions--tame your singletons! However, I felt this is also not an ideal design when dealing with different resolutions on different computers when we have to deal with static "HUD" (head-up-design) objects like radars, message screen, messages etc. I thus added secondary screen-percentage units as a member function of GameCamera (going from 0 to 100) for positioning of HUDs. For example, I want a radar always to be on the top right corner (=90,90) and no matter the resolution of the screen. Now since the screen is probably more wide than high, x units are automatically adjusted by this ratio, but not the radar size (10 units) as it would appear stretched. Naturally, in my class, I have the aforementioned function that initalizes through that the necessary members, but no , as I do not need anything dynamic like Scroll, Zoom etc. from GameCamera. This ensured me that I have the same design and same game feel, no matter the prevailing screen resolution etc. I have faced no issues so far in terms game design (currently 35k lines code) and can reuse my code in other projects, as I just refurbish my UpdateData() and InitAllGlobalData() functions. But, to be honest with you, I have not plunged into networking yet, and Update() may need some additional thoughts when coming to synchronizing at runtime, but I will update this post once I get to that stage. 

I don't want to personally edit the base question based on my own opinion, but a better 'version' of this question could be: "How can I get right to the programming and logic of my game without working on the sprites and other design aspects?" As @Jon has mentioned in his comment, the best answer to that is simply colored squares. In fact you probably don't want to spend too much time on sprites and artwork until you've created a working prototype of your idea. Make it just pretty enough to be playable. 

You could implement a "warning system" as well. Something along the lines of: 1) If the majority of the players vote for a player to be kicked, they get a 'warning' that shows up on their screen and vote-to-kick is locked out for 1 minute. 2) If the antagonizing player does not begin to behave within that 1 minute, the other players may vote to immediately kick them with a simple majority vote. This would give the 'lead' player a chance and give them a 'reality check' of sorts. [Editing in my comment as an improvement - I'm still new to SE behaviors.] Perhaps a user could accumulate 'warnings' on their account, and they only get kicked if they have 3 or more 'warnings' in the last 30 days? Ex: You can get 1 warning per game, and if you're a frequent offender then instead of a warning you just get the boot. I just try to be wary of 'vote to kick' systems from past experience. Players can be childish at times 

You could have a variable modify the difficulty of all challenges, and that modifier goes up based on how many cards have been 'drawn'. EX: Keep track of cards drawn and put your challenges in "pools". Thus any monster, X, will show up from card draws Y -> Z. This way keeps you from having to have a classic 'level' system, though one could argue the character's "level" would be the number of cards drawn by that point. [EDIT]: To further explain - I'm not suggesting adding/removing challenges from the deck, but instead generalizing them and then having them be decided whenever the card is drawn. You would draw a "Monster" or "Monster type A", not a "Goblin" or "Dragon". 

Edit: The OPs comment has been skeptical about the efficiency of the suggested negative circular bound check to improve the algorithm in order do checks whether an arbitrary 2D point lies within a rotated and/or moving rectangle. Fiddling around a bit on my 2D game engine (OpenGL/C++), I supplement my answer by providing a performance benchmark of my algorithm against the OPs current point-in-rectangle-check algorithms (and variations). I originally suggested to leave the algorithm in place (as it is nearly optimal), but simplify through mere game logic: (1) using a pre-processed circle around the original rectangle; (2) do a distance check and if the point lies within the given circle; (3) use the OPs or other any straightforward algorithm (I recommend the isLeft algorithm as provided in another answer). The logic behind my suggestion is that checking whether a point is within a circle is considerably more efficient than a boundary check of a rotated rectangle or any other polygon. My initial scenario for a benchmark test is to run a large number of appearing and disappearing dots (whose position changes in every game-loop) in a constrained space that will be filled with around 20 rotating/moving squares. I have published a video (youtube link) for illustration purposes. Notice the parameters: number of randomly appearing dots, number or rectangles. I will benchmark with the following parameters: OFF: Straightforward algorithm as provided by the OP without circle boundary negative checks ON: Using per-processed (boundary) circles around the rectangles as a first exclusion check ON + Stack: Creating circle boundaries at run-time within the loop on the stack ON + Square Distance: Using square distances as a further optimization to avoid taking the more expensive square root algorithm (Pieter Geerkens). Here is a summary of the various performances of different algorithms by showing the time it takes to iterate through the loop. 

Where trend is a random number between - 4 and 4 that remains constant for, let's say, 50 iterations of i. You may wish also to have int(50/aPower) iterations and pow(trend, aPower), where aPower is a random number 1, 2 or 3 to have the mountains a bit less boring and occasionally very steep. And finally, you may play with going an iteration back for a few steps by a small random chance to have an overhang.