Traceroute deliberately sends packets with low time-to-live values to make the routers between you and your destination send back ICMP TTL exceeded messages. The traceroute output is basically the list of source IP addresses sending these TTL exceeded messages. So the output tells you the 4th router has sent you a message from a private IP address. This is not a problem, your packets can be routed over links using private IP addresses. Routers typically forward packets sent by others, but in this case, the router itself generates a packet to send back to you. The router has to decide which source address to send the packet from. There are no rules on which source address to select. A common default is to use the IP address of the router's outgoing interface on which the packet will be sent. In this example, that tells us that the link between the third and fourth router uses private addresses. The packet with source address 10.230.12.197 is routed to your computer. It is not possible for you to reply to this device using that address, but it is also not necessary for you to be able to send traffic to this router directly. The administrator of the router with 10.230.12.197 could/should configure it to use an internet-routable address as the source. This would make the traceroute output cleaner and more meaningful. Note that in this case it might be possible for you to reach this specific router directly if it is part of the internal network of your organisation. If it is not inside your organisation, there should be a firewall preventing packets coming from the internet with private source addresses, but a private source address could work if no such filtering is being done. 

If an ICMP message is sent to notify of an error caused by a TCP connection, the ICMP message must include the header and part of the payload of the TCP segment that triggered the error. This is necessary to allow the receiving host to identify the TCP connection. A NAT device can do exactly the same thing to figure out where to send ICMP errors it receives. If it has a mapping corresponding to the TCP header in the ICMP payload, it knows where to send the ICMP message. An attacker wanting to spoof an ICMP error would need to know the source and destination IP addresses and ports to create his message. Because the ICMP message payload will also contain a TCP sequence number, the TCP endpoint could also verify if this sequence number is valid (i.e. sent and not yet acked). This will make spoofing much harder, but this validation might not be implemented in all systems. You should probably have a good look at RFC 5927 "ICMP Attacks against TCP". 

Yes, parallel HTTP connections requires separate three-way handshakes. Multiple HTTP requests can be handled in one TCP connection. This can happen sequentially, but since HTTP/1.1, the concept of pipelining allows sending multiple HTTP requests in one TCP connection without waiting for the responses. This results in a seemingly parallel handling of HTTP requests, but note HTTP/1.1 requires the server to send the responses sequentially and in the same order as it received the corresponding requests. 

So, as a router, your layer 3 switch will forward the IP packet in a frame with different MAC addresses. As a switch, it will do vlan tagging if needed when sending the packet on the switchport. The same is true for the incoming packet, it could have been tagged or untagged. 

Because 2897 is the sequence number of the first byte in the received segment, the sequence number of the last byte is 2897+1448-1. When this segment is acked, the ACK field will contain 2897+1448 since that is the sequence number of the next byte expected to arrive. The PSH or push flag indicates that TCP should not buffer this data. In other words, TCP should not wait for more data before transmitting it (sender) or before handing it over to the application (receiver). As to why the flag is there in this case, that is a question for whoever wrote the application or protocol being used. 

As many answers already explain, classes are a thing of the past because they do not allow subnet masks other then /8, /16 and /24. These specific subnet masks are still very popular, especially /24, because they are the easiest on us humans. For these masks, the end of the subnet part of the address lines up with a dot in the (dotted-decimal) IP address. Thus it is visually clear if two IP addresses are in the same subnet or not, no calculations required. This is why the class A, B and C terms stick around, they still align with the most common subnet masks. But they do not make sense anymore, and saying 10.11.12.0/24 is a class C is simply wrong. The first octet of a C class was by definition between 192 and 223. 

Of course you can directly interact with the IP layer. The question is not about "why you can't", but about "why you wouldn't want/need to". Since you mention higher level languages, the reason why they exist is the same as the reason the transport layer exists. A higher level language makes things easier by providing abstraction. You can code your application in an assembly language, but you will be spending a lot of effort on problems that have been hidden by higher level languages. Most applications will benefit from a network which provides features like process identification, reliable communication, in order delivery or flow control. So it makes sense implementing these features once in a standardized protocol, instead of having to include custom solutions in every application. There are situations in which designing your own solution can be beneficial or even necessary, but in most cases using TCP or UDP will just work and save you a lot of hassle. Doing it yourself can also be very educational and make you appreciate the work that has been done by others. 

The first 25 bits of a multicast MAC are always . This means they range from to . To construct the multicast MAC, append the last 23 bits of the IP to the fixed first 25 bits of all multicast MACs. In this case, we get: 

Will the computers be able to connect to the NAS at 10GbE? Yes, if both the computers and the NAS are connected to the switch at 10GbE and do not require routing (ie. both are in the same subnet and VLAN). Will the router slow things (other than internet) down? It will slow anything which passes through it down to gigabit, but only if is faster to begin with. Any other drawbacks? This could be the perfect setup for you, but it could also fail to deliver under certain conditions. Since we don't know what it has to deliver, it's hard to tell. It all depends on how you will use it and what you expect from it... 

No, this should not not work, it should work. Anyone in the layer 2 broadcast domain will be able to receive any multicast message sent in that domain. Unless you use vlans, anything attached to the switch can listen for all multicast groups. Routers do not forward multicast traffic, unless specifically configured to do so. Subnet masks only tell your computer which IP addresses are in its local subnet, and which addresses are not. They have no role to play in multicast. On the ethernet layer, the multicast group is mapped to a multicast MAC address. Switches will send traffic destined to a multicast MAC address to all ports (unless specifically configured no to do so). To find the multicast MAC for your multicast group, first convert the IP address to binary: 

This could first of all be necessary if for some reason, the client has access to more or different name resolution data than the proxy. You gave one simple example yourself: an entry in the client's host file that is not present on the proxy. Or the client could be talking to a different DNS server. It could also be an efficiency thing, since with option 0 all DNS requests will be performed twice, once by the client and then again by the proxy. In option 1, the proxy will only perform a DNS lookup as a fallback if the client supplied address doesn't work. Also note that when a domain uses round robin DNS, the client and proxy might get a different answer to their queries. This would result in a connection to a different server, not the one the client expected to be connected to. This could cause issues with protocols which somehow depend on being connected to the instance returned by DNS. Such a protocol would work with option 1, but not always with option 0. 

So a NAT device can indeed put a unique value in the Identifier field when forwarding a request to the outside. Two machines on the inside using the same identifier is no problem, the NAT device will use two different values and remember the combination of the original ID and the internal IP address. Some (old) Cisco specific information can be found here: $URL$ This page also includes a list of supported protocols/applications for NAT. 

Since there are only two routers on a point-to-point link, there is no need to hold an election for a Designated Router (DR) and a backup DR as OSPF would in a broadcast network. An OSPF router on a point-to-point link will multicast its OSPF on the link for the other end to receive. On a point-to-point link, a router can only establish one neighborship. A loopback interface in OSPF will be in loopback mode. Setting OSPF to point-to-point mode results in advertised routes containing the actual subnet mask instead of the default behaviour of advertising /32 for a loopback interface. Iirc I read something about scenarios in which advertising a /32 instead of the actual mask causes trouble. I have only ever used this to start advertising a network that was not yet attached to the router. 

Traceroute will show you the path your traffic is following. With split tunneling, a traceroute to an internet IP should not pass your VPN gateway. Another way to make sure traffic to the internet is not going through the tunnel is by visiting a website which shows your IP address (eg. whatismyip.com or ifconfig.me). If your IP address is from your local provider and not from the network your tunnel is connected to, the packets were routed to the website directly, not through the tunnel. 

Both are possible. If no units are mentioned, I would assume it means . Often, this ratio will be given as a percentage. When 'packet loss rate' is meant as a rate per unit of time, that unit of time should be specified. 

To get the MAC address for a given IP(v4) address, your computer will use the Address Resolution Protocol. For IPv6, the Neighbor Discovery Protocol does the same thing. The purpose of LLDP is to discover other devices on the network, and the messages are always sent from your own MAC address to well known destination MAC addresses.