Rubberduck One of the frequent contributors, Mat's Mug, is working on a project called Rubberduck. Him and his team have made it into an amazing tool that is capable of Code Inspections, Refactoring, some better UI elements, and some other really cool stuff. I strongly suggest checking it out here: $URL$ . If you have any questions, please don't hesitate to ask. This is a lot to take in at once, but I would be doing you a disservice if I turned a blind eye to common mistakes. 

Admittedly, this is uglier than Mat's Mug's approach, but this is the approach I use because it suits my style and needs a bit more. The benefit here is that you can choose your approach to handling the error. So, for example, handling an error in the routine can be different than handling an error in the routine. I also avoid statements as much as a possibly can. There isn't anything wrong with them when used well, but I try to anticipate errors if I can. On that note, and as others have noted, some of your subroutines need some cleanup. Someone in the RD group recently reminded me of the 'Single Responsibility Principle'. Everything should be responsible for one thing, and in turn, that thing should align with it's own intent. Along these lines, I would argue, that one unique thing should only ever be returned by one owner of sorts. For example: 

The only difference between the two is that the second is at least explicit about wanting a variant. The first is implicit. First bit of advice avoid implicit commands as much as possible. The reason for this is quite simple, there is a tendency to think that the computer is magically doing something it shouldnt be, but really you told it to do exactly what it is doing and as a result, you have a bug that can be nearly invisible. Consider for example : 

That was the first step I took in making your code make a little bit more sense. By extracting the two loops, and the dimension check, the main routine becomes much cleaner, and gets to rely on a few s to do the work it needs to do. The beauty of this is that your code now explicitly says what it is doing (anyone could read the code, regardless of whether they have been coding for days or years). The next step I took was explicitly checking for the supported types. For example: 

Aside from the couple of instances of a single ratio being matched to two different aspects, they are fairly consistent. So then I checked each of the original aspects and their results: 

To get you started, you have a number of unqualified references within your code. This is particularly puzzling to me since you declare and pass worksheet objects, but you never use this object when determining a reference. For example: 

First, it loads in all the data from a (excel Table) into an array. That's the easy part. Once we have the data, we need to know the indices of the headers. This makes manipulating the data much easier. It also allows you to move columns around all you want without breaking the code (just ensure the names are still there). Using a custom we can store all of the data in a defined structure. A is similar to a in other languages. In essence, it is a variable that has properties, but that isnt an object. Thus, it cannot be 'ed up. Loop through all of the rows, and create new records for cells with multiple addresses. Since the cannot be 'ed, it will retain old values. This means we dont need to re-create the entire for each new row. We just need to change the new values, then add it to the collection. Once the collection is loaded with records, we can translate them into a new array that is appropriately sized. No need to add/remove rows. It is just the right size at creation. The method will take an array and a worksheet and it will clear the cells on that worksheet, put the array onto the worksheet, and then turn that output into a table. Point it where you want the output to go, and it will do the rest. 

Implement a slow but obviously correct solution (in this case, it would just generate all subarrays, compute their sums and choose the best one). Generate thousands of small test cases and compare the output of your solution and the naive one. It's quite likely that you'll a test case your code fails if it's actually wrong (that's exactly how I found a counterexample to your algorithm). 

About the first one: there is no need to create and populate an . You can use static method instead: 

Is it worth having? If your goal was to implement your own object pool, than it's fine. If you have it for some other reasons (like performance or convenience), it's probably not. Firstly, it's definitely less convenient that a standard C++ container. Secondly, it may not be faster than a standard allocator. It might be even slower. Did you measure it? Did you have any performance issues in the first place. Anyway, implementing a custom allocator is the last thing I would do to tune the performance. Even if profiling shows that a standard allocator is too slow, I'd recommend to use an open source library with a custom allocator instead of implementing your own. 

Your code is not working fine. Firstly, it prints the maximum number, not the maximum even number (you can check it by running it on the input ). Secondly, it's not that it's slow. It never terminates for some input. If the is 342, your code goes into an infinite loop as the number transformation go as follows: 342 -> 102 -> 120 -> 102 -> ... How to fix? The first bug is easy to fix (just update the maximum when the number is even). You can fix the second bug by building a graph for all numbers (with an edge a -> b if a goes to b in one step) explicitly and traversing using, for instance, depth-first search and carefully checking for the cycles. 

There are some inconsistencies in your code style: sometimes you do put a space before an opening curly bracket, sometimes you don't. It is a good practice to adhere to one style(in this case, it is conventional to have a whitespace there). It is also conventional to surround all binary operators with whitespaces to make the code more readable. For instance, looks better than . In terms of time complexity, you algorithm is optimal(it is linear in the size of input). However, if it is supposed to work with long strings, I'd use iteration instead of recursion(it gets a when the strings get really big). Here is my iterative solution: 

I do not see any reason to use pointers here and cast them explicitly every time you access an element. You can just use and get rid of all casts. You can also use smart pointers( looks like a good choice here). Here is my version of this class: 

It depends. If you want to expose the field to the classes's clients, then you need a getter. For instance, it makes sense to write a getter for the stack in the calculator so that operators can use it (sure, you could have design it differently and pass a stack to an operator directly). It's really about the design of your class. There's no definitive answer. I don't think that you need a getter for the here. The String is redundant. You can check if a string is in the map using map's method. I also think that the should be passed as an argument to the method, not to the constructor. I just makes more sense to me to build one calculator for a specific sets of operators and then run it on as many different inputs as you need. I don't think that the input is the essential part of the calculator entity. It's more like something the calculator can processes, not something it consists of. I'd also recommend to decouple the computations from the output. Each method should do one focused thing. The should do exactly this: process the input and return the result (or throw an exception). Printing it is a different concern. It also makes your code more reusable: if you just return the value, you can still use the class if just need to evaluate the expression without printing it or if your need to display it differently. The comments should not repeat the code so something like is is even worse than no comments as it clutters the code. It just creates more noise. It's clear that a creates a new empty map. They should rather explain why specific decisions were made. It's also a good practice to write doc comments for your classes and methods to specify it's behavior (including what kind of exceptions it throws) so that one doesn't need to read the code of the method to figure out what it does and how it (and shouldn't) be used. I'd also suggest to create a copy of the in this constructor (so that the map used by the calculator doesn't change even if the is later changed by the client). Either way, you need to document this kind of decisions so that the users of your class know if it's safe to change the map passed to the constructor later in their code. 

I think it's a matter of taste and preference. In either case, you would have to duplicate something. But, there's something that drew my attention. I don't claim it to be correct or be a solution to your problem. Hard to say without knowing the context and data structures that you use. Anyways, here we go... I noticed that in both cases, whether or not, you pass the same arguments, though to different methods. I suspect that this checking might occur in many other places as well. So, what if we create a method (e.g. ) and move this condition statement to that method. And the method would internally decide whether to add a new or modify the existing one. Somewhat similar behavior may be observed in the method, where the method checks if the element has already been added to the and then returns without adding it twice... Then, we end up with something like this in the client code: 

I like the idea of this utility class, but there are a few points I would like to mention. Let's start with naming. I would rename the class, probably, to one of the following , , or . The rule of thumb is to put the / nouns in the end of the class name. Personally, I like the first two. Then come the constant fields which could be shorter. For instance, they could be named as instead of and instead of . That is, the 'BETWEEN' part is redundant because it's already obvious that a separator separates the one from the other. Two other fields would be better named as and , which is more intuitive. Another thing is that you have two separate methods for adding the field names and values and then you check that there is a corresponding value for each field name in the method. You also check for indexes and arrays' length in the method. All these checks are error-prone, but they could be eliminated by enforcing the one-to-one correspondence rule of the field names and values in a single method for adding those fields and their values: 

I would also suggest that you look into some popular MVC frameworks (Zend Framework 2, Symfony 2) to get comfortable and confident with the concepts. 

This way you control the state of your object and have no need in the and methods anymore. Moreover, internally I would store the field names and values in one data structure, rather than in two separate arrays. The single structure could be a or a , the latter one is preferable if you have a class. This brings us to the class. I think, it would be more practical to encapsulate the field names and values within the class, which will yield a better OOP-style design. Also, this change will allow you to transform the class from an inner class to a static nested class, because you don't need the reference to the outer class anymore. After you encapsulate the field name and its value in the class, the field would naturally belong to the class. And because the class name is , the field could further be renamed to . One other opinion on the constants would be that you don't actually need them because you don't use them anywhere else besides the methods. So, you could just use the string literals instead: 

Let me make it clear for myself. You have an array of images, which sometimes can be empty. You start off by checking the first image, if it's valid for your needs you take it, and if not you keep on checking the next one, and the next one, and so on until you find the one which is valid. Is that right? If so, here are my few thoughts. Firstly, I must say that Glenn has made good points, namely: 1) factor the common code in all cases out to a separate function, and 2) if you have nested conditionals, most times it's better and more readable to replace it with Guard Clauses. However, personally I would prefer the following solution: