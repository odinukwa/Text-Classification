(the in place of the the user-owner column means that it is set-uid (and user-executable), the owner is root; this means that no matter who runs it, it will run as root) Traditionally (and still the case on Mac OS X systems), it must run as root because the information it needs is only available via root-accessible devices (e.g. /dev/kmem) or root-only system calls. This is OK because (unless there are bugs in the implementation) the ps program is written in a way that does not let callers get information that they should not otherwise have. Other systems have other mechanisms that provide access to the info that ps needs and thus do not need set-uid ps binaries. Notably, the /proc virtual filesystem on Linux systems (and others) can publish very fine grained kernel information with equally fine grained permissions. Such a model is sufficient to allow a non-privileged ps to get everything it needs without allowing access to the more sensitive bits of kernel information. 

When I configure just those two mappings I do not see any timeout delay after typing C-w. You might want to check if something else (a plugin?) has defined any additional mappings that start with C-w: 

Usually, you record such configuration changes in a file in your home directory. You can, however, specify a replacement configuration file with the command line option when starting a new server (you have to exit all your existing sessions to restart the server — or start it under a different socket with or ). There is also a system-wide configuration file (it is loaded before the one in your home directory); the default location is , but MacPorts changes it to . The system-wide configuration file is always loaded for all users, so you should be very careful about what you put in it. 

You should be able to use this command (typed “blindly”; since there is no echo) to restore normal tty functionality: 

This answer assumes you are using vim in a Terminal window. The default bindings for Home and End are a bit different from what a program would expect based on the usual TERM setting (i.e. an xterm variant). If you want to stick with the default bindings (and having to use the Shifted variants in Terminal), you might try putting something like this in your : 

The effect is only temporary because the control file that defines when and how to launch that program still exists and launchd will read it again after your next login. You will need to find and delete that file to make the change permanent. The filename is usually the launchd label1 with added to the end. Since I could not be sure of the name or location2 of the launchd file, I downloaded and examined the installable package for SCPlugin. It turns out that its file follows the naming convention. The full pathname is . You should be able to use Finder to delete the file. Open a new Finder window and navigate to that directory (or press ⌘⇧G, type/paste , and click Go), then delete the file (drag it to the Trash or press ⌘⌫; you may need to type your passwword). 

It sounds like you want to change the session option. The initial default value is 750 milliseconds. If you want to set a new, default value, then change the “global” value (e.g. in your ): 

You can populate a temporary index file with just the contents of the subdirectory of the repository and then diff the existing files against it. 

If you are interested in making newly created Unix-style scripts files executable when you first save them, then you might find Tim Pope’s vim-eunuch plugin useful. It includes some (undocumented†) “autocommands” that will do a on a new file whose first line starts with (e.g. ) immediately after saving it for the first time. † Undocumented in the sense that they are not mentioned in the README file. 

(assuming default bindings) The first C-b is interpreted by your local tmux (because it is the first to see all your keystrokes). The second C-b is a command that causes your local tmux to send a C-b to its active pane; this generated C-b arrives at the remote tmux. The d passes through the local tmux unchanged; when it gets to the remote tmux it triggers the command. 

The argument given to the command will have a newline in the same place as it does in the script itself. You may need to take care to save such a script in such a way that it ends with Unix-style (LF-only) line breaks, otherwise you might get a CR+LF (DOS/Windows line breaks) or just CR (old Mac-style lineb reaks). You can also do this at an interactive prompt, but you will see a continuation prompt before the second and any subsequent lines: 

It could be bad RAM, or a faulty logic board, or bad power circuitry. Someone that sees lots of them (like a Genius at an Apple store) might be able to recognize the particulars and narrow it down. 

Incidentally, this type of command (from the ex predecessor to vi) is the origin for the name of the tool (: re short for regexp). 

The handler’s parameter gets a list of objects1. The curly braces () in your error message indicate that the error happend while it was trying to operate on a list object. Thus, you need to use something like to work with a single item instead of the list (and probably give the parameter a plural name while you are at it so it “reads better”). That should let your statement work properly. The next statement will probably fail though. will be a Finder object which does not have a property. Usually the easiest way around this problem is to have Finder convert its object ( is a subclass of ) into an object and then extract its ( objects do have a property). If you put all this together, you might end up with something like this: 

You can think of tmux as a terminal emulator that provides a terminal that uses -based protocol (on the “inside”) which it translates into some other terminal protocol (on the “outside”) while providing features like panes, windows, sessions, a status bar, et cetera. Since tmux always provides a -like terminal protocol on the “inside”, you must always use a -based TERM value inside tmux. Additionally, you must use an appropriate TERM value “outside” so that tmux knows how to talk to the terminal in which it is running (usually this is your terminal emulator, so use whatever terminal protocol your terminal emulator is configured to supply; often a variant of ). Specifically, the problem you are facing is that a Home is , while it is in : 

You can create an SSH key and entries on your host to simplify the ssh command lines (i.e. using just above instead of ). 

Your configuration file is working, but there are a couple of complications. Short-lived Commands First, the commands you are starting (instances of ls) finish running very quickly. The windows and panes for the commands are created, but they disappear as soon as each command exits. If your goal is to actually use such “one shot” commands in your eventual configuration, then you should probably use the window option (and possibly the session option to provide a default for all windows created in the session). When is set for a window, it will not disappear when the command exits. You will probably want to map the to a key (note: will respawn the original command; is also available in tmux 1.5 to respawn individual panes).