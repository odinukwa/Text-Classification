That huge / statement you have is terrible. First, you print out the values using the same print statement at the end of each if, just move that to the end: 

You should keep each level at the same indentation so you can see at a glance what level has what scope. 

You need to format your code neatly; this will improve readability, which will decrease bugs. First, you have this: 

You are wasting your time here. Once you know the value is not a prime, you do not need to continue looping. This will reduce your time greatly: 

According to JSLint, you should use fourspace indentation, not two-space indentation ($URL$ I don't know the official standard on this, though. 

I can use the same principles to get rid of my multiple other s, and noticeable reduce the runtime and make my code follow FP principles better. 

The modifier is now unnecessary. Because this method is called asynchronously, the parser will still run asynchronously, but the resolver cannot start until the parse task completes. 

Beyond this, your calculator does not follow the order of operations. Probably the simplest way to handle this would be to only update the calculation when the , , and buttons are pressed (like the Windows calculator does), parsing and calculating everything else from the stack. 

This statement can be confusing: . I would recommend not incrementing an item in a statement that also retrieves a value. 

As it is, the first line is utterly useless. Additionally, this only works because your methods are all static. Keeping track of your instances is important because what happens when you have two restaurants? You need to know which restaurant is controlled by which class instance so you can manage them appropriately. 

First, we might as well check for a cancellation request. Add this line before both statements involving : 

If implements , then it will automatically be registered as both and . You shouldn't need to register types with parameters explicitly; AutoFac will look at the parameters and inject them automatically. Actually, you really shouldn't be registering types explicitly; I don't know the exact syntax, but you can register a whole assembly at once. Finally, if you really do need a different container here, then what you do is inject an instance into your class and do something like: 

There are a few potential issues here, speed and accuracy in particular. Speed The cache is often faster than querying a value directly because of computation - you need to input, process, calculate, and output values. For example, when you search the web, the servers return results based on cached data so they don't have to literally scan every website, read keywords, process data, etc. Reading from the cache is as simple as getting the final value with no computation involved. Accuracy Querying a cache can return obsolete data. Let's say you have a product priced at $X, and change the price for a sale. If you don't update the cache, you will return outdated prices to your customers. Querying the original data bypasses the intermediate value, always ensuring the value is correct. 

This can be improved and made more Pythonic. First, there is the and keyword, which you already know of as you used it. Why not utilize that instead of doing two loops? You will have to change the logic slightly: 

Not only is this a bad and undescriptive name for a variable, it is unnecessary. Also, what type does the return, a ? If so, you probably do not need to cast it to an . 

Again, the indentation is wild. Your indentation on the CSS is very good. However, as your webpage grows, you may find it easier to have the CSS in a different file than the HTML and link to it like this: 

This would not compile in many languages, and it also allows the method to have two return types - a and an . I would adjust this to use an statement and convert the number to a string: 

As an attempt to learn multithreading better, I wrote a program to crack the password of a ZIP file. It is sort of slow, processing a three-digit password of the 95 printable ASCII characters in about 1:45 minutes. This is my class that actually handles the cracking: 

Use . It will be a lot more expected to have to remove/disable that than to change the if and remember to remove the then-dead method. (Principle of Least Astonishment, right?) Don't specify . It's just useless. First, it would be extremely surprising if someone tries to use multithreading 10 years down the road and it failed. Second, it doesn't provide any significant overhead (if any at all) to not use this. Finally, console apps run single-threaded by default. There is no excuse to disable multi-threading in the whole app. There is excuse to disable multi-threading in parts that can't be multi-threaded because of whatever (maybe it calls into code running on a STA thread), but those instances can be handled on a case-by-case basis with explanation in comments. 

One Ring to Rule them All fields--one instance of these fields across each instance of the class. Every time you assign a new value to one of these fields, each class starts working with the new value. This is probably a bug you will need to fix. 

Notice how my version is easier to see what code is in what scope and executes when because you don't have to figure out what closing parenthesis and brace goes with which opening parenthesis and brace. 

You are right that this roll is biased. Instead of using a fixed range and less-than for your rolls, you should just roll once and use specific ranges to choose which action is taken. Something like: 

Piece.fs This is an immutable class representing a Piece. It contains each option as a static member to ease building boards manually. 

Then, you have the same code run with different values in each of the statements. Why not separate that into a method, and pass the values needed to calculate the required values? If you do this, you would be able to change your into something like this: 

Your HTML is much worse. You can check that here at the W3C validator also. First, you made the common problem of leaving the doctype out: 

The same applies to . The rest looks good to me, except you should be consistent about using using spaces around your operators according to the PEP 8 style: 

F# has a function that is the same as , except it prints a newline at the end. You should use this instead of manually specifying you want a newline with * Well, sometimes complicated, fast code is better in performance-critical environments. 

Don't make your fields . General convention is that a field is a implementation detail; anything that needs to be exposed to anything else is a property that can control write access. 

If performance isn't critical, where you need to squeeze the last nanosecond out of performance, I would also consider using and ing results. This constructs a state machine that doesn't do the calculations until you actually ask for them. It has the drawback of having some slight overhead for each call, but if you only need to process a few bytes periodically and the performance cost of processing a chunk of bytes is large, it allows you to do just that, rather than processing the whole set at once--you only process what you need when you need it. 

Your function is very large. It should be split into multiple small functions that are responsible for a single action. is preferred to : 

Third, it is good practice to use braces around one line statements to help prevent errors. Fourth, you should keep your indentation at the same level: 

You don't always have your braces have the same style, and sometimes you don't use braces at all. You should always use braces, even if there is only one statement in the block, and you should always use the same style. Also, it is common to put spaces around operators to improve readability: instead of . 

The next post in my Checker series: The C# wrapper for my F# library to make it cleaner for these methods to be called from C# code. GeneralTypes.cs 

Now, instead of iterating through both lists for every character, you can just get the character you need to translate and call, for example, . This will (theoretically) reduce the time needed to run your code drastically, as map access is \$O(1)\$ (unless there are hash collisions), while iterating through a list is \$O(n)\$. However, as Klitos Kyriacou noted in the comments, the actual performance and theoretical performance are not necessarily the same.