DISCLAIMER: I am not an expert in caches so this might be a naïve idea, and also may be a known idea which I've never heard of before. So excuse me if I fail to cite its reference (if it exists); and please inform me if there is a reference for it to edit the post and add it. (I am suspecting it might have a reference because it is so intuitive). A quick solution after being inspired by Strilanc maybe to just keep a associative map of maximum $c$ entries (where $c$ is some constant) associating an item with the number of times it has has been seen. When the associative map is full and you meet a new item not in the map, flip a coin to add it or not. If you are to add it, then remove an item with probability inversely proportional to how many times it has been seen so far. 

I've looked in the Zoo and it seems it is not true because $PH \subseteq P^{PP}$. Nonetheless I've passed by a paper that appears to have used a positive result. It was in the context that $f : \{0,1\}^* \mapsto \{0,1\}^*$ is a function, computable by probabilistic polynomial time oracle machine $M$ with access to an arbitrary oracle $A$. The authors say and I quote: 

I am not sure if this answers your question but I hope it could be meaningful and leads to some insight. Assume that there is a turing machine $X$ that can simulate every atom in the universe including itself, it then necessarily can simulate itself. Now, reducing that to the halting problem is trivial: Let $X$ take a turing machine $M$ as its input and decides whether it halts or not by simulating the universe (since $M$ is included in the universe), then do the opposite (e.g. $X$ halts if $M$ does not, and loops forever if $M$ halts). Then $X(X)$ demonstrates a contradiction. Essentially this means that the best $X$ can do to decide whether $X$ halts or not is just by running itself (i.e. let the universe work its way), so simulating the universe doesn't give an advantage. The same applies when you want the state of the universe after $t$ time. Since $X$ can not decide if it will halt within $t$ time or not within $t$ time (same argument), then it will let it to the universe to do it. Trying to simulate the universe doing it, can not reduce the time you'll take to decide. And if deciding how the universe will look like in $t$ time takes more than $t$ then the simulation will diverge (as $t$ goes to infinity). This leads to the conclusion that only useful simulator that decides how the universe will look like in $t$ time must take exactly $t$ time, i.e. by letting the universe work. This simulator is then indeed the trivial simulator. 

Theorem 15.3 of the recent "Parameterized Algorithms" textbook by Cygan et al. states the following: "Let $L, R ⊆ \Sigma^*$ be two languages. If there exists an OR-distillation of L into R, then $L\in coNP / poly$" So, I think that if there exists an OR-distillation from a PSPACE-complete language $L$ to itself, then $PSPACE \subseteq coNP/poly$, i.e. not only does the polynomial-hierarchy collapse, but also PSPACE collapses with it. 

In the problem NODE KAYLES two opposing players take turns playing on an undirected graph. In each turn, a player selects a vertex $u$ and removes $u$ and all its neighbors from the graph. The first player who is unable to select a vertex loses. In other words, the two players take turns selecting vertices under the constraint that the set of all selected vertices must be independent. NODE KAYLES was shown to be PSPACE-complete by Schaefer in the late '70s. (See "On the complexity of some two-person perfect-information games", Thomas J. Schaefer, JCSS 1978). In the same paper, the edge version of the game, called there ARC KAYLES, is mentioned as an open problem. In ARC KAYLES, players take turns selecting edges (rather than vertices) under the constraint that the set of edges selected is independent (i.e. a matching). My question is if the complexity of ARC KAYLES is still open. I have seen a few more recent papers on NODE KAYLES (e.g. "Kayles and Nimbers", by Bodlaender and Kratsch) but I haven't been able to find a reference on any follow-up work regarding ARC KAYLES. Is it by now known that ARC KAYLES is PSPACE-complete? 

How about Planar Capacitated Dominating Set? It is W[1]-hard (see the paper by Bodlaender, Lokshtanov, Penninkx in IWPEC 2009), but should be solvable in $2^{O(\sqrt{n}\log n)}$ by using the fact that planar graphs have treewidth $O(\sqrt{n})$. In this problem we are given a graph with integer capacities on the vertices. We are asked to select a minimum size dominating set, with the added restriction that a selected vertex can dominate at most as many of its neighbors as its capacity. Even though the solution is not exactly a subset of $V$, I think it is known that, if we are given a supposed dominating set $D$ we can check if it can be turned into a valid (capacity-respecting) solution in polynomial time by reduction to Max Flow. 

Copied from the comments on the question as per-request. I have taken theory of distributed computing with Michel Raynal and he described a third model, where messages can be dropped randomly. In that model a message can fail silently to be delivered, but that doesn't necessarily mean that the node has failed. It is about link failures rather than node failures "fair lossy channel model", you can read more about it here : Quiescent Uniform Reliable Broadcast as an Introductory Survey to Failure Detector Oracles - Michel Raynal (ftp.irisa.fr/techreports/2000/PI-1356.ps.gz) 

In fact there is a whole journal that is intended to be funny. The journal of craptology. The topics are usually related to cryptography. There are also some sessions videos (!) One example is the Volume 4 paper of Cryptography in a Hitchhiker's Universe (section 5) is : 

This answer is about feasible solutions based on homomorphic encryption that is NOT fully-homomorphic, as the latter may be extremely inefficient (if there are efficient fully homomorphic cryptosystems that are comparable with those provided below in terms of efficiency, I'd be glad to hear about them). Since you only need one multiplication then there are solutions that are potentially less expensive than fully homomorphic encryption: [1] and [2]. The latter works on encrypted bit-decompositions of the input so it will need a bit-decomposition protocol like [3] and [6], but the former works on whole values. Just for completeness, the former has been extended to $d$-operand multiplication in [4], even though the OP may not need this. These solutions are non-interactive and should work in the two-party case. If you have more than two parties and could afford some interaction then [5] provides a "secure multiplication gate" which is potentially more efficient and allows unbounded number of multiplications. It works basically by converting the homomorphically-encrypted values to some sort of secret-sharing, multiplies the result (interactively), then convert it back to homomorphic encryption. [1] Evaluating 2-DNF Formulas on Ciphertexts [2] Non-interactive cryptocomputing for NC1 [3] Unconditionally Secure Constant-Rounds Multi-party Computation for Equality, Comparison, Bits and Exponentiation [4] Additively Homomorphic Encryption with d-Operand Multiplications [5] Multiparty Computation from Threshold Homomorphic Encryption [6] Efficient Binary Conversion for Paillier Encrypted Values