What am I doing wrong with the velocity? I have been staring at this for very long so I have gone blind. I have tried different values of recursion depth but it does not seem to make it better. Let me know if you need more information. I appreciate any help. EDIT: A combination of Patrick Hughes' and teodron's answers solved the velocity problem (I think), thanks a lot! This is the new code: I decided to use a separate recursion method now too since I don't want to recalculate the acceleration in each recursion. 

When I set the intersection point, if I for example use 0.1 instead of 0.001 the puck travels further before it gets stuck, but for all values I have tried (including 0 -> the real intersection point) it gets stuck somewhere (but I necessarily not get a stack overflow). Can something in this part be the cause of my problem? I can see why I get the stack overflow when using -1.0 when calculating the new velocity vector; but not how to solve it. I traced the time steps used in the recursion (initial time step is always 1/60 ~ 0.01666): 

If the tutorial text is vital, why would you allow the player to dismiss them forever and get themselves lost? Here's a few ideas: A common approach I've seen is to dismiss the tutorial text only when the player has completed the required action. For example, if the current text is: 

Start with Northerly directions only, i.e. the player is only moving up the screen Gradually add in East/West directions Finally, add a few Southerly directions 

Since Android devices don't have left/right buttons (well, a long time ago they used to, and if you use bluetooth keyboard/gamepads they will), what you want is onscreen buttons. If you search for that then you will find plenty of answers and tutorials. The easiest method is to use the built-in class. There are many other ways to do it, such as detecting touch events and checking if they intersect some part of the screen. 

There are many ways to skin this cat, but the easiest may be to create a doppelganger sprite, constrained to the discrete coordinate space. That is, make your actual sprite invisible, and set a second sprite that follows the main sprite with discrete movement. 

As you can see the collision is detected early in every recursive call which means the next time step decreases very slowly thus the recursion depth gets very big -> stack overflow. 

I have been reading plenty of tutorials about sliding collision responses yet I am not able to implement it properly in my project. What I want to do is make a puck slide along the rounded corner boards of a hockey rink. In my latest attempt the puck does slide along the boards but there are some strange velocity behaviors. First of all the puck slows down a lot pretty much right away and then it slides for awhile and stops before exiting the corner. Even if I double the speed I get a similar behavior and the puck does not make it out of the corner. I used some ideas from this document $URL$ This is what I have: Update method called from the game loop when it is time to update the puck (I removed some irrelevant parts). I use two states (current, previous) which are used to interpolate the position during rendering. 

When bullets can hit many different objects at different times. Maybe the bullet travels through objects to hit more objects behind it; maybe the bullet bounces around and hits anything in its path When bullets stick around and deal damage depending on how long an object is touching/intersecting it, such as a fireball or laser beam 

I'm not aware of this ever being used, and I suspect it's because it has very limited benefit for greatly increased complexity and bandwidth use. It might make an interesting experiment, but it seems impractical. Consider that to support such a scheme, and assuming that most traffic is generated from player actions, you would need to double the downstream traffic and multiply the upstream traffic for all clients, not to mention opening a large amount of new connections. Double downstream because now you are receiving player commands from the peers as well as the server. Multiple upstream because clients need to send their commands to all peers as well as the server. But perhaps the biggest cost is that you run into tricky situations when you now have three points of reference. With a traditional client-server architecture, there are two: the client and the server (technically the other clients have their own points of reference but the server multiplexes them into a consistent, single one using techniques under the latency compensation umbrella). Now you have three (or more): client, server, and peer. Consider this scenario: 

The Mastering Unreal Technology books are really good for learning how a great engine works. Learning how a great engine works doesn't necessary teach the nuts and bolts of how to create an engine. But, it will teach you the features of a great engine and how those features should work. There are two versions of the books. An older book and a new set of three (1, 2, 3) 

Lua is a popular choice for a general purpose scripting language. You can create your own scripting language using Lex and Yacc (check out the article in Game Programming Gems 3) but I would say most of your needs could be taken care of with Lua no matter how big or small. 

The scripting object needs to have access to the other objects it will provide data for. Be careful not to pass those other objects directly into the scripting object. Do so creates a brittle interface. You might want to have something like a mediator class that manages those object references and provides data access to the scripting object. 

Since moving to the top works, we'll do that. Note also that this is a method that only works when everything is AABB - all your walls are horizontal/vertical and so on. In the general case, such as when you have diagonal walls, you will need to work out which way the walls go, in order to "slide along" them. 

The reason why this solution is "good enough" is because it will run into problems with edge cases like this one: 

It may seem that guessing and checking repeatedly like this is inefficient, but most games have very complex rules for whether a spawn point is valid. Your game rule may dictate that players can't intersect each other, or over certain objects. Your map may have inaccessible areas. You may want to spawn close to some things, or further away from others. It doesn't take many of these rules to create quite a complex function, and certainly one that is too complex to guarantee your guesses are successful. Therefore unless you are spawning hundreds and thousands of players per game tick, this sort of loop should be ok, even if you iterate hundreds of times in this spawning loop (just make sure the loop terminates). Another advantage with this approach is that it's very easy to make; your game probably already has routines to check whether spawn points are valid, as part of your normal gameplay. can be as simple as creating a random point. Just be careful that it makes a good enough guess, such that the guess has a reasonably good chance of being valid. For instance, avoid using a completely random guess over your entire world dimensions if your map is very sparse. Your idea of using a spiral is good because points next to existing players are more likely to be valid spawn points; just be aware that your suggested algorithm will tend to spawn players close to others than further. Finally, the reason why we should handle the extraordinary case where we don't manage to find a valid guess is that, for non-trivial game rules and map layouts, it's hard to guarantee that we'll find a valid point, in all cases. For example, you may (inadvertently) specify game rules that players should not spawn in sight of any existing players, but apply it on a wide-open small map (where every point is in sight). Therefore you should think about what should be done if you cannot find a valid spawn point - is it ok to try spawning again later, or spawning in a position that breaks some of the rules, or not spawning at all? These are the general issues you should be keeping in mind. 

When constructing an orientation matrix, are the rows of the matrix the axis? The matrix is row-major and I'm multiplying vectors on the right (Mv). So, the matrix looks like 

I want to take a vector that is using world coordinates and position it using the orientation of an object. So, if the direction of the object is the z-axis, and the vector is (0,0,1), then the orientated vector would point in the direction of the object. I want to vector to remain in the world coordinate system. All I have for the object is it's up and direction vector. So, I can build a matrix with those by crossing them to create the third axis. Multiplying the vector by this matrix transform the vector into the object coordinate system (right?). But, I want the vector in world coordinate system. Should I use the matrix to find euler angles and then use those angles to create a rotation matrix? 

If your 3d engine supports a scene graph, some scene graphs will have a node called a switch node. This can be used to switch between different types of geometry. So, you could put a switch node above the lip and switch between a mustache and no geometry (an empty node in the switch). For clothing and skin tone, you might be able to do something similar with switch nodes at the texture level. Not sure though. 

There is no easy method with pygame. pygame uses sdl_mixer and shares its limitations. sdl_mixer only supports one streamed, music channel. You could use sound effects instead and manage your own sound samples and channels, but it's a lot of work: 

There is no need to filter in this scheme; you might have a rendering system that draws all the "drawn" components, and a physics system that moves all the "moved" components. 

There are also other handy features in Tiled; the trees you see in the tileset will be loaded as separate tiles, but you can use Tiled's Brush features to draw those trees in one go. There's also the Terrain Tool which helps you paint tile transitions, after you've defined the border tiles. From there, it's best to treat the tile maps as a whole, via the frameworks that support TMX maps, rather than individual tiles. For example, you would load and render tile layers, or draw all your "wall" tiles in the same layer and perform a layer collision. There is usually no need to split a properly-authored tile set into individual tiles.