I found an answer here that gives a really easy to understand algorithm that can be used. He says himself it's not correct, but rather an approximation, but that's good enough for my needs. I'd like to know if this is an accurate approximation. I'll inline a summary in case it goes down some time: 

Although the site contains a description of what they're for, it goes over my head. What are easing functions and what are they used for? Update I found a better example of the functions themselves from Phaser.io's source code. These functions are much simpler than the answers here would suggest. They only take one parameter, . As part of the answer, I'd like to know how to use these. 

Now you can access it from cheetah. Somewhere in your update method you should grab it and assign the cheetah position with it. 

I think would mean how many pixels to advance on the line to put the next character. I have 36 characters but I want upper and lower case to output the same image. I need this specifically for libgdx but this would probably be the same for any tool that uses a . In addition I have a file that came with the sheet that includes the characters allong with the other images. 

Now all you need is to sync the project with the gradle files. In Android Studio I would go . If you do not use Android Studio and cannot find this just search google how to sync with gradle for your IDE. 

I'm getting feedback on my game which has Action RPG elements (think Diablo, Torchlight, etc.) but you control a team of heroes. When you kill enemies sometimes new weapons will drop. In my game the DPS of the weapon will be randomized but stronger the further you get. Each weapon type has a hard coded range and rate of attack, but it differs between types. As an example, every Pistol will attack once per second and every Machine Gun will attack 5 times per second. A common complaint I'm getting is: 

Using MVC in games (as opposed to web apps) always confuses me when it comes to the view. How am I supposed to keep the model agnostic of how the view is presenting things? I always end up giving the Model a that holds and but invariably, these values end up being in units of pixels and that feels wrong. I can see the advantage* of avoiding that but how am I supposed to? This idea was suggested: 

Now we can use the direction vector to move your arrow towards the mouse. But remember when I said a vector is a magnitude as well? Currently that angled vector stretches has the same length as the distance between the two other vectors we got direction from. So if we add to it would be instantly be on top of the mouse pointer. We can deal with this by normalizing the direction and make the total magnitude of it . 

The only thing you need is to hookup and to your variables. You might want to change the variables to private with get/set, but since they are only coordinates I like to have quick access to them. -Edit- Here is a basic example of how a Tile class looks like. 

I'm building a game where the player's character can attack bad guys and vice versa. I built this with the concept of an "attack cooldown" because I don't want units to be able to attack each other every single frame. I want there to be some delay between attacks. Here's roughly how it works: 

If you look at the "synergies" section, you'll see it can be combined with other collectibles for interesting yet intuitive effects. For example, if it combines with The Inner Eye, it "Will enable Isaac to fire multiple homing shots at once". This makes sense, because The Inner Eye 

The math depends on how everything is set up but is very simple. For example it makes a difference if the center of the screen is the camera location, the top left or bottom left. You should end up with something like this: 

Now this is not much different then your method, only mine stores if the tile can be walked upon too. Your walls should probably never be walked upon and floors should so why bother changing to my method? Scalability is the answer. What if you decide that you want to add objects to your map? If you have say 10 objects like tables, chairs, pillars, etc then for each int that represents a floor you need 10 more of those. Where I just add another int for the objects texture or perhaps the object itself if it has more properties like a tile. Yes you could add another array to represent your objects and draw that over your tiles. But then you decide that object a can damage the player in a certain state. Now you need to make another array or a extra int to refer too. Where I change the behavior of a object in it's class. This is why you use a object oriented language anyway. 

Lots of 3D fighting games avoid scratch damage. Examples are Tekken and Soul Calibur 2. They avoid this by making it difficult to have a perfect defense. Some attacks are simply too fast to react to. I think it's a pretty good solution. 

I'm making a top down 2D game and I want to have a lot of different attack types. I'd like to make the attacks very flexible and combine-able the way The Binding of Isaac works. Here's a list of all the collectibles in the game. To find a good example, lets look at the Spoon Bender item. 

This is a fairly simple system. It also allows you to work magic on the damage and armor. Add bonuses and multiply it by the players strength and if you do this formula last you will always be good. 

Ok I decided to help you on your way. But we are simply not doing homework for you. UDK documentation seems down for maintainance but I have found this: $URL$ example. You should read it completely since it helps you understand projectiles. Towards the bottom they explain projectiles. Let it be clear that I have no experience other then creating some simple maps a decade ago with UDK. The code I found on the mentioned website that I will be discussing: 

I also have a page where I show the character's stats and list this as "Attack Cooldown". I was showing my friend and he said, "Why don't you rename that to 'Attack Speed'"? I explained that it's not really the speed at which you attack because "smaller is better". We both agreed that "attack speed" is a more standard way to show this concept and that I should change things the way he suggests. The problem for me is that "attack cooldown" is a much more intuitive way for me to program the solution. I'm wondering if there's some "trick" to refactoring the current code I've got. I'm thinking something like this: 

I'll assume you are talking about a 2D game or at least a 2D UI. Well, if you think you need to create graphics for 1920x1080 then you should go for it. If you setup a viewport properly libgdx does all the scaling for you. Personally I have my viewport represent a 1280 x 720 area. You won't see any difference on phones, I barely even notice the difference on descent sized tablets. But I'm not a great 2D artist, lol. Anyway this saves a ton of work so keep that in mind. So what you basically do is create graphics that fit your viewport or camera size. If you are setting the screen size to 1920 x 1080 I guess you should always create your 2D art for that size. For 3D it's different, higher resolution will give you crispier edges on your models. Here I would use a high resolution camera for rendering the 3D and a lower resolution viewport to overlay the UI, again unless you want your 2D to look really crisp on bigger screens. 

I'm struggling to achieve this. I can vary speed and range for each type, and this seems like an "ok" solution but it's not good enough. This just feels like a sliding scale that looks like this: 

But those numbers conveniently work out. What do I do if the numbers divide in such a way that I get decimal places? Floating points are unsafe. I think allowing decimal places would eventually cause really weird bugs in my game. *It'd let me write the model once and write different views depending on the device. 

Here you can change the range and the rate of attack, but the DPS is still going to be based on the level of the enemies. In the end, it's still not going to matter which weapon you choose because they'll all have about the same DPS. If I make it so they don't have the same DPS, then yeah, there will be reasons to change weapons, but it'll be because some weapons suck and some weapons are good. I don't think this puts me in a better place. I want the player to feel like weapon type X has pros and cons over weapon type Y. How can I achieve this?