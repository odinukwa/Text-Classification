They have to be orthogonal to each other so that's why the cross products need to happen. Some libraries provide a arbitrary should the user supplied one be invalid. 

If you can buy more turns then it's for monetization. The non-buyable turns are to keep you playing over time. You have no choice but to wait until they regenerate which means you will come back the next day to spend them and then see the advertisement to buy more turns of the other kind. If it is a multiplayer game then the goal is usually to limit the grinding options and keep casual and hardcore gamers at roughly the same level. 

You can detect on which side of a line the cursor is by using a cross product. If the cursor is on the "inside" of all edges then it is inside of the hexagon. This only works for convex polygons though. For a grid You can approximate is with a rectangular grid and then refine it by testing just a few lines. 

doing a slerp between the null quaternion and the target lets you get the power of a quaternion. or you can acos the w component and then multiplying with the factor and then get if you don't need massive accuracy then you can replace the slerp in the first solution with a lerp 

The easiest method is to only keep 2 tracks in memory; one playing and one ready to be played. When one track is done you start the next one and also start loading the track (in a background thread) to be played after that one and the Clip that just finished. 

this will overwrite all 16 values, if you want to keep the old ones you can keep them yourself or query them with 

first thing: don't nerf it into being totally unusable, so that they can transition easily to other strategies if they desire without dieing to critters 10 levels lower one way to do a nerf is to add something so it requires more skill to use effectively, on a spell add a longer cast time/longer cooldown, require a timing mini-game to get the most out of it you can also implement counters, this way the OP layout isn't as effective against bosses; for example stun being resisted by a new resist stun stat so that stun-spam will be broken sooner or later 

BufferStrategy will often use VolatileImage for the buffer. Part of the use case of volatile image is that its backing buffer may be lost without warning. This require you to rerender to the volatileImage. What you can do as an optimization is test both and inside the inner while loop and repeat the loop using if either are true (disposing the graphics object as needed): 

It's not a massive change, just instead of it will be . Otherwise you can reverse the search, go from the endpoints to the start. That way you can use A* (given a proper heuristic). You just need to start with all endpoints in the starting set. 

One thing I have seen often is highlighting key words like places, a macguffin to collect and key characters to talk to next. this allows a player who is just skimming to stop and reread the context consider having a fortuneteller character who gives more direct hints, just someone who will be always available to talk to maybe in the home town maybe duplicated all over the place, depends on the world really. if the players are lost in the sense that they don't know where places are then add signs and a world map 

you can say on pond tiles that they are part of a multi-tile object with a reference to where the actual data is stored if there is no data then you can create a type for each sub tile of the large object and just store those, so you can find the orientation and bounds by just looking at the type in game you can have it act as one object. edit: let say your pond is a 2*2 and needs no other data, then you create 4 tile types , , , , with pond0 the top left file. when you place a pond then you check if all tiles are free and then change all the tiles into the appropriate pond tile when you interact with it then you forward the interaction to all tiles of the pond and have them act on it properly, (start glowing; have one trigger a sound, etc.) 

If the positions are always the same you can even do without any buffers by storing the array in the shader and using to select the vertex in the vertex shader. 

After your glClear call you can render a full-screen quad with your texture (loaded like you would any other). You may want to disable writing to the depth buffer to avoid odd rendering issues. 

's trig functions use radian so multiply the angle by before passing as parameter you can apply a delta to the angle to reduce the speed if you want to rotate along a specific point then you can do the following 

When glDraw* is called the new data will be used. I use because you would change the data often whereas would indicate that you won't change it often. It really doesn't make a difference but allows the driver to optimize differently. 

the biggest problem I see is the call each step which is I suggest using the heapq so it will be reduced to per insert and pop saving you a factor of you will need to add the steps as lists with the sort key (the as first and then the tuple so natural ordering will be used 

sweepline, you sort the objects by the X or Y coordinate of the center and then check the objects in the range 

Where to put the data depends on what the data is and how large it is. You can embed the data in the executable and then just reference the byte array when you need it. This has the upside that the data is loaded in memory automatically but it will remain in memory until the game is exited. The data also cannot be changed unless you recompile the entire executable/dynamic library. The other option is putting it in the file system under a data folder. This requires using an installer which is essentially a self-extracting compressed archive or a downloader. This also allows shipping and using DLLs and makes changing the assets easier by just changing those with an updater. 

If a light is in a updating cell then the new light value is either the calculated value or the emitted light whichever is greater. Then when no more cells have been updated then the update is finished. Each iteration can be done in a separate game tick to avoid freezing the game. You don't even need to do a full iteration. The number of iterations can become quite large if the lighting level is very granular. Removing a strength 255 light will result in 128 iterations to remove all of the light. This is related to the count-to-infinity in network routing. To solve this you can instead reset all light values in the affected radius to 0 (except existing lights to their light value) and mark the edge of the area (and neighbours of existing lights) for lighting updates. 

and index with . You can possibly keep it allocated statically (or thread locally when multithreading) and reset when you need to. Also instead of recalculating the entire path when the player moves prefill the open list with the previous path (returning if the player is already on it) as it is very likely the first part (until clearing obstacles) will remain the same. 

Technically reading a value that another thread is writing to is undefined behavior. This means that anything is allowed to happen up to and including nasal demons or getting your harddrive formatted. In reality it usually means the reading thread gets a corrupt value. This can cause visual artifacts like flickering models. Or if the value read is a pointer or pointer offset (and you don't do a bounds check) then a segfault is possible. Also the optimizer is allowed to reorder your memory accesses unless you explicitly prevent it and doing that screws with the optimizer. To fully fix it you need 3 buffers. 

Then most of the magic will happen in the fragment shader where you will be sampling textures and such based on and your uniforms. 

first get the bitstring for the standard way you described then just encrypt it with some symmetric cypher and chosen key then you pack that into the password string into something the user can enter 

Getting whether the turn is completed means checking how much more the unit needs to turn. If the remaining angle is small enough then 

It wont be correct. If you take 4 points; 3 of which lie on a circle and the 4th is in the center. The diameter of this set is the distance of 2 points on the circle. Your algorithm may choose the other point which won't have a distance like that. The proven correct way is to create the convex hull and use the Rotating Calipers method for finding the largest distance. This ends up being time complexity. for creating the convex hull and for iterating over then entire hull to find the points the furthest apart. 

1a) just flood from the destination depending on how many units were told to go there 1b) you can keep the path mostly along the same path and split only in the last few meters 2b) let the flock rearrange itself when squeezing past obstacles (using local avoidance of static obstacles) 

It's called GPU skinning (or a variation of it) Add several uniforms that represent the changes. Then add attributes to the vertices that represent how much they are affected by each change. For example bulging would be going towards the normal vector: 

It depends where the bottle neck is. If you IO bound (the game is always waiting on network IO) then yes compressing will help. If your game is CPU or memory bound then it will just run slower. You should compress before encrypting because cipher text is less compressible as a result of trying to remove patterns that could be used to reverse engineer the cipher. A better solution would be to make the protocol as compact as possible to begin with, for example by using a binary transfer method; binary data is easier to parse than text data and can be more compact (a double fits into 8 bytes while most doubles printed out take more than that). 

either shift the right edge of to account for the geometry of the player (requires a new second function for the ) or you shrink the walkable bounds in the setX function 

always double check on the server, don't allow teleportation through position but instead ensure the speed isn't too large you can ensure authenticity by having the client keep a counter and encrypt it together with UID with a prearranged client-specific secret (also send the unencrypted counter to account for lost packets) 

if a portal face is not visible then you don't need to render the room that connects through the portal tutorial I found for creating a portal engine: $URL$ 

It probably isn't, most languages has asynchronous sockets that allow you to use multiple connections at a time without blocking while data is waiting. This shifts the "socket server" part to the OS/kernel. With an explicit socket server you will incur the cost of a few extra copies as you pass the data through the local socket; one thing that will kill scalability is extra copies where you don't need them. 

All collision detection methods can benefit from pruning the list of objects to test before testing. One of the ways is to partition your world so you can query the objects that may intersect with some area (false positives are allowed) then only do the collision test on those objects. For example store the axis aligned bounding box in a grid and knowing that you can just index into the grid to know which objects are in each grid cell and you don't have to worry about those across the world. 

You can explicitly get those numbers from after linking; the name is the string that appears in the vertex shader for the attribute. For example if you passed "vertexPosition" for name then you would get . If the layout information is not in the shader then openGL will create a default layout (usually in order as they appear) or you can define your own binding with before linking. 

Kerbal Space Program used to have the same issue, and called it the Kraken. They solved by moving the bubble around the player it has a radius of 2.5 kilometers outside of which all objects end up "on rails" where the orbit is fixed and large jumps ahead are easily calculated. That can be done using the patched conics orbit model. Essentially it means that all objects are only in the sphere of influence of a single celestial body which reduces the problem to the solved 2 body problem. 

In java you can use an RGBImageFilter and a FilteredImageSource to change the individual pixels of an image before you draw it. 

Create a program that takes the relevant parameters as uniforms and pass those. Then the size and position of a rect can be passed as a single vec4 uniform and you only need to pass a single VBO that is (or for non indexed draws) 

first of java has good OO let it shine each time you used create a new instance method and reimplement in the subclass you can also use getter methods that return parameters like base movement speed for use in standard methods do the same for the saving and loading (like @shotgunninja does but each entity is ISavable) and when loading have the hashmap (or just an array if you can ensure the order will remain the same ;) ) contain the Entity factories that creates a blank entity on which you can call which will configure it (as a bonus this allows pooling when GC pauzes becomes too much for ya) 

Adding the sorting requires that you keep a cost field in each Tile that is defaulted to the max value; 

uniforms will remain the same for all vertices (this is why they are called uniforms) if you want to change it you need to call gldraw* twice and set the new uniform between them: 

GPUs can branch conditionally. It's just more expensive when not all threads in the SIMD execution follow the same path. What will actually happen is that the pixels that break out of the loop will "disable" themselves so that when all pixels in the group are out of the loop some will have the variables from earlier loops iterations. 

If you remove a wall then the next wall at index i but you skip it. Decrement i after the remove or use an iterator based loop: 

It's more efficient to not unbind the buffer as it's an extra call that will get undone later. Code beauty is not worth the penalty of rebinding the element buffer in your main render loop. 

Most games go with #1 and a variant on #2 For timed events they use a priority queue to keep the events and in the game loop check for events to occur at this time step. This means that an event gets a trigger time in the future with which it gets inserted into the queue. In the game loop you extract only those events which trigger time are now and leave the rest for a future iteration. For triggered events, as in triggered by another event depending on some condition like a harvester emptying the last resource from a field, then the event is run as the other event triggers it. For example to remove itself as a target for harvest. 

If you implemented A* correctly then you would have a "open" list of nodes to search sorted by the expected cost of a path through that node or This means that the 2,0 node should still be in the list. But The algorithm should continue with 3,3. If it doesn't then the way you select the next node to investigate is flawed. 

the way to create your Quaternion rotations matrices (I assume from euler angles) look funny, I would expect you use unit vectors of each axis rather than 

You can't. That's one of the downsides to MC's lighting model. What you can do is update the just the cell by setting them to max of the neighbours minus the decay like if there wasn't a light there and mark each of the neighbours as needing an update. 

Create a map and save it along with the world, that way if you ever add/remove blocks the old IDs remain valid. This is what minecraft does starting from 1.7. 

first you transform the cannon ball into the coordinate space of the ship. Then you act as if you want to add the ball's model to the octree and step down through the nodes. If the ball straddles a boundary line then go through both sides. Once you get into a leaf not then there is the bucket with faces to test with. 

In an MMO you already have data about where the user is going, which quests he takes and what equipment he uses sent to the server. Other data you may be interested in is how they use the various guis, how long they keep stat and inventory screens open. You can for example record the number of times a feature has been activated with the mouse vs. the keyboard. One important factor is to allow the user to opt-out (or make the collection opt-in) of the (non-critical) data collection to comply with privacy regulations. And to allow the server to decide what data should be recorded during the game session/next hour to spare your players some bandwidth.