Suggestion: if you do in-place sort, make sure it is documented that the function modifies the input array. In general, I would prefer not returning the result, as to limit confusion. I can't really see anything wrong with the implementation itself, but I'm not familiar enough with insertion sort. Using is fine for short lengths, but as this is a list-sort, you don't really know the values will take. Maybe use instead? (Or better: upgrade to Python 3!). One thing I would really really like to advice is switching to Python 3 for learning. Python 2 is only supported up-to 2020, and a lot of people would be happy if more people learn Python 3 instead. 

Furthermore, writing is not really idiomatic Python. Better would be . But, in this case you're trying to emulate a loop. I'd suggest writing it as follows: 

Now I just hope I got my boundary conditions right (that's always a problem with a bisection algorithm). Just write plenty of unit tests for this specific part, please! Choosing from an empty storage? I'm specifically talking about the following lines: 

You're basically asking a question, and then "What is the answer to the question?". Better to just ask the question alone. Instead of writing , you could write or . Another thing of note: the score (I assume that's what you mean with ) gets reset to each time you get a new problem statement, but the score () is only printed at the end of the rounds. That is, you have (pseudo-code) 

This keeps my code DRYer and I don't need to worry misprinting or forgetting to return it (your does need a !) You don't handle errors (but you knew this already ;-) Your has way too many dependencies and responsibilities. The best practice is to keep your controllers "thin" with the sole responsibility to glue your data with its scope. Changing routes (states) looks like one job too much. Say you want to keep another sing-up form elsewhere with its own controller - will you really want to copy over all the logic? This is good for prototyping but is generally to be avoided in production: 

Again, pure functions without side-effects are easier to test in isolation. Use the and methods on arrays for shorter and simpler code and libraries such as Ramda (my favourite) or Lodash. 

UPDATE. Having another look I see better what you are trying to achieve. Still I would improve design by making the directive more re-usable. You basically want to throw any HTML inside the directive and pick the associated with event's target. The directive makes this available on the scope of your expression . Just like made available inside the . I would then mark this as something special like: 

But if equals , the will have been executed, and you won't reach any other lines anyway. So you can just write 

The comments for the and are really trivial. You can easily drop them. Please do. Consider what your comments add to the code. If they detail how it's implemented, try very hard to find a way to remove them without reducing the clarity. The following is just as clear. 

The difference will be that this gives a list of tuples instead of a list of lists. That's hardly going to be a problem in the following. 

Not going into the question as to whether or not this is a good idea, I can see very little wrong with the solution. One thing I would very much like to suggest is the following. Instead of 

And similar for match2 and match3. However, the real complixity in your implementation lies in the determining of the error message to show. I would suggest building a dictionary mapping the display error to internal errors: 

There are so many things going on, it is a bit worry-some. Also, you might want to add a space around the operator, causing the need for yet some more work. By using string formatting ($URL$ you can make it a bit simpler: 

Note. Your code looks cleaner without after function declarations. You watch and then update it upon change - this looks like a loop and may lead to your browser crash. Read best practices on using Angulars . 

Having looked at your code I can see one major problem - your directive hides but does not isolate its scope. That makes it vulnerable to both external and internal changes. Internally you may change a variable and forget to adjust it and suddenly your directive is using the same named variable from outside! Imagine all the bad things can happen to your directive! That makes the maintenance a nightmare - you can't even use reliable tests to catch the "leaky" variables that you forgot to declare. They will keep "sleeping" quietly deep inside your code until the wake-up explosion :) Your directive seems to be intended as encapsulated drop-in component. For which Angular's isolate scope is the best solution. The isolated declaration inside your directive tells you exactly which attributes are "allowed" inside and how are they named. You see it clearly right at the top of your directive, which makes your code more readable and maintainable. Now you can change the outside-inside coupling nicely inside that declaration. That also would make your code cleaner, shorter and DRYer. As side remark, I would generally try to avoid, if possible, the low-level "system functions" such as , etc. They are used by Angular internally to expose more user-friendly (and reader-friendly) API to you. Such as the isolated scope binding and using filters rather inside your templates (i.e. what it is meant to). 

Already a lot clearer, no? Still, I've typed the sign 3 times here. By using the module, I could write: 

Now, let's start analysing the large method . First of all, we could apply the same trick as we did for to speed up the lookup for . That's going to make your code a bit more efficient. It's a tad large, so let's first talk about the branch. 

Don't know if it's faster, but at least it is more readable! And I expect faster. But the main gain might be in the next section The main loop Your code was written as 

Why do you even have the /? It adds nothing of value. Also, the parameter is now a list of , instead of a . Another thing I'd suggest doing is using the attributes of our class we just defined. 

And a similar loop for columns. This has one problem: What if the user does not enter a number but something else? 'Pizza' or 'one'. In that case, the throws an exception, and that should be handled as well. 

Ok, so we do not get a string, but a list of characters. That's what is for. Finally, we need to convert it back to an integer, we can do that using . 

Your code is manually recreating HTML, which is an anti-pattern. The Angular way is to supply separately HTML template and its data scope object. 

Warning. Keep in mind using inside HTML, that your code becomes invalid as soon as those s are not unique. This can easily happen by copy-paste and forgetting to change the . Unless you use reliable validators, and consider this a feature to help your validators, I would avoid using s whatsoever. Styling can be done merely with classes and is a recommended way. 

Then it is the job of the directive to pick the right model and make it available under this name. This way I can change to inside without breaking things, so the directive is more encapsulated and re-usable. 

You are re-defining , which is a bad practice. It will break the chain, forget all your previous properties and can lead to unintended effects if using (which isn't good idea too unless you know what you are doing). It is better to specify individual properties of it. 

which is, however, blocking, may result in delays, and makes the page unsuitable for offline testing. On another note, library such as async loader, does not seem to work with this particular script. 

Let's think out loud what the lambda does: first, we find out the position of in . Then, we use that position to look up the value at the given position in , (which should, in all reality, just be again), and then get the second component. Better would be to write 

I'm going to look at the code without the intermediate print statements. They expose an implementation detail, and not the end-result. 

(Disclaimer: I'm not a Java-expert). Moving the tile You intentionally left this one as a black box, to keep it out of scope, I think, but I'd still like to comment. 

Because is inside the loop, it always gets reset. Are you sure you have tried the algorithm with larger files? (And tested it is correct)? There are more reasons why I think your code is broken, for instance the handling of , and where the assignments take place. Rewriting . What should do is the following: 

I know that threading is a bit of a problem anyway here, but I would just like to comment on this specifically: by writing you are waiting on the thread to finish before starting the next iteration. This gets read of the threading all together, as there will only be two threads alive at a given time: 1 worker thread, and the main thread waiting on the worker to die. I'd suggest writing it as: 

In that case, is a function argument, so using it won't throw any error (in contrast to a variable) and hence there is no need for . Also note that evaluates to , so the two expressions are different, strictly speaking. 

You define as array of anonymous functions, which is a bad practice in itself. You can't reliably test these functions as your index will change any time you update your array. A better way would be something like: 

I am puzzled by how you use both inside and outside . Each iteration of has its own scope, so its own . For instance, if , which item do you mean to use inside ? The way it is used now, the seen by that function will be another on the outside scope. If this is the intention, this variable should be named differently: 

I know good naming is hard but maybe a name revealing more about what the Router is doing would make it easy to read your code. Also you don't seem to provide the files defining the routes and both links to Github seems to be dead (which is why you need to provide the files, not the links!).