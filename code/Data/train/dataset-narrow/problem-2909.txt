(The image has Numbers with capital letters, my fail, ignore that, shouldn´t have the starting letter in capitals) For example, is an array that contains space for 10 ints (numbers). You can access values from the array ("list"): 

Assign each "piece" of cable an state (an integer, for example). You assign each of this states to two sides (Up and down, Up and left(For turns, for example), Left and Right...., all the combinations). (Edit: You can also do this with four booleans, , , , , This might be a lot easier) You then can run a loop checking this state in each piece of cable and determine if they are connected to the left, right, up or down. (They will be conected if there is cable in this position). Assuming (1) is implemented, you only need to check if one of those conected cables is a power source. (For example adding each piece of cable a boolean ) 

Prison Architect uses "pieces" of cables, it is not all one long cable, it is a sum of lots of "pieces" (or squares, not sure how to define it): Image here (The bright green conected pieces are cables) I don´t know how they do it, and I bet they are not going to tell us, but I can tell you how I would do it. 

Not as good as using a proper Profiler, but at least I can measure times on runtime, and identify bottlenecks. 

Color is easy to understand and easy to implement as visual feedback, you can make the environment get different color tones depending on the distance from the spiders to the player. Usually, Red/Orange toned colors symbolize "Danger" and Blue/Green toned colors symbolize "Peace/Calm". (Color blind people might have problems with this if not implemented correctly (It is not easy though, be careful)). 

Music is probably the most effective way to express feelings. If you manage to use the appropiate song that tells "Danger, run!", that is better than any camera movement (If you combine music with those kind of effects, it gets even better, of course). Imagine playing Silent Hill with david guetta music, that would make Silent Hill a joke, you would laugh at every monster you see. Edit: As some other users have mentioned, a lot of people play mobile games without sound, music is still my favourite option, but the second one would be: 

Disclaimer: This answer is 100% subjective, it is related to code design personal preferences and might not be the best answer. I would delete InteractionsManager class. The idea of having 2 lists (arrays) and checking for collision in a loop is nice, but you can do that on your Screen class. (just create a checkCollisions() method and call it on render()). The code will remain the same, no performance increase, but usually having too many classes might make the code hard to understand. If you need more interaction types, you can follow the same idea: create a new function in your Screen class and call it on render(). I can´t really help you with performance without seeing the code. 

I am not sure what you mean with Sensor Listener, but In case you mean accelerometer and other mobile phone sensonrs. You can disable them with this code: 

I would suggest using a "stagger grid", in which every row is displaced half a square west of the one to its north [somewhat like the keys on a typical keyboard]. From a programming perspective, a stagger grid can be processed much like a square grid except that movement will be permitted NW and SE, but not NE and SW, and a map whose sides run north-south will to the program appear as a "diamond" shape. A stagger grid can easily be rendered to look like a hex grid (just scale the X and Y axes suitably and superimpose hexagons on it) and doesn't require any really weird programming. 

An essential ingredient of singleton-elimination which opponents of singleton often fail to consider is adding extra logic to deal with the vastly more complicated state that objects encapsulate when singletons give way to instance values. Indeed, even defining the state of an object after replacing a singleton with an instance variable can be difficult, but programmers who replace singletons with instance variables should be prepared to deal with it. Compare, for example, Java's with .NET's . Both are quite similar, but they have a key difference: Java's is hard-coded to use and (it effectively uses a singleton comparator) while .NET's can accept an instance of as a constructor parameter. The run-time cost of keeping the is minimal, but the complexity that it introduces is not. Because each instance encapsulates an , its state is not just a mapping between the keys it actually contains and their associated values, but instead a mapping between the equivalence sets defined by the keys and the comparator and their associated values. If two instances and of hold references to the same , it will be possible to produce a new instance such that for any , will equal . If, however, and may hold references to different arbitrary equality comparers, there will in general be no way to merge them so as to ensure that condition holds. Adding instance variables in an effort to eliminate singletons, but failing to properly account for the possible new states that could be implied by those instance variables can create code which ends up being more brittle than it would have been with a singleton. If every object instance has a separate field, but things will malfunction badly unless they all identify the same object instance, then all the new fields have bought is an increased number of ways things can go wrong. 

For games which require a person to react to audio cues, every millisecond by which the sound is delayed will cause the person's response to likewise be delayed. Someone who is simply watching a movie or cut-scene may not notice too much if the audio and video aren't exactly in sync, but it's often important and sometimes critical that audio be in sync with what the player is expected to be doing. 

A very important aspect of a game is what Warren Robinett called "controlled randomness". If you don't want a level to have a particular fixed solution, ensure that the level of difficulty will not be unreasonably affected by the random number generator. The game should be designed so that a someone who plays perfectly would have a 100% chance of completing every level regardless of whether the random number generator was "favorable" or "unfavorable", but a certain amount of skill would be necessary to have a significant chance of winning no matter how "favorable" the random number generation happened to be. A major source of frustration with some games is the fact that there can be times when e.g. a player cannot possibly win unless the random generator produces a particular sort of tile, and it's not uncommon for the player to run out of moves before such a tile appears. If the design of the puzzle is such that e.g. the player will have 50 moves, but a key piece won't arrive until move #46, and thus a player must figure out how to use the first 45 moves to set things up to allow a five-move win once that piece arrives, then tell the player that. Make it clear that the failure of the needed piece to appear within the first 45 moves is not a result of "bad luck", but rather represents the essence of the puzzle. A player who thinks the piece in question is simply "rare" might go out of his way to ensure that he's always in a position where he would be able to use it if it arrives, even though such a strategy couldn't possibly win if the piece doesn't arrive before turn #46. By contrast, if the player is informed that the piece will arrive precisely on turn #46, then the player will have a much better idea of what's necessary and be able to work much more productively to accomplish it. 

I'm working on a 2d RPG game in C# using an Entity-Component-System architecture, and I'm currently working on movement. Right now, I'm wondering how to organise the code so it looks a bit more.. pretty, or dignified, than it is. Currently, I have four components: VelocityComponent - Contains the speed (velocity) of an Entity. The behaviour currently is that if an Entity does not contain a VelocityComponent, then we continue onto the next Entity, because we cannot move if we haven't a velocity. TransformComponent - Contains the Width, Height, X and Y fields for the Entity. Basically, the position. Similar to VelocityComponent, if an Entity does not have a TransformComponent, then the GPSSystem just continues the next iteration, because we cannot move anywhere if we don't have a position. MovementComponent - Contains a pair of co-ordinates for use as a destination position, and a boolean indicating if the Entity is currently moving. MoveFromKeyboardComponent - Signals whether or not a key is pressed so that the Entity that this Component is attached to should move or not. The update loop currently goes that the GPSSystem collects a list of all entities (by accessing the EntityManager. The EntityManager simply contains a key-value pairing of Guid to Entity of all active entities. All systems have access to it), then iterates over the whole lot.. It'd be better if I just posted the code; 

I'm working on a project and I'm using some 3rd party sprites just to get it off the ground; recently I've come into a hitch. Slick2D doesn't seem to want to load my images. That is, it will warn me that images are the wrong bit-depth. All the images are in 16-bit PNG form (PNG is required for transparency). Is there any way I can disable the warning (being the bad guy programmer (the console print for each individual load REALLY SLOWS DOWN the image)) or is there another solution? I was thinking about converting all images (using imagemagick) to .gif (with an alpha channel). Would there be any loss in quality between formats? EDIT: I tried using imagemagick but some of the sprites use pure black so I can't do that without wrecking the image. EDIT2: using "identify" on any of the images show them as being 8-bit.. but Slick2D won't load them. What the hell? D: EDIT3: Issue solved (ish). If you are googling this then just disable the java png loader from slick by sticking this somewhere in your code (like the main method): 

However, I am unsure of how to proceed after this point. I just don't know how to manage the movement. I am aiming to have a movement style similar to Pokémon, where all Entities move one square (16 x 16) at a time and have smooth movement across those tiles, however the player can hold down a button and keep moving square after square, and when he releases that key, he stops moving (and snaps to the nearest tile if he is in the middle of two). So, on to the question: Am I going about this correctly? Have I got too many (or too few) components for movement? And lastly, how would I manage the fact that an Entity may have a MovementComponent and a MoveFromKeyboardComponent? I'm just confused I suppose. I am not looking for the code for that, I am just wondering whether I am going about this correctly? This is my first whack at an entity component system, you see. Best regards. EDIT 1: I should add I have now changed the structure of the System class, such that it now has a ComponentAdded and ComponentRemoved method; that is, we no longer iterate over every Entity in existence every Update(), instead we store the entities that have components we want to listen to in a data structure in the class. My question remains the same, though.