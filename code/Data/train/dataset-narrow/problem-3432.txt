I am using a Raspberry Pi 3 to control a series of Arduinos in a master/slave setup. All communication is via I2C. I've done quite a bit of googling on this and can't seem to find an answer on best practice for setting up a repeated I2C exchange. The communication flow is as follows: 

I am creating a master/slave setup with an RPi as the master and an Arduino as the slave. For now I am only using one, but I will eventually have up to 25 on a single I2C bus. On the Arduino side, the Wire library has a Wire.onRequest function as well as a Wire.requestFrom function, where .requestFrom is used by the Master to request a number of bytes from the slave, which uses Wire.onRequest to respond with the requested info. I'm currently using the Node.js i2c-bus library on my Pi to handle I2C. I'm wondering if the i2c-bus.read function works similarly to the Wire.requestFrom function. Are these apples and oranges, or functionally the same? The i2c-bus documentation mentions nothing about a specific "request" functionality. More generally, is the plain I2C read the same as the Arduino's "request" functionality? 

and this should be all that is necessary I think. I wrote a Bash script to set this up automatically: 

I figured out the cause of the problem and the solution was so simple it made me feel dumb. When I configured the static IP address in , I used as my CIDR number for some reason. Once I changed the CIDR subnet mask to , the webpage on the Pi started working across all 8 of the class C networks on my college's campus. 

I have a Pi Zero that is always running a Python script connected to a MySQL database on a website I am hosting. Every 5 seconds, the Pi updates a time field in the database, and there is a cron job that runs on the website every minute which checks that the timestamp has been updated within the past 60 seconds. If not, it sends an email to notify me that the Pi is down, and once the timestamp in the database has been updated, it notifies me that the Pi is up again. I have noticed when my home Internet goes down for a short period of time like a few minutes or less, it often takes the Pi approximately 15 minutes to reconnect. Other devices on my network reconnect as soon as the Internet is up again. I am using the official Raspberry Pi USB Wi-Fi dongle with my Zero, and have observed the same behavior on a Pi 2. I don't understand why there is this delay for the Internet on the Pi to reconnect. Has anyone else experienced this and figured out how to fix it? Thank you. 

Here is where you have to decide if you want the Zero to act as a serial gadget or an ethernet gadget. If you choose a serial gadget, it will simply give you a login shell and you can go from there. However, you'll need to be to access a shell on the Pi some other way. If you choose an ethernet gadget, it will show up as a network interface. This gives you a lot more flexibility because you can do things like VNC in -- which will give you a graphical desktop -- or you can share your computer's network connection with the Pi (Adafruit's tutorial talks about how to do that under "Ethernet Tweaks.") If you choose an ethernet gadget, enter instead of in the next paragraph. You'll also want to create a file called (no file extension) on the SD card to enable SSH. You don't have to do that now, but it's convenient. 

Since upgrading to the latest version of Raspbian, I've been having some problems with using it through TightVNC. I set up using the instructions in the official Raspberry Pi documentation, including the part that adds an init.d module to automatically start a VNC server at boot. Whenever I shutdown or reboot from the GUI (not the command line), or insert or eject a USB flash drive, I am asked for a username and password. This did not happen before upgrading Raspbian. I noticed that the release notes for the latest version say "Removed sudo from shutdown options", which seems like it might be related. I did some testing with a fresh SD card image, which showed that this problem does not occur when using the Pi directly (through HDMI, not remotely). It also doesn't occur without the init.d module that automatically starts VNC at boot, so if I start the VNC server manually, the Pi acts normally. This leads me to think that the problem has something to do with the Bash script mentioned in the RPi docs: 

The Pi 3 has a 1.2GHz quad-core processor and 1GB of RAM, while the Pi Zero has a 1GHz single-core processor and 512MB of RAM. It's expected that the Pi 3 would be faster on things like this. There's not really anything you can do. Your comment about the HDMI output not having this trouble does make some sense. I don't think that the BCM2837 (the chip in the Pi 3) has a different GPU from the BCM2835 (in the Pi Zero), so the speed would be roughly the same for both on HDMI. But with the touchscreen, speed is throttled by the GPIO pins, which (to my knowledge) are controlled by the CPU, which is slower for the Zero. Hope this helps. 

I've worked a bunch on this with my father and some colleagues. As far as we can tell, the i2c-bus.read functions identically to Wire.requestFrom, as we've been using .read on the Raspberry Pi and the .requestFrom interrupt on the Arduino side. The Arduino responds in the way you'd hope/expect it to. I can only really speak to the actual functionality. I'm not sure if there are differences when you get closer to the metal, but I would expect them to be pretty close since I2C is such a simple serial bus. 

If you are using Kodi, you can follow this tutorial. Fairly deep into the page, it mentions sound quality. You can use the HiFiBerry to provide better sound quality. I believe the HiFi will work with standard 5:1 surround sound. It functions both as the Pi's power source and as an on-board amplifier for really nice sound quality. Hope that helps! 

For the past month or so I've been working on basically the exact same thing, so I've researched how to do this a lot and know how to do it with the latest version of Raspbian (PIXEL). is a minimal display manager that bypasses loading LXDE, and (which is already installed on the Pi) provides a minimal session manager and works with the X server. To set up this environment in Raspbian, install with and edit the file . You need to set the option to and to (or whatever your username is). Then create a custom Xsession file in your home folder () with the following contents (the loop isn't necessary, it just automatically restarts the Python script if it crashes): 

Next, open . This file is one long line, so don't add any newlines. Go to the end of that line and add a space followed by . Now eject the card and plug it into the Pi, but leave it off. If you decided to go the serial route, you'll need to boot the Pi, log in by some other method, and run to enable using the connection as a serial console, followed by to power it off. Now, use a micro-USB to USB cable to connect it to your computer (make sure to use the port labeled "USB"). The Adafruit tutorial goes into more detail on how to connect to your Pi from there. 

You can make the Pi act as a USB gadget and impersonate a USB device. Adafruit has a tutorial on how to do that -- or you can just keep reading for a summary. Plug the SD card into another computer. Depending on the OS, you may see one or two new storage volumes. (If you see more, that's because you're using NOOBS. If you only have one OS installed, the rest of the tutorial will work.) Find the volume with the files and in it. Open a text editor. If you're on Windows, open it in WordPad or Notepad, not Word. Scroll down to the bottom and add on a new line. Now save and close. 

The problem only occurs when the VNC server is started by this script, but not otherwise. Is there anything in this script that looks like it might be the cause of the problem? 

My college has a WPA2 Enterprise network, which I can connect to on my Pi after adding the network in wpa_supplicant.conf. I don't want my Wi-Fi password stored in plain text, so I use to hash it, and then store the MD4 hash instead of the plain text password in the file. I've helped a lot of students to get their Pis connected to the network, and doing this has always worked, until last night when it wasn't working for someone. It seems like the problem is that their password is longer than 14 characters, which is great for security, but it causes problems with the MD4 hash algorithm. Is there a way to hash passwords in the wpa_supplicant.conf file that are longer than 14 characters? I guess I should try using only the first 14 characters of the password to connect, but if that worked it would seem insecure. 

Is it best to simply stick these communication functions in a loop? I have several other major functions (reading/writing from/to GPIO, exchanging data with a webserver) that are about equally important as I2C comms. What is best programming practice here? I'm brand new to Javascript and want to do this right. 

Pi broadcasts a few bytes of start/stop data to all Arduinos on the bus. Pi then requests information from each Arduino, one at a time until it has gotten a response from each one on the bus. Repeat 

If you have an external display (i.e. a TV with an HDMI port or a desktop monitor) you can simply use that to get started. However, if you don't have that, you can follow this guide which should get you started. The linked page walks you through using a laptop screen as a display for your Pi. Luckily, all you need is an Ethernet cable! 

I have set up a Pi 3 as a web server on my college's WPA2 Enterprise network, with a static IP configured in . I've connected it to the Wi-Fi manually by editing (and am using a CA certificate). It stays connected to the Wi-Fi consistently, so I can always access it remotely through a RealVNC cloud connection. Since the Pi is set up as a web server, students whose laptops are connected to the same Wi-Fi network should be able to access it simply by entering the IP address in their web browser. However, most of the time the IP address is not accessible, and attempting to load it in a browser results in a "connection timed out" error. If I connect to the Pi through VNC over the cloud, then the IP address loads in a web browser instantly, and continues to work for about 10 minutes or so afterwards. It seems like there is a timeout on accessing the IP address over the Wi-Fi, but somehow starting a cloud connection enables it temporarily. I can't do pings on my school's network, but I tried running a traceroute command on the Pi every minute to see if that kept the IP address accessible, and it didn't. I'm not sure what is affecting whether the IP address can be accessed?