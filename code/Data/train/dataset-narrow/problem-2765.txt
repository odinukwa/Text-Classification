The A* algorithm will also allow you to assign values to tiles indicating their suitability. For instance, you can assign the lowest cost scores to low land for rivers, to flat land (but not swamp) for roads, and generate based on that. This doesn't give you the shortest route, but it does give you the most efficient route. Apply a little randomness to your tile values and you can get some sub-optimal routes. 

So, after some research, I found the problem (Jamie Hyneman: Well, THERE'S your problem!). Essentially the comment I referenced earlier describes the issue. When you change window size, the device is lost. When the device is lost, rendertargets are invalidated (but not textures). You can either check the RenderTarget2D.IsContentLost flag, or attach to the RenderTarget2D.ContentLost event to trap this as it happens. Also, the Rendertargets don't seem to ALWAYS get invalidated. It may depend on resource usage. 

I've run into something sort of similar, and the quick answer is that once windows starts processing the quit, you don't have a lot of time. Controls and resources start getting destroyed immediately, and it is entirely possible that by the time your thread gets around to referencing the resource, it's already extinct. I got around this by intercepting the WM_QUIT (IIRC) message and sending a command to the thread to shut things down. The thread then informed the main window when it is time to actually close, after all cleanup had been completed. 

I am working on a GUI in XNA 4.0 at the moment. (Before you point out that there are many GUIs already in existance, this is as much a learning exercise as a practical project). As you may know, controls and dialogs in Windows actually consist of a number of system-level windows. For instance, a dialog box may consist of a window for the whole dialog, a child window for the client area, another window (barely showing) for the frame, and so on. This makes detecting mouse hits and doing clipping relatively easy. I'd like to design my XNA GUI along the same lines, but using overlapping Textures instead of windows obviously. My question (yes, there's actually a question in this drivel) is: am I at risk of adversely affecting game performance and/or running low in resources if I get too nuts with the creating of many small textures? I haven't been able to find much information on how resource-tight the XNA environment actually is. I grew up in the days of 64K ram so I'm used to obsessing about resources and optimization. Anyway, any feedback appreciated. 

Normally I guess you'd use BlendState.AlphaBlend because normally when you load your textures through the pipeline they're already premultiplied. However, if you're loading textures at runtime from PNGs or some such, you have to loop through the pixels and premultiply them, which can take a long time if you've got a lot of textures to load. So it looks (haven't tried it) like using BlendState.NonPremultiplied instead of BlendState.AlphaBlend should handle non-premultiplied textures and produce the same visual result, without all the startup costs. I have to wonder if there's a non-obvious cost to doing this, like a huge drop in performance or something. Anyone know? 

I'm playing with XNA 4.0, VS2010. I've created a window (not maximized) and drawn some sprites. All is good until I resize the window, after which the sprites stop displaying or only partially display. I'm pretty sure it has something to do with needing to reset the device or something, but can't find any clear instructions or sample code. It's not just a case of needing to increase the preferredbackbuffer size, because even if I shrink the window I get this symptom. I've looked at the source code that I was able to get from Microsoft before they shut down XNA, but it doesn't actually explain anything. Any help or advice? If it makes any difference I'm creating DrawableGameComponents and doing my updates and drawing in their Draw/Update routines. 

Using XNA, c#. I'm writing a stellarium-type of program-- well, trying to :-) -- and I have a 'sun' texture that I'll be pasting onto triangle primitives. I'll also be floating some text above each node, which will probably be on the primitive as well. My issue is how to force the primitives to always be facing the camera, despite rotations and movements of the viewport. I'm going through my XNA programming books, but there's no obvious solution. I'd appreciate a pointer in the right direction. Note: I'm not using 3D models, so AFAIK there's no Matrix to work with. I have 3 vector3's that define a triangle, and I guess I have to modify their addresses on each update to face the camera. That seems pretty intensive, so I'm thinking I may be missing something obvious. 

Ah yeah. Fire Emblem, a great game indeed. If you take a really close look to the critic attack of Lyn you will actually got it. The first slash is going from down-right to up-left. That will be the first slashing image starting from the left of the sheet combined with the second. So, we can say that the second slashing image is a continuation of the first one, and that makes a single large blow. That's why the end of the line in the first image is fat headed, so the second image can be placed parcially on top of it. Same thing happens with the third and fourth images, (from up-rigth to down-left), they both are a single great blow. After the enemy get's hitted, she then returns to his place, and that's the last slashing image. Reasons for making a first blow in two images could be a couple, I think. One of them is to make the eye believe that the blow really last a while so, it gives an impression that Lyn traveled a long trail around the enemy in pretty high speed. She is really fast, so she cannot be seen! D: The other reason is that the width and eight of every image that represents the blows were not enough, so they had to make it in two pieces, probably, because some systems work better in power of 2 images, say 64x64, if you take a look to the second and fourth images, that are the continuations, they have the same width and height, and the fourth one Its like is not finished, but it doesn't matter, because, where is placed on the screen, it make's it look like it continues. And about the spikes, I'm not an artist, but I think it resembles where the end of the sword is pointing, notice that, spikes are when she draws the sword from the cover, and at the end of the blow, when she hit's, giving some impression of colition or friction. And the middle clean part is where the sword takes more speed. 

So a Floor block, Its just floor, and does not need to be animated, you will only need to place it somewhere, and give him a look, (asuming you are making a 2D game), that, would be just drawing a sprite and... done. Then a floor, a wall, a door should be allright just extending of Enviroment: 

I will try to help you a litlle bit, in the way I can. Correct me If I am wrong. If I got it, then your game is about creating a dungeon, in wich, you can place block's to build it, like floor, ceiling's and such., and not only block's but you have other object's as well, like chest's and spikes. So If I where to create a game like that, first, I would make an abstract class, wich is a father of all kind's of block's, or "Placeable's", these can be placed on dungeon's to build the stage. So, the essential part of code wich manage placing thing's on stage, will be in this class. Everything that you will put on the stage to build it, will be, in essence, for example an "Enviroment" Object., this object should be like an "Actor" as well, because, It's an object that is going to be drawn on screen, and (I least that's what I think) he should know how to draw himself, every Actor should have a Draw method that say's how he behave's when need's to be represented on screen. That said, father class, would be like: 

When you make a list, you are making an Enviroment one, and you are adding Enviroment, you don't really care what kind of Enviroment, you just know that they are going to be placed. I think that a game is complex enough for not-to-be organized with code, so, this is how I would do it. Sorry if I extend it too much or If I gave you bad practices, but at least is a point of view; Im curious of what kind of platform you are aiming for, if your objective are smartphones I would start from here and then see what I can do to ease method calls or drawing, for example, floor's, don't necessary need to be a lot of block's, but just a large sprite with a certain pattern that cover's all the screen, different would be the case with other Enviroments that could be smaller. A solution could be just store in a list where the HazardousEnviroments Are placed, so you just ask if any adventurer I'ts on any of them, and if possible, limit the amount of those according to your adventurer's level, should help you save the amount of check's. Hugs.