That array is pretty small in comparison to your alternatives.... Now, using that, you can quickly find (in \$O(n \log n)\$ time) whether a search string is a suffix: 

Your question implies that you have a sieve of Erastosthenes, but you do not. The sieve works from known-primes forward to a value with a given magnitude. In other words, you start with a known prime (2), and then you eliminate all the multiples of 2 until you get to the end-point of the sieve. Then, you move forward from that known prime, to the next prime (which is the next number in your sieve that is prime). You then eliminate all multiples of that next prime too. This ends up looking like a 2-stage process with a setup stage, and a double-loop stage. Your code has a setup stage that is not used, and then has a three-loop structure that does things back-to-front. The setup stage creates the sieve, which is a fixed size, that needs to 'cover' the 'nth' prime, wherever that may be. You may have to cover more than the exact value, which is why the formula looks handy, but you should investigate this Wikipedia article about the approximate value of the Nth prime So, once you have a large enough 'sieve', you then loop through it as follows: 

In general, I think this solutions is doing the right thing, and the algorithm, in a broad sense is doing it the right way. There are two specific areas where I think it can be improved: 

I have been testing it against some input data similar to @tsleyson's, and then added in a performance test too, that checks the scalability of a non-matching case. 

That loops through each grid position, but instead of 'clipping' the checks using simple conditions, you try/fail them. Use the following types of logic instead: 

In your code you have declared a variable which is a . This is an indication that you have a mismatch between the object and the implementation. The fact that you call it 'dice' implies you want something that is a Dice.... not a Random. A should be able to "encapsulate" itself. I would suggest a clean Java object oriented design would have a Dice class, something like: 

Additionally, the "wrong character" message is .... useless. You shoudl have an exception that indicates what the wrong character is: 

Your code is an odd collection of loosely related functions, many of which have solutions in the Java Streams API. In addition, you have odd signatures that don't make sense. I look at methods like: 

General I believe the rest of the code supplies the required functionality. There are odd cases where, for example, on Linux you can remount a sub-directory at a different mount point. These two distinct file-systems may mirror each other, and a file/directory in one mount-point is identical to the other mount point. This may produce false-positives in your code (where your code will claim the directory is not allowed, but it actually is...). False-positives in 'edge cases' in a security situation are better than false-negatives. The intricacies of the new-in-Java-7 NIO2 Path class/interface may help with this. You could translate your instances in to instances, and then use the isSameFile(...) method... which may, or may not help (reading the documentation it is unclear, and I do not have direct experience with that). Update .... more Paths: Using the and other NIO2 features, your code could probably be reduced to: 

Badge classifications The first change required transforming the badge source/classification data in a collection of in-statements, to a set of virtual tables instead. Statements like: 

Note, this declares the dimension for the game. This is a single constant. Your use of and in a lot of places is called using Magic Numbers, and this is a bad thing... You need to replace those with a OK, that gets rid of the copy/paste initializer. Math.random() To initialize the 'alive' cells you use: 

Your description of the problem indicates that each event type can have multiple listeners, but the code only implements one listener for each event. Is this intended? The awkwardness is a "feature" of go.... Because Go is 

Input validation is a critical aspect of any reliable program. Your code is functional, but there are a few things to note. First up, the is not a good error type to return, use an instead (because it is an illegal argument). Note that extends so it does not need to be explicitly checked/thrown. Next, you should validate inputs before using the values - using a "Guard Clause". While your code technically does that, the logic looks like the validation is done after the are updated. Finally, error messages should give the user/programmer an indication of what's needed to fix the problem. Your message should be more useful. So, all things considered, I would do the code as: 

Yeah..... no. Not a good idea.... ;-) You are using a class to do the job of a method. The real question is why you feel you need to declare the method inside your other method (for the record, it is highly unconventional to declare a formal class inside a method too... an anonymous class is common, but a formal class is odd) You really just want to have a private-static method that does the work for you... something like: 

Your code is neat, and it is easy to follow the logic through. On the other hand, I am confused by two things. 

This looks for an asterisk, followed by characters, and then a (zero length) word-boundary. Now, both and match that, since the happens before the asterisk. The negative lookahead would be useful after the word-boundary. Consider the following: 

is essentially remove the item at position 0, which, for an array list, means every other item needs to be shuffled forward one spot. To remove the first item, you have also moved every other item. Again, when you find the next multiples of the prime, you are shifting each larger value by 1 position as well. This could result in a lot of shuffling..... a huge amount, in fact. What's worse, though, is as you go through the multiples of the prime (for example, 7), you say: 

the value we are processing right now (the value ) the column above the us (contains the values ) the row we have processed so far (contains the values ) the rectangle above-left of where we are so far (contains the value as well) 

scan all the characters once, and count the 1's and count the 0's - O(n) find out which one is more common (difference between overall counts) - O(1) 

Right, when you have value-based items like this, it is often convenient to make the Point have a 'natural' ordering. This means that the Point class should implement , and then implement the method. Having two comparators is a problem, you only want one, that does both coordinates. Consider a method like: 

The TreeSet is a problem because it has a significant time-complexity (and storage size). Adds to the TreeSet are \$O(\log{n})\$. As the dataset grows, it gets noticeably slower. You can be sure that the test software will do something like: as input, and that will take a long time, and a lot of space, in your TreeSet. Your solution, because of the TreeSet, essentially becomes one of time complexity \$O(n \log{n})\$, and space complexity \$O(n)\$ The solution is much simpler than what you have done... consider a simple function: 

That's a pretty short list of nit-picky things. In all, this is a good program. There is one suggestion I have for your recursion, and that is that there are multiple 'styles' of recursive methods. If you choose one method, and use it consistently (except for those times the other methods are better), it helps. My suggestion is that you should settle on what I call optimistic recursion.... which is the opposite case of what Wikipedia calls 'short-circuit recursion'. What I am saying, is that 'standard' recursion checks the recursive state, and, if it is valid, it does it's work, and it then calls recursion. The short-circuit system does the state-check of the new state before recursing in to that new state. By way of example, a standard (what I call optimistic) recursion for this problem would be: 

Now, we're cooking. How much, though? Before we get there, I am going to suggest another change, which is to take the insides of the loop, and make it another function too, and also make some variables 'final', so the code looks like: 

The array in an enum will always be indexed in the same order as the ORDINAL of each Enum. The second thing, is that you should only be calculating the Datacenter location once for each JVM. Having it as a method which is called potentially multiple times, each time interrogating the java.net.* layer for hostnames, is inefficient. I suggest you add a static initializer method to your Enum that 'knows'. Consider the following changes to your enum, and replace the logic in your code: 

created when you accept a socket. switch to Reading if the client is a valid client (using your protocol). be attached to a SelectionKey.OP_READ when data is available, the handler is updated with the new data if the data constitutes a full message, the state changes to Processing and: 

Doing the split-on-change (with the non-capturing change regex) allows you to do a simpler "removal" of the newlines in each change. The result is... simpler.