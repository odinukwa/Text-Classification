You write code in Lua when developing in CoronaSDK. That information is definitely on their site, although it's not as prominent as it used to be (I haven't looked at the front page in a while). For example, here's the page under the "Games" heading: $URL$ First sentence: "Built on top of OpenGL, OpenAL, Box2D, and Lua" 

At my company we use FingerGestures Using that add-on, you'd be listening for and responding to events like: FingerGestures.OnFingerDragBegin += FingerGestures_OnFingerDragBegin; FingerGestures.OnFingerDragMove += FingerGestures_OnFingerDragMove; FingerGestures.OnFingerDragEnd += FingerGestures_OnFingerDragEnd; Use the position returned from drag begin and drag end to determine the magnitude and direction of the drag, and record the start and end times in the event handlers to see how fast the gesture was. A drag done quickly is a flick. 

(this is just one of a million reasons why developing multiplayer online games is harder than developing single-player games) 

This question sorta implies to me that you don't actually know what aliasing/anti-aliasing means. I mean, you say you "know what it looks like" but if you actually knew what the terms mean, you'd probably realize your question is nonsensical. Aliasing is a side-effect of how computer graphics are rendered, and computer graphics are pretty much by definition not physical phenomena. "Aliasing" just refers to the stair-step look on angled lines because computer graphics are actually comprised of lots of tiny squares in a grid. Here's an image to illustrate what I'm talking about: 

First off, are you aware of the command BroadcastMessage? It's not quite what you are asking for, but it's close and it happens to be named the exact terms you used. That command sends a message to all children, not siblings, but that means it will message all siblings if you use that command on the parent. So write something like: transform.parent.BroadcastMessage("FunctionName"); 

SDK applies to all of software development, whereas "engine" pretty much only applies to games. That's the only real difference between the terms (and even this description of "engine" plenty of people will disagree with); everything else is just semantics. 

This is closer to the real problem. Again, I've never thought about it in terms of "X swipes per unit time" and more in terms of "swipes are a lot less accurate than a joystick". 

The simplest thing to try: Make the rate that the missile turns very low while the rate that it moves forward is very high. That way it can't make quick turns and will zoom past a dodging target. Another approach that may look better: Track only until the missile is within a certain distance of the target, and then the missile is locked onto it's course until it has passed the target position. That way it won't correct again until after zooming past. 

You mentioned Metroid in your last paragraph, but I would point to that game as the best example of an open-feeling 2D side scroller. Castlevania II also did this well (the others were more linear). 

First off, "better" is a relative term. 2D animation (2D games in general, not just in unity) is generally done using spritesheets because they give you the most flexibility. That said, Unity can display any 3D content within a 2D game, so you can use a 3D animation like fbx. That will give you an advatage with interpolation/variable framerates, but at the cost that the appearance of the animation is less flexible. The thing to realize is that it's still fundamentally a 3D animation, it's just viewed from one side. Thus create the animation in a 3D animation tool, but make it work with a static side view. For example, the 3D parts may actually be planes oriented to face the camera. 

What you're talking about is non-photorealistic rendering (aka NPR). In a realtime 3D game that's done using fragment/pixel shaders. Scroll through here to see a few examples: $URL$ 

Various Flash game frameworks have this sort of functionality built in. The gist: 1) Load your map data. Lookup how to load XML/JSON in Flash. 2) Loop through the data in order to figure out where to place tiles. 2b) While looping through the data, instantiate the appropriate images and place them at the coordinates defined in the data. Pseudocode: 

It is an apk, but your computer associates that filetype with Gamespy Arcade Online. When I search on "gamespy arcade online filetype" I see that it is also APK: 

First off, there's this function $URL$ But this may not be the ideal approach in your situation; it's hard to tell. The more typical approach to referencing objects in code is to link them in the Editor. To do that, declare a variable for the object at the top of your code, and then that variable will appear in the Inspector. Now drag your object onto the Inspector. 

However if you don't want to use that tool for some reason and absolutely have to have test controls done using a joystick or keyboard, just program alternate controls using GetAxis("Horizontal") and put this code inside a compiler directive #if UNITY_EDITOR 

Corona SDK is a great tool for developing 2D games like Angry Birds or Cut the Rope. cocos2D is a very awesome tool but programming in Lua is way more productive than programming in ObjC. It's a lot like using ActionScript. They even did a sample specifically to demonstrate developing an Angry Birds clone in Corona: $URL$ 

Depending on exactly what you are trying to achieve, I might recommend not scaling anything (either the camera or your sprites) and instead just worry about the differing aspect ratios (eg. moving things to the edges of wider screens). Things will scale to fill the screen automatically; the graphics won't be pixel-perfect anymore, but with the high-resolution displays these days, that may not matter. 

This depends a lot on how the events are actually communicated between objects in your game. For example, if you are using a central messaging system then you could have a tutorial module that listens for certain messages and creates tutorial popups whenever it hears certain messages. Then you could set what message to listen for, along with what popup to show, in an XML file or something that is parsed by the tutorial module. By having a separate tutorial object that monitors the game state and displays tutorial popups when it notices stuff in the game, you can change the tutorial object at will without needing to change anything else about your game. (Is this the Observer pattern? I'm not familiar with all the design patterns.) Overall though it depends on the complexity of your tutorial if it is worth worrying about this. Hard-coding the events in your code and/or levels doesn't seem like a big deal to me for just a handful of tutorial popups. I am curious what exactly you have in mind that makes you think it'll be inefficient, since all you should be doing every trigger is just dispatching a message to the tutorial module, something like TutorialModule.show("1st_kill"); 

My favorite spritesheet packer is Texture Packer: $URL$ There's a free version that works pretty well, but the paid version adds features like resizing. Another option is Zwoptex: $URL$ 

Octrees are a good way to organize polygon soup scenes for visibility culling. The idea is similar to other sorts of recursive dividing techniques like BSP or even quicksort, but more 3 dimensional. 

You're 16. Don't worry about not being sure about your future career, just concentrate on learning as much as you can about as many different things as you can. 

There are many ways to give all your game objects a reference to the EventManager class. A static reference is certainly one way; another is with a Singleton. Both of those approaches are pretty inflexible however, so most people around here recommend either a service locator or dependency injection. I've been doing dependency injection; that does mean a separate EventManager field for each object, which is what you seem to want to avoid, but I'm not sure why that is a problem. It's not like there's a lot of overhead from storing a bunch of pointers. 

Well there are a couple ways of thinking about this. One is to list the specific features the engine should have (what you've asked here.) However the other way is to just start making games without worrying too much about the "engine", and then features you find are being reused between multiple games (in particular, features used in every game) you should migrate from the source for a specific game into a shared codebase called "engine." Because in the end, why you want a given feature in the engine rather than in the game is that it's shared between multiple games. Typically that'll be things like drawing commands, input controllers, and networking code. A 2D game engine will have lots of 2D graphics features, like loading images, a display hierarchy with z-order, handling spritesheets, tweening, etc. A lot of games need physics simulation, although on the other hand many don't. Meanwhile more "under the hood" stuff used in almost every game includes timers, event messaging, and even math functions specific to game development (eg. distanceToTarget() 

I want to add the caveat here that it's more efficient for processing if there is only one listener for each event on an object. This is kinda premature optimizations so I wouldn't stress over it too much, but if you have multiple functions that you want to happen in response to an event then it's better to have a single event listener that calls the multiple functions. This is a slightly different situation than what you asked (a single listener on each of multiple objects vs. multiple listeners on one object) but it's related. 

I usually go with a design where objects handle themselves (that's what methods are for, after all) but the base World has lists of all the objects and it uses those lists to coordinate them. So something like: 

Another important consideration besides the sheer number of entities is their complexity. A component-based system helps a lot with complex entities, but is just unnecessary overhead for simple entities. Going back to my keys example, I probably wouldn't bother with a component-based system for keys. I would use a component-based entity system for enemies, but then you said your game won't have enemies. What exactly are the entities you have in mind? Maybe not a full list, but at least give us a few representative examples. 

It depends what exactly you mean by "maps". If you are just talking about the tile layout to display, then that's probably not necessary to put in a database. A database is meant for a massive quantity of data that needs to be sorted, like all the users of a website; for the relative handful of maps that a typical game has you can just store those as flat files and have the game use a plain old URL to retrieve them. In other words, what you're already doing (a text file stored on the server) is fine. Now if you are talking about dynamic and persistent data about what is going on in the maps (eg. where other players are) then that data should go in a database. Similarly, if the maps are user generated then that's a whole different enchilada, because players will generate a lot of content; again, massive data that needs to be sorted goes in a database.