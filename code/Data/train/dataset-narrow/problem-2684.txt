Otherwise CoolPlayList probably be treated as an SQL command and would come back with an error such as invalid SQL statement. 

I'm not sure why you think: As you can see, sooner or later, with many maps I will be dealing with many IDs. And that can possibly get a little confusing and hectic. LeftID will always be -1 of the currentID, the rightID will always be +1 of the currentID. UpID will always be -(total map Width) of the current ID and downID will always be +(total map width) of the current ID with the exception of zero meaning you've hit the edge. A single map can be broken into many maps, and are saved sequentially with mapIDXXXX where XXXX is the id. That way, there isn't anything to be confused about. I've been to your site and it seems, I could be wrong, that the problem is down to your map editor imposing a size limitation which is hindering your automation to break down a large map into multiple small ones on save and this limitation is probably restricting a technical solution. I've written a Javascript map editor which scrolls in all direction, 1000 x 1000 (I wouldn't recommend that size) tiles and it still moves as good as 50 x 50 map and that is with 3 layers including parallax scrolling. It saves and read in json format. I'll send you a copy if you say you don't mind an email approximately 2meg. It is meant to be on github but I haven't got any decent (legal) tileset which is why I haven't bothered to put it on there yet. 

Consider the factors: 1 - purpose of this character is commercial in nature, as even if it's a small event in your game, everything about it would be a commercial for the game 2 - no actual work is being copied here, only a reference to an idea 3 - no amount is copied, again only an idea is used 4 - one could hardly claim that MGS series would be out any consumers due to a minor reference in your game Now for extreme contrast suppose you had this example: 

Open the application and go to New. In the dimensions, put 8 for width and 8 for height. A new 8x8 canvas will open, typically I zoom in all the way to 3200%. I'll also get rid of the white background layer, by making a new layer, then deleting the background one. Now you have the canvas to work on, you can save it as a .pdn file. When you are ready to save the tile/image/sprite, go to File -> Save As, and choose file type: PNG. A "Save Configuration" box will open up and you can choose "Bit Depth: 8-bit" to save the completed work. 

Chrome is likely to use hardware acceleration. Create a canvas 240x240 and run your experiment in Chrome then create a canvas 300x300 and do it again. The larger canvas I expect to be faster due to the fact hardware acceleration kicks in after 256x256 and chrome uses software when the sizes are less. Also it worth pointing out that -webkit-transform:translateZ(0) turns off hardware acceleration. I haven't tested any of the above; I only know this due to the fact one of the chrome engineers commented on a bug I reported in chrome when you cross the hardware and software threshold by dynamically resizing the canvas from larger to smaller than the 256x256 boundary or vice-versa. The solution to this bug was to turn off acceleration using the translateZ as mentioned above. In my case, I simply did not allow users to resize less than 256x256. 

These four factors often play differently weighted roles from case to case, See American Bar - Satire/Parody Fair Use It would probably be really hard to prove damages from such "infringement". The main idea behind copyright is to protect the vested interest of the copyright holder from losing value due to someone stealing the holder's work and passing it off as their own. Without a copyright law, the stealer could gain profit from the holder's work and the holder would have no legal recourse to gain back the lost value. When referencing other's work, you have to consider, does their work benefit from your perspective and provide mutual gain, or does your work benefit from the reference and hinder their's? 

I think your way works best. These sort of items each give a condition, if used together they produce a different condition, then you would effectively need all 3 possible conditions defined. You could also go about it by creating a new type of definition when both items are present, but this actually adds to the convolution: 

Looks like you you have duplicated the background position twice in the else part. I've inserted the 2 below 

Reason for this is that you will not time your interval with the main loop which is clearing the screen which prevents you from seeing the 'sparks' Finally, probably harmless, but to be safe, change the comma to a semi-colon here 

You don't give enough detail for me to conclude if this is a viable method but I'll throw it in there anyway as a possible solution. Someone else may find it useful if you don't. You don't say how many zlayers there are and if there are only very few layers then this may be an option. What you can do is store more one tile data in a long variable by using bits. Let say you have 4 layers and 255 tiles per layer to keep my explanation simple. You can do that in a single long by using bitwise AND and rotation. first 8 bits could be layer 1, second 8 bits could be layer 2, and so on. in order to get the right tile in this particular data format for the layers you would do something like 

If you developed the demo in the video on your own you should be able to understand what is needed for the movement animations. You need to post examples of attempts at coding the movement. In simple terms; You need to capture the movement event(s), you then need to specify which animation(s) to use in those events. 

You are saying here: If the left mouse button was released AND is being pressed currently; This seems like contradicting actions, mouse buttons are usually pressed first, then released to signify a singular action (or continuously pressed to signify on-going action(s)). Perhaps what you are looking for is here is: If the left mouse button was released OR is being pressed currently; 

The purpose and character of the use, including whether such use is of a commercial nature or is for nonprofit educational purposes; The nature of the copyrighted work; The amount and substantiality of the portion used in relation to the copyrighted work as a whole; and The effect of the use upon the potential market for or value of the copyrighted work 

Scaling up any bitmapped image such as png will always look pixelated. To avoid this, if you have the memory, save the non-scaled image twice the size you currently have now and scale down 50% to get it looking like the non-scale image in the above diagram. To get it looking crisp at 2x-scale, you don't scale at all because it is already at that size. Your other option is to use vectors, but this can become expensive in terms of consuming processing time and may lack finer details compared to bitmap, i.e. look cartoony but that could be a positive on your game. You also need to find an appropriate library to do this. The advantage of using vectors is that it will most likely take up less memory and will look good, as long as it isn't too tiny, at any scale compared to using bitmaps.