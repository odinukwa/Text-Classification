Now DHCP will still write informations on these "files", but the content will be live deleted :) Edit : If anyone knows how to do this in the config file, it would be nice ! 

I had never work with, but , a virtual keyboard, seems quite common in the rpi community : florence.sourceforge.net This page also list alternatives virtual keyboard programs : GOK, XVKBD and OnBoard, wich may, or not, run on Raspbian :) 

As the "up to" syntax don't seems to be valid in this case. Instead, try to use or , or just leave this line as a comment :) 

For a real world code, you may want to use one of these syntax, that close camera even on unexpected error : 

Triple check your CSI connection. It may seems trivial, but one can easily loose hours not doing it ! 

About 2) I doubt you can reverse your signal with this shematic. If you want to swap these values in an electronic manner, you will need a NOT logic gate. This gate can be a specific chip, or can be made with a single transistor, using this kind of shematic : 

Here is another way to achieve the most bare-metal display system i can imagine : Writing raw pixel data to the frambuffer device : Prerequites : - the touchscreen has to be recognized as /dev/fb0. - the frambuffer resolution has to be defined in or via command. You can aquire raw pixel data by reading /dev/fb0 : 

You may also define the env.var. in the same manner, if you know the /dev/ node of your sound card. The value of this variable should look like "/dev/audio" "/dev/snd". 

A better solution is to remove the : and lines, as this pin is not connected with the ULN2803A chip. This pin configuraton was only provided in the adafruit tutorial for compatibility with other stepper chips. 

To got a bit further then Steve Robillard, I would use the result of command, showing CPU usage in %, as a base of calculus. As gives CPU usage over different periods, it will suit any of your need. Now that we can see our CPU usage, it's trivial to measure RPI consumption under different load (using any multimeter), and find either a formula that links these values, either a table that will associate CPU % usage slices and mA consumption. Note : if CPU % usage isn't enough reliable, cpu temperature could also give a hint on power consumption. You can get this value with : 

If you need more flexibility, you can edit themes by modifying images : /usr/share/plymouth/themes/themeName If you launch plymouth via initramfs, don't forget to update it ! This is the case if you have a line in your conft.txt file that starts with 

Surface.get_at() or or Surface.set_at() functions may be a bit slow, in this case you can use Surface.get_buffer() as described here : $URL$ Welcome in the graphical programmation world :) Edit : you will need to run this code with sudo, and may also need to hit Ctrl-C in order to complete pygame initialisation (see : $URL$ 

- Then the subprocess is told to refresh the UI via a stdin message. (take 0.00s) Can I expect to achieve better performance on the conversion or mmap part ? Or is there a faster way to communicate this RGBA layer from my main python app to my dispmanx C program than mmap? Thank you for your suggestions ! 

Try to replace your by a . You may occur this strange behavior as GPIO.output is switched too quickly from HIGH to LOW to be set/detected/seen. Increase/reduce the sleep duration until the program works fine (increase) and fast enough (decrease). 

You will quickly face 2 problems : voltage and current. Voltage You battery produce 3.7V, the Raspberry use 5V, your motor 6-9V. You will basically needs two DC-DC step-up voltage converter to produce 5V and 9V from 3.7V. Current Now let's look if your supply provide enough current : The raspberry pi3 needs 2.5A at 5V and the converter is said to have a 95% efficiency. 

Found it : mmal is slightly faster than mmap. Refer to the picamera module, overlay section, for a real-world implementation. 

I'm not sure that the camera can output such a resolution. Can you try with another resolution, using one listed here ? For note : 2592x1944, 1920x1080, 1296x972, 1296x730 or 640x480 on V1 camera For a V2 camera, the HD resolution is 3280 x 2464 

I was in a quite similar case, and did choose to use , a python binding to SDL, a graphic library. Good points : As SDL don't rely on X11, pygame can be run from console, and shows a nice fullscreen graphical application, heavily customizable (aka : you start from a black screen, then draw what you want on it) Pygame is quite well documented and discussed, quite easy, offers all the base functions you will need to manage user interactions and interface in a single library. Bad points : Pygame lacks GUI content: it's up to you to draw every buttons, icons, boxes, as image files. (You still can display geometrical shapes and texts to screen just with code.) Some user input have to be manually managed : by exemple don't expect to use a text field object "out of the box" : you will only be able to read raw keyboard press and have to edit the right button in the right page, then refresh your screen, at each press ! Don't worry too much about this, it's not dramatic, just a bit annoying. If you want to give a try to pygame, take a look to this software from adafruit, it's a very good inspiration when building a GUI : The Button and Icon class are very well written, the page management is quite nice too. Alternatives There are other tools to write graphic interfaces running without X11, and even GPU optimized : dispmanx and openMax. They are far more difficult to work with (gpu memory management is a pain) and your client would need to be written in C/C++. Worst, these libraries lack tons of tools that pygame can provide (no user input management ..) 

I'm working on a graphical application, made for console mode, and facing some performance issues when working with large resolution (1920px wide here). One part of the display, a video background, is generated and displayed via pygame (SDL 1.2 python bindings). The other part of the display, the UI, is also generated with pygame, but is displayed as a GPU overlay (based on the dispmanx API : $URL$ via a fork of pngview, launched as a subprocess. Here is the detailled steps and timings : - UI image is generated on a pygame Surface. (take 0.03s) - Pygame surface is converted to a (x,y,4) int8 array, representing the RGBA array. (also take 0.03s) 

I can't exactly reproduce your problem (i had the "Out of resources (other than memory)" error), but I still think your code lacks a crucial part : closing the camera after use. So your code may work, but only one time : after that, the camera ressource will be locked, until reboot. Adding a simple line may be enough for your minimal exemple : 

This will work fine, unless you have to tranfer large amount of datas (i.e. images). In this case, I would write these data to a temporary file, then only pass the file location via stdin/stdout. 

Passing this variable to None at the program initialisation and at each specificFunction() call prevent your program to trigger this specific function at boot or multiple time. 

Please consider it's almost impossible to use a random screen with your rpi ... If you are extremely lucky, you will be able to find your screen reference on this github wiki. In other cases, you will need to write or adapt by yourself the driver for your specific screen, wich is an hard task for an expert. Be kind with yourself, buy a 3.5" touchscreen compatible with the pi, you will save a lot of time and loose only 15-30$ ! Note : idem about the camera. Most of the USB cameras are compatible with the rpi, first price are around 5$ ! If you want to keep it small, the rpiCam is also really wonderful ! (around 30$) 

So both humans and "computers" will physically be able to push your switches. This method has a backdraw : it seems to need a specific OS to work on the rasberry, as discussed here. 

As you are converting images from Color to Gray, your should have a format like RBG, BGR or RGBA. These formats use 3 or 4 colors per pixels (as stated in the error message). So you may want to save your image once captured and look for these 2 points: - Is the image valid ? (0 sized frame may throw this error) - Is the image already black and white ? 

I worked with one of these almost unbranded 3.5" touchscreen, facing the same problems. So I had to work with an obsolete OS for a while, until I found a compatible drivers (device tree overlay to be precise) in Jessie. DTOverlay route : 1 ) Check if your device is using such a dtoverlay, by looking in the /boot/config.txt on the modified OS (look for the line with "dtoverlay=somefilename"). 2 ) Look on a fresh Rasbian if the "somefile.dtb" or "somefile.dtbo" exist in the /boot/overlays folder. If it's not the case, you may try to copy this file from the modified OS to the new one. In the worst case (i.e. raw copy not working), you may also have to find the source for this dtoverlay from the filename, in order to recompile it (not so hard, I even tweak mine to improve touchscreen FPS XD) 3 ) Copy the "dtoverlay=" line to rasbian /boot/config.txt file and reboot. Kernel Module route : Some touchscreen rely on specific kernel module to work. The one I know can be identified with : 

You need first to analyse your system to detect the bottlenecks : Using command, you will see how much CPU and RAM are used. To analyse network usage, you can measure it from the rapsberry (using i.e. ) or from the client side, and compare it to your WIFI estimated bandwith (802.11b = 2-3 Mbps / 802.11a and 802.11g = ~20 Mbps). In one of these limits are reached, your only options are to decrease image resolution, to move your project to a stronger Rpi, or maybe to optimize the code you use (or it's context). You may also want to give a try to the program named , that easily implement camera control and webRTC streaming, in a quite efficient way. $URL$ 

As the chips may draw up to 40mA, we won't be able to power them directly with GPIO. In this case you may use a transistor as a switch. Using this method will allow you to power the circuit with classic 5V/GND pins, controlled via a GPIO, adding only few common components to your circuit. If the provided tutorial isn't enough, you will be able to find more help about the circuit on Electrical Engineering SE Note that corrosion will happen because of current, but also because of moist. Don't forget to protect your connections and pins, at least with glue, or with specific electronic gel. 

Sadly, the PIL.show() function won't work as you expect it to do. As far as I know, if you work in graphical mode with X, then a new image viewer would be opened to display each image. If you work in console mode, it won't do anything. In order to display something on screen, you will need to use some display manager. On raspberry, this could be i.e. SDL, openGL, dispmanx, OpenMax ... As you work in python, i suggest you to use , a library that run SDL1.2 through python, allowing your program to run under X, console mode, windows, OS2 .. It's quite powerful and not so complicated, as you can see in this piece of code: 

If the previous solution isn't feasible because of the lack of wires in your walls, a workaround would be to use some wireless button pusher, instead of your relay. 

Then rewrite in C++ by yourself the main part of it, named BN0055.py Other way to go may be to : 1) Use a arduino as external device (i.e. via USB) and read clean values from it. 2) launch a subprocess from C++ that call a simple python script made for reading the clean value. 

I've done something like this for my company. But keep in head that you can't perfectly secure your product if someone has a physical access to it. We can only make their hacker's life a pain, until they give up ! Presentation : First, I've made a C program, an homemade encrypter, that takes the Rpi serial and generate a password from it, with some unnecessary complications and obfuscations, in order to prevent basic reverse engineering. This program encrypts my sensitive folder with this password and copy the result in a obscure system place. Once done, both sensitive folder and encrypter are deleted. I made another C program, the launcher, launched by a service at boot, running an infinite loop, that can generate the same password (with complications too), extract the folder to a temporary location, and launch it's content. And again every time the python program stops. At the very first lines of my python program, I delete its own file in the temporary folder, so the code is only loaded in memory, no more as a file. Benefits : - it protects me from someone who just duplicate the SD card to use it on another RPi. (protection by serial in the launcher, via the password, and in the python program, via a simple comparaison) - encrypted folder can't be bruteforced, unless it's location has been found by reverse engineering of the launcher (in this case, the password generation algorithm may have been reversed too ^^), or by tedious system examination. - due to the very short life of the decrypted file, nobody will notice them, nor catch them. At least without a good practice of linux and an access to the system ! - I use "compiled" python code (.pyc file) : if my encrypted folder is compromised, it will be still very hard to modify the python program, even for only removing the 2nd serial verification inside it :P Drawbacks : You can see that's not a perfect approach, and I suppose there is no perfect solution : it would be like trying to make a box locked from the inside. Because of this, I had to rely on secret (password generator algorithm, file location), which is the last card we have in security, and won't resist to someone well determinated. Notes - I don't glue no more my SD card, for maintenance purpose. - I apply basic security rules about permissions, network ... - My system run with the root partition in read-only mode : this limits the risk of SD corruption, but also of poison taping or unrevelated exploits. - My users don't have access to bash via keyboard (discard signals caught in python), nor network (ssh is still enabled, but passwords are secrets) - I trace the use of my program via the homemade update management : this let me see if some RPI with unknown serials are asking for updates (and let me destroy them, by deleting files) Results : Whatever may be the weak points, I used this system for a year, with a few dozens of Rpi sold, and still didn't notice any hacking attempts :)