One advantage of this approach over is that it detects problems early: It raises on most garbage input. Negative numbers, floating point numbers, strings that that contain non-digits, lists, etc. -- they all bomb. That is a good thing in python. On the other hand, you'll get a ValueException at the end when you try to convert a goofy string to an integer. 

Your function and mine have a similar edge case behavior: The name does not quite agree with the return value in the case the input is an integer power of two (or integer power of the base in your case). The docstring should clear document the nature of the return value in these edge cases. Finally, your function does not return the floor of the log base 2. It returns 2floor_log2(n). Renaming it , 

What this means is that defining the move constructor (or the move assignment operator) as deleted implicitly knocks out the other three. All you need is 

The version is even faster than is the C-based I/O version in the case of using g++. Clang, in this case, bites. Or perhaps it's the standard C library. Here's the getline version: 

Almost all of the wall clock time is reading the file. C++ I/O is notoriously slow. If you need to read, parse, and write millions of lines in a couple of seconds I suggest you revert back to C I/O. And don't use . It, too, is slow. Take advantage of the known format of the input file. Read a line. If the second character is you have a . Otherwise you have a . Parse the integer that starts at the character after the , or the fifth character (character position 4). Update It turns out the compiler and standard c++ library makes a big difference. Reporting only the real times (first item from /usr/bin/time), 

There is no need for your function. The problem statement does not say to do that. Your is gold-plating. (Aside: Your implementation has flaws.) Replace that 100 line long function with a simple Edit: On second thought, the problem statement does imply that something along the lines of is needed. However, a good programmer will push back on stupid requirements. This is a stupid requirement. There is no need for your two functions. Those two functions represent another big chunk of code, and they use insertion sort. Your first choice for a sort function should almost always be . Unless you have very weird data, will be much faster than a hand-rolled sorting function. Even if you do have very weird data to be sorted, your first thought should be with a custom comparison function. There is no need for your , , and , either. You chose a poor representation. Sorting dates represented in the form is hard. On the other hand, sorting dates represented as a string of the form or an integer whose decimal representation is is trivial. Just use and you will get the correct sort order. Internally, you should have represented your data in some sort of format. Assuming properly formatted user input, converting from a string of the form to a string of the form is a one liner. Converting back to a string of the form is another one liner. This of course assumes perfectly formatted user input; a professional program would care very much about malformed user input. But the problem statement doesn't ask you to check for that. Those checks would be another form of gold plating here. This is C++. In general, one should prefer one of the standard containers over C-style arrays. (This is not the case when doing numerical or scientific programming. But that's not what you are doing here.) In this case, a or would be just right. 

The keyword has been a keyword in C since C99. Use it! Inline functions are a much better option than macros. Macros are beasts from the previous millennium. Let them rest in peace. The function approach is much better than the macro. Editorial comment: It is now 2016. If your compiler is not compliant with C99 (preferably C11), it is time to get a new compiler. 

The above declaration is incorrect. You need to allocate one more character for the null character at the end. You are adding that null character, but you are invoking undefined behavior by not having enough space in the array for that character. 

A key problem with a monolithic construction such as my is that it's hard to see what's going on without lots of commentary. A key problem with a slew of overly-short functions such as in your implementation is that it's hard to see how things fit together without lots of commentary. There's a happy medium where you can still understand individual chunks of code and where you can see how things fit together, and without needing an excessive amount of commentary. Some comments about my code: 

You have provided a non-default constructor. This means the default constructor is not implicitly declared. You also have a data member that is of a reference type. Even if you hadn't provided a non-default constructor, the default constructor would have implicitly defined as deleted. Bottom line: You don't need to say . There's also no need for defining all four of the copy and move constructors and assignment operators as deleted. The very nice capability of defining a special member function as deleted did not exist in older versions of C++. One insteadhad to use the ugly trick of declaring that special member special member function as private but never providing an implementation. You are obviously using C++11 (or perhaps even C++14), so you have this nice capability available (and you are using it). You should also understand the rules by which the compiler implicitly declares and defines special member functions that you have not explicitly declared. 

In fact, those four functions could be rolled up into one function that still satisfies the single responsibility guideline (note the name: the function does exactly what the name says, and nothing more), and it isn't all that large: 

While neither one of these is a very good integrator, the latter choice is far better than the first. You should try the two variations and see what happens. Once you see that the second choice is far better, you might want to learn about more advanced integration techniques. 

The only logic that's left is reading the input. When I run this on my computer, I get timing results of 

This is just wrong. The standard approach for determining whether some string occurs within another string is to loop over the substrings of that start with the first character in , returning true if the characters that follow are equal to the remaining characters in , in order. 

Even after incorporating those very standard coding practices (the statements that follow , , , etc. should be on separate lines and should be enclosed by curly braces), fizz-buzz should be small, even in Java. 

One last point: You did not mention how you are using and . I'm assuming you used one of the following: 

The above raises a exception if there is no such index. The easiest way to deal with that is to simply let that exception pass through up to the caller. Doing the same with your next chunk of code reveals another one-liner: 

Regarding -- Don't use that. In a professional code review, that is a sign of a rank beginner who has read the wrong books. The standard idiom for an indexed loop in C++ is (in C the increment is written as instead of .) Anytime I see a indexed loop that is not in that form in a code review, I have to wonder why the author did that. 

You didn't show the value you are using for . Given that you used this in the function , I strongly suspect you are doing it wrong. You either shouldn't have called the function or you should have used a different equation. (The correct value for given the expressions you are using is 1.5.) What you should be using to compute the acceleration of a body due to gravitation is along the lines of 

It's not surprising that your serial code is faster than your GPU code. You are not taking advantage of the places where GPUs perform exceptionally well, and you are using the GPU in exactly the places where GPUs don't perform well at all. Regarding the former, GPUs are geared toward floating point rather than integer operations, and on arrays where the same computation is performed on every element in the array. You are using integers rather than floating point numbers, and don't have any arrays at all (but you could if you used a sieve). Regarding the latter, two things that GPUs don't do well at at all are integer division/modulus, and atomic operations. You are using both. There are over 7.6 million primes less than 5123, so you are calling on a global variable over 7.6 million times. This alone is a huge bottleneck. 

Two of the key sins in software engineering are scope creep and gold plating. Scope creep is a sin committed by clients and managers. Gold plating is a sin committed by programmers. This is a perfect example of the latter. The requirements for fizz-buzz are very simple. There is nothing in those requirements regarding printing 25 values per line. An implementation of fizz-buzz that prints one value per line is just fine. While Java is well known for being a long-winded language, even in Java, an implementation of fizz-buzz that is 63 lines long (counting blank lines and comments) is far too long. As an interviewer, I would congratulate you on getting the answer right. However, in the post-interview meeting, I would most likely recommend that you not be hired. 

Since the non-default constructor is private, specifying is okay for readability reasons. On the other hand, when I see a slew of definitions where only one is needed is a sign to me that the author of the code doesn't know the language and that I should poke deeply into that code during review. 

Now it's a simple matter of assembling the output. Once again, this is much easier than you made it out to be. Simply swap the values at the pivot and swap points, and then reverse the digits after the pivot point. Putting this all together yields 

Minor nit: The name is a bit longish. PEP8 says we should keep our lines to less than 80 characters long. Overly long variable names get in the way of that. Returning a flag value (-1) is not very pythonic. More pythonic would be to raise an exception, or to use an existing search mechanism that raises an exception (and then let it pass). Finally, and most importantly, that's a whole lot of typing. What we want is the smallest array index such that the digits after this index are in non-ascending order. This is easy to find. First imagine constructing a list of all of the indices for which . This is easy to do with a generator expression: . The problem with this is we need the last generated element. That's easy to fix: work in reverse order: 

Specialized to 3D space. Just as you can only tie your shoelaces in 3D space, gravity basically doesn't work in anything but 3+1 space (3 spatial dimensions, 1 time dimension). No call to . Unless you are using Fortran, it's best to avoid . Some compilers such as gcc and clang know how to deal with . Javascript? No chance. And even and don't know how to deal with 3/2. Fortran compilers not only know how to efficiently compute , , they also know how to deal with things like , , and also . Only one division. In fact, you can do even better than what I did. There's no reason to compute the relation between particles j and i when you've already computed the relation be particles i and j. Using mu (μ) rather than G*M. We are taught in elementary physics that Newton's law of gravitation is F=GM1M2/R2. This is correct, but it is also a lie to children. The masses of the Sun, the planets, and anything else to which we humans have sent a probe are computed by dividing the observed gravitational parameter for that object by G. There's a problem here: the Newtonian gravitational constant G is by far the one physical constant that physicists cannot measure very accurately. It's best to avoid G, and there is no reason to use it. Use gravitational parameters instead. (Or treat mass as a derived unit, with base units of length3/time2. Same difference.) Using previous calculations. Your code is doing a lot of repeated calculations, and they are very expensive calculations. When you're doing scientific programming, it's important to pay attention to look out for redundant calculations. It's acceleration, not force. You made two key mistakes with regard to units. One was the calculation . You mislabeled this . This is not a distance function. The other is your calculation of force. Force has units of mass*acceleration. You are clearly using the quantity you calculated as acceleration. When you are doing scientific programming, it's extremely important to get your units right. While getting the units right does not guarantee that you have the physics right, getting the units wrong most certainly does guarantee that you have the physics wrong.