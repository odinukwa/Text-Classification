Sometimes, the correct answer really is "Nope; it's all good." It makes for a boring answer, but there it is. It doesn't look like you can make this much faster, based on what you've provided. One thing you might consider is checking the variables to see if the image manipulations are actually needed before calling the respective methods. So, for example, something like... 

Do you see that this bit of code appears twice in your method? It looks like you copied and pasted it. A good rule of thumb is that if you ever hit CTRL+C and CTRL+V in succession, you are probably doing something the hard way. If logic is repeated explicitly like this, it's a sign of bad design. Either it should be refactored or the repeated logic should be encapsulated in its own, separate method. I'll explain what I did with this later. 

Comments: I think you make the very uncommon mistake of having too many comments rather than not enough. I'm actually loathe to even mention this, because I love when people comment well (and other people will love you for it, too), but commenting every single line is a bit overkill. For example, having a comment to explain that holds the player's name is redundant. Sometimes, it's okay for code to be self-documenting. (Indeed, some would argue that the best code is self-documenting with well-chosen variable/method names and good control structure.) Also, make sure your comments have consistent style. For some of them, you have just a description () while with others you have complete sentences (). Just having the description works fine and is less wordy, but regardless, choose a style and stick with it. Consistency is very important. Access Modifiers: All of your global variables are simply declared as , but they should almost always be explicitly , , or . Utility Class: I like that you wanted to separate out some of your functionality into different classes. But a true "utility" class is one which has "helper methods". These could be things like testing to see if a holds a valid , or validating that a user's input actually exists. Instead, you have functionality which is critical to the game in the utility class. As such, those methods would be better off in the class, since they really are part of the game. If you still want to separate out functionality, consider having a class called something like which has your method, and then having your game logic in a different class. That's actually a fairly common practice. Intuitive method names/functions: The names of your methods don't always match up with what the methods actually do. I'll explain more about that below. 

For an example intrinsic to the Java API, you can look at Thread.State. Here, it doesn't make any sense to have a Side without a Coin, and it makes the code more understandable to always reference a coin's side as something like . We don't get much added benefit from extracting it into another class (i.e., ). Would you say this is the case for all of these inner classes? My personal opinion is "No." You're even creating whole hierarchies of classes in here, with your and then having other inner classes it. All of this is a bit complicated and all over the place for the function of a single class. This is often quoted, but it's true: remember that a class, just like a method, should do one thing, and do it well. Consider extracting some of these classes into their own files, if you see fit and think it will clean up the code some. 

To follow Java convention, any method that begins with "is" should return a . This is a standard which again allows for consistency across applications and across the language as a whole. Again, the name implies getting a piece of information, not actually affecting anything (as you do when you call ). Everything I've said applies to most of your code. So to summarize, when designing methods: 

This is the basic rule for how constants are defined in Java. I named the variable because this is a convention for referring to the "standard input" stream, but or something would be just as good. 

Finally (minor thing), rename as either or . This will let it follow the camelCase format and be more descriptive. 

Here you are attempting to do some error handling, which is good. In your comment you say "You cannot set selected item [in] a [JComboBox] with a negative number". And that's very true. But notice that you already do so before you perform your error check. First you call and then you check to see if is less than zero. But at that point, your code has already broken. Always check for valid data before doing anything else with it. Now I'll show you step-by-step how I refactored your code and present you with the final version at the end. 

Without having written the code, this statement takes awhile to figure out. It would go a long way to have meaningful variable names rather than random letters. Java is supposed to be verbose, so don't be afraid to make it so. I won't say I understand what your code is doing with 100% certainty, but you can see how something like this is a bit more understandable, hopefully: 

This entire method will be refactored below. But basically you don't need two loops, since you're just looping through the class's fields. This also eliminates the need for the overarching constants for the field names and the method signatures, as you'll see. I cut your code length by about half by doing all of the above, and I think it's generally more readable and understandable this way as well. 

Same thing here. Since we're going to be getting multiple integers from the user, we may as well encapsulate the processing. 

As a developer, I would assume that the method did exactly that -- turned her North. But it doesn't actually do that explicitly; you only know that it will always turn her North because of the specific problem presented in the PDF. What it actually does is turn her left, which may or may not be North-facing depending on her current state. For this reason, I would also extract the call from this method. You can't guarantee when it's called that she will actually be facing "upwards", which again makes your design a bit inconsistent and much less flexible. Also, the method name implies a directional adjustment, not a positional adjustment. In other words, a developer would assume that this just shifted where Karel was facing rather than actually moving her to another grid location. Consistency is a big concern as well with method names. You have , but then you have . Choose one: either cardinal directions or up-down/left-right, but don't mix and match. It makes your code that much harder to follow. 

This is a small modification which I just thought prettied up the code a little bit. It just uses the ternary operator to shorten all the variable declaration and if/else assignments into one line. I think everything else pretty much follows what I've already said, so that's about it! Let me know if you have any questions about the code. 

Again, you don't need either of these since you have Reflection, which gives you access to methods and fields. 

You can encapsulate the entire "guessing round" of the game into its own function which then returns whether or not the player won. This will let you have a bit more control over your code structure: 

The Sieve of Eratosthenes is one of the most efficient prime-finding algorithms out there. If you really want a program with good performance, make sure to Google the clever methods that have already been devised. "Don't reinvent the wheel" is a common programming mantra. As far as your implementation, there are a couple of simple logical notes (which I believe are covered by the other answers): don't check even numbers at all (increment with rather than ), and don't print until/unless it's absolutely necessary. To address issues in the comments below: Division into the constant value is computationally trivial compared to the process of actually finding the primes. It's the finding that we want to speed up. After all the primes have been found which are less than the desired number, we can iterate over them from highest to least and find the largest one. It's pretty straightforward. 

In general, I'd prefer to have these kinds of objects (, , ) be accessed via getters and setters rather than being exposed as . This is especially important for the one named , which I assume is supposed to be a singleton. A singleton's initialization should always be thread-safe, which means it needs its own synchronized accessor method, like so: 

It's a very simple point which I'm sure you already know, but I wanted to say it anyway just in case. You should wrap the main execution like the following: 

On a positive note, I really like that you named your loop variables and versus and as so many people do. It makes your code much more readable. But one of the principles of good code design is to avoid this kind of intense nesting as much as possible. You can do this like the following: 

This method will print your input prompt and then wait for the user to hit enter/return on STDIN, then return whatever was typed. I've added a call on the result for convenience and cleaner input. (To see why that's relevant, consider what happens if your user types in "s " for your variable.) I also changed the to be , just because I think it's a more beautiful command-line interface when the prompt is on the same line as where the user types. Of course, that's very subjective and completely up to you. 

@gnanz's answer has a great tip for your method, but I just wanted to go over some more general style points for Java. 

I just picked this bit out because it contains a lot of your variable declarations. Your code was very, very difficult to decipher because of the names you chose for your variables. If you intend to ever work on a large scale project, you will likely be working with other people. And if you're working with other people, code readability is much, much more important than anything else. There's a common adage that goes something like "A programmer's job is 10% development, 90% maintenance," and that's incredibly true. You'll find that even if you're the only one working on a project, you'll come back to your code and look at this and ask yourself "...What in the world was I thinking here?" Believe me, it happens more often than you think. Bottom line: pick good variable names to try to make your code self-documenting. Note that in the final version that I post below, you can pretty much know exactly what every line of code is trying to do just because I've chosen my variable and method names intuitively. Also, if you want to be really Java-esque, follow the naming conventions. No underscores in variable names (unless they're ). 

I would say that this isn't controlling the flow of your application. This is handling an exceptional circumstance (i.e., failure of your code to perform what as it's meant to), which is what Exceptions are meant to accommodate. The recommendation is more for circumstances like this: 

I hate the fact that I've made an anonymous extension like this and it makes me cringe. Are there any better techniques I can use to accomplish this? Changing the file to a instead of an isn't an option. As I said, I'm just retouching a large, pre-existing code base. 

Your code certainly seems to do the job (assuming that the tree is only a root node with two branches; otherwise you will need to implement some recursion). It doesn't "feel" very Java-esque, but you've said in your previous questions/comments that you don't really want critique of method and variable names, so I'll try to avoid that. 

Unfortunately, I can't use static initializers in an interface. So after much frustration, I finally have my implementation as follows: 

I'm not sure how you got this to compile. I received compiler errors saying "Unable to cast Object to int." In any case, that's easily solved by changing the downcast to like so: 

It seems wasteful to check the conditions twice through each iteration of the loop, and I feel like there ought to be a better way to accomplish what I want without the vague code smell. Anyone have any cool tips or tricks to make this more elegant? It also prevents me from using an enhanced for loop, which makes me sad. is a . Also, for those saying I should just join all the s with , that's not an adequate solution. Firstly, it doesn't actually address the general coding practice. Secondly, when writing to a file with a , it's important to use rather than writing a . 

This is only my third Python script. Be brutal with me. Any tips, tricks, best practices, or better usages would be great! 

Overall, this is pretty good code for a beginner's solution to a relatively complex problem. But your code does have me a little lost. For one, I'm not quite sure why you're using recursion here. It seems like that will be a lot more memory intensive than it needs to be for a straightforward problem. It also confused me for a good ten minutes why you were checking for to return that the problem is solved, when the sum for the entire board is actually 405. I would rewrite this as an iterative solution rather than a recursive solution. I think the recursion adds a lot of unnecessary complexity to the code and flow. I don't have the time at the moment to rewrite it as such, so I'll just give some other general comments on your code. 

You don't have any input validation here. Meaning if I type in , your program will break. Not a big deal for a beginner's program, but you can start to look into Exception handling as you progress. 

... or you could write it all in-line, if it looks better to you, since each block only really does one thing: 

I'm not a big fan of the above implementation because it relies on the method modifying the original array in place. It also makes your paradigm of returning a from the method irrelevant; you never compare or check for it. I think it would be a better design if you preserve the original board and create a new variable which you return from the method. 

I created another class called which performs simple utility functions. I said that I wanted to do some sanity checking on your statements, and here's the method where I do that (in MissileUtils`, not in the enum):