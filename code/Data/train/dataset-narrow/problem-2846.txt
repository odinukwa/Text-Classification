You have both the texture and the polygon and know you want to know how to store and draw your polygon. Storing a 2D polygon is a real easy job, you only have to store all the vertices in order in some array. and to apply a texture to your polygon you need equal number of vertices on your texture and the rest is done by the GameEngine. remember points on the texture and on your polygon should have same order. You have some texture and you want to extract vertices/edges from it. This one is a much harder problem but still it's solvable. First of all I would rather force my artist to give me polygons for the shapes he is drawing as well but maybe that's not possible so here are the steps to generate vetices/edges from a raw image. let's assume you can easily check if a pixel is a part of shape or not. So for the above picture before it's cut we have some picture like this : 

Magnets are kinda hard to simulate, but if you are looking solely for the effect of pulling and pushing objects you can use coulomb's law and simulate an electric field. Basically there are some points in the plane with an electric charge, which is either positive or negative. Since you are not aiming to do a physics simulation and for a game you are only interested in the final results, you can assume the ball has '+1' coulomb charge. With this assumption, all the points with negative charge will pull the ball, and those with positive charge will push it. The total force applied to ball will be equal to sum all forces from each of those electric charges. 

There is one other option you might want to consider, which might result in better playing experience. after step 2, where you create a list of all possible you can find a path starting from yourself to the nearest point. The basic concept is just like A* with a single difference in heuristic function. In a normal A* you have a single target and you have a way to predict how many more steps you have to take to reach it. with multiple target you should predict the number of steps remaining for each of target nodes, and return minimum. 

after many attempts I went with box2d. there are generaly two approches to for this simulation or at least I found 2: 

this is a simple enough algorithm to implement. note that each line is represented by two points. which are head and tail of the line. you can also calculate normal value for that vector, and rotate the character to that angle. 

the next step is to shorten (or stretch) your vector so that it's total length equals to exactly 1. and here is how it's done: 

solving that equation is almost easy but the results of the equation will tell us about collision states: if in a results we get or it means the ray does not collide with the curve itself but with it's trails which is a point we are not interested in. if in a results we get : it means the line collides with the curve in the opposite direction. if we get : it means lines collides with the 

Here is an idea: You can create one-way paths, with a little tweak. If the player enters the path from "Site 2" he should see everything mirrored. This way, if he starts from Site 1 he can go to Site 2 as level was designed, but he can't change his mind mid way and return to Site 1. Of course when he reaches Side 2, he can come all the way back to Site 1, since the path (and everything in it) has been mirrored. Another Idea: Again with one-way paths. if your design gives you the permission, you can change how the ground looks. So that instead of firm earthy thing in the bottom of the page, it looks more like a curve mid screen. Now, you design the path, in a way that player can start from the left, and go forth till the very end in the right. In his way back though, he should start from right, but this time he should be under the that Curve shape, with gravity affecting towards top of screen. This way, if for example, there is a long jump in the end of way to Site 2, there will be a long jump right at the beginning of the way to Site 1. 

you can implement some replay feature in your game. using replay function, killcam is just a replay being played from some specific gametime, and from some player's point of veiw. later you can save replays and let others review games after they're finished. also your idea to run a same game with inputs by 10sec delay is a good approach if your game doesn't consume high computational power. 

cocos2d is not much different than a normal opengl app. there are some basic states that is set while you are running a cocos2d app, but other than that every thing is just the same as a normal opengl application. I guess the normal way of using or is to inherit some class from class (or any other class that you want it to drop shadow) and then override method. it will look something like this : 

I'm pretty sure all the widgets have parent in their information (except the root widget of course). So you can go back all the way up to the root whenever a key is pressed and pass events to all of them. I'm not really sure if you are found of static fields/methods but it can easily be implemented using those. 

to fix this issue you should always apply the force to the center of your ship, and the rest is the same as explained in byte56 suggested. It means you need to rotate force vector yourself and then pass it to farseer 

As Droideka suggested, we should create a sequence. CallFuncN takes no time to complete, but we don't want object to be moved second or third time, while the first one is still in progress, so we just have to wait. Note that should be there in it's last argument, it means there are no more actions in the sequence. 

draw player at depth 0 draw the wall at depth 2 change depth test function to MORE draw the overlay (blue) player at depth 1 restore depth test function to LESS 

Now let's see how much data we need for this new replay system (4 + 2 + 8) * 20 * 5 * 60 = 84kb per replication, which means you can easily show up to 100 replications in any iOS /Android device! Do you need to save even more memory? You can try storing only key frames with their time and interpolate all the frames between them. key frames simply mean the frames where player's Velocity changed due to any reason (hitting obstacles, user input change, ...) but it'll result in consuming much more processing power while showing those replays. 

If i'm not mistaken that Idea is generally considered and Anti-Pattern named Anemic Domain Model, but if you use it wisely it can be beneficial. I Prefer one big function if you are not going to implement many controllers with different behaviors, but if you are going to have more than one controller and decide in runtime what that controller should do, it's not a very bad idea to use them but you have to be very careful to prevent possible errors (like controllers call order). --EDIT-- I guess if change your function to this way there won't be any problem, and you'll get smaller functions: 

why do you get division by zero? it's simply because either or values could be exactly (-1). in that situation you computer will start computing which is basically ! how to find sign of a number (or how to normalize 1D vector)? let's say you have a number 'X' and you want to check if this number is negative or positive. usually there is a function in math libraries named or . They implement that function like this: 

one is to have all objects in your scene to be in same time frame at the end of update call. It doesn't matter if they are updated 2 miliseconds or two hours, the only important thing is to have a snapshot of your game objects at specific time T. this way you can have show your gamestate, since in every picture all objects should be in same time. for example you can't imagine picture of a man being chased by a lion and say "hey that picture is wrong the man and lion are 2 seconds out of sync!" you can update object in your scene asynchronized. I'm not much of an expert in this feild myself but I know there are some simulations based on async updates in different node. I've just seen this method once used and it was to optimize simulation speed in Connwayâ€™s Game of Life. it's called hashlife. but still to give user the simulation results the application would continue simulation untill all the cells reach some specific generation and then show the results. 

So far you seem to be on the right track. those books can really give you a boost if you are going to develop your games using objective-c. if you have some a good knowledge about obj-c you can easily try changing tech-demo codes, released with the game engine. at least that's the way I usually learn how to work with new tools. and there are other options for iphone development too. if you feel more comfortable with other languages like c# or c++ or other popular languages, there are engines to based on them. you may need both OpenGL and mathematics knowledge while developing but just working on the engine helps you learn almost every thing you need to know. and later if you get into any problems, you can easily pinpoint them and directly ask about those specific opengl/math problem you are facing. As far as I know, there is no game engine using java for iOS, since iOS doesn't support JVM or equivalent softwares. the most related one is JavaScript which is supported by unity. other than that the main programming language you need to use for iOS development is Obj-C, and cocos2d-iphone is one of the most successful gameengines using that language. but you need to learn c++ since there are many libraries written with it. even in cocos2d the main physics engine offered is box2D written in c++. 

if you don't let them rotate, that's exactly how you have to implement it. but if rectangles are able to rotate, it's pretty hard to solve equations needed for simulation. though you still are able to solve it yourself, it's much more better if you try using 2D physic engines like Box2D. 

you can add any class inherited from of as a child of another instance. player is a inherited from and CCLayer is also inherited from , so there is no need for a instance in there, you can directly add player instance to your layer! 

all your questions have same short answer, "YES". windows.h is still used. also people still use "winsock.h", but there is "winsock2.h" which has provide same API as the "Berkeley sockets" (the one used in linux/unix/etc.) so the later is more common. in windows working with devices is very restricted, it's either using windows API or using DirectX API. Infact DirectX was introduced to let people use devices directly. so all the libraries should use one of those two. on linux however things are a little bit different. there is a direct access to every device. But all devices usually have some libraries to handle them. for example almost everyone uses OpenAL for audio management. 

In "tiles" value, you should change all the curly braces to brackets. In JSON, curly braces mean an object, while brackets mean arrays. Also about parsing JSON, once you actually have the content of JSON file (via reading the file for example!), there are lots of pure CS libraries to help you parse it. Json.Net for example.