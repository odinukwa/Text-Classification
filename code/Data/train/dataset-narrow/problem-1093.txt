To relax the valid characters range, you might like to alter the character class just before to use or specifically declare additional valid characters with . 

If your input array is not grouped and not sorted, then I use two loops to complete the task: Code: (Demo) 

Using your lowercase, alphabetized , when you want to find "whole" matches, you merely search the column with the operator. 

Just an extra note about your posted code block: You didn't need to compare using because there are no US zipcodes that end in ; so would have sufficed. 

The following workaround will wrap your keys and values with double quotes. Such hacks will always be vulnerable to edge cases. To avoid sprinting down a rabbit hole of possibilities (I can think of a few cases off the top of my head -- 1. keys/values already containing quotes 2. declared empty/null keys ...there will be more), I'll just provide a solution for your sample input. For now, I'm using to ensure that the space before is not included. There are several ways to do this action, but I would need to have intimate knowledge of your project data to develop the expression that I feel is "best / most robust". If you discover any fringe cases that break this simple regex pattern, please update your question and I can create a patch. Code: (Demo) 

Regarding a lookup array and writing a custom function, I don't think these design options will improve code maintainability. Though it may save a few lines of code by separating the declarations from the conditional structures, navigating and updating your code will be more tedious and possibly error-prone. Using the switch cases will simplify debugging, updating, and will be much more comprehensible to future developers that lay eyes on your work. 

How about removing the dictionary preparation each time at a cost of increasing your dictionary width? You could have an alphabetized column (the rows aren't alphabetized -- each letter of each word is sorted alphabetically) and a column: 

When you want to loop through all elements in an array, you can use to avoid counting the array size as well as declaring and incrementing a "counter". 

I guess I should also point out that your function makes a few assumptions about the data being passed to it. There are a few ways to elicit Notices/Warnings from this function by passing an uncooperative array of data or grouping value. This may be a "tinfoil hat" observation for the scope of your question, but I thought I'd acknowledge it. Generally, it looks likes a good cover-all function for the many StackOverflow questions that seek what this function can provide. p.s. In a previous comment that I have since deleted, I suggested replacing with another function. This was before I fully understood what this function was doing. I toyed with an approach that used , but there was no advantage. is sure to be the most efficient way to modify the subarray (when necessary). 

Finally, I recommend simply changing your second statement to so that the second statement is ignored when the first is true. This method will be fast, clean, and instantly comprehensible. 

So I've toiled away at this for a while and although I am feeling a little out of my depth I'll submit my approach which employs what I do understand about preg_replace and regex. 

I like YourCommonSense's unconditional casting of as an array. bumperbox's advice on is good and necessary. bumperbox's patterns will have the desired accuracy because word boundaries (spelled with an 'a') when used with alternatives () must wrap each alternative or the alternatives must be grouped. Otherwise, if you have a pattern like: then , , , and will be unintentionally matched. (Bad Pattern Demo) In this case, takes fewer steps than . Capture groups will not be necessary for this task, so use a non-capturing group . The fullstring match will contain the substring. Unnecessary capture groups bloat the output array (although only by one element in this case). Different from the other answers, I have built in a shortcut to a non-regex method. The rationale behind this is the general knowledge that regex functions are notoriously/usually slower than non-regex functions. The cost of building the path to the non-regex processes is minimal -- just 3 conditions, only the 2nd condition uses a function call. I suspect any gains in performance to only manifest when dealing with rather large haystacks. Regardless, I think it is worth considering. My function performs more checks than the others to prioritize building a lean, accurate pattern. My function will return or the matched needle string. *For those who might not know the behavior of alternatives in regex, the match will be the alternative found with the lowest "offset". Regex will not prioritize matching by the order of the alternatives. Code: (PHP Demo) 

I am going to borrow a couple of Philipp's variable names because they are solid advice. First, my suggested code: 

FÃ©lix Gagnon-Grenier's method does not provide the same effect and the function would be better named . Notice the difference in output, only the values are re-ordered while the keys stay the same. This yields a set of dissociated elements. 

I may be confusing some of your subsequent function calls , , -- so you may need to adjust my suggested code to return the intended boolean value. Your pattern can be condensed. You can logically remove the outer capture group, convert all capture groups to non-capture groups, reduce alternatives by leveraging , and remove the unicode flag: Demo Link 

I didn't test my code (and I have no prior experience with ) but this is theoretically what I had in mind to return the "guts" of the table from the function: 

Your method custom sorts the array while maintaining all associative relationships. To demonstrate with some data: 

If you don't trust the user to provide clean, single-spaced substrings in , then replace your & portion with: 

Effectively, I've changed the pattern to "pile up" the "non-ellipsis" words into a single capture group. Beyond that, the method remains mostly unchanged. *note in this second, more dynamic method, you may need to replace white-space characters that were not replaced by my gluing action (the piled up substrings). 

Normally I take the time to study Mike Brant's answers (because they are so frequently educational to me), but this time it was tldr;. If this was my project, I'd specifically/exclusively target the "long" strings with regex to reduce overall handling in the task. My pattern uses to target only 40 or more non-white-space characters as your method does. If you wish to be more specific about valid characters (perhaps exclude punctuation), you might use a character class or negated character class, but I can't make a call on that give your posted information. Yes, regex is notoriously less efficient than simple string functions, but the substring targeting advantage in using it in this case may likely tip the scale. Code: (Demo) 

If you are concerned that your error messsage substring may contain line breaks, then regex is better suited. The code to follow will break the string into a 1-dimensional array of alternating and before pairing them with then assigning them as your desired key-value pairs with . Code: (Demo) 

I understand that you are not a big fan of regex, so I'll do my best to explain what I've done and why it isn't too scary: 

*notice the difference if you change to . Depending on the length and content of your input string, this will be a better approach because you don't have to explode on every space, process each element, and implode. This approach seem very clean and direct to me. If you like one-liners, here is the equivalent: 

Using a switch block is an advantageous design because you are evaluating just once. I think the only aspect of your code worth refining is the repeated parts. It just isn't as D.R.Y. (Don't Repeat Yourself) as it could be. I recommend pulling all of those portions out of the switch block and running a single after the switch block to handle all disqualified cases. Notice that you will need to slightly tweak the expressions to maintain accuracy. Something like this: 

I don't see the benefit of being able to call from . If there is an important use, please let me know as I'd like to be educated on this point. My code to follow cannot be called like this: as yours was designed to do. I have made a few modifications and have a php<7 friendly version to offer... more specifically, I've omitted the type (and nullable) declarations and null coalescing operator so that PHP<7 versions can use the snippet. I'm not suggesting that your type declarations are a bad idea, I only mean to make the function more usable to a wider audience. Code: (Demo) 

You are storing a multi-dimensional volume of data in a collection of 20 one-dimensional arrays. While this approach may be successful, it will not enjoy the ease and simplicity of data access and iteration like a multi-dimensional array would. In the great majority of situations, using variable variables is evidence of poor programming design (there may be fringe cases where it is acceptable, but unless you can provide a compelling reason, avoid using variable variables). Pure arithmetic and the function will succinctly generate bucket keys for you. Then you can preserve the zipcodes as keys for deeper indexed arrays holding the individual/exploded . I've eliminated any single-use variables as a matter of best practice and slightly altered some of the variable names in an attempt to improve comprehension. If you need & (bucket keys as zero-padded strings), can be used during declarations -- but I doubt this is an issue based on your provided working code. Code: (Demo) 

This regex-based approach enjoys replacement limiting and only uses one set of short echo tags. However as a general rule (of mine anyhow), regex functions should only be used when other functions fail to offer a reasonably succinct equivalent. For this reason, I see no justification to use versus to achieve the same resultant array.