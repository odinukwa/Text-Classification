To link the top and the bottom, you must make quads between pairs of pairs of vertices that face each other. So think ahead and why not make yourself a function that makes two triangular faces out of four vertices? Done. Notice that this time we use the fact that the same structure (circle + center) appears twice in a cylinder to take a shortcut. We don't have to make all of the vertices, edges and faces by hand, contrary to the cone where it was necessary. Following this laziness principle, it's also possible to just make one quarter of the circle and duplicate it, and again, to make a full circle with very simple transformations (valid with any circle so with the cone too), but that's really overkill for a not so complex shape. You must always use the geometric properties of the objects you make to simplify their making. Namely, their symmetries and invariants. For a cylinder, just don't make the base vertex, just make the circle, duplicate, translate the copy, make the quads, done. The sphere and the capsule: adding complexity, still not the same work twice To create a capsule, we want to create a UV sphere, split it into two halves, translate the first half and then link the two with the sides of the capsules. Again it's possible to make only one eighth (!!) of the sphere, then duplicate it and reverse it, and then duplicate and reverse the result except along another axis, etc, to get a full sphere, in 4 steps (create the eighth, duplicate and reverse three times). Maybe overkill, but less so than in the case of the circle. A simple UV sphere: 

The way to generate the edges and the faces of a primitive shape like a box, a cone and all those you cited is to generate them at the same time you create the vertices. In fact, you should create the vertices in a logical way that makes it easy to compute the edges and faces accordingly. There are algorithms that take as input a set of points in space and compute a so-called "point set triangulation" over it, but the problem of point set triangulation is NP-complete, so that it is faster to make the edges and faces as you go than to just compute the vertices and let an algorithm do the work. Just letting you know this solution exists. Apart from this inefficient solution, I reckon you can only treat the primitives on a per-case basis, as in the examples that follow. A mesh is vertices and faces. The edges are contained within the description of the faces unless your mesh contains lines that do not make up faces. The vertices are tuples of 3 floating-point coordinates. The edges are simply pairs of references to the vertices, but then again you surely won't need them. Say for instance that your vertices are in an indexed array. Well your your edges could then be pairs of indices of that array. The faces are triplets of references to vertices or triplets of indices in the indexed array case. You should be able to count the vertices, edges and faces that make up each of these primitive shapes because being able to count them means understanding the properties of the object which helps you devise the method with which you'll build them, using loops and other tools as we'll see. Cone For a cone with n+2 vertices, 3n edges and 2n faces: 

where R'(t) is the first derivative of R(t). But the laws of kinematics also tell us that Vp = Vg + ω×GP 

Now let's modify R(t) to get R(t+dt). R maps the vectors (1,0,0), (0,1,0) and (0,0,1) onto the vectors contained in R's first, second and third column respectively, per the definition of a matrix. Knowing these three column vectors is necessary and sufficient to know R. In fact, from any two of them you can deduce the third. That's a property of rotation matrices. If we can compute the new values of R.(1,0,0) and R.(0,1,0), we'll be set. Let's take the first derivative of the important equation above. From the "positions" equation we deduce the "velocities" equation: the velocity of any point P belonging to our moving solid is given by Vp = Vg + R'(t).OP' 

But it's collision detection we're doing, so we can optimize that a lot We originally had two bodies A and B moving without rotation during a timestep dt (from what I can tell by looking at your pictures). Let's call vA and vB the respective speeds of A and B, which are constant during our timestep of duration dt. We get the following: 

Now, suppose that our solid has moved since the time it was in its base version. Let's call the rotation matrix that will give us its position R. Since this matrix depends on time, R(t). G has a position vector OG which we have already computed with little effort at this point of the computation (G is now away from the origin O). With all this, at any time t, for any given point P belonging to our solid in its new position, OP(t) = OG(t) + R(t).OP' where P' is the point of the base version of the solid corresponding to P. Like, it's the same point, but in the base version. If I have a pointy hat and I move it upside down and onto that shelf over there, if the tip of the hat is P, then P' is the tip of the hat when upright and centered. Making this distinction between the base version of the solid and the real, displaced solid allows us to compute the position of the solid by storing only one known, clean, easy to manipulate version of the solid as well as the transformation that allows us to move it to where we want it to be. You don't store the current position of the solid and apply a small transformation to it. You store a base version of the solid and refresh the transformation that takes it from its base version to its actual version. 

where R is the matrix of the associated linear rotation. For example, in dimension 2, say you want to rotate A = (1,0) around B = (1,1) by 90 degrees counter-clockwise. That will yield (2,1). Make a picture if needed. And, if we call R the matrix of the linear counter-clockwise rotation of angle 90 degrees, we have 

but the buoyancy of the object is simply the opposite of the weight of the volume of fluid it displaces. Therefore, it's equal to the displaced volume times the density of the fluid, times gravity, times -1. Note that the density of the object and that of the fluid are different in most cases so you can't reuse , as the buoyancy has nothing to do with the weight of the object. Also, multiplying by will yield Newtons multiplied by squared meters, but we want Newtons! That's where you may have wanted to use (assuming the rest was correct in the first place). Finally, you must apply an impulse equal to the total of the forces, not just the buoyancy! So, !! As a side remark, I suggest you always work with newtons (and standard units in general) unless your use of kilo newtons is justified. That way, you and whoever uses your code will have less needless thinking to do. Also, no more conversion to make in your constructor for Vector2D. 

We in fact only make one half of it (for example), duplicate that half, turn the copy upside down and translate it by the length of the capsule: 

The real (somewhat) hard work comes from the trigonometry that goes into making a sphere. The set of all vertices belonging to a UV sphere can be described as the set of all points of the form: 

Make a vertex. Make a circle around the vertex. Add edges (if you want edges) between the successive vertices of the circle and between the center vertex and each circle vertex. Add faces between each triplet of vertices made of the center vertex and two successive vertices on the circle. Duplicate all that, translate the copy in the direction perpendicular to the base you just made, by the length of the desired cylinder. Link the top and the bottom. 

...and still the same d(a), because we again found a solution that obeyed the specification, here d(a), and we do have the properties mentioned above with w and a contributing to the damage (suppose we look at d as a function of a and w: then if a were fixed and we had w vary in the equation d(a,w) = a/30.w, d would still be an increasing function of w, and the same is true if you fix w and make a vary). This w(a) could give you the value to be displayed in the weapon's ingame description: we would get "Weapon Damage : 220" with the best weapon in the game for instance. We could have used a completely different specification for our gameplay and therefore for n(a), for example one that makes the number of required hits increase quickly as the game progresses and then plateau, and the resulting solutions would have been different. 

But we'd like the damage and the enemy's HP to increase an awful lot so that there are big, impressive numbers at the end of the game, just for style, so we instead set H(a) = a² . 20/3.sqrt(a)    and    d(a) = 10.a² 

This has a ton of other advantages. But i'm not going to cover them, because that's not the question. 

and, as you point out in your pictures, these bodies do sweep through areas (or volumes, in 3D) as they move: 

Notations and hypotheses: We are in the plane with basis vectors ex and ey. A is the center of the rear wheel. B is the center of the front wheel. The length of the bike L is the distance between A and B. The angle between ey and the vector AB is φ. The angle between AB and the front wheel is θ. Intuitive rationale: We suppose that, at a certain instant t, A(t) has a velocity V(t) colinear with AB. Therefore, for an infinitesimal timestep dt, A(t+dt) = A(t) + V(t).dt. We also suppose that, at time t, the front wheel doesn't drift, i.e. the speed of B is colinear with the direction of the front wheel, i.e. forms an angle θ with AB. We call Uθ the unit vector forming an angle θ with AB, i.e. the unit vector with the same direction as the front wheel. Therefore, at t+dt, B(t+dt) = B(t) + λ.Uθ for a certain real, positive λ such that the length of the bike L is conserved: distance( A(t+dt) , B(t+dt) ) = L Calculations: This last equation translates to norm²( B(t) + λ.Uθ - A(t) - V(t).dt ) = L² but B(t), by definition, is A(t) + L.Uφ, so that λ must satisfy the equation norm²( L.Uφ + λ.Uθ - V(t).dt ) = L². The solution, of course, is independent from φ since the problem is the same when the bike points towards positive y. Therefore, if we call R the rotation matrix with angle -φ, λ must be the positive solution of norm²( L.ey; + λ.Uθ - R.V(t).dt ) = L². After a few calculations, if we call v the norm of V, you get λ = L.( sqrt( 1 - (sin(θ).(1-v.dt/L))² ) - cos(θ) ) + v.dt.cos(θ). Here's the pseudocode I used to get the animation above (instead of using Uθ, I use u = U(θ+φ) because it was simpler): 

Remark: we can easily find H(a)/d(a) here because we know the function of which n(a) is the ceil, but if our specification for n was less nice, we'd have to make our own fitting function using various tricks. Not all problems are this nice! So we want H(a)/d(a) to resemble a customized square root function and we know that H and d must be increasing functions. Solutions are aplenty. For example, H(a) = a . 2/3.sqrt(a)    and    d(a) = a 

From left to right: velocities in the base reference frame; relative velocities; computing relative velocities. By regarding B as immobile in its own reference frame, you only have to compute the volume that A sweeps through as it moves during dt with its relative velocity vA - vB. This decreases the number of vertices to be used in the Minkowski sum computation (sometimes greatly). Another possible optimization is at the point where you compute the volume swept by one of the bodies, let's say A. You don't have to translate all of the vertices making up A. Only those that belong to edges (faces in 3D) whose outer normal "face" the direction of the sweeping. Surely you had noticed that already when you computed your swept areas for the squares. You can tell whether a normal is towards the sweeping direction using its dot product with the sweeping direction, which has to be positive. The last optimization, that has nothing to do with your question regarding intersections, is really useful in our case. It uses those relative velocities we mentioned and the so-called separating axis method. Surely you know about it already. Suppose you know the radii of A and B with respect to their centers of mass (that is to say, the distance between the center of mass and the vertex farthest from it), like this: 

The function used is n(a) = ceil( 2/3.sqrt(a) ). We want H(a)/d(a) to stay within the ranges of values that make n(a) have the desired value and since n(a) = ceil(H(a)/d(a)), these ranges are the following rectangles: 

If you repeat a lot and/or increase the steering angle, the trajectory is a circle, which is coherent, I believe. 

The convex hull of X+Y. We have removed the "inside" vertices. We therefore get A first, naive algorithm 

We want to change the matrix encoding our solid's orientation based on the angular velocity we got from the equations above. 

and they end up as A' and B' after the timestep. To apply our naive algorithm here, we would only have to compute the swept volumes. But we're not doing this. In the reference frame of B, B doesn't move (duh!). And A has a certain velocity with respect to B that you get by computing vA - vB (you can do the converse, compute the relative velocity of B in the reference frame of A).