My first idea was to use OpenVPN client and OpenVPN server to have your remote Internet connected Raspberry Pi VPN into an OpenVPN server on your home network. However after reading some of the details to get this working I decided to look for a more simple solution. I found this article that shows how to use OpenSSH installed on the remote Raspberry Pi to SSH into a machine on your home network and then have your home computer create a local TCP port (2222 in the example) that would automatically get forwarded to the SSH port (22) on the Raspberry Pi. Here's another article that describes the same process and even shows a recommendation to have a CRON job create the SSH connection from the Pi every 10 minutes in case the connection every breaks. Of course, the computer on your home network needs have an SSH daemon installed and your home firewall needs to allow that computer to receive in bound connections. You should be able to easily configure your home firewall to forward some unused TCP port such as 9099 and forward that to port 22 on your SSH "server" on your home network. Then you would need to use that port with the option on the SSH command running on your Pi. For the 2nd article the command would be: 

Not sure why you've got Ground and 3V3 used in your circuit, you want one or the other depending on whether the input is pulled high or low. You are also using the wrong pin (12) if you are using GPIO.BOARD - should be pin 32. If you were using GPIO.BCM then 12 would be correct. There is also no need for your 2nd while loop. $URL$ Here is a circuit using 3V3 with the input pulled low : I've amended the code for pin 32 : 

Download 'Raspbian with Desktop' $URL$ (no need to unzip) Install Etcher $URL$ Use Etcher to flash the 'Raspbian with Desktop' image to the sd card (min 8GB) Place the sd card in your Pi and turn on 

Then Reboot To test it's working you can install and run glxgears - a graphical demo that should run at close to 60fps: 

You don't give any details as to what format the video file is and what type of server you host the video file on, but if the server supports HTTP you should be able to do the following: 

I followed these instructions from HowToGeek on how to turn your Raspberry Pi into a low power network storage device. Those instructions worked perfectly for me, however, I did change the external drive formatting from NTFS to ext4 due to the very high CPU utilization used by ntfs-3g. I was getting less than 5 MB/s write throughput to the Pi using NTFS. By switching to ext4 my throughput increased to 10 MB/s write throughput to the Pi. I still hit 100% CPU utilization on the Pi, but my 100 Mb Ethernet was running close to 80 % utilization so I figured that this was going to be as good as it gets on the existing Pi hardware. I also use two external USB drives as the article suggests and use rsync to copy from the primary drive to the backup drive. I get about 5 MB/sec throughput when copying data from one external drive to the other. 

I believe your relay board works like mine so the relay is on when the output is low, the relay is off when the output is high. Change your code accordingly: 

( based on Roger Allen's tutorial : $URL$ ) 10 Download “OptiFine 1.12.1 HD U C5” from $URL$ 11 Install Optifine 

No, the camera input can only be used for cameras or a few video input boards. If you need usb ports and ethernet how about a combined 3 usb port hub including ethernet: $URL$ 

This will start the config utility. Select 'Advanced Options', then select 'GL Driver', then select 'Enable' (latest utility requires selection of 'GL (Full KMS)' ), then select 'Yes' to reboot and enable the driver. 4 Install OpenAL Audio & glxgears demo 

Assuming your running the latest Raspbian Stretch with Desktop. To enable OpenGL, from a terminal window: 

As stated in @Kenneth's comment you need to compile your C program and you can then execute it using a CGI script. Here's an example of running the command from a CGI script from $URL$ 

For your second issue ` You need to add this part of the program from the tutorial that is missing from your copy. Obviously the comments (lines starting with "#" aren't required, but the remaining lines define some constants including ). 

You get a message that you try to install a virtual package and you have to install a concrete package. You find a list of concrete packages. Install the concrete package 

Here is the source of which automatically outputs and to temp files in and checks to see if a previous copy of the script is still running and tries to kill it if it is. The python program outputs its PID to file . The script can also be disabled by creating a file called in : 

Buy the official 5.1Volt 2.5Amp 18 AWG cable power supply. $URL$ Looks like that Moto charger will only supply full power to a compatible Motorola phone. 

Login with Minecraft email and password If your using a newer Minecraft.jar click 'edit profile' and select use release - 'release 1.12.1', then 'save profile' Click Play to install game You will then receive an error Close launcher 8 Copy libraries 

Change options in Minecraft to reduce render chunks to 2, this should avoid running out of memory. Turn everything down to low in the video settings (and turn on things like fast math) Suggest running in the default sized window for best performance - full screen may crash. $URL$ Hopefully Minecraft should run :) 

Your code worked fine on my Pi3 Check that the negative pin (shorter pin) on the LED connects to ground (black lead in image, pin 6). Check that the output is connected to the correct pin 12 (yellow lead). $URL$ I'm using a 220 ohm resistor between the output and the LED. 

I vaguely recall getting errors when trying to run an exectable that was built for a different processing environment. 

As @lenik's answer says, your TV needs to support CEC. I installed a compiled version of libcec which included the command line utility from SourceForge using the following commands: 

The timelapse option says to take a picture every milliseconds. By using you're specifying to take a picture every ~999 seconds. Try using a smaller number such as to take a picture every second. I do know that there are issues that cause the camera to hang such as specifying a very-long exposure, see $URL$ for more details on that issue. 

Update: Success! I've recreated your problem! I get your results when I run using LANG=de_DE.UTF-8, see below: 

As previously stated you need a DC-DC converter, this DROK® Electrical DC-DC Buck Voltage Converter 4.5-40V 12V To 5V/2A Step-down Volt Transformer Stabilizer Voltage Regulator Module Power Supply Switch Inverter Board with LED Voltmeter 5V USB Charger should work for you: 

Download Rasbian Stretch with Desktop $URL$ Flash Raspbian (no need to unzip) to sd card using Etcher $URL$ Place sd card in Pi and boot 

You need to use the new 'RetroPie 4.3.15 Stretch image'. This includes changes required for the Pi3B+ otherwise you will see issues that look like lack of power. $URL$ 

13 Edit runOptifine1_12_1.sh Update MINECRAFT_LOGIN, MINECRAFT_USERNAME and MINECRAFT_PASSWORD to your own (may need "" for special characters) 14 Start Minecraft from terminal window 

Then select 'Advanced Options','GL Driver','GL (Full KMS)' Once you've rebooted glxgears should run at close to 60fps with the correct colours. 

Similar post: can't set gpio to low, trying to control single channel relay (raspberry pi b+) For reference the spec on my relay module states: 

Raspbian Stretch with Desktop requires an sd card with a minimum size of 8GB. I tend to use 16GB sd cards. $URL$ 

I recommend that you copy all of your data off of this drive to another hard drive before it fails completely. It is possible that it could be the USB connection on the Pi instead of the drive. Does the drive behave like this on a different computer system? Again, I strongly recommend that you backup any irreplaceable data on this drive before it fails completely. If you have another USB drive I recommend using . I use the following command to backup one external hard drive to a 2nd device on my Pi where is the mount point of the 1st drive and is the mount point of the 2nd drive. can recover from an interrupted copy in case your drive disappears while performing the copy. You should be able to just power cycle failed drive and perform the copy command again. should pick up where it left off. 

If you get any questions or prompts during raspbian update press ‘q’ ‘enter’ 2 In Menu\Preferences\Raspberry Pi Configuration : System Tab - set Splash Screen to Disabled Performance Tab - set GPU Memory to 64Mb - if using Pi2 set overclock to High(1000MHz) Reboot 3 Enable ‘GL Driver’ from a terminal window 

The Raspberry Pi requires 5 Volts - if you've fed it 12 Volts you've killed it. Powering the Pi using the GPIO pins bypasses the fuses that might have saved the Pi if you had used the micro USB connector. If smoke came out - you've provided too much power to the Pi somehow. That board appears to be designed for an Arduino which has 5V outputs, the Pi's GPIO outputs are 3.3V. 

My tutorial for Minecraft 1.12.1 includes the ability to connect to servers: $URL$ Copied here for completeness: How to setup Full Minecraft 1.12.1 (with Optifine) on Raspberry Pi 3 Please note : Do this at your own risk. If you have any doubts use a spare SD card. The OpenGL drivers are experimental - they may not work with all screens. If unsure make sure you can ssh onto the Pi from another machine to turn back off. Most likely to have success with OpenGL drivers if using Raspberry Pi 3 with heatsink, genuine 5.1 volt 2.5 amp power supply with heavy duty 2 core power cable, 1080p screen. This should also work on the Pi2. This tutorial was tested using Raspbian Stretch with Desktop - release date 2017-08-16 Video tutorial : $URL$ 1 If you need to update an existing version use 

This is the answer to the 2nd question asked, namely what is . This is the 1st partition of the SD card and the file system is mounted on that partition. is the Raspberry Pi's boot partition. If you run you will see all of the partitions on your system, here's what's on my Pi: 

Reading more on this you may need to set . This this comment for more information on when to use versus : 

Your original problem is that you are using Python version 3 and according to this posting the module has been renamed in Python 3. After correcting that issue you state in your comments that the program still doesn't work. I suspect that is because you never execute the line of code because the previous block of code is an infinite loop, will run the subsequent block of code forever and the thread.start will never get executed. I recommend that you move the line of code before the block. I also recommend that you put some sort of into your routine otherwise your will continuously output either "on" or "off" very quickly. I would try: