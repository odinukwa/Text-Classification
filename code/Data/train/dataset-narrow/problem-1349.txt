The steps are not necessarily in order. It relates to your recursive call of the solve()-method the stateExists()-method and the addState()-method. I'd expect following structure of the State-Class to use in the generic path finding algorithm: 

I looked at it twice and I do not see any kind of Bridge Pattern. I see a simple abstraction and some concrete implementations of it. "ApiClientExample" is maybe a wrapper. Technically it seems to me ok. Nevertheless I'd like to comment on one semantic thing: As the method "visit" is totally fine, the method "getDocument()" seems strange to me. Without totally rejecting it I'd make some research on the liskov substitution principle. You also should consider a wrong abstraction level or a wrong semantical assigment to the interface "CrawlerAPI" as the method "getDocument" is totally generic. Will the return value of "visit" be put into "getDocument()"? If so, the method is at the wrong place. You introduced a mental mapping and it would be more a cascading call than a method delared in the same interface. 

A Business-Object "Dog" that is self organized to keep its internal state consistent A Mapping-Object "DogMapping" that represents an intermediate state with little assertions to consistency. Its purpose is to make it easy to persist, load and transform it to a Business-Object A DAO-Object "DogDAO" (former name: DogMapper) that abstracts from the data layer. It can be used from the business layer. 

After that we create a predicate that defines that we are only interested in potentially successful decoded texts: 

Due to JAVA restrictions JAVA does not support tail call optimizations of recursive calls. So this is a choice for or against readability and for or against potential StackOverFlowExceptions when the amount of stack elements becomes very high. 

The idea is to have every class that writes or displays the result depending on the model class "Calculator" because this class is producing the result. Why should Writer depend on Display or vice versa? The Listener-interface should look like this: 

Currently you are not able to execute a function without parsing. Decoupling helps in different ways like in testing or reusablitity. Example structure for parsing I only will provide an example for parsing as this is often the most complex issue. 

Anonymous classes Registering objects (functions) in a HashMap together with its character representation is ok. What I am missing here are structures that have expressive names for the functions. I'd resolve the anonymous class to a named class. Avoid static initializer As parsing itself is a complex thing you should keeps things around it as simple as possible. Static initializer were executed out of your control when the corresponding class is loaded. I do not say static initializer should never be used. But in a business context you should rely on constructors and methods in objects as the primary way to execute code. Multiple parsing concepts You are following different parsing concepts and your parsing is spread all over the place (inheritance, different methods and semantically different classes). 

The best "comment" for a "procedure", "function", "method" is a set of tests that show the usage of it so other developers can see, how your code will work in different situations. Instead of testing your object in a main-scope I suggest to make ... Unit Tests Following the suggestions you can do expressive unit tests: 

There are some things to adress. "synchronized" Like you recognized: Using synchronized variants of certain maps or set classes will not get you away from the burden to define a proper "monitor". Often these variants are not even neccessary to solve the problem so that the synchronization elements will only reduce performance without participating within the synchronisation neccessity. A monitor is an area of code execution that has some assertions to the behaviour of the code under concurrency situations. The simplest situation would be "restrict access to the monitor to only one thread". So putting a synchronized-keyword "somewhere" will not solve the problem until your monitor is properly defined. Responsibilities You have to be clear about what are critical code fragments that should properly behave under concurrency. I do not want to say that I am THE reference but for me it took a while to interprete your code and identify what it is all about. Even (I would say especially) in concurrency we should be aware of clear responsibilities. Busy waiting Some other thing is "busy waiting" (while (true)). I reject those constructs. You should always provide a loop exit AND a mechanism to avoid busy waiting. Usecase As far as I understood your code you have a stream of elements from multiple arbitrary sources to print out or do whatever you want to do with it. It seems to me like a "Buffer" but currently I am not that sure about it. Abstraction from element sources Currently the elements of the stream come from 2 sources: 

The question is: what do you want to achieve. As you store the singleton in the database it seems to me that your singleton is semantic and not technical. Technical singletons have that unified structure of static instance field, maybe lazy initialization and private constructor to ensure only ONE instance per JVM. Semantical singletons do not have the assertion to be unique per object identity in the JVM. Their assertion is they BEHAVE the same EVERYWHERE and they have semantic identity (equals) in ANY JVM to ensure identity beyond JVM boundaries. Often this kind of singleton is used to have a central entry point to a domain/module. To avoid the public constructor in the semantic singleton I have separated the requirement "central entry point" from "object instantiation". In my design I have a SingletonX class that adresses "central entry point". Furthermore I have a class X that is more or less a POJO Finally I have an interface InterfaceX to redefine the public interface of class X. Class X should be resolved at runtime and is mostly out of scope to be instantiated through client code. Class X is the class to be serialized. 

Finally I did a little research as I was interested in a solution for limiting streams by a certain condition. I had to implement a mystic interface called "Spliterator". Fortunately there was an abstract Base-class I could derive from even it may have a little drawback in performance. So Here it is: 

I would follow semantics. Persons are not Accounts. A person may have multiple accounts. Either you rename Person to Account or you have a separate class "Account" so you have following semantic: Amy transfers 500 from her Account 638423331 to an Account 747266783 that belongs to John. Transactions are not bound to Accounts. They are on the level of the system which tries to ensure consistency. Sure you can have a list of transactions in each account the account was participant. But that is semantically redundant (denormalized) and has to be synchronized. So I suggest to introduce a class "Accountingsystem" that holds all transactions that keeps the whole consistent. So my preferred model: Accountingsystem knows all Persons, all Accounts and all transactions An account knows its balance and its owner that must be one of the known Persons. A Transaction knows the accounts participated and the debit/credit amount. You can have convinience methods to filter transactions or which accounts belong to a person within the accountingsystem. 

General I do not know exactly why your question remains unanswered till now. But I guess "exercises" tend to have less attention as this exercise seems to be really basic. Do not get me wrong. Everybody had to go through basic things. So the point is that you found a solution to a problem. And so far you did very well. But I want encourage you to keep on going as this is only the surface. Here are the things every programmer has to go through. 

Semantic of methods The implementation or the signature of the method "int getCount(String term);" does not make sense. Either you delegate the parameter "term" to the search algorithm with a stateless implementation or you omit it and have a stateful implementation. In the last case your "term" should be given to the constructor. I prefer a stateless implementation and all further comments are related to that. Programming using interfaces You are not using the interface "WordSearch". The assigment 

I'd like to have as less parsing concepts as possible. Harmonize your parsing through ONE general parrsing concept. Favor composition over inheritance You currently derive two levels from A_RayCode: A_RayCode<-LoopCode<-IteratorCode. I suggest to have a strategy pattern here. Longer functions names Your concept does not consider functions with names that have more than one characters. Introducing such functions you will have to think over everything. Even if this artifical language seems to suppose to have very short function names (at least one I guess) this can be a serious problem in real world parsing. You are closed for extension. Responsibilities Parsing responsibilities are divided and as I mentioned you have different parsing concepts. Furthermore you mixed parsing and execution.