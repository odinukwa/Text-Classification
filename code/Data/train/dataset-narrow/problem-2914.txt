If you want, I can write this through, completely. For that, I will use my Loader.js utility, which I recommend you use as well. I assure you that this code will not work, because you're working with strings, not image objects. 

I'm making a small game where things can fly around and collide. Things like boxes and so on. For each object, I have an array of all forces acting upon it, I have it's mass, it's position and it's velocity in both directions (a 2D vector). I know how to detect collision between them, but I just don't know how to react. I used to calculate their orientation towards each other, it they were on top one another, I would just negate their y speed (), and if they were next to each other on the x axis I would negate their x speed (). Now, this isn't very realistic, so, how do I do it? All objects are rectangles represented by vectors. Objects can't rotate. 

The best way to increase your chances of being employed as a game developer is to get your hands dirty and actually work on the development of some small games. You say that you are "interested in programming games", which makes me believe that you haven't developed any games, yet. I advice you to stop thinking and start doing. However, the first order of business will not be to specialize in any of those fields. Let me elaborate. When I interview you for a job, if you tell me you are interested in programming games and your specialty is game AI, I will immediately ask you which games you worked on. If the answer is "none", I don't care about how many books you read or how you believe you are an expert in game AI. You won't be hired, period. To obtain game development experience in a specific field such as AI, you need to seek out others that are developing games and try to get into their teams. You want specialization, remember? A generalist can develop the whole game, but a specialist needs to work in a team. However, you will again be asked for previous work for someone to trust you with the AI of their game, let's say. Even if you will work free of charge. So, it's a chicken and egg problem right there. Basically, you can't just specialize in anything with no prior game development experience. Here's what you need to do: you need to forget about specializing and start contributing to the development of a game in any way you can. You can develop a simple game using a game engine such as Unity, or ask someone else developing a game and they will tell you what they need done. Then you'll figure it out and that will give you experience. Once you have something to show, not only you will have a better chance of joining a team, but also you'll have a better idea on fields that you can specialize in or that you don't like to work on. Trying to make a decision right now without that experience is like marrying someone without getting to know them. You cannot know if you will hate coding game AI unless you have some relevant experience. 

I heard of the game Dwarf Fortress, but only now one of the people I follow on Youtube made a commentary on it... I was more than surprised when I noticed how Dwarf Fortress actually generates a history for the world! Now, how do these algorithms work? What do they usually take as input, except the length of the simulation? How specific can they be? And more importantly; can they be made in Javascript, or is Javascript too slow? (I guess this depends on the depth of the simulation, but take Dwarf Fortress as an example.) 

Should I finish high school or teach myself? - those two aren't mutually exclusive. I'm both finishing school and teaching myself. And there's not much "game development knowledge" that is exclusive to game development. It's mostly just mathematics, computer science and physics, all of which you learn about in school. I know it's a very unpopular opinion around people of our age, but school has actually been quite beneficial to me. If you have to sacrifice anything in order to get more time for your own hobbies, there are much better candidates than education: sports, social life, TV (didn't watch it in years), procrastination... The definitive answer is that you should definitely stay in school. It will give you knowledge that is not only applicable to game development, but other fields too, because you cannot predict your future. 

I know exactly what's going on and it's a tricky one:) In time, since one orbits after the other (the update functions do not happen at the same time), their distance increases or decreases little by little. Right when the planet orbits a bit, you want your moon to do exactly the same motion so that their distance does not change. Otherwise you'll make an orbit around a slightly different radius. Your planet, before doing its orbit step, can remember where it was and where it went to, and tell the moon to move in the same direction with the same amount. To show you how to do that, I would need access to your planet code as well. However, it's simple subtractions and additions of transform.position values, you can also figure it out. In the meantime, below is a hacky fix that should remedy the situation if both the planet and the moon are orbiting around Vector3.up. I wasn't sure about how you use the orbit angle, so I changed that a bit. This works for me here: 

I have seen a mechanic which I call "armor points" in many games: Quake, Counter Strike, etc. Generally, while the player has these armor points, he takes less damage. However, they act in a similar fashion that health points do: you lose them by taking said damage. Why would you design such a feature? Is this just health 2.0, or am I missing something? To me, armor only makes sense in, for example, RPG games, where it is a constant that determines your resistance. But I don't see why would it need to be reduceable during combat. 

I'm making an MMO game and I just got to a point where I need to implement achievements... How do I do that? The most straight forward thing to do would be to run this once every 100ms,: 

Now, when you're adding an entity just do . Most of the problems raised in that AltDevBlog article Darcy posted don't really apply here: we're not letting anyone name entities, strings are just numbers here. If you're using C++ you might not need strings at all, as integers work as keys too. 

It is generally assumed that the mass does not matter and they bounce up to the same height. This is because the coefficient of restitution, which lets you calculate the velocity change after the collision, does not depend on mass. The velocity right after the collision determines the height that the ball will move up to, independent of the mass (just like how mass does not affect free fall duration). So, for games, it's safe to assume that they will end up at the same height. However, in real life, it can be hard to make the two have the same contact properties and balls with different masses may end up bouncing to slightly different heights. This paper can provide further insight. 

1) Yes your observations are correct. 2) The standard global XYZ coordinate system makes sense when you think in terms of a first person shooter, when you are looking through the eyes of a character in the scene with a blank(identity) transformation matrix. Like it would when you draw a coordinate system on a piece of paper, X points to right and Y points upwards. According to the right hand rule (x->thumb, y->index finger, z->middle finger), Z points towards you. 3) It wouldn't be wrong, but it would be a diversion from standards. There are three problems that I can think of at the moment: (a) Let's say one day you want to use a physics library that uses the standard coordinate frame. If you did not follow the standard, now you have to think about the transformation that takes you from your world to the physics world. Can get annoying when you want to fix a bug. (b) When you want to share code with someone, or bring someone over to help with development, they have to get used to your convention. (c) When using standard 3D models, you always have to have a transformation above them to prevent them from looking sideways. Now to add to question 2, it is sooo useful to think of X, Y, and Z as not just three letters, but as right, up and backwards. Every character in the scene has a local coordinate system attached to them, and in their local coordinate frames X is always right, Y is up and Z is backwards. Once you have this, now you can make sense of vectors that you print out, or write your algorithms in a way that makes sense. Let's say you have two characters A and B, and you want to do something if one of them is facing the other. You can simply find B's location in A's coordinate frame (Ta^-1 * p_b), look at the vector you get and see if Z(backwards) is negative and X(right) and Y(up) are small, because that vector tells you how much backwards, right and up B is with respect to A. 

Make it impossible to advance to certain areas without having them previously unlocked with a special character class. Make it possible to merge two characters into a single one in order to gain benefits. Introduce crafting and collecting professions, WoW style, which has already been proven to work. You need at least a few characters to get the most resources (e.g. a miner, a blacksmith and an alchemist). This is simple: make classes distinct and fun to play. This adds replay value to the game as well. No reason for the players not to go on another adventure if it wont be the same thing over again, and if they have new problems to solve and new mechanics to play with. 

I'm not really a 3D person, and I've only used shaders a little in some Three.js examples, and so far I've got an impression that they are only being used for the graphical part of the equation. Although, the (quite cryptic) Wikipedia article and some other sources lead me to believe that they can be used for more than just graphical effects, ie, to program the GPU (Wikipedia). So, the GPU is still a processor, right? With a larger and a different instruction set for easier and faster vector manipulation, but still a processor. Can I use shaders to make regular programs (provided I've got access to the video memory, which is probable)? Edit: regular programs == "Applications", ie create windows/console programs, or at least have some way of drawing things on the screen, maybe even taking user input. 

Unity animations do not animate changes to mesh details. Animations are only pos-rot-scale of nodes. Unity's skinned mesh renderer uses animations of nodes to deform meshes. How Unity deforms your mesh can be slightly different than Blender's deformation. Unity is trying to do the right thing given the armature animation and the mesh weights for the nodes of the armature. How are you animating the normals in Blender anyway? The armature in Blender isn't supposed to deform normals like the first screenshot you gave. 

1) Since speed is a concern, you may want to take a look at approximate nearest neighbor algorithms. I've used ANN in the past and it performed very well for around 12 dimensions. It lets you adjust desired precision so that you can have a trade off between speed and precision and find what works best. 2) Since your visual occlusion is a black-box one (I'm assuming unpredictable moving obstacles), I'm not sure if you have much of a choice other than doing occlusion tests on the points that the NN algorithm returned. 3) I don't believe ANN supports points changing, but I'm not sure since I didn't need that. It seems Cgal and Pastel support dynamic sets, but in terms of insertion/removal of points. Perhaps the papers here would also provide some insight. I don't know if you need this advice, but I found that reusing libraries for such problems almost always is a better idea. There are so many pitfalls one can fall into while implementing the details. Good luck! 

What is not to be saved in the save file are things like level info, which should be loaded off separate files that don't need to be changed, or general static info that doesn't change. To do this in C++, I suggest that you take a look at how filo I/O is done: $URL$ I suggest that you also use Json: $URL$ Once you tell us the actual problems you have, we will be able to provide more concrete answers. 

Check out the atan2 function. It gives you the angle between (0, 0) and (x, y), and being the function arguments. Edit: if the center of the circle isn't (0, 0), no matter, just do this: . 

I once heard that Runescape "ticks" every 0.3s, and that seemed like a very long period of time, although Runescape is kind of a slow game. I'm building a more dynamic top-down shooter game, and I'm wandering, how often should I communicate with the server? ASAP, or every 0.1s? How do shooter games usually do it? Both the server and the client are written in Javascript, node.js and socket.io are being used. 

Try placing this code in FixedUpdate() instead of Update(). Physics motions happen in FixedUpdate() and Update() is synched with draw calls. The two don't always happen at the same frequency. Most of the time this is the cause of the jittery motion. So, if you are going to affect the motion of a physically-simulated object, you need to do it in FixedUpdate(). Now, why does it happen only when you do the normalization? Probably it's because the extra processing time required by Normalize() causes the Update calls to lag more behind FixedUpdate. The fact that it acts differently in different computers also supports this idea. How much out-of-sync Update and FixedUpdate get depends a lot on the available CPU cycles, which tends to be nondeterministic. 

You need to create variables that determine the position of your image, make your render function use those variables as the position, and change those variables when you want to move your object. Here's how you can do it: 

With which approach should I go and why? Is there a better alternative? Also, in case the second approach is the best, how frequently should I perform the tasks? 

As you can see, there are 4 types of components here. is an instance of the position component, and is just a normal vector. is too, just a vector. If you want something to stop, then just set its movement vector to , or delete it. All systems would now have a neat way of requesting entities that interest them: . As for the input, that could be a system that has access to hardware stuff, and it is the one that actually knows the state. Then, it iterates over and changes their movement components accordingly. 

If your game is singleplayer: it's not possible, but you shouldn't care. If your game is multiplayer: then you should store all your important state on the server, which is much harder to hack than a local machine.