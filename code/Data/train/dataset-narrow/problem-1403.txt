There is no need for the else at all since you don't do anything if is not odd. Also, there is no need at all for two lists. Just one is enough: 

Here is a solution which replicates Guava's interface. Since this interface is really easy, here is how it is done: 

Delegate the computation of and to a method, say, . Since we want to spy this method's execution, we will suppose that we have Guava and its useful annotation, and make the method : 

For more complex cases, I generally create both classes in the same package and make instance variables for both package visible (this leaves of course the responsibility on me that what I inject into the frozen part is actually immutable, but I deal with it ;) EDIT Right now the methods are called and , to reflect the pattern's intents; do you think of better names? EDIT 2 Objections from @bowmore: the SRP (Single Responsibility Principle) is violated; this is true: the frozen instance has the added responsibility that it must generate a pre-filled thawed instance. The suggestion here is to create an additional constructor/static factory method/method (pick your poison) on the builder class so that it be able to "swallow" the contents of the frozen instance. 

This is the key: asks the question "Is this proposition false for all possible inputs"? To test this, we split into two parts: its first argument and the rest. If the first argument is , then is it possible to satisfy proposition with the remaining arguments? If not, then it's a contradiction. This is the part . is itself a function of 1 Bool argument, so it is in class , and so we're able to apply to it to see if it's a contradiction. We also need to be sure that it's not possible to satisfy if the first argument is either, which is why we this with . I'll leave the function as an exercise, and move on to the next inductive step. Inductive Instance Definition - Inception Since is of class , then so too is . I could be mistake, but I'm fairly sure that is actually just short-hand for this. So this means that a boolean function of two boolean variables is itself a proposition. How do we determine its validity? We check if both and are valid. The former means 'if and both evaluate to True'. Hopefully you can see now the recursion that's going on (I haven't done a great job explaining it; sorry)-- what we're doing is recursively defining the ity of the type so that such a function is valid if and only if it evaluates to for all possible inputs. 

First and most important: you are using Java 1.7 (as the try-with-resource statement proves), so do yourself a favor: use ! The API should have been marked as deprecated ever since this new API was here. In most situations, the class itself is all you need: 

You may want a static method in your class, named, for instance, taking a as an argument and returning an : 

Then you use can use . Note however that since this is an enum you can always access this via . And NEVER do that: 

If you are intent on using a builder, then I'd suggest either making it an inner static class to the main class or a different class in the same package. If the first solution, then the constructor for the built class can be made ; if the second, it can be made package local. First scenario: 

These correspond to three questions which we could ask of any proposition which is a function of any number of propositional atoms. In case you're unfamiliar with this terminology, an 'atom' is one of the inputs to a proposition which is a function taking some number of atoms and itself evaluating to either or . Typeclass Declaration The name for the type class bears no meaning for me, so I changed it to short for "Proposition". 

Not that you need these grade messages, but that's an example of the power of holding on to the type rather than converting the grade directly into a . Sorry if I've made syntax errors as I've not used Java in a while. Edit: Just realised that you might like to put , and into the itself as static methods. 

Yes, it is. Generally your event listeners when writing this sort of code 'control' the flow of events. That area (like in your code) is in charge of negotiating between your data and user/presentation, letting the logic layer know when the change happened. It is generally cleaner to register all such handlers in a specific place. 

By using immutable objects we also don't create a new copy for each element. I can pretty up the code using ES2015 if you'd like. Here is a modern version of the above code for Status minus allowing usage with (per your request): 

Here is what I'd do. I'd split it into two actions - adding a single property and assigning them all. Adding a single property is just adding a function if it's something like , and it's adding a property to a sub-object if it's something like . So let's use recursion and break it up into those two use cases: 

After all, the method returns a boolean! Also, I'd put out of the method, so that it needn't be recreated on each method call... 

OK, this question may seem a little strange at first; however I'd like to have your comments on it. Background: I do Java. A lot. Java is a statically typed language, it has means to restrict visibility of instance variables, etc. And as such the builder pattern (see here) is quite adapted to it. I took this pattern a step further. The builder pattern is a one-step process: once you , you obtain an instance, preferrably immutable; but once you have the instance, there is no going back. The freeze/thaw pattern is a "reversible builder". I implemented it in Java and this gives the following interfaces, which I use quite a lot in my own projects (one-sided discussion about this pattern here): 

Notice how as soon as the grade matches the range corresponding to something in the Enum, the method immediately returns. Now an example of how you might use that : 

It won't be very often that a number is , so let's tuck that check away so that it only fires if the number passes the check first: 

to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

What we're doing here is creating a new typeclass called Prop. We need the syntax because we need to define the behaviour of an instance of the class. If we don't introduce a symbol for it, then how will the compiler know what we're talking about the in the typeclass definition? For example, the line says that for every instance of typeclass , there must be a method called which maps to a boolean value. Likewise, there must be a similar method for . Now the line may cause some confusion because appears twice. It's important to understand that , being an instance of a typeclass, is a type. There are no "objects" as in object-oriented languages. Remember: is a type which satisfies the typeclass contract given by . The Java equivalent would be a class implementing an interface . What we're saying here is that for type which implements/is a part of this typeclass , there is a method called of comparing them. And its type is meaning that it takes in two expressions of type and returns a boolean indicating whether or not they're equivalent. 

Note: the way your class is currently written, it is NOT thread safe. The quick, coarse way to fix it is to make . EDIT Discussion on a different design to get the value of This requires a creation of a new factory class for instances of class ; it would have the responsibility to create new instances and compute : 

Easy to adapt in the second scenario. Second remark: I fail to see why is an illegal value at all for your predicate; as your code reads right now, I can very well input as an argument to the predicate and it will work. Why not just "let it be"? After all, it is the user's fault if a correct predicate is not provided, isn't it? Third remark: calling a an ? Uh... Why not just ? Also, remind that any interface obeying the prototype of a can be used, so you can define and use instances of this interface. By default, you could supply an empty one, or one that s, for instance 

One simple solution would be to extract your common functionality into a method. We'll also cache the selector for speed (don't do this if the elements change). 

This is Bluebird, but it's very similar to Q in syntax. Note the automatic promisification and utility methods: 

If I may ask, why are your display items in a directive in the first place and not in the DOM? You could use an in the DOM to repeat the items instead and drop the directive altogether. Directives are useful for code reuse, are you reusing this spefici component in a lot of other places through out your code? Behaviors affecting your models and not just your presentation logic should probably not be in the directive to begin with (like in your example), a directive should encompass presentational behavior and not business logic. 

Alright, so is valid if and only if it evaluates to for both arguments! That's what we want. Now for : 

Alright, this is the first time I've used Typeclasses so someone feel free to slap me with a tuna if I mess something up. First of all, I don't understand why the use of "FlexibleInstances" is necessary, and it scares me because these kinds of warnings are usually put in place for a reason. With that out of the way, I'll go through the code. 

Boolean Instance Definition All we've told the compiler so far are our promises: there will be methods for checking whether an instance of is valid or a contradiction, and a method for comparing two propositions of the same type for equality. To start, we implement these procedures for the most basic type of proposition: one that is just or .