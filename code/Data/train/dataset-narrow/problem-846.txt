If you wanted to look more ruby-ish, you could convert your switch statement into a hash and then / your input string. 

After the worker has completed, it will call the event, where it will return its result (which should be the encrypted block and the block index. The event handler should write the encrypted block to the corresponding index in the output file, and then add the worker back to the list. Repeat until all the blocks have been processed. 

Your code here is really just wrapping the Array class from the ruby library. As such, your performance will be exactly the same as just using Array itself. The array can hold as many items as you can hold in RAM and the performance will be determined by whatever machine you are running on. The ruby array class is written in C and performs fairly well. You ask about optimization but you don't given any criteria, so I can't really speculate beyond that. If you need something that is extremely fast or needs to scale across millions or billions of items, you may want to look at a different language or even a database. Looking at your code, you have several instances of the pattern . The last two are redundant and can be combined. For example, the max of an array with one item will be the one item, you don't have to break it out. Likewise for doing the average; you can average a list with one item and you will still get the correct answer 

I'm sure there a few variations of this idea that would work well too. This example is just the first that occurred to me. 

(Note that I wrote and tested this code in ruby and then ported it to C# by hand, so there may be a minor issue when multiplying decimals and floats or other trivial compilation errors) 

I know this is a bit confusing, and I can edit this answer with additional comments or code as requested. When I implemented this in in ruby, this bottom-up approach ran in 6ms. 

Aside from Pimgd's comments, I'd like to add that from an architecture point of view, you might want to reconsider your abilities. To make them easier to maintain, you should design all (or nearly all) abilities as just a dictionary of pure data. Figure out all the possible interactions and make key-value pairs for them. For example: 

Finally, if the spaceship is destroyed, skip directly to the particle application logic. Don't waste time checking torpedoes and asteroids. 

We can see that it took 165 seconds to run on my computer. Almost all of that time was spent calling . was called 27722 times, which is 360360/13, the number of iterations in the loop (plus one or two more). There is also another function, that was called many times. This is called from inside to compare each value in the hash to the value being searched for. It is also called as part of the modulus check and probably a few other places as well. The number is very close ot the number we predicted with the formula. In summary, almost all of the processing time is taken by and its inner call to . Fixing The Code Your bottleneck is in so we should get rid of it. All you are doing is checking if the test number is divisible by every number less than or equal to . You store this in a hash, but never reference anything other than the current iteration. As such, you can get rid of the hash and use a simple counter instead. 

Wrong Objects You've made objects, but you haven't really made the right ones. Your , , , and classes are really just wrappers for a string, which is already a class. Object oriented programming is not always the best solution for a problem. FizzBuzz itself is frankly very trivial and almost any object based approach is a needlessly complicated solution. With that said, perhaps we can redefine the problem to make it a better fit for an object oriented solution. New problem definition Consider this modified problem: As input you will receive a list. Each row (a rule) will have one or more numbers (divisors) and a text substitution. After parsing the list, for every number 1..100 you will either print the number or a substitution for the number. For each rule, if a number is divisible by all of the divisors, you will use the substitution. In the event of a tie, use the substitution from the rule with the most divisors. If there is still a ties use the substitution for the rule with the smallest individual divisor. For example, given "3 6 apple" and "2 9 banana" and "18 candle", they all tie for an input of 18, but "2 9 banana" has the smallest divisor, 2. 

Some Code Comments Like Eric mentioned, you can speed things up by not doing duplicate work and intelligently managing the values you loop over. 

Power Issue The increase in current when you increase the baud rate is expected behavior. See this question on the electrical engineering stack exchange for more details. Also see these guidelines on wireless considerations Arduino Code Some considerations: 

Ruby also has C-style format strings. Use '%d', %f', '%s', etc in the string and then supply an array at the end of the string with all of the arguments. 

Your code is nicely organized, but there really isn't much to the calculation that it would require all of that. All you really need is your enumeration and a variable of how much you've accounted for so far. This code simply loops over the rates and starts summing by bracket until the quantity is fulfilled or it runs out of rates. Any remaining quantity is added in at the highest rate. 

Sort your corpus Before processing your wordlist, sort your corpus into a dictionary by character. For each character, if a corpus entry contains that letter, it gets added to the dictionary entry for that character. 

I'm working on a dataset from a MOOC. I have a lot of python3 code snippets that I need to run and get the results from. To do this I've written a python script that loops over each snippet. For each snippet I: 

Profiling and Benchmarking Rather than benchmarking, which just does total time, you would be better off profiling, which is like recursive benchmarking. I recommend you use the ruby-prof gem. I profiled your code thusly: 

will pass the array items in groups of n, using a sliding window. So [pt1, pt2], [pt2, pt3], [pt3, pt4], etc. After that you can use to calculate the distance and sum the points. 

I would like to point out that while your code is clear and well written, if your actual goal is to experiment with A*, you don't need to be so literal with using a directed graph. A simple two-dimensional array of weights is perfectly usable for A*. In fact this is exactly what many interactive javascript demos of A* do. It looks as though your final graph is this way too. If in the future you want to experiment with a sparse graph or a non-rectangular grid (like a hex map or something), with a little work your code is a good starting spot for that. 

Use a struct and a union to do what you want. Note that this implementation is verbose and can be combined into a single declaration. Also depending on your system architecture, you may need to pack the struct or declare the members in a different order. 

Caching You can increase performance by caching the result. For each number generated by the sequence, cache the number and it's length in a . The later, if the sequence generates a number you've already seen, you can abort the sequence and add in the remaining length. For really long sequences this can save you a lot of time. Note: you should be caching across all runs, so that the work you do in earlier tests can be preserved during later tests. 

Create new StringIO objects Set and to my stringIO buffers Execute the code snippet in a object Join the thread Log the results in the stringIO buffers Restore stdout and stderr 

Foreach function, these tables show the number of calls and time spent on function call, recursively all the way down. Some portions, like the "range#each" can be ignored as part of of our testing overhead. Looking at the results, I can spot why dominant_2 is the fastest. Integer operations (FixNum) on a processor will always be faster. Floating point (Float) is slow and floating point divisiondividing is slow, and big integers (integer numbers bigger than that hardware can natively support, typically 2^32 or 2^64) will also be slower. 

This line also removes the need of cleaning up your nils at the end Additional Thoughts While the logic is largely fine, stylistically your loops could be a little more idiomatic. Unless you are using older ruby, you should tend to prefer over . They do the same thing but .with_index is a little more functional (programming). Secondly, in general, try to chose better variable names than . You have comments describing what they are, but with better variable names, the code becomes self documenting. (I've used ix_row and ix_col, but that's my personal naming convention for indexes; feel free to change it, just make sure it's purpose is obvious.) Finally, you are overthinking your boundary checks as well. All you need to do is simply check the index. 

Note while the regex works perfectly in RegexBuddy (set to python), I had issues getting this to run at the command line. The regex looks for a non-zero digit (1-9), followed by an optional grouping of [any digits (0-9) AND a final non-zero digit (1-9)]. Any match will be the significant digits. Getting the length of the match returns the number of significant digits. Also note that in your example, the last entry appears to have two significant digits, but you have it listed as three in the comment: 

Background threads tend to run at 100% CPU utilization unless you do something to prevent it. If your requirements allow for it, try adding a Thread.Sleep(10) (or some other number) to the code. 

When ruby does a regex match, any capture groups are assigned to the global variables , , , and so on. See this question on StackOverflow for more details about the mechanic. Note on your regex: If you want the capture groups to actually contain anything, you should change the asterisk to a plus: . Without the plus, "www.twitter.com/" will be captured by one of the regex. With the plus, that string will fall into the default case. 

Easy Simplification: Integers convert up to doubles just fine. Since you aren't returning the number directly you can safely drop the integer case for LessThan, GreaterThan, and Range and always convert the number to a double. You'll get the same result. 

Alternative Solution This will be a bit confusing, so my apologies in advance. Bottom-Up Search When I did this problem, rather than brute force looping over all the possible permutations, I constructed my pandigital numbers from the bottom up. We can do this because each 3-digit sub group is highly constrained. For example, the last 3 digits have to be a multiple of 17 and be less than 987. There are only 58 different multiples, and any with duplicate digits, like 119, are ineligible. Let's say that about 40 are valid. that means the next 3 digits (d6d7d8) must contain the first 2 digits of one of those 40 AND also not contain any duplicate digits. The constraints mean that trying to construct the number from the bottom up is a very, very small search space, and thus very quick to search. Possible Implementation/Algorithm Here is a high level breakdown of my implementation: 

Updated Thoughts I think you should completely rethink the way you are handling time. Use a regex to validate that time is a valid string, then simply use to get each portion of the time: hours, minutes, and AM/PM. Next you should convert those into a quantity of minutes: 

Update 1: Added second enumerator and search function, fixed a bug Update 2: Added lazy enumeration and profiled code against a tree with 10K nodes. Searching for nodes with values in the middle, the new lazy code runs about 2.5 times faster than the poster's original implementation. Also running rubocop, there are no Cyclomatic complexity warnings 

You can use a ruby case statement to check for different regex matches. If a match is found, it is by definition not nil, so it removes the need for a nil check as well.