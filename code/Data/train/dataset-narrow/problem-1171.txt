Then you can write your program such that it's only trying to guess the input language whilst your enum variable is set to . Of course you will still have to handle the case where your program has determined the input language but then encountered a character it wasn't expected (e.g. thought the input was a Java name only to encounter an underscore). This is an error and your code should throw an exception or do something to notify the calling code that they buggered up. It's not your responsibility to recover from it since that scenario is undefined based on your problem definition. Just to elaborate a bit more on why you shouldn't return "Error!" is that if something goes wrong your function always returns a string. This is ambiguous since your successful value goes in the same variable as an error. Don't make life hard for yourself, throw an exception so you force the calling code to implement error handling the proper way. Consider Using Regular Expressions Regular Expressions (RegEx for short) are a dark art and are very powerful for string pattern matching and manipulation. In this particular case I can't give you any real answers but a PHP framework I have used in the past has an Inflector class whose job is convert between naming conventions. You can find its implementation here. Control Statement Nesting This is a massive bugbear of mine and I see it all too often. Your code isn't especially bad but I think it's something you should be aware of. Control statement nesting is where you have an if-statement inside an if-statement inside a while-loop inside a switch statement, and so on. Doing this increases code complexity. Your for-loop is on the edge of what I consider being too complex, but I think given your implementation, there's not a lot you can do. You want to keep your code as flat as possible because it makes it easy for someone else reading your code (and yourself for that matter), to follow the logic. 

Firstly I don't agree with a particular coding convention being tied to a language, implied by your excerpt. I know this isn't the point of your question but as an aside, coding conventions develop from an amalgamation of best practice, and what your development team is happy with adopting (I've been through this painful process). Naming of Boolean Variables A fairly neat convention I've adopted recently is naming of boolean variables by the name suggesting something is true (i.e. an assertion). What I mean by this is that where you have and , you could have and . Then, when you need to use the variable in an if statement you have: 

From then on, every operation on your data should be an operation on a NumPy array instead of on a Python list. The way I wrote it, it assumes your data are integers, and also that 0 can never occur as a real data point. You can modify the and offset of the call to accordingly to meet the requirements of your particular data. This approach will only be good if each user has a number of data points that is not too different from the number for the other users. Other wise representing your data as a full matrix will be memory inefficient. Use s. If your data are non-negative integers, for example, then will be much faster than , for example. Actually, if your data are integers, then you could probably just use to make your histograms in native Python, which could also save time. 

I usually dislike when people are sticklers for PEP8 variable-naming conventions in mathematically oriented code, but I think your naming could use some work. For example I had to read multiple times to understand that was not an index but the data. So would have been more natural to me. Plus isn't the best name either. If I understand the code correctly, perhaps would be better? Possible bug: Related to the above, do you really want to create a dictionary keyed on the elements of ? Doing so means that the behavior when integers are repeated in the input is probably not what you want: 

Using the built-in solution is definitely the way to go and is still way faster than even the improved "slow" method. 

The advantage of doing that is you don't have to remember what order parameters get passed into your initialization function when you use it. 

Starting from Jaime's solution, I noticed that was being called in each loop iteration. This function seems to compute the mapping between links and knots, which is something that doesn't change in any loop iteration, at least as I understand your program. Thus I wondered if things would get factor by eliminating this repeated function call. One way to do that is to represent the mapping between links and knots as a connectivity matrix. This matrix takes up more memory than the simple lists and , especially if dense, but if that tradeoff is acceptable, it would allow just using a single call in each loop, rather than two different calls in each iteration. Effectively Jaime's code is a kind of sparse dot product, while this code uses the dense dot product. A nice bonus of this approach is that the code in the loop becomes much simpler. 

Could you please suggest how to avoid excessive statements in the solution. Also, this solution wouldn't be scaleable for more array's so a more general approach would be helpful as well 

I solved this problem using heaps(since it was tagged under this category). I feel my solution is a bit verbose which includes building a vector from a map and so on. Can you think of any redundancies that can be removed from this solution or any better way of doing it. 

Load the task by it's occurrence in a queue While the number of distinct tasks is greater than the period we pick the number of tasks with highest occurrence and decrease it by 1. If the number of distinct tasks is less that the period then we multiply period with the highest occurrence of the task. 

The idea behind my solution was if at each iteration we have the closest triplets we will be able to get the optimal absolute minimum. I couldn't find a clean way to implement this logic. And my solution is this. 

I am not sure if my solution uses the right data structure in the correct way. As inserting back into the queue requires me to store the -ed values in an temporary array and then insert it back. Could you review this code for the right usage of data structures. 

The approach was a pretty straightforward DP implementation which is in terms of space and time complexity. My solution took about to execute all the 1183 test cases while I saw solutions which executed in about in the same language. As far as I know there isn't a greedy solution to this problem, only approximations algorithm exist for this. Can you suggest if there exists a solution with better time complexity for this problem or if my implementation has some redundant initialization or iterations which slow it down. 

The approach used is very similar to the way one would do this by hand. This solution looks like it has a lot of if/else statements. Could you please suggest a cleaner way to write this solution. 

The greedy criteria I came up with is, for scheduling a particular task optimally with minimum empty slots we pick the highest occurring task and maintain maximum number of distinct tasks at each stage. Algoritm : 

Whether you regard my code as an improvement probably will depend on how familiar you are with numpy. I doubt it matters in this particular application, but if for some reason you wanted to do it with huge words, this version would likely be faster. Sample output: 

With and its functions, you don't have to do any looping at all, although under the hood looping similar to yours is going on (but in C, and thus much faster). Here's a numpy version of your function: 

This run, which covers about 1/5th of the effect sizes and 1/10th of the sample sizes you are interested in, takes about 5 minutes to run on my laptop. Since it uses , I think scaling up to your full system size would take about 50 times this number, or about 4 hours. The bottlenecks here are still the t-tests, but also simply calling , a sign that we got rid of the assignment-by-element bottlenecks and reduced the t-test bottlneck at least somewhat. 

I had my own solution to PE #2 lying around and in case it's interesting or useful to you here it is. (It uses and is wrapped into a function.) 

In the loop, the first call you make to is superfluous and can be removed. You aren't even using the results of the transformation calculation. The next line, where you have is doing all the work. Removing this line halves the number of model fits and speeds things up by ~twofold. You don't need to assign outside/before the loop. If minimization of code lines is the goal, you can avoid assigning to temporary variables and just put the expression that you would have used to define the variable in the code line that uses it. I did that for in the while loop. It is more compact but probably harder to understand. You don't seem to need to full module, so that can be removed. I didn't change anything in my code below, but why are you squaring ? According to the docs this error is the Frobenius norm of the difference matrix (X - WH), so it will always be positive even without squaring.