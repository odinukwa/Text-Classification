Expanding their use Regarding the last point: Once the solution is coded in your language of choice, I like to show the solution in a number of different languages: Fortran, Pascal, C, Java, Python. It is interesting to see how similar the solution something to Fibonacci will be in each of these, and it gives (imo) learners some confidence that, once they master one language, and the concepts involved in software development, they may be better able to learn additional languages in the future. Equally, providing some code in Fortran and having them generate a flowchart and code in your target language can be an interesting exercise. Apologies for migrating tangentially here, but I'll assert that it is still related to both pseudocode and flowcharts :) Free Tool for Flowcharts A really nice FREE tool is draw.io. I've tried many, but settled on this one as it is free and is stored in the cloud, so they can work from any computer on a work-in-progress. 

I use peer evaluation forms as a part of group projects as discussed by @Buffy above, and I also split the marks between group and individual elements. Taking the question in a wider context, I'll just speak from my own experience of peer evaluation, and the opportunities and difficulties I have found with it. My first experience of peer evaluation was on the Rice University MOOC, An Introduction to Interactive Programming with Python. I liked it from the start, and thought it was a great way to grade work, provide feedback and reduce teacher marking time for formative assessments. We do not use it for summative assessment. 1) Sample exam questions: theory An exam paper based on the theoretical elements of the course was designed, and a grading rubric with sample answers prepared. I assigned each learner an ID number known only by myself. Each learner received a copy of the exam paper with their own number on it The exam paper had space for answers- no separate sheets. At least one question has some ambiguity- this is not told to the class, and they cannot ask questions during the exam. This is to allow discussion of question design afterwards. At the end of the exam, all papers were collected and each photocopied 3 times. Each learner is given a copy of a grading rubric and three random answer papers (not including their own) They are given time to grade each paper and make a note where marks not were achieved or partially deducted- this provides each learner with feedback. All feedback must be positive- indicate what would have improved the answer, and why marks were deducted. Collecting all the papers and re-ordering to give each learner back a copy is tedious work. After the exercise, we had an open discussion on each of the questions, if they could have been phrased more effectively. Expansion option: Given a specific Learning outcome, how might they create an appropriate question for an assessment. At the end of class, I provided them with sample answers to the exam so they could compare with what they had themselves. Outcomes: It was interesting that many found it difficult to award a grade, and did not realise how much time it can take to correct a paper. There was some variation in the scoring of identical questions- this proved a useful talking point. Each learner got useful feedback on their own work. Learners have a greater appreciation of the creation and marking of assessments. It was quite time consuming, but a useful exercise. 2) Coding mini-assignment- peer grading on Moodle Given that photocopying code is a non-runner, I set up a peer-graded Assignment on Moodle. Each learner had to work on a mini-programming assignment and had two days to complete it and submit online. Firstly, getting this to work the first time on Moodle was very time consuming. Even on the day, there were several delays in getting started. The grading rubric identified many elements such as use of "appropriate" names for variables and functions, header info, docstrings (Python), clear user prompts/instructions, working code, use of comments and so on. When peer-grading, it is possible to place a comment in each section to explain why mark(s) were lost, and each marker can place a final comment/general observations. Benefits of Moodle Peer assessment Learners are assigned the work of others to mark randomly Anonymity is an option in the setup Each learner was forced to really look at the grading scheme, which was provided from the outset. Many lost marks for simple things that they should have included (e.g. header information). This is important- that they realise they can get some marks even if the code doesn't work completely or partially. All got to see examples of other learners approaches, structure, working and non-working code. Seeing mistakes others make should help them identify those that they make themselves. Teacher can review all more easily without looking through a lot of paper, i.e. the grades given and received by each learner, and the comments given and received. Difficulties I have to say, from a practical perspective, it ran about as smooth as a dragons tail (i.e. not at all smoothly) but this was likely due to my inexperience with using this in Moodle. That said, it was better than paper. Some students failed to provide any feedback even when it was a requirement of the exercise. There are some relevant/complimentary points also raised here. 

The call stack They've presumably already learned about functions, so if you use that as the example, you both teach them about stacks and give them a deeper understanding of how functions work. I would take it in two main phases, using code similar to this as an example. 

First, focus on how the return always knows to transfer control to the statement after the line the function was called on. So for instance, the return from might go to either or , depending on where it was called from, and in the former case, in turn knows where it was called from. If the language they're using is one that prints the call stack when it crashes, they're probably already somewhat familiar with this. Make sure they fully understand how the control flow works first, then bring in the concept of a stack and explain how you can implement function calls by storing the return addresses on the stack whenever you call a function, and popping them whenever you return. Once they understand that, you might want to proceed to explain how parameters are stored on the stack. That might confuse them a bit, though, since you can't access elements other than the one on top in a "theoretically pure" stack, but you do when accessing values in the stack frame. I would probably just mention to them that the reality is a bit more complicated than what you just described, but save the details for a later lesson. 

Alice looks at Bob's assignment when Bob isn't paying attention. This is less of a problem in CS than it would be elsewhere, due to the large number of coding assignments; a quick glance generally won't be enough. But for instances where it might be... The students are informed that keeping their work from being copied is their own responsibility, but if a small enough portion of the answer is copied that this is a plausible scenario, I'd probably give them the benefit of the doubt anyway (especially since small similarities can happen by coincidence). Alice and Bob collaborate a bit more than they should have, but don't actually intend to cheat. I'm perfectly okay with students discussing assignments so long as they're helping each other learn the material instead of just copying answers, but sometimes the line between the two isn't perfectly clear. My policy here is to insist that if students collaborate (or ask for help on stackoverflow, for that matter), they cite their sources on the assignment. If too much of the answer came from another source, I might take off a few points or have them redo the assignment (or more likely, just let them know that in the future, they need to do more of the work on their own), but as long as they're honest about where it came from, there's no ethical violation. 

As much as I hate the fact that we need to consider this, paper and pencil makes it harder to cheat. Even if you restrict them to using lab computers and not their own laptops, and cut off networking to the room, it'd be easy to smuggle in a USB key with entire books worth of notes and the source code from every one of their labs and projects. (Yes, with enough effort, you could lock down the computers to the point where they can't even mount a USB key, but the logistics are a lot trickier to manage than just scanning the room periodically to see if anyone's got a small library of cheat sheets on their desk.) (I don't think that this should be the only factor considered, or even a deciding one, but other answers have covered various pros and cons well enough already, and this is a factor that hasn't been mentioned yet.) 

But we do want to avoid punishing someone who unknowingly helps someone cheat. There are two likely scenarios here: 

If you get two near-identical projects, it can be nearly impossible to determine which was the original. If you can only punish the one who copied, then you won't be able to punish anyone without determining which is which, and people can cheat with impunity. Suppose that Alice and Bob are friends in the same class, and Alice asks Bob to let her copy an assignment. If it's known in advance that there will be no consequences for Bob even if they get caught, there's some social pressure to go along with it. But if both are punished, Bob can simply say he isn't willing to take the risk. The policy makes Bob less likely to aid in cheating and also lessens any social consequences for doing the right thing if he would have done so anyway. Helping someone else cheat is unethical, so I have no problem punishing someone who does so willingly. 

Agile doesn't mean "don't plan", so there should be plenty to talk about. Have your students developed user stories? Can they talk about these? For example, let's take this example user story: 

I would argue most teachers do want to reach every motivated student in their classes; the issue tends to be that there isn't enough time to tailor the teaching to each individual student. So, in answer to your title question, I don't think you need to convince other teachers that you should reach everyone; but instead argue how to effectively reach everyone. As discussed in this fascinating CGP Grey video (who, incidentally, was a teacher—of Physics, not CS, though), the style of teaching adopted in most subjects hasn't changed for hundreds of years — a subject expert discusses the material in the curriculum, which marches on whether you understand or not. That leaves most students either bored because they're ahead, or confused because they're behind. The Problem With 20 or 30 students in front of you, and a lesson that might only be an hour long, there isn't really a lot of leeway to reach each student individually. $$\frac{1 \text{ hour}}{30 \text{ students}} = 2 \text{ minutes}/\text{student}$$ Instead, you have to deliver material to the whole group. Generally: 

Two things will print here: the contents of and the word 'Hello!'—but which prints first? The answer is: you can't tell, despite the intuition that many students have that would suggest the order is file then 'Hello!'. Event-driven programming starts to encounter a lot of these 'gotchas' because it's difficult to predict in which order things will happen. Ideally, each event wouldn't need to consider any other event happening, but in practice it is necessary. Let's say you wanted to end the game if your spaceship was touching two others at once. With events, you could need to subscribe to 'Touching [spaceship1]?' and 'Touching [spaceship2]?' and synchronise them (not terribly straightforward). But polling like so would be far easier—for each update loop, just test . Getting to your original question, I would personally introduce event-driven programming first, since it's so straightforward for trivial use-cases. As the problems start to appear with events, then introducing polling in an update loop would be wise. Most of the major introductory programming environments seem to follow that (Scratch -> Greenfoot, etc). The same principle should apply to your own environment, I think—consider your audience and what they'll be using your own environment for, and you'll have an answer that suits you. You might also find Polling vs event driven input on Game Development Stack Exchange interesting for reference on the problems faced by professional game designers regarding events vs polling. The only alternative, perhaps, would be to batch events from inputs so that they can be handled in the next update loop—that's something to consider if you're looking for another way of handling the issue, but it is more complex than the others. 

Image by Booyabazooka of Wikipedia (public domain) Whether this explanation is useful would depend on your students' proficiency with mathematics and set theory. For younger years, you could simply skip the subset discussion and show a Venn diagram to represent the idea that a float can be an integer, but an integer type can only represent an integer—not all floats are whole numbers, but all whole numbers can be floats. The issue of large integers not being represented by integers in some languages is more difficult to explain without stating the way that integers are stored. In many curricula, binary representation of integers is covered quite early, and if that's the case, explaining why types can't hold extremely long integers is straightforward. 

On the face of it, event-driven programming seems far easier to explain. "This code will run when the button is clicked" seems obvious, and similarly, visual environments that favour this technique seem relatively intuitive: 

I would expect that would need some explanation, because it will be the first element with attributes, and it's self-closing, which is different to all the others. 

1You might also know a variant of this as the ROT13 cipher where the shift is 13. This has the convenient property of being self-inverse, so you don't need to subtract to decrypt in a separate function. If our student was really clever and wanted to implement that in Python 2, they could have just written . It's a whole new world up here! 2There's a bit of a lie-to-children here, if you're not paying attention. That code assumes that all the letters you want to encode are encoded from 0 to 25 (e.g. 0 = A, 1 = B). That's not how character encodings work in reality (there's an offset in ASCII before you get to the capital letters), but it's not relevant for the example. 3I cheated and calculated the amount of lines you'd use from that approach, rather than actually writing the whole thing and counting the lines.