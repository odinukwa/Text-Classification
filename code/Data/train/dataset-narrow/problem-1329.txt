I was working on the Project Euler problems today in C#. Here is my code for this one. nhgrif's technique is excellent, but you can shave your code execution time down to an extremely fast 50ms without any advanced techniques. The only thing I did to optimize the code was iterate from instead of . I didn't even implement code to skip even numbers, which could make it even faster. Perhaps your technique of storing every prime, instead of just the current one, is why your code is slow? Your technique is to store every prime in a advanced data type. Instead, you could just store the current prime and current prime count in or primitive data types. 

Other than those tips, I will defer to more experienced PHP coders. I hope my ideas help you out a little bit though. Good luck! P.S. As for your original idea of combining the statements: I don't think they can be combined because they are doing different things. One is SELECT, another is UPDATE, and the third is INSERT. If they were all doing the same thing, then you could combine them using various types of JOINS probably. But since they are performing different actions I don't think that is an option. 

I think this problem is of interest because pre-emptive concurrency doesn't seem like a good way of solving it -- most concurrency libraries do their best to help you avoid deadlock, not model processes that have got into deadlock. (But perhaps I'm wrong, and this is easily modelled with a standard concurrency library - I'd be keen to hear.) Also it gave me a good reason to look at some of the streaming data packages (conduit, pipes and streaming), all of which I believe are modelled around the idea of processes that can "yield" data "downstream", or "await" it from "upstream", which is exactly what this problem requires. Here's my code: (NB: contains possible spoilers for the Advent of Code 2017, day 18 problem, Part 2 - but this is not relevant to my question, which is about modelling deadlock with coroutines.) 

(Possibly a hand-coded loop might be even faster than , but I didn't check that.) I'd also suggest splitting out the parsing of input from the actual solving of the problem - no advantage is gained by putting everything into . I'd further suggest that writing makes your intent clearer than ; and that you use s instead of , since this will (a) get rid of extra bits of cruft in the code and (b) allow you to use the package, which already contains a binary search function. It's usually far better to use someone else's de-bugged search routine than write your own. However, if you are submitting for an online competition, that package may not be available. Nevertheless, it provides useful inspiration on how the search may be sped up. This gives code along the following lines: 

CASE CLASS I would change to a . One reason for this change is more concise object declaration, e.g: 

Below are some of the changes I would make to your code. In my opinion one of the nice aspects of Scala is that it gives you all sorts of ways to reduce the amount of work your mind has to do in order to decipher code. As an example, one of the first things I did was declare a type that is equivalent to . I then just substitued where necessary and the code (to my mind) became more readable. The choice of was arbitrary on my part, you could if you wanted use instead. Along these lines I shortened all of you variable and value names. As the program is set up right now you don't need to pass in a array, but I left it in anyway. As you mentioned this is a homework assignment so I'll leave a bit of mystery as to why this is. And really you don't need the and the . Next note that is equivalent to . And finally (for now) checkout how I initialized and . If you still would like to use your function you should look into the method called . Cheers. 

This may not be as concise as your code, but should be much easier to follow and to modify - and importantly, for your purposes, it runs in less than half the time. Other notes - the versions of will normally be faster than the boxed versions, if you can use them; if you're submitting code for review, then I'd think a few more comments in your code wouldn't go astray. I hope that helps. 

I'm modelling two processes which have been put into a cyclic pipeline - the output of each feeds into the input of the other - so as to work out when they've deadlocked (i.e., neither can progress since they're each waiting on output from the other). I've used the conduit package for this, as I couldn't see an easy way to do it using pipes, and streaming doesn't really look suited to this sort of task. It looks like monad-coroutine would be another possibility for this, but I didn't investigate it further. Define the problem as follows: 

For Euler problem number 17 there is no reason to utilize . At a high level using implies that there are missing values in the domain/codomain of your function. To put it another way, as long as we can trust that will produce an ordered sequence of integers from to we can drop the use of and just focus on the logic of the problem. It is rare as a programmer that we get such an explicit definition of what our program input will be, so we may as well take advantage when we can :) The advantage in this case is being able to not use and thus allowing our code to be much more concise. Below I've coded up a solution to 17. I partially obfuscated the code in case you (or whomever might be reading this) didn't want a direct answer to the question. I can give proper variable and function names if you'd like me to. 

Thanks for the comments. I understand what your webpage does now. Suggestion #1 - Descriptions Of What Your Code Does - You might want to create some functions (or add some comments) just to make it more clear what each segment of code does. The OOP people like to make tons of functions that describe chunks of code, and the non-OOP people like comments. You can go either way, in my opinion. In my example here, I will use functions. Suggestion #2 - More Whitespace - I would also add some spaces after your commas and maybe some enters after your commas in your bind_param() functions so that everything wraps nicely and is easy to read. You can do the same thing with your prepare() functions. It isn't a big deal for single line SQL statements like "SELECT * FROM table WHERE field = 'value'", but it starts becoming very helpful when you're doing long, complex INNER JOINS and other complicated SQL statements. 

I've introduced a smidgen of strange syntax just to show you a possibility. As a way of explaining what is going on, consider that the following are functionally equivalent: 

Note that in the first case clause you can replace with any arbitrary constant that you want to match against. In the second case clause simply means match against the wildcard, that is, can have any value or type and the block will get evaluated. As a general Scala tip I'd recommend learning about the many other ways in which pattern matching can be used to create concise code. There are a couple of other places in your code where you could apply pattern matching, but I'll leave those to you as an exercise :) 

Pattern Matching Within the helper function each layer of the recursion checks the value of against some constant value using an if statement. The more idiomatic way to do this in Scala is to use pattern matching. For example: 

It's a good idea to profile your code (which is easy if you use – instead of , just type , and run your program with the options ) to find out exactly where the bottle-necks are. See the GHC profiling guide for more information. If you do that, you'll find that a significant amount of your program's time is spent splitting up strings into words, and parsing them into s. Remember that a Haskell string is a linked list of characters, and thus not particularly efficient – I found that using the type from the package results in the revised program taking only 40% of the time of your version. (Contrary to the other comment here, the binary search you've implemented seems fairly efficient, that's not where the slow-down is.) Instead of from the standard Prelude, use the version of from ; instead of parsing a line of text using , I'd suggest something like the following: