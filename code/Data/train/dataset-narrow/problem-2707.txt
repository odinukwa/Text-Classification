My guess: You have 12 floats for your positions. You are telling to OpenGL that each vertex should be 4 floats by second parameter in here: , so you have 3 vertices for these. Then you tell OpenGL to draw 2 triangles in glDrawArrays command. But this would need 6 vertices - 3 vertices per triangle. So this could cause segmentation fault. Try to draw just one triangle or add more vertices. 

The first thing which can be wrong is the vertices order. Now they are drawn counterclockwise (if we are looking from the 0,0,5 position. Try to draw them clockwise. And that your triangle is skewed - you should post some picture. It can be caused by projection matrix. So you should also write how you create it. 

I haven't read those articles you linked, but whenever I want to implement constant game speed, I call elapsedTime dependent code in my render function. Just like you in your second solution. And I think it's really sufficient for this purpose. 

Here is my full answer: Your glPushMatrix and glPopMatrix count should be equal. It's first problem. But main problem is in matrix mode. In first case (background), you are using texture matrix, which is modified by glTranslate. It means, that in every step texture coordinates will be multiplied by this translation. Because texture coordinates are in range <0,1>, and your background rectangle is wide 4 units, it will not be translated by 0.01 every frame, but it will be translated by 0.04 units in world. In second case (box), you are changing modelview matrix. Which will cause to translate your box by 0.01 units every frame in world. When you change background rectangle to new coordinates (x coordinates are 0 and 1), then every frame texture coordinates are really translated by 0.01 units. 

I think, SFML is library, which gives you power to use OpenGL. So hardware rendering is self-evidence. And it's fast with blending - you can write your own shader and do blending by yourself. I also think, double buffering is enabled in default in SFML. Apply image to screen can be done by drawing a rectangle with texture ;) Transparency can be also enabled (blending). I don't have experience with SFML and images, so I don't know nothing about this second. And I don't understand the last point (image clipping). 

If shapes are really complicated, I would recommend 3D modelling software (for example Blender, which is freeware). When you will be loading data, you can just throw away one coordinate. You can for example use front orthogonal view and then discard z-coordinate. Such software also allow to export data to some graphic format, like OBJ or PLY. There is a lot of loaders for them already written. 

You should always have your transformations in order: scale * rotation * translation It's because matrix multiplication is not commutative. For demonstration, look at this: If you use transform and then rotation, it's different from rotation and then transform. EDIT: Of course if you want special behaviour like Earth rotation around Sun, you can first translate (all the time the same direction) Earth from Sun and then rotate (rotation is changing in time), which will do the trick. 

I think that this is not only Python specific problem. You can create some bounding boxes around walls and than compute collisions with them = if user collide, shift him outside the box. You can also use some kind of 2D array (texture with information, where user can go and where not). 

You can also use SFML. There are differences between them. With FreeGLUT you can control OGL context, window properties, single/double buffering, multi-sampling etc. SFML is more object-oriented. You can set FPS with it, it offers you multi-threading, image loading, etc. It sets window itself (it always uses RGBA, double-buffering, depth buffer etc.) - you cann't change it, but it's all you need (you don't need to change it in most cases). 

If you want to use OpenGL, it should be enough to use some library like SFML or GLUT or FreeGLUT or something like that. It will give you all you need to "render" things. But for example physics is on your own - collisions, models, animations (if your hero will be only 2D, you can use just sprites - animated pictures). You may want also create some level editor, export levels from it and import them to game. I think, that the hardest part is levels and collisions with environment (and if you want 3D character, then maybe also animations). 

You can find some information in these materials: Randima Fernando. GPU Gems: Programming Techniques, Tips and Tricks for Real-Time Graphics. Addison-Wesley Professional, 2004. Chapter 28 David Blythe, Brad Grantham, Tom Mcreynolds, and Scott R. Nelson. Advanced Graphics Programming Techniques Using OpenGL. Course Notes for SIGGRAPH â€™99. ACM, 1999. 

So you should move your near clipping plane the furthest you can and your far plane the closest you can. 

I would prefer bitmaps, which will hold information about objects (buildings, roads, water, etc.). If you have problem with tile / pixel size, you can separate "city / map" into several big tiles and each tile will have separate bitmap. Problems with tunels and bridges can be solved by using more than one bitmap for tile / map. Or by using different color components. When you will be rendering you world, you for example just look, if there is no bridge over water, you are just rendering. 

If you have projection matrices of each image, you can use triangulation (for example here). It works for two cameras and generates one 3D point. 

If you use glDrawElements, you should be able to define offset. If you have bound indeces with glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indices), last parameter in glDrawElements is just offset. So you can start from anywhere and stop after few indeces (second parameter - count). 

This will maybe not give you exact results, but at least some. I also presume, that you are interested in countries of the whole world: You are talking about people, that really play your game. So probably you need to figure out something about their computer. If I look for example at Windows and .Net, you may use CultureInfo to get some information about user's PC. For example language (country and region) of his Windows. I know that this is OS / technology specific, but I believe that you can get such an information with other technologies too. It's very likely that user in some country has localized operating system. This information can be then send to you (if you have for example updates or some high score tables). Question is - do you want to try to send it secretly? 

Here is a simple answer: They do it all in 3D graphics applications like Maya or 3DS Max. First they do some concept arts (on paper), according to them they create models, textures (in Photoshop or something like that). Simple animations are done whole in software too, more complex animations are done via Motion Capture and then mapped to your model. For animation you usually use Skeleton animation. All of these data is saved in files. When your game starts, it parses all these files and loads models, textures, animations. And when it's needed, it displays them. 

This can disable depth buffer. You should enable it again. It should be enough to set DepthStencil state to default. 

I think that problem is in your view matrix. The third parameter is so called "up vector". You should maybe se it to Vector3.Forward. Or you can calculate it as this.cameraForward.cross(Vector3.right) - I don't know, if XNA syntax is like this, but there should be cross product of vector cameraForward and vector pointing to the right (or left). 

I see two problem candidates in your bottleneck function: First is "contains" part - this is probably the main reason of bottleneck. It's iterating through already found bodies for every body. Maybe you should rather use some kind of hash_table / hash_map instead of vector. Then inserting should be faster (with searching of duplicities). But I don't know any specific numbers - I have no idea how many bodies are iterated here. Second problem could be vector::clear and push_back. Clear may or may not evoke reallocation. But you may want to avoid it. Solution could be some flags array. But you may probably have a lot of objects, so it's memory ineffective to have list of all objects for every object. Some other approach could be nice, but I don't know what approach :/ 

Josh Petrie has right. If you want to compute vertex normals, you should weight triangle contribution by angle. But you can use naive solution and just sum all normals from all faces around vertex. So you just compute all face normals and normalize them. Then set all vertex normals to zero. Then for each face (triangle) add its normal to all of its vertices. Then normalize all vertex normals. And it's done. It's not too correct but it could be enough. And your face normal calculation above - it's correct but you should aware, which side normal heads. It could head up or down. It depends on cross product - AxB is not the same as BxA - it gives you opposite vector.