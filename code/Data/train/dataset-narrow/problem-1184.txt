See what I did there? I magically reduces nearly all your indentation by one step (while keeping a correct indentation). This is done by switching the condition for the statement and returning inside that . I'll do that again with (just be sure that you reverse it correctly when you do this with an if-statement that contains or ) ` 

I should add that Jackson also have support for other POJOs, Lists, Maps, Sets, and more or less every other data type you need. The beauty of Jackson is that it also supports JSON (this is built-in inside Jackson itself), and also YAML and a whole lot of other formats if you use additional Jackson-plugin libraries. 

Let's say that you have the ability skills 4, 3, 5. The sum is 12 which means that an integer from 0 to 11 (inclusive) is generated. 

This will not have a big impact on performance thanks to the fact that you are using a . Now, I am not fully aware of your exact situation but another option might be to implement hashCode and equals in your class, in which case two objects with the same properties won't be added to the in the first place, and if you want to remove one and replace with another, you can do so with \$O(1)\$ complexity instead of your current \$O(n)\$. This assumes though that you are actually free to do this. Implementing hashCode and equals can have other unforeseen consequences. Other comments 

This is very easy to fix. It's horrible that you haven't fixed it already. I'm sure that you know what generics is by now so I don't need to explain it to you. Whenever you see this warning, add generics! --> Problem solved! Then you can get rid of the cast next to Why Binary Search Tree? My first thought, once I understood the problem your solving was: Why on earth do you have the data as a Binary Search Tree? What does the tree have to do with anything? If this was a question given to me at an interview, I would ask them this. Why a Binary Search Tree? The operations you're doing is totally unrelated to a tree. You could just as well perform this on a regular . If there is a good reason for why it has to be a Binary Search Tree then please explain it to me. Here's a simple implementation of how to perform this on a regular , without using a Binary Tree: 

Think about it, you currently have some code that generates a map that you then search through the entire map to find out where you placed that one exit and that one start tile. When you place the start and end tiles, you should save the position that you placed them at. As for general two dimensional looping, I wrote a for looping through 2D arrays a while ago that you can use if you'd like. 

Summary Overall, I'd go with one of the other suggestions you've received here. But even when you do so, I hope you've learned something from my comments above. 

My experience with Android and handling touch events is that it's very hard to look at the code and understand how it will work when you're running the application. It can even be a difference with different Android devices, so make sure that you test your app on an Android 2.3.5 device as well as an Android 4+ device (assuming you're targeting Android 2.3.5 as well). From what I understand, "moving the map by touch" you mean that you are scrolling through the map, like a combined with an ordinary (vertical) . It is said to be possible to combine these two together to create a "two dimensional scroll view", I myself have not been able to accomplish that in a way that creates a smooth user experience (I actually think this is a bad way of doing it). I have however, managed to find a quite easy-to-use Android view class that takes care of all this scrolling. It seems however like the link has disappeared but you could try this GitHub project, if that doesn't work for you then let me know either by a comment or find me in The 2nd Monitor chatroom and I can provide the implementation I'm using. As for your existing code, it's clean, it's straight-forward. But where/how is / and / used? Could the problem be there? I only have one suggestion for improvement of your code: 

Loop through the list, and create buttons for the list - and call the methods to determine the state of the button. 

If you switch to using instead of , that would remove the need for your entire method. A takes care of everything that the method does. I would also change a part of your method 

But in reality, there is no need to transform all the positions to a number, instead you can access the 2d array directly, like this: 

What has to be the step before ? Which number was added to which? Was it or was it ? would be nuts as 15 is less than 19. Therefore, we know that it was . And x must be 4, as 15 + 4 = 19. By continuing to subtract the biggest number with the lowest number, we can find out all the possible inputs that can produce these two numbers. 

Some of your variable names are a bit too short and does not properly describe what they are used for: 

As your code is iterating through a list, it could use the for the list instead of using the indexes. For a , the performance of is very slow, so always using would give a significantly faster performance for such lists, and is a good practice even on . 

I can't help you with the wrong result your code produce, but I would strongly recommend separating the input/output logic from the computational logic. Your current method is defined as: 

Naming conventions Classes start with an uppercase letter, methods start with lowercase letters. would be slightly better, but would be even better, although describing what the class is used for is often best. That's hard to apply on homework though. Following the conventions, is a better name on the method, or even better: . Right aligning code does not feel right. I do not often see code like this in Java. 

However, although Java 8 is beautiful and nice, I'm not sure if I would recommend using the command pattern like this. I think the command pattern loses a bit of it's point by using method-references. 

It's not very readable to see that one tag will become and the other . If you really really want to have some self-written PHP function for this, then I suggest putting things that belong together, together. Something like this: 

can be called and either or . There's no need to use such short variable names, unless you are starting to run out of power in your keyboard (which I doubt). In fact, your variable doesn't seem to be used at all. If it would have been marked as your IDE would have told you about that. 

This has led to a whole lot of code duplication which is harder to maintain. You can't change one of your strings without also changing at least two other things. What is your data, really? Is your data strings? No, your data consists of: Which persons will move, and how long will it take. As such, a could contain a where a contains a and . 

If-else-if-else-if-else... Your can be switched to a statement which would make it a bit more clear what's going on there. Also, it is very easy to miss that the first if's don't use braces, which leads us to the common suggestion always use braces. If you switch to a , you won't use braces but instead. I believe this part of your code can be simplified a lot by using some mathematics instead of hardcoding the system. I haven't found out the exact solution yet though. But I do believe that the specific case is useless as that is exactly what will happen with your last else-block, which btw can be a bit simplified: