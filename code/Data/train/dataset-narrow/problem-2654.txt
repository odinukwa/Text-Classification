This might seem like a lot of rigamarole for just testing an arm bending, and well it is a lot for just that. However Mecanim was designed for the complex animations that happens in games, where you want a character to fluidly transition between a bunch of aniamtions. With animation clips set in the imported model, and animation states set in the Animator controller, there's very little your code needs to do to run the animations. 

In the editor's Game view, you can set the size that you'll see when you hit Play. Across the top of that view are buttons for screen resolution; the far left side has setting for screen size, and the right side has Maximize on Play. 

GameSalad is good for either quickly prototyping ideas, or if you want to develop an iPhone game on your own but don't know anything about programming. If however you have even a little familiarity with programming then GameSalad has many significant cons. The most significant con is that it is simply a very restrictive development tool; I haven't looked at it in a long time so I don't know what features it has now, but last time I looked it didn't even have arrays (if you think about it, how could you represent arrays without programming?) It's hard or impossible to access a lot of iOS features, like Game Center. And then there's poor performance. Cocos2D is a much more flexible and powerful development tool, but on the downside it's also considerably more complex to use. Working with Cocos2D you will be programming in Objective C using XCode; you can implement literally any feature that iOS is capable of, but it'll be a lot of work. There is a middle ground you didn't mention: mobile game development platforms like Corona and Moai. These are tools that aren't quite as flexible as Cocos2D but are considerably more flexible and powerful than GameSalad. Meanwhile they use Lua for all the programming so working with these tools is considerably simpler than using Cocos2D. If you haven't done so already, I would strongly suggest evaluating one or both of these. 

I wouldn't necessarily use an MVC design for individual units (at my company we do take that approach with the UI) but rather a component architecture. You can look up "component design" in other questions, but the gist is that Unit is comprised of a collection of loosely coupled components, of which AIComponent and AnimatedModelComponent are just two. 

I should mention, the more general method for detecting geometry at a specific camera position is to use raycasting, shooting a ray out from the camera. For example, this link explains how to cast a ray from the camera in XNA $URL$ Such an approach is unnecessarily expensive for a 2D grid of blocks, but would be necessary for a 3D grid of blocks. You didn't specify this in your question, so I assumed "an array of block positions" meant a 2D grid but just realized you may have meant a 3D grid. The issue is that you don't only need to determine what blocks are being faced; you also need to determine which faced block is nearest. In a 2D grid this is a non-issue since all of the blocks lie on the same plane. However in a 3D grid many blocks overlap each other, which means there could be multiple overlapping blocks all in the direction the camera points toward. Raycasting will detect the first block hit. 

(coincidentally I just wrote about this topic for my book. That chapter should be released next week; here's a brief summary) There are two primary steps to what you're trying to do: 1) Determine which direction to face 2) Rotate the player to face that direction The first task is handled via transforming the direction vector from camera-space to world-space. That is, take the "left" direction of the camera and transform that into a global direction, something like this in the player script: 

Ray intersection usually starts with a faster check against the bounding box of the cylinder, before you do the more expensive check against the cylinder geometry. Either way, it boils down to a line-plane intersection test (since the cylinder is comprised of a bunch of polygons, which are themselves bounded planes). The math for that is explained here (hope you're good at math!) $URL$ (incidentally I'm assuming you need to do the math from scratch and aren't using a framework with raycasting already in it, since you don't mention that) 

It depends what exactly you want to learn and what your goals are. I would tend to say it'll be more valuable for you to finish the games completely, rather than leave a trail of half finished demos, but there is something to be said for moving on to more complex topics (eg. 3D graphics) and leaving the simple stuff behind. On the one hand, finishing your games fully will build up a crucial skill/attribute I refer to as "finishing ability." In other words, the grit and doggedness to actually see the project through to the end. It is one thing to just hack together the interesting part of a project, but it is pretty rare to find someone who can stick through to the end and not peter out when the project gets less interesting. For example, I knew a guy who was a graphics programmer on a AAA game engine (ie. this guy was a top notch programmer) who couldn't build an entire game when I first met him and found the process of building up his finishing ability a revelation. That said, my little anecdote does point out that you don't necessarily need finishing ability in order to be, say, a graphics programmer on a AAA engine. Managing other people and/or a large project does require the doggedness to keep going through to the bitter end, but you don't necessarily need finishing ability when you're first starting out and being managed by a superior. A bigger company might care more about specific advanced technical skills the team needs, whereas a smaller team needs people who self-manage development. (aside: I've never really pinpointed this before, but now that I'm thinking about it, I think finishing ability is the main thing I see separating experienced developers from novices) 

(I'm going to assume you are talking about a 3D game; if you mean a 2D game then you should specify that in your question.) Different kinds of projectiles necessitate different approaches to visualizing them, with the three main kinds being: use a 3D model to represent the projectile (eg. a missile in an FPS), use a billboard sprite to represent the projectile (eg. a laser in a space sim), or use a particle emitter to represent the projectile (eg. a magic blast in an RPG). Using a model for the projectile is pretty straightforward. Simply make a 3D model of the missile or whatever and move that model through the air when the weapon is fired. Often you actually combine this with a particle emitter to do, say, the flame exhaust of a missile, although shots like arrows from a bow would be just a 3D model with no particle system. Using a billboard sprite is similar to using a model, but instead of a full 3D mesh the projectile is only a single quad. Apply a picture of the projectile as the texture on that quad. Sometimes the quad is stretched from gun to target (eg. a laser). If the projectile is something like an energy ball then the sprite is usually set to face the camera completely, but if the projectile is a laser then you want to set the sprite to rotate toward the camera around its long axis and not on either of the other axes. Using a particle emitter for the projectile requires you to first implement a particle system in your game. With the particle system in place, spawn an emitter (ie. the point the particles emit from) at the weapon and move the emitter through the air to the target.