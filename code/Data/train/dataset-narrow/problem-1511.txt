Note that there is no error or pointer check. I wrote the code just to give you an idea on how it should look from a readability point of view. You can do a similar implementation for any algorithm you choose. Because of the poor readability in your initial implementation I didn't spend time to validate your logic. Though I would be more than happy to do it, if you refactor your code using some of the suggestions I gave you. 

Regarding implementation. - Use self documenting naming for template arguments. ; what is ? Let's use something such as . Maybe in this case is not really required but nevertheless is a good practice. - Name your classes and structures with a capital letter. => More like my personal preference, but is good to have your classes starting with capital letter. Standard library is an exception. If you have such a coding guideline then this is no issue at all. Also many libraries are using the same guideline so it should be more expected to find it in various projects. - Do not use pointers in C++ If we're using C++ we are not using pointer types unless really required and backed up by a reasonable explanation. Instead, what we do is use smart pointers or objects. So for your we would have: 

Unless there is a need to create all the parameters at the same time, in C# you can have lazy initialization, which looks very nice and helps with your problem. I am going to make some assumptions in my answer but a nice solution is the following 

There is no need to have and as global variables. Create a structure to hold your data members together and pass a pointer to that structure to your functions. Variable names are too short and not intuitive: , , , , , , etc. Use better names (ex: , etc) that explain what the variable is doing. For readability reasons I would go with a recursive implementation. My second choice would be a stack based, if recursivity is not an option. And if performance would really be an important point of my implementation that I would do something similar but: 

For me this whole idea smells like a bad design. I don't like having this logic hidden in the event sender. If I see an event and I subscribe to it I really expect to be called each time that actions happens. Would be really weird, at some point, to simply have my delegate removed from the list. And this is because events shouldn't really have so much control on the callers. If I really need a one-shot event I would most definitely let the caller take that decision and unsubscribe itself. Semantically speaking, an event is a class yelling "DUDES, I JUST DID whatever" and no longer cares about what happens with that information. Whoever was interested heard it and can act accordingly. So if you just completed the then simply let everyone know you completed it. Now, let's get on the more interesting topic and that is why do you need a one-shot event? I see the following cases: 1. The receiver is interested only in the first occurrence of an event. Then let the receiver decide when and under what circumstances it will remove itself from the event. Maybe at some point you will have a receiver interested in the first two occurrences. Or based on some weird circumstances decides to not handle the current event and waits for another one. 2. The sender switches contexts during two events therefore the second call is no longer valid for the initial listeners. Then you have an object that does too much. Refactor such as the lifetime of the sender matches the context from which he triggers the event. 3. The sender will trigger the event multiple times but only the first one is valid. This is a bug and must be fixed properly not patched. I don't know your specific use-case so I can't write some good suggestions, but in any case, I would definitely let the users of my events decide when and under what circumstances they unsubscribe. Now, if you would be so kind to provide us with a proper use case of why is this design needed I would be more than happy to extend my review for that as well. 

All your method expect a as parameter. Why? As a user of your class I expect to be able to call without having the need to send the root object. I have no idea what does. Receives nothings, returns nothing. I don't want to read the implementation to figure it out. Why are , , and methods public? I have no idea what they do and why are they public. Again, I don't want to look in your implementation to figure it out. Calling clear method will not reset the to 0. So I have a tree, I call clear on it, but when I ask for its size it is not 0. This is a major bug. again, the naming is very confusing? Does this check that the current instance is a BST? Why wouldn't it be, since it is named BST. Please rework the naming. 

You could probably encapsulate all that in a function and call the function three times. It would arguably be a slightly worse solution. You could create a more generic event whenever the tag count is updated. This event is triggered from and . This event will read the current tag count and display it. You could encapsulate all this in an object which has methods, methods and can automatically display the counter. Additionally you could sepparate the view from the model so just keeps the logic and will create the associated HTML based on an event triggered by so everything is decoupled. 

Here is third option: 3) Stop creating so many utils and write your code in an OOP way. Utility classes or methods are, in most circumstances, a very bad anti-pattern. Why don't you have a class that can make use of or using composition and on those classes you can just call methods such as or and so on. For further proofing your design we would need at least an UML diagram of your classes with semantic explanations. There are too little details to be able to make a more in-depth analysis. Regarding your , although I don't know exactly what are the semantics of this methods (you should had included this in your question) I would guess it would suit something as that returns the progress, in percents, of your scroll bar (I think that is a scroll bar). You can have an additional method then to check what you want, maybe called or such. , and don't add too much value to your method name. Those should be deducible from the context. The method can be generic enough and shouldn't have any concept of or . 

Lastly, what I said at point and I would rewrite my algorithm as close as possible to the actual pseudocode. 

Take note that this is just a simple example I wrote directly here. You should adapt it to fit your needs. If I were to make a binary tree implementation for generic purposes I would aim at providing an interface as close as possible to standard library (mainly providing proper iterators for your tree). This means also changing the implementation and maybe using methods such as , etc. But mainly iterators, those are the most important part. Then you can use stuff like or and so on for working with your tree, so you no longer need to implement all that. And finally few more words regarding your implementations... Method implementations - Your methods should never make use of . Never. I will not go into details here, just look at other code reviews on C++ codes as this is a very common mistake. There are people who explained it better than I can do it. - is simply not readable. Too much code, too chaotic, inconsistent... For instance, why are your throwing if the tree is empty but just logging to console if ? Really, I don't even know what to say here, you need to tackle simpler problems before dealing with this. Basically every single line from this method has something wrong in it. Dealing with the API, the implementation and cleaning the whole design would render this method useless. Even more, if you take my advice and use iterators, you can just call and completely delete this monstrosity. ... and more Heavy usage of pointers, dereferencing pointers without checking, many if-else branches, breaking while loops when going through the tree, mixing recursion with iterative algorithms in the same method. Final suggestions Please tackle smaller problems. Something that fits in 20 lines of code or so. You could even aim to learn a bit of C before and slowly move to C++. You'll get much better code reviews if you solve problems that match your skill level. Also, it is mandatory for you to learn standard template library. Learn to work with smart pointers, collections, iterators and algorithms provided by . There are so many improvements here that I could write 20 times as much as I did here and I still wouldn't cover it all. So start with smaller problems or ask review on smaller parts of your code until you get better. 

will be triggered only once, at the moment of completion. Users of this class can check if the tutorial is done by calling otherwise they can wait for the completion by listening to . Clean and simple. 

But really, is it worth it? Why go so great lengths? DRY is a nice principle, especially when having a complicated logic or big code bases. But for 15 lines of code from which 3 are duplicated, with a good reason, why use DRY? The only logic you would encapsulate would be the addition so one could argue that maybe it is better to put all this in a function. Something like . I would argue that the code is best in this state. It is simple enough, it is clear, don't over-engineer it. Take a note or left a comment if you feel like wanting to ensure it will be refactored if it will increase in complexity. But take the refactoring decision then, not now, so you can pick the best solution for that situation!. What if you create a generic way of displaying that message and then you decide you want to change the color to red when you have one tag left. But then some users will have a bigger tag limit and there will also be automatically added tags by the application which will not count toward this limit, except when the automatically added tag is a tag taken from the user preference in which case it must count. And the color should be bright green if there is no tag currently set but should not color at all for mobile because it ruins the UI there. You get the point. Don't solve a problem you don't have. 

which leads me to the next point... - Avoid public data members especially when those are pointers Have your class provide access to those data members through specific methods. You can then include debug only asserts, return objects by ref and do various improvements to your code, something like: 

Several things to mention: 1. Use a loop. Semantically speaking, a loop is way more suited in your case than a loop. usually means "repeat this for a specified number of steps" while means "repeat this as long as a given condition is true". Given, you can ALWAYS replace a with a from a technical point of view and exactly this is the reason why you need to decide which one to use based on semantics 2. No need to use explicit array initialization. When you assign the result of to your array object the interpretor will take care of the object type. There is no reason in this case to make it explicit so it is better to delete that line. 3. Naming Not sure if this is part of the exercise or not, but consider using proper names for your objects. What do you explode? What does the array contains? Is a list of houses? Are those candies? Users? does not have too much meaning. If you really don't have any real objects to work on, invent some and use those. It creates good habits for your programming journey.