I would say that we should be able to execute different query handlers given the same query parameters – for testing purposes. Simple data transfer object (query) being passed to the repository interface allows us to do it in a well-known and understandable way. The same time the following works well for me (SSAS MDX queries)… To define MDX I use a partial class in multiple files (example): 

Defines a conversion from array to collection of some DTO objects loaded concurrently from the database and assigned to the property, while 

Please note that you can use this extension methods to compose comparers for other purposes, like multilevel multidirectional sorting. Hope it helps. 

I would define IElementWriter and IElementReader using your content terminology. Let’s say for writer: 

It is not perfect, as (to browse code structure) is slow and not available for MSBuild, but I just could not come to the better solution at the moment. 

Anyway, it makes sense to think about delegating it to IoC container... I don't think that it is a responsibility of this class to verify if connection string is the same. This interface delivers different perception. 

Supports and where is Entity or Anonymous Type, tested with EF6. Just one class to simplify copy/paste: 

We need to project EF Entities to models (), but it should be really cheap to do manually in the repository, as it probably has a very narrow interface. It would help to publish your input and output (query/result) structures. Sorry, everything else could just turn out to be a redundant overhead in this case :) 

mean for you a none-safe cast to none-empty required text? How does it play with C# syntax/semantics? So these two should throw: 

Original approach works too slow and syntactically inefficient – it is also quicker to recalculate everything than track dependencies. Now I defined a template to create class with overrides, so if attribute named marks property or class like here: 

I am trying to use Two Step View pattern in WPF. The problem is about keeping things in sync – I need a way to data-bind models to view models. Are there any good existing solutions? My approach is to introduce to be used this way: 

Basically, I am just looking for type alias with a guard constrain, but not so many things are possible in C#... Let’s define the casts (yes, it is ugly): 

Here it is - RX example. It might not be exactly what are you looking for but demonstrates "applicability" of the library in your case. To make it work - create a console app and add RX-Main NuGet package. Now let's define some infrastructure: 

I would like to re-render my WPF chart control when data source is changed. My minimum requirement for a data source is but it could be also or , so collection change notifications are sometimes becoming available. Chart class (simplified): 

Please note that the solution is type-safe (no reflection), thread-safe (immutable) and testable (DynamicActivator is an abstraction). The only field is an immutable empty composite activator singleton, which should be OK. 

Version #2. Disclaimer: it is also just an experiment (more sleep, less coffee :) It is dangerous to eat all the exceptions, so I would go with a list of explicitly stated exceptions we expect and could tolerate. The same time, let’s try expose version + define a special inherited class, named , which will log all the problems for us: 

I would not return IStopwatch from Start/Stop/etc. This IStopwatch is not an immutable Value Object, like String for example: it would be easier to set expectations by having just this: 

I think I got it :) I removed my previous answer as it was not enough SOLID (too much dependency on subtypes). Here is how it can be: 

I would recommend using TypeDescriptor instead of directly enumerating PropertyInfo. It helps defining columns at run-time. 

Hope it helps to grasp the idea. Please let me know if you would like me to be more specific. Exceptions are omitted for brevity. 

It looks very interesting. I just find a little bit difficult to read so much code with comments, so I would like to suggest to have even more code but without comments :) Let’s have a look at . It has not so many dependencies to the class, just an attribute name which is never used anywhere else. It also requires a lot of comments which have tendency to become outdated. 

P.S. Generally speaking, C# is a pretty verbose language, so it is often punishing good programming practices… 

What about name? It sounds more dotnetish :) It could be like this - 17 lines instead of 36 - and could be a way shorter if C# was reasonable :) 

I would personally prefer to use HttpClient directly as it provides full control and perfect testability - see here. We can define our REST API as: 

You could play with it to discover how perfectly contravarians works here. You just declare what to validate - compatible validators will show up. No need to change client code - just register more validators if necessary. One of them might be with attribute checking. 

I found myself in a situation where it is necessary to often decorate connection strings with some kind of metadata, like an extra DB Provider attribute, read it back, and remove the decoration without damaging original content. Here is how it looks like: 

Does this immutable configuration work? Do I have a right API now? Library code – abstraction to be consumed (with a lot of helpers): 

My IoC container was setup to construct and invoke a transient instances of all implementations of on a T event raising. 

Is it about web or windows UI? WPF or WinForms: you could just use PropertyGrid - it is the same component you have in Visual Studio to edit properties. To define properties at runtime if happens to be needed - see TypeDescriptor. 

You can possibly try Domain Events. Or just Event Broker patterns? What I usually use is something like this: 

What do you think about non static validators? While making validators smarter, we will sooner or later need to wire up their dependencies (like repositories)... Validators can easily do much more while being instantiated by IoC container. I would suggest to define this interface and class: 

These methods are defined on and return so they can be chained. invokes parameter delegate once per each inner exception instance of a specified type and returns a new copy of without those handled exceptions. An optional exception being thrown in the delegate will be added to the resulting . method tries to find a first inner exception instance of specified type and throws it if found. You can chain them to decide on priority. extends an to throw it when collection is not empty. 

Let’s try to apply SRP, and get rid of mutable state to increase code maintainability. It inflates C# code a little bit, but usually makes sense. Demo: 

I removed my previous answer, as it could be modeled a way easier using singletons and reference equality. Demo: 

Azure Service Fabric uses serialization, which is a total disaster – it violates LSP (wiki) - see all those things, making framework development basically impossible. I made the following class be a parent of all to convince Service Fabric actually consume Binary serialization when it thinks about Data Contract one: 

Now let's define an active (threaded) component. You could find it useful to pass to resource actions to support long running processes termination: 

OK, now it is SOLID :) Let's do not mix infrastructure and application code. Unfortunatly a lot of stuff is missing in .NET, so infrastructure first. AsyncStream: 

I am not quite sure about this method – reflection invocation is slow and dangerous. Is there a better way to make pickup changes? Here is the custom control code I use for testing: 

You could empower . Here is a good article. Approach described will allow your model to do not mix concerns - they use memento design pattern. UPDATE: I do not feel right by copy-pasting that article, so I would still recommend to have a look at it. Quick test though might look like the following: 1) Download and reference project in your WPF application. 2) Create model: 

I would go with mutable state only when it is required for performance optimization. Immutability almost always makes code a way cleaner and maintainable. We should not depend on implementation – let’s prefer abstraction where possible. I mean we should work with , not to define a service. 

OK, see below, it fetches configuration updates from the db. It is going to be a lot of code :) First of all, we need a helper infrastructure base class to help compare configurations: 

I would recommend to create composite to broadcast your changes between multiple implementations if needed. 

Now let's implement protected thread safe façade, which unifies order of locking (like A -> B -> C) to get rid of dead locks: 

It is really dangerous to fork background threads in ASP.NET. Task Scheduler immediately gets crazy, which degrades performance significantly. There is a way though: . 

has no effect on existing delegates. It actually constructs a new one. Delegates are immutable and cannot be changed after construction. You can remove this line. I would not implement IDisposable or any cleanup code here at all. Just release reference on event dispatcher (it makes sense to do it anyway after calling . 

Well, I do not actually think that the following is the shortest solution, but it is SOLID, so is maintainable, extendable, and reusable. First of all – how to use: 

Just an idea - I would probably try to consider serializing command history to the couple of memory streams... Then you can create a command struct on the stack, execute, and make it persist itself to the stream. It is important to be careful about keeping references to the outside resources active though - some kind of resource locator service might help. Just don't allocate new byte buffer for the write/read operation, BinaryWriter/BinaryReader + MemoryStream should not do it also every time. 

This library [GitHub] helps merging partial WEB API JSON payload with existing prepopulated DTO objects. Let's say that JSON is represented by JObject from JSON.NET package. Naïve implementation will probably get us to the following code for the optional string property mapping: 

How do you list your referenced solution assemblies for IoC registration? I was really tired of typing something strange as . What do you think about the following approach? Use case: 

These statements define exceptions we can tolerate and continue trying. All other exceptions will be interpreted as critical. We can also rethrow or log in the optional handler. Library classes: 

Nothing prevents method from being called multiple times. method code is broken allows task cancellation before starting. is OK. violates SRP. It does job management, error handling, and document OCR. Also, running with option could be a way simpler – they worked out well for me in such kind of situation under a heavy load. Scheduler looks smart enough and basically has the same blocking queue inside. 

We could use it this way (please note the initialization code – it should be repeated for every data type supported): 

Where allows to subset by indecies provided, while is working in terms of and . and objects have (current selection) and (allowed to be selected) properties: 

Collection mapping is even more verbose, as we need to instantiate/find necessary DTO for collection items and perform the same logic as above on their individual properties. library allows to define this mapping declaratively and execute necessary requests to external data sources concurrently. Given the following example JSON loaded into the JObject : 

I was looking for a way to cache them while keeping syntax clean, so property calculation logic will not intermix with caching. A proposed solution is: 

Facade class we use to help IoC container to emit realization types for mixin interface registration: 

What we consume here are the following (classes are short, so there is probably no need to explain the code – I basically combine multiple implementations of ): 

We are probably supposed to charge per line… Here is what I use to mitigate the problem. The immutable type is as easy as it could be: 

It looks good but there are a lot stuff like this in the class. One could argue, but I would rewrite it in a dedicated file as: