I wouldn't advise cloning a live system, but if you have enough space on the SD that you're running the Pi on, you could put the OS image on it, and expand it onto the new (USB connected) SD card, using the official install instructions. It may take quite a while, but it does work. Essentially, you'd put the new image file onto your existing Pi's SD card, plug in your USB SD card reader, figure out what the new drive is called, and: 

Here's an example that does the same thing, but uses my Mock::Sub Perl distribution (it's equivalent to Python's 'Mock'). If the env var isn't set, it'll mock out certain functions/methods. If it is set, we're on a Pi board, so we can run natively with the original functions: 

The IP will be the IP address of the hotspot. To resolve names to IP addresses, you'll need to add at least one DNS server: 

To avoid having to install a custom kernel, you can use this driver, and then follow these instructions. Specifically, because you have the 5" model, you'll use the following command after following the first few steps of extracting the driver tarball and changing into its directory: 

Now in my IDE, I can simply open the repository as if it were local (). Much, much simpler and easier than setting up an entire Samba setup for my needs and purposes, and I maintain the file system security per user, as I needed. 

If you can't find anything in the user's crontabs, it is very likely there's an entry in that is kicking off the procedure. 

These are pi specific rules for setting access mode on device nodes (in ; these are created by the kernel and tweaked by udev) such as and , and symlinks for the UART. They are not particularly lengthy or complicated. A fairly current version looks like this: 

This time, there's a payload attached (a 151 byte html page in UTF-8; here we can infer it's a "Sorry, the resource you requested cannot be found" type thing). You could use C to produce either of those, but there's no such thing as a header in C. They're plain text. Perhaps what you are looking for is an HTTP server with a C interface. Most general purpose servers have a CGI interface, which is based on executing a sub-process with the HTTP request processed into environment variables (and any payload fed via stdin); the response, including a partial header, is written to stdout. So that can be in any language you like. There are other ways to produce web pages dynamically. Apache (aka. httpd) has a C API, although this might be overkill in this context. Other web servers available on the pi which may also have a C interface are nginx, lighthttpd, and yaws. 

I don't think that should be happening. There is an explanation of the thermometer icon here updated last month, and it says it comes on halfway at 80Â°C, when the CPU should begin throttling due to overheating. 

In order to be valid, some kernel options first require other options be set, which is why you may not find them in . To figure out what the prerequisites are, you need the option tag name. You can then search for it in menuconfig by pressing /. Searching for in the 3.18.6 kernel shows: 

I know how important start up text is. But I was wondering if anyone could help. I read somewhere online today about having the start up messages in another area during boot up (ive taken that as another sort of terminal instance). If this is true can two terminal instance be run at boot. First terminal going through all the messages as usual but not currently selected. Second terminal showing an image/slideshow (with maybe a timer to show boot time taken) and then say if i want to check boot message I can press a key combination. I have no experience in making Pi OS's or Kernel's etc. and was just wondering if it was possible. Would make a lot of visits from friends easier when I use my Pi and stop them asking about the text and what it is doing. I have experience in command line and ssh. If this is possible I would be happy to try it my self just need some guidance/advice. PS feel free to rewrite this as needed to make it make more sense. 

this is probably a really noobish or simple answer question but I am Stumped. I have SSH'd into my raspberry pi 3 which is running the latest retropie. I have attached a screenprint of the storage information of my Raspberry pi as I am missing 1.4gb. It says that /dev/root has 15gb total yet only 8.3gb is used and 5.3gb is free (8.3gb + 5.3gb = 13.6gb which is not 15gb). I even added up everything from the tmpfs stuff it all adds to 15gb, but seeing as all that temp stuff is in /dev anyway isn't it already counted in the 8.3gb. please help kind regards Leo PS I hope I haven't made a right noob of myself lol. 

I am pretty sure that uses the HTTP proxy environment variables, and the issue you're having is that you can't fetch anything during install from the Internet: 

What I often do (from Linux not Windows but the premise is the same), is set up a share (sshfs in my case, but Samba works equally well) that shares the repository/code working directory, and mount that into Windows. Then, in intelliJ, open that as your code base. In the terminal window within intelliJ, SSH (using Putty) to the Pi, and exec your code on the Pi directly. This allows you to code in your IDE, but work on and execute code on the Pi itself. I often have a whole slew of tests for my code that can run on any platform, then a bunch that can only run on the Pi. To do this, you have to instruct the test to 'skip' if it's only to be run on the Pi, and for ones that don't require specific Pi functionality directly, you can use something like mock to mock out the GPIO calls. Although I don't use Python on my RPis, I do use techniques such as these in the Perl distributions I write. Here's an example that checks if a certain environment variable is set or not. If not, it skips all tests in the current unit test file: 

This question may come off as ambiguous and/or repeatable, but I can't find the answer I'm looking for. I use intelliJ IDEA with the Camelcade Perl5 plugin to do development work for the RPi on my laptop. (I either wrap or write C code that contains a Perl API interface). The Pi isn't well suited to run such an IDE efficiently. My problem statement: I want to be able to load up a directory in my chosen IDE from the Pi on my laptop, so I can write code from the comfort of my laptop to that repository, and have it like I may as well be doing the writing on the Pi itself without having to have the UI started on my Pi. My question: What is the preferred way to do this. Specifically, I want to know the most secure/efficient way to set something like this up, in point-form (I think this puts the question within the guidelines; advise if not). My issue(s): There are multiple explanations across the web on how to share stuff, whether it be Unix or the Pi itself. However, I've been out of the sysadmin world for a few years, and I just know that blanketing things with is unacceptable here. I need a proper way to do this with reasonable *nix permissions, while still allowing RW for authorized *nix users, without global write access or other nonsense that create huge gaps in file system security. I'm looking at and , but again, most things I find online are tutorials that advise to blanket allow permissions with or perms and that's not acceptable. Is there a de-facto standard that Pi users use for situations like this that are secure file-system wise, with the ability to maintain user-level access? 

You probably do not need to do that, particularly since that CD is very unlikely to contain linux driver source code, which is what you would need to use it on the pi (I'm presuming you are using Raspbian or something similar). That, or linux versions that have been compiled for the ARM architecture used on the pi, which is even less likely (because normal computers don't use it) and generally useless anyway (because such drivers have to be compiled for particular kernel versions, which is not worthwhile bothering with on the pi). First, without the adapter attached, after a fresh reboot: 

According to your output you have 125 MB available, more than half your total. If this is a B with 512 MB, you have allocated way to much to the GPU. If you are using HD video or 3D graphics, 128 MB should be plenty. If you are doing normal web page stuff in Midora (you mention a dashboard), 8 or 16 MB is fine. You don't describe or provide an example of the "Cannot allocate memory" errors you are getting which makes this hard to diagnose, since obviously the system is not out of memory. 

I'm not a libCEC user, but a quick glance round their site revealed something on the vendor support page regarding implementation of the "standby" feature for LG products; namely that it is "supported by all devices except TVs". I'm not sure if that explains all your problems or not. LibCEC's front page does have a "More" section at the bottom with some contact information, you could ask them directly about this.