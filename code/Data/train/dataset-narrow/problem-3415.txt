Then, save (it's Ctrl+O then Enter for nano). After that, you simply need to run with the configuration file you've just created: 

A highly useful resource is packages.debian.org in cases like this. If you search up , a package is found, but the key bit to note is the distributions that the package is available in (top right of the page) — it's only available in the Buster and Sid repositories — not Stretch. That explains why you're seeing the directory in the package repository, despite not being able to access it yourself with your Stretch installation. As you can see in the directory of the repo, Buster is an available option, so that's why the package has crept in. You may be able to install some packages from the testing repository while keeping your system mostly stable, but be aware that it's technically not supported. If you want to go down that route, take a read of the Advice For New Users On Not Breaking Their Debian System which is highly informative. 

( looks more up-to-date and might be a better choice, though). I would advise trying the APT method first, and if not, try using Pip. 

PHP5 packages are not available in Stretch (see the package lists for , and note that there are packages for Wheezy, Jessie and Sid, but not Stretch). You can either: 

You likely mean , not . 'Venv' stands for virtual environment, so it's not surprising that isn't found. The correct command is: 

Note also that "Initial specifications stated that Vulkan will work on hardware that currently supports OpenGL ES 3.1 or OpenGL 4.x and up", according to Wikipedia. The BCM28xx video core "is documented to fully support OpenGL ES 2.0", which is not sufficient for Vulkan. 

If you are using a Raspbian version after or including Jessie (i.e. Jessie or Stretch as of 2017), you can take advantage of , which gives you much more control. Let's create a new service file at : 

In practice, this means you're limited to a 1.35 V core voltage, because without or , you can only set to a maximum of 6. 

You're using the full local file path, so even with the glob being correct, you'd be getting output like so: 

The point of buying the license keys is to enable hardware decoding of MPEG-2 and VC-1 — see Why does the Raspberry Pi need a MPEG-2 licence? for more information on why you might want this. While there was much rejoice recently at the patents expiring for MPEG-2, this makes little difference to Pi users, it seems. This thread claims that despite the patents expiring in most countries, the Pi Foundation won't be making any changes until 2025 until all patents are expired across the world. You can still do software decoding of MPEG-2 without paying any fees, but performance is generally much worse than hardware decoding. If you're creating a media centre and experiencing poor playback of these video files, investing in the license key may be valuable. So, if you do need hardware decoding for MPEG-2 or VC-1, you still need to pay up, unfortunately, for the foreseeable future, by buying a license key from the store (I might add that I didn't believe that was official until I saw it linked from the official blog!). 

If you know specifically which command needs the environment setting, you can set the environment variable just for one time by setting it, then typing the command you want to run. I suspect if you did this, you'd need to run . 2. For a terminal session This is probably the most straightforward option — run: 

Note that the option searches the full process names, but you can just put in a fragment of the full process name (e.g. just the call to Python and your script name) and it should work. If you can't find the full process name, you can list all processes with and look through the output. We can then pipe it into , using to run for each PID: 

I'd recommend the method above of fixing the code, though, as the more recent versions of Django come with more security patches and bug fixes. 

You can download and install the front end source from here (). Once this is installed, you will be able to find and use the binary as expected. Alternatively, you can choose one of the other listed front ends, if you decide that you like one of those more. 

Bash scripts, in their simplest form, just act as if each command was typed out on a new line in your terminal. This should be the most straightforward way for you to run multiple commands in series like this. The will set the environment variables for the length of the script, but won't last after the script ends. 

As goldilocks points out, the cleanest way to do this would be for the script to stop itself. Alternatively, you could execute a cron job to kill the process you launched. To do this in a script, you'd need to first find the process IDs to kill using : 

Espada (espada-tech.ru; translated) appear to be a Russian computer company. They sell Pis from raspberry.su (translated). It's unclear how they're related to the official Pi distributors; my guess would be that they're not official as I couldn't find any mention of them on an official reseller list, such as Farnell's list. It was pretty challenging to even find any mention of them on the English language internet, which would be odd if they were official. For comparison, the official reseller's company name does come up in a search result for approved resellers. I'd honestly be surprised if a convincing fake of a Pi could be made; the costs involved in finding a SoC that could be passed off as the Pi's for less money than the Pi Foundation make it for would be great. They're probably just unofficially reselling Pis that they buy elsewhere and ship in, but it's impossible to know without seeing one of the devices they sell. 

Just as in vanilla Minecraft, you need to set two blocks to be a bed for this to work. The vanilla commands would be: 

It's unlikely that you'll find a free API for sending text messages, simply because sending them isn't cost free. That said, you're looking for an SMS Gateway. Many US mobile providers offer free gateways that will convert an email sent to a specific address into a text message to the corresponding telephone number. This may also be the case in other countries, although you will need to check with the providers you wish to communicate with. Otherwise, you'll need to use a paid SMS Gateway, such as Twilio. Pricing varies by volume and location, but they do offer a free trial balance to test with, before you commit to paying per message. They offer libraries for various languages and the documentation is pretty extensive, which is what you'd expect if you did choose to pay for the service. Other paid gateways likely have similar pricing structures and features, and you'll need to take a look around the market for the most appropriate for your use case. 

You will of course need to integrate that into your web server, but it should be relatively straightforward to collect a WAV file from the user and return the output. 

(run that in the directory from the ZIP you extracted). If this is unsuccessful, it is likely that it relies on platform specific features, in which case you will need to look for another MQTT client; HiveMQ list a few on their site. As pointed out in the comments, though, be sure to consider whether you actually need a client on your Pi... If the Pi is accessible to the internet or your local network, it may be easier to connect from a different device with better support. 

I would say the vast majority of Pi users (and Linux users in general) don't bother installing anti-virus software. There is a myth that frequently gets told along the lines of "Linux can't get viruses" or "No-one writes Linux viruses; they write for Windows instead". Those myths aren't true – viruses can and do exist for Linux distributions, although they are significantly less common than on Windows. The Debian documentation on security lists some anti-virus scanners, should you choose to use them, but most of them are geared towards scanning email rather than scanning your computer as a Windows anti-virus program would. More commonly, devices which are poorly configured are vulnerable to being taken over by an active attacker (as opposed to you downloading software which is infected). A prime example of this is Pis being taken over which used the default SSH password without changing it. SSH did at one point run by default in Raspbian, so if the default password was not changed, it was possible, depending on router configuration, for a Pi to be exposed to the Internet with only the default password as protection. If you want to keep your Pi secure, it's generally better to stop any attackers from getting in at all – the Pi Foundation have some tips, which include configuring , which can act as a firewall for your Pi. Their suggestion is to configure with , the "Uncomplicated Firewall", which you should be able to do easily. While a firewall won't stop a virus, it may help to defend against other attacks. 

You'll probably need to create that file with root privileges. Once done, save that, disable your cron job and run: 

If you are able to use Python 3, though, it's generally advisable to use it — Python 2 doesn't receive the latest updates, and will, eventually, reach its end of life in 2020. Python 3 does have far fewer quirks, so I strongly advise you to consider using the methods above and install for Python 3 instead. 

I'm guessing you're running Raspbian Jessie, which only has Mosquitto 1.3.4 in the repositories. Raspbian Stretch does indeed have a more recent version — 1.4.10. If this would be sufficient, you can just flash a new Raspbian Stretch image on to your SD card and install Mosquitto. Note that the Pi Foundation suggest using a new image rather than upgrading with your package manager, although that may work despite the warnings. Be aware that flashing a new image will of course delete all of your files. Otherwise, you may need to build the latest version from source: 

If you're still using Jessie, use the instructions before that for . Give that a try with , and hopefully it should be compatible. I've heard that occasionally Debian's repos vary slightly from the official Raspbian repositories, but it should work in this case. Good luck! 

After booting is complete, you'll find the chart saved in as an SVG file. Then, revert to its initial setting (or delete it if it wasn't there before). See also the man page for . 

That couldn't have been a Raspberry Pi 3 Model B+... because that model didn't exist! Until March 2018, the only Pi to have a Model B+ version is the original Raspberry Pi 1 Model B+. The differences between the Pi 1 Model B and B+ are as follows: 

By default, systemd sends a SIGTERM, then SIGKILL to your service unless you've specified more complex logic. SIGTERM doesn't raise an exception in Python, so your block probably doesn't get run. Try adding: 

Generally, instructions for compiling don't change from architecture to architecture very much. Compiling code for x86 and compiling for armhf will usually just need the same commands, so I would expect the official README to be accurate. The other page you linked to says that is adapted from this answer, which is in fact from our own little corner of the Internet, Raspberry Pi Stack Exchange. It's much more obvious why the other link does all of these unusual steps if you view it in the context of the Stack Exchange Q&A – someone tried following the official instructions on the Pi, and it didn't work for them, but another user was able to find some steps to make it work. I suggest you try the official instructions first, and if you have trouble with those, this answer's steps might be worth trying. There might be slight variations given that you're using Ubuntu MATE, but the only way to find out is by trying. Good luck!