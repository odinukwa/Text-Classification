is very unconventional, and unconventional is usually bad. It is important to be consistent with your naming scheme, otherwise it will be difficult to read the code. The convention would be to name it . But now it is only consistent in style, still not logically. You didn't name the other functions , so I suggest to leave out the "win" here as well. After all it is pretty clear what is checked for in tic-tac-toe. Furthermore, a method should only do one thing, and method names that contain "and" are often a sign that it should be split up into two methods, here and , or better and shorter and . Note that these names might still need to be changed if it turns out that we find a better way to do the algorithms. 

Printing the level here is a side effect that you might want to prevent. The method should do only what its name implies, which is getting the level. A better name might be or , since is normally used for just returning a value that is already there. Then you can print the return value where you call this method. 

You are using and to separate logical parts of your code. It is better to move these parts into methods and have the methods name explain what is done. Removing items from In a comment you ask whether you do this correctly. If I understand your intent correctly, then you are not doing it right, and it only makes no difference in your case because your items' values are the same as their indexes. It is important to note that and are not the same thing. They are two different types, being a wrapper for the primitive . In some cases the JVM automatically "boxes" these s into objects or "unboxes" them the other way around. Since an contains objects, when doing the will search for the contained object if it exists in the list, and will remove the item at the index . Since you randomly select an item by calculating a random index, you might as well save the index in a variable (see my example above where I do it for better readability anyway) and then remove by index. Initializing your ArrayList This seems a bit verbose: 

The same applies to many more blocks of code that begin with such a comment that sounds like "do this and that". 

The constructor of your class takes a parameter . What is that value? Better use a name that tells you what kind of value it is (e. g. level, age, etc.). 

The variable name "split_string" lies about its contents. It contains the , not a split string. Saving the result of in it should give you a hint. Don't iterate over the substrings with , if you don't use the index for anything than accessing the string. Instead do 

Yet another capitalization style. This should be . Probably it should even be something like or , or something similar. But then it should be returning a boolean. 

The if-else looks very pressed together, which makes it hard to read. Always put the code that is executed under a condition on a different line than the condition. Furthermore, adding braces prevents you from introducing bugs when you add a line without realising the missing braces. 

My version Following is my version of your bank account class, with the members removed that I think should not be part of the account class. Furthermore I added an interface with two implementations and . Both are immutable (meaning they cannot be changed, neither through direct access nor methods). Note that they are not implemented as what you would usually regard as transactions, but it should give a hint about in which direction the class could go. 

Especially in the API of a class, i. e. its public members like this method, you should use interfaces or abstract types, rather than specific implementations. If you replace with , you can use any implementation of that you like, without having to change many parts of your code. Style The Java convention for class names is . should be . 

This comment already reads like a function name, so pack the code inside of a function. This way you don't even need the comment, because the function name tells you all you have to know. It could look like this: 

This formatting is confusing. The constructor is on the same indentation level as the class declaration. The same thing in the actually made me double-check a few times which class I'm reading. To be more readable, it should be indented like this: 

Note that previously to Java 8 this results in the first element being an empty string, which must be handled accordingly. Then add all of the characters in the array to the collections: 

Your names are not only inconsistent in capitalization, but also abbreviation. should be written out as , to fit with but also because abbreviations sometimes force the reader to guess what it means and thus destroy the code's readability. 

Use expressive names to create self-documenting code. If a comment is needed to explain a variable, use a different name: 

Don't forget the break after every case. If you have an at the end (instead of an ) use the case. Comments 

Your indentation is weird. Use 4 spaces (less common tabs with width of 4 spaces) for indentation. You have sometimes 3 spaces, sometimes 2. Since is a boolean expression, you can return the result just like this: 

Since we said above that not defining these functions might be better, you can use lambdas as callbacks. Lambdas are anonymous functions, that means you do not have to define them with , but you can just use them where you need them. In the cases where you just change a variable however, you will still need the function. This is what it could look like: 

Performance I will give you some hints on what to look for when coding for performance, however I don't think that performance is your biggest issue here. Until you find a bottleneck by profiling different parts of your code, I suggest you to try to improve the code's quality in general first, and it will probably be easier to find possible performance issues then. If I understand your function in ai.cpp correctily, it doesn't really do anything except drawing a progress bar and artificially slowing down execution in order for the bar to not instantly be full. If the only purpose of the progress bar is to make it more fancy, but it doesn't really show the progress, I'd much rather just leave it out, or replace it with something like and . When you have if-else branches where you can estimate the relative probability that one condition is true, that condition should go first. For example: 

The comments at the end of the lines do not tell you anything that is not already in the code, so you don't need them. Comments should usually tell you, why something is done, not what is done. What is done is already in the code. 

This is redundant. You have the same code twice, with just different conditions. You can already see why this is bad: You typed the output strings differently without realising, so in some cases when the player is out of bounds the output will be , in some cases it will be . This is a bug, and a very simple example of bugs being introduced or at least made much harder to find by redundant code. To fix it you can either combine the logical expressions into one condition: 

has a boolean field , and a method , which returns the variable's value. The value is set once the is set to 0. A better implementation of would be to just . This reduces the complexity of your code and reduces the risk of introducing hard to find bugs. 

is another atypical naming scheme, and the functions should rather be called something like . The name you chose (aside from the capitalization) sounds more like a custom version of any print function, like for example printf. 

Coding in English as a non-native speaker, a translation error has found its way into your code: . The English word is . The risk of this happening can be reduced by reading all of the strings from a file, having one file for each language if you want to support multiple languages, and letting someone translate the file for you who does not need to be a programmer, because the "strings" are not part of the program anymore. 

Your variable is not really a percentage, because it can have values between 0 and 1. Percentages are values between 0 and 100, so you could change the scaling and use a random calue between 0 and 100, or simply rename the variable to something like or . If you don't like any of those names and can't come up with a better one, change it to . Style In addition to the indentation, you are using newlines and whitespace in an unusual way. For example 

Note that I also converted the string to lowercase before the comparison, in case the input string is not all uppercase. You might also move that counting loop to its own method and return a tuple with the two counts, so that you can write 

is a very bad name for a variable. Since this looks like a calculation of Euler distance, I assume that it is supposed to mean distance, so better call your variable or at least . You can write here to make it shorter. You might want to put the ouput code into a function (e. g. ), to separate logic from I/O. is hard to read, because of the formatting, and because it is a long formula with variable names, namespaces and method/function calls. Better put it in a function: 

Header files You have a lot of implementation code in that header file (files.h). Header files should only contain the function or class headers, the implementation should go into an extra cpp file. That makes your code more organized and also more performant, because your code would be included as is in every file that includes your header file. Out-commented code Your ai.cpp contains a lot of out-commented code. When that code is not used any more, you should delete it instead of commenting, as you might later not know why you commented it out, and whether you can safely delete it or not. If you want to make sure not to use it in case it turns out that you do need it again, that should be covered by your version control system. 

Your variables are not set to private. That means that anyone in the same package as well as subclasses can change the account's balance, without it knowing about it. 

does not really execute commands. The only command it knows is to shut down the bot. The actual command execution is done in . Since process commands only returns or (like error codes, but not quite) you might return a boolean that simply determines whether to close the bot or not. 

Note: I did not check whether your code matches the formula correctly and I am not an expert of the mathematical background. I only refer to your code. Style 

Here we are only checking whether they are equal, not which symbol they contain. But we do not have to do that if we only check for a win after any symbol is placed, and we store the current symbol somewhere. 

You have a lot of getters and setters. This breaks encapsulation, and is not object oriented. It is just slightly better than accessing the fields directly. While in some cases they makes sense, it is not good practice to use them for every field. Objects should only expose the information about themselves that they need to. For example, instead of allowing the to access the caster's power level, add the power level to the constructor parameters of the skill and let the caster inject its power level. Since this is the only reason you inject the caster into the skill, you can even remove the knowledge about the caster from the skill class.