Edit: In view of @Tokland's suggestion of constructing a set of prepositions when processing the words one at a time, I thought it might be interesting to run some benchmarks. You'll see that I just used random arrays and words, rather than read and write to files. 

Incidentally, I made the number of elements whose product is to be maximized a variable because it wasn't really any more difficult to do that and it facilitated debugging. 

A word about the regex (which I've used to avoid the need to ). looks for a string that contains one or more characters other than . is called a positive lookahead. It is not part of the match (which is why it is sometimes referred to as having "zero width"), but it requires that the match be followed by , where signifies the end-of-line. This strips off from the beginning of . To make it easier to remove leading zeros on trailing numbers, I've not included at the end of each subdir. (It can be added at the end if desired.) Next we execute 

Harness the full power: Why stop at a single arg constructor and use a switch over the strings? Simply add a second arg, and set a final String for the name along with the number: 

OK, the data-structure looks a little wierd here, because your list consists of map-entries, but this was the main work. If you print this result, you already get (format added manually): 

Disclaimer: this has not been typed in an IDE or compiled, but just done on the fly, thus it might include bugs. But the concept should be clear. 

Then, the actual call of the logic is simple and clean, no matter whether you use a loop or a stream: 

Your queue does not have any overflow protection. As queues tend to be used in multi-threaded environments with different producer and consumer threads, you'll have an immediate overflow when the consumer stalls for a while. In fact, this will simply throw an ArrayIndexOutOfBoundsException right now, so you'll have a program crash (which is somewhat OK.) If you expand this by creating a ring-buffer on a fixed array, you'll overwrite unread data without even noticing it and find yourself in the hell of untracable program behaviour. Thus: add bounds checks. 

[Edit: I'm not happy with my solution after reflecting on it. Constructing the array is wasteful, as one can just maintain a running count, as others have done.] Here's a slightly different way of looking at it. Let be a car position, west to east. First compute an array , such that: 

it would return . What is the rational for that? Moreover, the question asks for the last item in the list, not the last item in the last list of the list. I think the only reasonable interpretation would have return in @200_success's example. To do that, you can modify your code as I have done below. Code 

Below I've suggested how pcc's code might be altered. The edit history of the question shows that pcc came up with virtually the same thing. In fact, before pcc's question was rolled back, I left a comment saying how I liked that factoring, in part because it was virtually the same as what I had come up with independently. (My comment has since vanished.) 

Fetch the concrete enum constant via lookup by name, extract the value from the object via reflection, and create the comparison value by some form of String-to-whatever conversion. Then, simply apply the test. 

This is all just a question of knowing your data structures. You already represent the input as a (which is good), now the next step is simply to represent the match pattern as a too, an then use the equals function of lists. Naturally, you will have to iterate over the list to create 2-element sublists to check the equality. Thus, setting up the combinations (may be done differently, the important thing is the structure as List: 

You mix business logic with UI code. Normally, you'd go for separation of concerns and move the conversion functions into a separate class which is used by the UI, but does not belong to the UI. Running a separate thread: how long does the conversion take? 1 ms? 2? I really doubt that the overhead of thread-creation is necessary here. (Though it may indeed serve as an excercise!) Binary to ascii validation: if the amount of bits does not match, you overwrite the user input? Thus, if I, the user, make a little mistake, type 319 bits instead of 320, you actually force me to start over? /me pissed user :-) 

Here is an example of test data with 8 4-character words, of which 3 are prepositions, and a sample size of 2. 

Your first question was answered nicely by @sockmonk. You could have written , which, though longer, is arguably clearer. Regarding the second question, I suppose that's a matter of individual preference, but I am happy to use a ternary operator when it fits comfortably on one line. One reason is that it reads fasters than an clause or statement, as we humans have greater experience reading horizontally than vertically. @200_success makes an important point in his comment on the question. For the example he gave: 

Note that after the sort, is an array of two 2-tuples, each corresponding to a key-value pair from the original hash. If I misunderstood what you are doing, and you do need to pull out the 10 elements of the hash corresponding to the 10 highest-ranking keys, just change the parameter for from 2 to 10, then extract the first two elements when you need them (i.e., ). You can then retrieve the key values from these 2-tuples or convert to a hash for the return value, as I have done with . Edit: Ah, is modified by . Consider this as a further possibility: 

... the same for min. As a general advice: Java is a very mature language, and chances are good that every "simple everyday task" is already solved in the library. (Also note that most books on Java are from the pre-java-8 era and may be considered somewhat outdated today.) 

That is exactly what Sonar says: "... from which an application should not attempt to recover". Thus, if you catch Exception and NOT Error, yes, this will effectively terminate your scheduler and probably impact the DataStore. BUT: as Errors indicate a severity, where the VM probably won't be working reliably anyway (also see $URL$ this is exactly the thing to do: terminate the program, bail out, call the admin. When you continue working under error conditions, the result is generally somewhat undefined. Better avoid this. 

Variable scope In your loopUntilExit(), you declare the input String outside the loop - why? This should go to the minimal acceptable scope, that is in the line where you call sc.nextLine(). Law of least surprises I don't like abusing the toString() method to create a multi-line screen menu. This is not what I'd expect of toString(). Thus, I suggest you create another method to do this, and call it explicitly. One afterthought In 20 years of programming Java, I have never seen the use of Scanner in real life (TM). Is it really necessary, that every teacher seems to love this object and base their classes on it? Yes, it is simple, straightforward to use, and probably an easy-to-explore way to teach other principles without the input getting in your way, but it does not hold any practical relevance (at least as far I am concerned.) 

creates an empty string, designated in the block. It is then a simple matter to consider each element of each term in the polynomial to build up the string. I'm not certain if I followed the formatting rules exactly, but if I did not, it should be easy to modify the code to conform. (Edited to fix boo-boos spotted by @200_success.) 

To my way of thinking, the shorter the method, the shorter the variable names can be. If a method is short, and you understand what value a variable holds, you don't have to remember its name very long, so it can be short. Here I used (and ) for "number" because I always use that convention. obviously is a method that calculates 's triangle number. I can use something short like because the expression says what it is. Same with and . If you want to get fancy you don't have to begin with the number . Instead, you could calculate a lower bound on numbers that have triangle numbers with the given number of factors. Calculate triangle numbers Next, in order, the method . Your method is fine, except doesn't add anything to the name and there is no need for an instance variable. Just return the triangle number, which also helps with the self-documentation of the method: 

There's not much to add to @Imus excellent answer, apart from a little naming advice: your is in fact an edge in a graph. You even call the collection . So really should be renamed to to correctly grasp the business object behind it. (BTW: as an interviewer in a rush, that would probably the first point of criticism I came up with.) 

you can perform every possible action and return a detailed result ("performed 'A', but 'B' was not possible due to...") you can validate the actions, and only perform the complete set, if everything was possible ("no action taken as 'B' is invalid") 

This way, you divide the problem into manageble pieces, give you thoughts a place to stop every once in a while, and should get rid of this nervousness. BTW: from an interviewer's point of view (at least I you want into my team in my country ;-)) a well thought pseudocode algorithm is worth more than working code. If you apply for a programmer's job, I just assume that you have the basic skills to use an IDE and kick against some piece of code until it compiles and produces the correct result. What I am looking for is organized thoughts and problem solving skills. One last thing: there is one and only one correct exception to throw for a null parameter that must not be null: NullPointerException. Ideally by simply using Objects.requireNonNull. 

The way I've displayed the error messages may not be what you want, but that would not be difficult to change. Note that, when a file name has an invalid format, I've listed all the reasons it is invalid. When matching a substring against a regex, notice that the length of the substring is checked by including start/end anchors and avoiding the use of , and . For validity checks that involve a list of possible values, I've made the list an array of the values from your hashes, as the keys did not appear to be used. If the keys are needed, those arrays could be replaced with hashes. A potential problem with this approach is that it's not very flexible. If, for example, a validity check were changed to involve something other than matching a list or a regex, it might be difficult to alter the code to accommodate it. I initially considered a different approach that offered greater flexibility. It retained the array of hashes, , possibly changed somewhat, but also had a module that looked something like this: 

Version 1: Basically OK, but the copying of elements to another list is unnecessary. Have a look at on how to create lists from a given index range. Additionally, you should change the return statement to so that the recursion does not take place if result is already false. (Look up short-circuiting in logical statements.) Version 2: NO. It is much better not to copy the elements and use indexes into the unmodified structure, but here you recurse for every element in the list, i.e. the recursion depth equals the list size. This is a total no-go, as it will definitely blow your stack if we are talking about serious data sizes. Nevertheless, explore the option of using indexes (maybe a start-index AND an end-index) into the given structure some more and combine it to a divide and conquer-approach as in your first solution. Happy coding! 

This basically boils down to a grouping problem: you have an input list and want to group it by date, which yields a per-date list of a given length (1 to number of departments). Then, these list's contents get added to a collector list chosen by the list's size, i.e. add all contents of list with size 1 to collector 1, add all contents of lists with size 2 to collector 2, and so on. Using the stream API, you already have the grouping, the rest is a little footwork: 

That's up to you, but you probably want to use the first form at least while you are debugging and testing. Calculate number of factors from prime factors Now let's go out of order and look at the method . This one is actually quite easy, as we can employ a version of the Tau function. Suppose we have constructed to return the array: 

I have formatted the numbers to make them easier to read and also added three statistics I thought might be of interest: 

You may wish to consider writing this as follows: First obtain the number of months per billing period: 

We see that two of the are 's (), and one is the original number . The number of pairings is the lesser of the number of 's and the number of s. Here that is one. I will now go through the steps to determine the number of pairing in above for . To make it easier to follow, I will first sort (though the method neither requires to be sorted nor sorts it):