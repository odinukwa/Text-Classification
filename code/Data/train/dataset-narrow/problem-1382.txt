The first has a little more to it. I think it's worth special-casing the situation where everyone can fit on the rollercoaster: 

And at that point, you're done. Again, what you've written now definitely adheres to OCP- there's no situation in which you'll have to change that class. Unknown requirements are kept in the realm of code you haven't written yet, and design you're not locked into: 

Overall, the problem of having a collection, not knowing whether it's null, and wanting to treat a null collection the same as an empty one is probably a problem to be avoided, rather than solved. But that's beyond the scope of this question. 

So of those it's likely to be the second, if any, which is of concern in this particular case. My preference is to avoid the complexity of trying to implement my own hashing algorithm and let .NET do it for me: 

Regarding your original , the names aren't great. Shouldn't be , and likewise shouldn't be ? This also reveals another problem: there's no guarantee that these values are valid (they could be negative, or above the maximum possible). This could be done with validation in a constructor, making the setters . 

From there, the solution with and is really just noticing that you can predict what the loop will produce without actually having to go through each iteration, and likewise knowing about the modulo () operator and thinking to use it, to simplify the column bit. But being able to clearly state what you want to do in English and turn that into concise, readable code is a far more general and wide-reaching skill. 

To this you'd pass an array of names of all your clubs, and it would return the selected club. Notice how this is only concerned with presentation concerns, whereas the part that we've now extracted (the club names) is now completely isolated from presentation. If we changed to a GUI, this method would be changed entirely, but the code which uses it could remain exactly the same. This idea of each piece of code only being concerned with doing a single thing is called the Single Responsibility Principle. Eventually, you'll find that there are more sophisticated structures that can help you with this (in Java, that will be object-oriented programming), but even making sure a single method isn't mixing many responsibilities is important. 

To my mind, that line is simple and readable enough that it may no longer warrant its own method, especially its own extension method which will apply to every single type. Validation doesn't seem like something that would be done in too many places, so even if you didn't like that line, you might just move it to a private method somewhere. That's more a matter of taste, though. 

Generally this is well-written. You already mentioned the reason for the "ML" suffix, but to emphasize, it should definitely be removed. For naming in general, I'd steer away from "OrDefault" for a few reasons: 

This can now be bound (I won't go into the details of how) to any class/method, so that when the class is retrieved from the container and the method called, that interceptor is used. You don't need to use that exact format of course, but those are the basic places at which you can perform some action like logging. The can now be replaced with an , which would essentially be an implementation of the method above. Notice that it's completely decoupled from the actual method that's being called- no knowledge of the method, class or interface corresponding to the invocation. So now this cross-cutting concern, instead of having to be sprayed all over your project in repetitive decorators, has its own single class which is appropriate for what it's trying to do. This is a specific example, but because of the decorator's coupling to the interface, AOP is pretty much always preferred over the decorator pattern for cross-cutting concerns. The Alternatives - Part 2: Perspective Shift () That's all well and good for exception logging, but file header validation certainly isn't a cross-cutting concern. And to work out how to best deal with responsibilities like that, I'm going to suggest a bit of a perspective shift. To start, let's look at the only public member on : 

You'd then just need to implement (which you'd want to make lazy, so that you don't calculate primes higher than you need) and 

With the former being the much higher priority. For that reason I chose an interceptor as the trampoline construct, using Castle's dynamic proxies. (EDIT: As pointed out in the comments, the CLR will sometimes optimize tail-call recursion and avoid stack overflows. However, my understanding is that it does not always do so, and makes no guarantee about ever doing so, and so it's generally not reliable enough to avoid exceptions in many situations) The Code 

This is somewhat a matter of taste, but I know I'm not the only one. Generally I'd only put both parts in-line without braces if they're both very short. Putting the statement on a new line without braces is generally considered poor practice so I won't recommend it, though it is actually my favourite in terms of readability alone. So two remaining options are: 

Most of this seems good, so the points are relatively minor. Conditional order Your conditional statements are written like or . This style, with the variable on the right, is a trick from C/C++ designed to prevent accidentally typing and doing assignment rather than comparison. However, in Java, there's no need to do this, because if you typed inside a conditional statement, you'd get a compiler error. Using a C idiom in Java is confusing, and means that any Java developer reading your code is likely to have a bit of extra cognitive friction before they can parse what's going on. That extra difficulty in translating between code and what you actually want to say leads to bugs, like: 

There's probably a lot more things to point out, and I'm sure other answers will. However from my perspective, these are the two key high-level concepts that will help you progress at this point. 

Is any of this necessary? You don't need to say it's a string, it's right there in the signature. And everyone knows what a string is so linking to it is useless. The name 'getMessage' already says that you're getting a message, so writing that again in the comment is pointless. I suppose you've added the information that this is the message "to be displayed", but that's rather vague, coming to this code for the first time it wouldn't tell me anything unless I then went and read the rest of the class. If you really think it's important to communicate the information that the message is being displayed, you could rename the variable and the corresponding method instead. And finally, the overall summary and the part again say exactly the same thing. This is a trap I fell into a lot myself. You think "Well, I have to write something for the Javadoc." But you really don't! If you have nothing to say there, say nothing. Use of static This is where we get into "difficult to review because it's such a simple application" territory. Because you're basically done now, you're not going to extend this or use it in a larger application or anything, there's nothing really wrong with using a static message as you have. So I'll try to talk about why, in a more general situation, it might not be a good idea. Essentially I don't really know why you'd make the message static and everything else instance. Why not get rid of your static message field altogether and just have: 

One thing this doesn't address is the leading zero for minutes < 10, but this can very easily be done in a few extra lines. It's hard to do a line-by-line comparison of this to your version, because it's quite structurally different, but the key is to see how we've separated out each individual question we need answered into its own piece of code, and decoupled those questions from each other. We don't do a check like: 

Putting aside whether you adhere to CQS, or to what extent, the idea of everything being either a command or a query is a useful one in guiding how you test it. For a pure query, a necessary and sufficient condition for its correctness is the correctness of what it returns. It really doesn't matter what it does, which means that a test shouldn't be concerned with its implementation. A test that relies on implementation details is coupling itself to the way the query method works in a way that violates encapsulation. This adds extra maintainance effort if you ever want to change the implementation. It also undermines both of the purposes of unit tests I mentioned at the top. They're not good living documentation if they test details which are not actually aspects of expected behaviour to an external consumer, and they can't give useful instant feedback if they have to be updated alongside the SUT. So, all that said, take a look at . What this is doing is taking a pure query method, and instead of checking the result it returns, it's looking at the specific implementation of how it gets that result. Consider again the possible future requirement I mentioned before, of adding paging. For efficiency, you might add a new method to the repository which takes the page number and entries per page as parameters (so that you can do the paging in generated SQL, rather than in memory), and switch to using that in instead. Now, even though is still perfectly valid, your test will fail, and will need rewriting. That's because your test is testing an implementation detail rather than actually documenting what the method should do. The smell here is that you're calling a method on a mock when testing a pure query method. It's fine to use a mock object as a stub or provider of fake data for a method like this, but you should be very wary about any calls. You don't have any commands yet, but when you do, that will be where using a mock as a full mock, including , will come in useful. For a system like this, a command will often be something that modifies the persisted state, like adding a new blog post. Say that's done by calling an method on the repository. Calling that method, and passing it the correct parameters, will be the intended behaviour of the method, rather than just a particular implementation, so in that case, verifying that it's called correctly will be just what you want in a test. In this case, it will accurately be documenting what the method should do, and it never break during a refactoring unless you actually introduce a bug, which is exactly what you want. Dealing with and Unfortunately, this is a bit messy. There's essentially three things you might want: 

With this method, there's now no longer any need for the methods, and so now there's no longer any method that needs to be on and so you can remove the class, just using a instead. Renovating JobList The above would be my suggestion, but it's based on certain assumptions. What if is called in multiple places? What if really does perform better and that performance is critical? What if there's some additional logic or validation which that class could usefully handle? In those cases, you may want to keep . So instead of deleting it, here's how you could improve it: 

You know the and need to be in there because they're the ones in stacks. The way I've done it I've replaced the class with an iterator method, which necessitates the being passed back and forth rather than being kept as a class-level variable. From there, it's fairly simple to rework what you have currently to a new version: 

Aside: Naming Actually, now that we're here, extracting this method has brought into sharper focus that maybe the naming isn't ideal. is extremely vague- why not , which is what you actually use it as inside the method? Likewise would be better as a description of something the method is doing, like . Initializing the height One of the uglier pieces of logic is the special case for the number of cycles being 0. Is that necessary? What are we actually getting at with this: 

This goes back to what I was saying about this being difficult code to review, because it essentially exists to fulfill requirement which is already fulfilled so simply by the .NET framework. However, if we go with the fiction that exposing the counts for all those different methods for a single string is something that is done commonly throughout your program, then your approach is sensible. Using the LINQ-style counting above, you can remove the second statement and all the s inside, replacing them with one-liners. You can also remove all the variable declarations and feed them right into the result constructor, since they are so simple: 

Simplicity When creating complex code structures, it's useful to compare them to the alternative and ask what exactly the trade-offs are. So the pros and cons of your approach as I see them: Pros 

In fact, at this point the exception type is really just a particular piece of human-readable information, and the stack trace is just further information about where the problem occurred. So really, all three are the same thing- diagnostic information for the person who has to come along and understand what went wrong. So here, the purpose of wrapping an exception is to provide better diagnostic information. Maybe there's some variable which is likely to be relevant to trying to work out what happened. Specifying a specific type of exception could give important information too (knowing, for example, that the problem arose from the database). With this in mind, let's compare the two exceptions in your example: 

Beyond this, I have to echo Heslacher on both the issues with naming and with this method mixing its responsibilities. In fact, these issues are linked, because taking care with your naming is often the best early-warning mechanism for a method doing too much, or lacking a single purpose. For example, what should this method be called? as Heslacher suggests is nice, but doesn't actually describe your initial method well, because it gives no indication that it's also going to be doing IO. would be a more accurate name, and this should immediately raise alarm bells: Why is this description so long? Why does it combine two unrelated concepts (initializing an array and console IO)? The answer is that the method lacks a single purpose (or "responsibility"), and should be separated out.