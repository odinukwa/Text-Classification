Macros can be quite good at alleviating these sorts of pains; there is , for example, which works well at handling Results; if you refactored your code so that all of the important stuff was inside a function which could then return , for example, you could use on all of the fallible I/O operations. As it is, you can do things like writing a new macro to assist, and also give a more helpful message explaining where the error occurred. Here’s something more like what I would write; of course, there are various points that are subjective, and I have made some stylistic changes to be in line with what I believe to be more common standard style: 

One must realise that in these common tasks that people tend to assume must succeed there are actually possibilities of failure. 

Making private fields public only for the sake of tests is undesirable; you should instead add new methods which are only available in tests, e.g. 

If you wanted to minimise allocations, you could shift the definition out of the loop and replace its assignation inside the loop with . That way it can keep using the same heap allocation time and time again. But that’s an optimisation that is not necessary for something like this. I might or might not do it, depending on what I had eaten, if anything, for morning tea. Personally I think I’d go with instead of in this particular case, but that’s completely subjective. 

Expressed simply: testing your own code shouldn’t have any impact on the API exposed to library users. is already ; no need to wrap it in . should be rather than in most places. Basically, you should never need to clone the after the first time when you insert it into (to “remedy” that, you could use instead if you wished; not sure if I would or not). You’re doing a lot more memory allocation than is necessary. Unwrapping is undesirable. See if you can avoid it. can be rewritten thus (note how this also makes it only one lookup rather than two, so it’s faster as well): 

(Note: at present this actually doesn’t play optimally with using for as it requires you to clone the user ID every time you call rather than only the first time a user ID is encountered. RFC PR 1769 would fix that.) is unnecessary ( is in the prelude). shouldn’t be necessary; you don’t appear to be using any unstable features (mostly just benchmarking, really). Something to bear in mind: you’re locking the entire balances table to make any changes at present. This is probably undesirable. If you were doing this seriously, you’d be using a proper database which would take care of this stuff properly. Just thought I’d mention it. 

HashMap has some really nice things for efficiency. Just as returned an in the previous point (which rendered the part superfluous), can use the Entry API to do less work: 

Secondly, you shouldn’t be using strings for this; you should be using paths, because that’s semantically what you’re dealing with. The easiest way to get a path tends to be to take a or a generic parameter implementing and calling on it; , , , and more implement it. You can get the base name from a with ; this admittedly produces a , so if you want to display the path you’d need to convert it back towards a string with e.g. . Anyway, the point of this latter part is just that for something that is semantically a path, you should be handling it specially, as a rule; a path need not be Unicode. Think on it more. 

The name should, under Rust conventions, be . The macros could be written as private methods, and I tend to think that they’d be clearer thus. I would expect them to be inlined automatically, but you could mark them also; because of inlining, there will be no performance difference to the macros. wrapping is only needed to provide indirection so that recursive data types work. thus needs it, but doesn’t. Your implementation could (and thus should) be replaced with . You check if , but then report as the error that universe size must be > 2; the clause, however, would correspond to > 1. Now, concerning the equation; for starters, should be written as —superfluous parentheses hamper reading. But there is a more significant issue at stake: the actual equation being calculated. The comment gives this equation: $$2^{floor\left(\frac{log_2 x}2\right)}$$ But the code calculates this equation: $$floor\left(2^\frac{log_2 x}2\right)$$ These give quite different results; the comment would yield only powers of two, but the latter will yield all integers, and might as well be . I feel that would be clearer as , seeing as has already been asserted. In : would normally be nicer written as . One less indentation level, and a more natural way of expressing it. In : is being called quite a few times; it feels like it should be possible to remove some of them, but I haven’t thought about it much at all. 

See how this works with the actual class hierarchy to build comprehensive tree functions simply and recursively? It should be fairly obvious how you could add depth or size methods. You don't need that wrapper class. What I do recommend is 

Applies the sum function to the contents of a list. So my first line of code takes the list returned by largest2, squares each member of the list and returns the result. Now, what you want to do is find the largest of two. Even if you don't think of a nice way to do this, your code would be cleaner if you just output the two largest and then give it to my first line of code above and it will be cleaner than what you have. But here is a simple way to find the biggest two of three. Firstly, assume you have a function max which finds the largest in a list. It's actually part of the standard Scheme library but it is not hard to write if you want to write one yourself (or if your tutor wants you to write one yourself). Either way, this will give you the two highest of three numbers: 

Your code is full of conditionals and duplicated code. This makes it both fragile and hard to read (and, as a result, hard to verify visually). This problem can best be addressed by splitting it cleanly into two functional parts. 

Filtering out the diagonals threatened by this queen is a hell of a lot simpler than your . Note that it also contains an infinite list of numbers (1 to infinity) but laziness means it doesn't crash. I'll save comments on idiom/style in your code for a separate answer. This answer is to explain why the whole approach is not Haskellish. Laziness for the win. 

splitParameters Same as the other two, but multiple recursive applications of is even more expensive. This can be rewritten safely as 

You perform a series of maps. Each one creates a complete new collection before the next is applied. If the first line is poorly formatted and there are 20000 lines in the file, your first will all 20000 lines before crashing when it cannot parse that first line. Worse, if the first line is "1/0", which is well formatted but not a valid , the code will split 20000 lines, then parse 20000 s and only then halt on the first invalid input. The solution is to start with . A view is a lazy version of the collection. If you apply a transformation (e.g or ), what you receive is not a transformed collection but a new view with all the original items, each of which will not be transformed until you access it. If you apply a second transformation, you receive yet another view, still with the original items but now with with two transformations which will be applied in sequence (in other words, they have been composed into a new function) to each item as you access it. And so on. So if we change your code to 

In Java, the way to represent things which are essentially the same, only with different details, is though classes. Imagind a class which contains a field (a String) and a field (a object - an instance of the class). Imagine a class, which contains a field (a collection of strings),a way of printing the description (calling on each collection element in turn) and a collection of . The has a method which 

Basic problems with input Your code will blow up if there are fewer than two fractions in the input. Even @janos's solution (which can cope with only one fraction) fails if there are no fractions in the input. Is that reasonable, especially given that the sum of no numbers at all is 0? Your code also fails on any badly formatted input but there's enough else to talk about to leave that for another day. Style apply method It's common practice in Scala, with types like your , to add an method to dispense with the need for . It can be added directly to the class or in a companion object.