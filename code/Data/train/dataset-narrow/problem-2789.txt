This angle is the angle of the velocity vector that needs to be added. The amount of force that is applied depends on the distance. To be exact it decreases by the square of the distance. So if something is twice as far away only a fourth of force is applied. For the distance the deltas are required too. 

If you really want to make it possible to the player to influence the jump height, you can use a initial impulse and make the influence on it less than gravity. 

Make sure that the paths are case-sensitive else you will run into problems with everything not windows. 

Until now I used a list of objects sorted by a single axis for limiting the amount of objects that collisions are checked against. The idea is simple: if the x coordinate of two objects differs by more than their width it is plain impossible that they collide. So if I want to know all possible objects inside a specific rectangle I just need to check those that are inside the indices of the smallest possible and the biggest possible x value. Now recently I have learned about Morton Code as a way of reducing multiple axes into a single value that preserves locality. However the implications for it aren't 100% clear to me. Can I determine something like "all objects with a morton code smaller than varA or bigger than varB can't possibly be inside rectangle A"? If so how do I determine these values? 

Make a vertex attribute "vec4 Color", and multiply the color you get from the texture sampler with the Color vertex attribute. 

Yes, isometric maps are just rendered differently. For the game logic it makes no difference what kind of angle the coordinates have. Isometric rendering is similar to the rendering of square tiles, the difference is just how the tiles are aligned (how the drawing position is calculated). Instead of drawing tile x,y at 

A material is a combination of attributes which describe how a surface of the given material should look like. Some engines use different shaders for different materials, in which case a material definition could look like this: 

Edit: But Beast, I don't want the player to know the result of the throw before hand! In that case you'll need to negotiate a secret every time you want to make a throw. This could look like this. Peer A: I want to roll a dice for Action and need a RNG Seed for that. Peer A: The checksum of my part of the seed will be 459023. Peer B: The checksum of my part of the seed will be 390564. Peer A: My part of the seed is 38000. Peer B: My part of the seed is 76000. The checksum is needed to enforce that the seed is generated before the peer has received the other seed. Now you can generate the actual value of the negotinated seed by doing some simple math, such as (38000 + 76000) / 2. 

After you have defined a progression like that by hand or procedurally you can calculate the waves in between, for example Wave 3 would be a few more small mobs and a single special mob. 

You are witnessing the "Key Repeat" feature. It's common to repeat the key press if it is hold for a longer amount of time. You can disable it with SDL_EnableKeyRepeat. 

There aren't that many essential features for a game engine. It all depends on for what kind of game the engine is. Well, the few features pretty much any 2D engine needs: 

I would avoid any physical rewards since they cost you money and time and there isn't that much interest in those. 

Seperate Axis Theorem The Seperate Axis Theorem says "If we can find a axis on which two convex shapes don't intersect then the two shapes are not intersecting" or more practicable for IT: "Two convex shapes only intersect if they intersect on all possible axes." For axis aligned rectangles there are exactly 2 possible axes: x and y. But the theorem isn't limited to rectangles, it can applied to any convex shape by just adding the other axes on which the shapes could intersect. For more details on the topic check out this tutorial by the developer of N: $URL$ Implemented it looks like this: 

Then you can simply change gameSpeed to speed up (>1) or slow down time (<1). For the player to move at different speed just check wheter the time is slowed down or not. 

The Fix your timestep article is about physics, not graphics, for the most predictable result you'll need a fixed timestep, but for the smoothest animation you'll need to use delta time directly. Realistically, just enable VSync, there isn't really much of a downside. You don't spend your time calculating something you don't need in the end and you get a constant frame-rate. 

Though, it would be better if you just store the parameters alongside with the transformation and just read out that information when needed. 

I think the reasons for this are of a much simpler nature: letting the player know how much longer they need to survive and allowing them to react accordingly. For example you know that the next wave is the last wave which will be harder than the previous ones so you pay extra attention towards improving your defenses. Unless you are making a horror game it is never good to leave the player in the dark about what awaits him. Else it can be a source of frustration, and frustration is not good. The player might think the game is unfair and stop playing it. 

Initialize the render target with black and draw those sprites onto it with Maximum or Additive blending. In pass 3 you combine the two prior passes. There are multiple different ways how they can be combined. But the simplest and least artsy method is to blend them together via Multiply. This would look like this: 

Usually you want to use a list if you want your object list sorted in a different way than chronocially and thus have to insert new objects rather then append, a deque otherwise. A deque has increased flexiblity over a vector but doesn't really have much of a downside. If you have really a lot entities you should take a look at Space Partitioning. 

Pre-Alpha is the version before the Alpha version, Alpha is the version before the Beta version, Beta is the version before the Gamma version, Release Candidate is the version just before the release. It's basically just to denote "this version is not supposed to be completely satisfactory and may contain heavy bugs or may even be completely broken". What the different notions mean exactly differs from developer to developer. 

Sound back-ends usually use threads to make sure that the sound/music is played continuously and not interrupted or distorted when larger calculations are done. However you won't need to deal with those yourself, as they are implemented by the backend, for example OpenAL. There is one additional issue that can be solved via threads, namely the streaming of the music from the hard disk, this however, isn't as time critical as the playing of the sound itself and mostly depends on how much you buffer, if you buffer multiple seconds at a time and have a recuring loop such as the game loop a dedicated thread should not be necessary. 

This is kinda backward. Conflict is necessary to build up tension, tension is required to make a compelling story. Violence is the easiest form of conflict. Most games try to tell a story and violence is the easiest way to archive that. You don't need to tell a story to make a game (a good story adds a lot the atmosphere though). The core component of a game still is the game-play. And the game-play rarely "needs" violence. For example a shooter could also be about a guy running through a parcour where he needs to hit all the targets once. Your game should be fun with or without violence, so think about that first and then think about violence. Not the other way arround. 

However note that you probably will need a dependency on the world sooner or later, that is whenever you need functionality of the World: you want to know where the nearest enemy is? You want to know how far the next ledge is away? Dependency it is. 

The map is a grid, where the spacing of the grid is specified as the map.tilewidth and map.tileheight. Now tiles can be bigger (also smalller, but that doesn't make much sense) than the grid spacing. If the map has a tilesize of 64x64 for example there could be tiles with a size of 128x128 or 64x128. This is useful when you want to overlap the tiles. If no offset is specified these will be drawn from the bottom left corner, this is fine for rectangular tilemaps, but for isometric tiles you are often required to apply a offset. 

The OpenGL setup is rather straightforward under linux, in comparison to windows. If you link to -lGL you will dynamically link to whatever OpenGL library is installed and should be used, so under a X11-Environment with nvidia driver it will link to the NVidia specific libgl, with a ATI driver to the ATI specific libgl, the OpenGL libs of the different vendors have all a compatible ABI, so nothing is needed to be done from your side there. For the headers you can use the Mesa headers, or any other generic OpenGL header, as said the ABI of the different libraries is compatible so you can use any headers with them. You don't need to load the pointers to the functions either, though it could be useful so that your application works on both Windows and Linux the same. Generally you just need to make sure that the header you use defines the needed functions. (They can be linked directly under Linux.) If you want to link the newest version of OpenGL instead of getting the function pointers you'll find the newest headers on the OpenGL website: $URL$ About the context creation I have no clue but I would recommend to use GLFW for it, it is really not necessary to communicate with the native platform directly. That way you can even use the same code for both Windows and Linux. 

I would suggest using alpha blended textures instead, as simpler alternative. The texture would then look like this, and instead of triangulating it you just draw one textured quad with it: 

But Beast, how does that help?! A dice roll isn't deterministic! No, that is wrong. Random numbers as we use them in games aren't actually random, they are pseudo random. If the state of the RNG is the same the result will also be the same. So if your game is synchronous then you just need to make sure that both clients use exactly the same seed at the start of the session. 

First of all you need to use more, smaller texture atlases. The less textures you have the more difficult and rigid memory management will be. I would suggest a atlas size of 1024, in which case you would have 128 textures instead of 2, or 2048 in which case you would have 32 textures, which you could load and unload as needed. Most games do this resource management by having level boundaries, while a loading screen is displayed all resources that aren't needed anymore in the next level get unloaded and resources that are needed get loaded. Another option is On-Demand loading, which become necessary if level boundaries are unwanted or even a single level is too big to fit into memory. In this case the game will be trying to predict what the player will see in the future and load that in the background. (For example: stuff that is currently 2 screens away from the player.) At the same time things that weren't used anymore for a longer time will get unloaded. There is one issue however, what happens when something unexpected happened that the game wasn't able to foresee? 

No it isn't, changing the game data is called modding, which is a common practice and often seen as positive effect. It's actually good to keep the game data as transparent as possible, and editing it as hassle-free as possible. Even more so if you are choosing more "advanced" players as your target audience. The reason why you won't find many AAA-games that use a plain folder structure for their data is that they use custom optimized archive formats to get improved loading times. The downside is the decreased transparency and the additional required tools in the toolchain. However, for smaller, or 2D, games these two things are usually more worth than the improved loading time. Just make sure that what the people see is not just a huge mess :) put the files into a proper folder structure. 

In pass 1 you draw all the sprites and the terrain. In pass 2 you draw a second group of sprites which are the light sources. They should look similar to this: 

Since you use a completly synchronized approach to networking you need to use a constant delta for the physics calculations, else a similar outcome is not guaranteed. Something like this: 

The kind of physics you have described in the question can be handled by the world if you expose the velocity of the entities: 

It doesn't matter whether it is part of another game or not, but due to the small size it is usually not worth to release it stand-alone and very well suited to be used as such. 

The "canceling" you described earlier should work, just you need to separate the movement between the axes and check both seperatedly. E.g. a collision on the X-axis shouldn't cancel the movement on the Y-axis and vice versa. This also applies to the bouncing, hitting a wall should just invert the movement on the X-axis and not affect the movement on the Y-axis at all. 

I have little experience about this topic but by logic and knowledge I can give a few pointers that might be worth a few pennies. First of all: those two markets are big, I mean really big, maybe, just maybe, too big for you. This is good as you have a large target audience, but the size already has attracted many many many (you are not the only one, no) game developers, this market is largely saturated. Most games won't even be recognized due to the sheer number of games there are. You won't make a penny this way, at best you will get a balance of 0. You'll need a better plan than just making a game and selling it. 

The problem you are facing is that you can't simply "tint" the whole image, the appearance you see is more than just a base color. For one you have fine gradients from one one material to the other, but more importantly you also have reflections,highlights and shadows, which are not influenced by the base color. (Those are basically added on top of it.) So you need to decompose the image into it's components. A Example: 

Dividing a vector by it's length is called "normalization". Normalizing a vector gives you a so called "unit" or "direction" vector that points into the same direction but whose length is exactly 1. So for example 17, 0 normalized is 1, 0. And 0, 5.32 normalized would be 0, 1. And 4, 4 normalized would be 1/sqrt(2), 1/sqrt(2) e.g. 0.703, 0.703. Since the length is 1 you can just multiply it with any scalar to get a vector of that length. So even more simplified it would be: 

In a basic multiplayer game cheating in the kind of Cheat-Engine simply won't work. The clients are only sending the data and the actions you designed it do to. Usually thats not much more than what the player "did", e.g. in what direction he is running, if he is shooting and so on. So the changes he does to the memory will only affect his own game, but the other players will see no change, a so called desync. Most games detect desyncs like that and remove the desynced player from the game. Now there are also other ways of cheating, but those are all about how your game is designed. To protect from the easiest hacks, which is faking network messages, the server should check those package for their sanity. "That guy just jumped 5 screens? Thats impossible, deny package." (Note that you can also go the fully synchronized route -that means everything is synchronized and only "What buttons did the player press."-kind of messages are send- which makes faking network messages useless by design.) The last way of cheating in multiplayer are visiblity hacks, thats modifying the client so that it shows data to the player which he doesn't know. Examples for this are not showing the fog of war, being able to look through walls, displaying a minimap or other things. These are impossible to prevent. 

Let's not over-complicate this. This is not a "perfect" solution but should work for most games and any imperfection should be invisible to the player. 

Axes can be as represented as normalized vectors. A range is a 1-Dimensional line. The start should be set to the smallest projected point, the end to the largest projected point. Applying it to the "sweeped" Rectangle The hexagon in the question is produced by "sweeping" the AABB of the object. Sweeping adds exactly one possible collision axis to any shape: the movement vector.