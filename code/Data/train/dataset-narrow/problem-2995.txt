Lots of things you can do via role-play, e.g. simulations of how a processor works, how the internet work, how e-mail works etc, but also playing through some scenarios or dilemmas in online safety. Plenty of scope for debating broader moral and ethical issues around CS, including AI: What should Audi's programmers and managers have done? Should end-to-end encryption be available? What rules should a self-driving car be programmed to follow? 20 questions, or something simpler such as guess my number? Lots of fun with hand-drawn graphs, e.g. minimal spanning trees, shortest paths or the travelling salesman problem. 

We're introducing some aspects of parallel processing quite early on in Scratch. Each sprite has its own script which appears to execute in parallel with those of the others. Scratch has a broadcast and receive message protocol, and support for shared as well as private variables and lists. Children might encounter this in a maze game, perhaps programming a number of similar ghosts to chase the player's avatar. It's also useful for agent-based modelling, e.g. the spread of an epidemic through a population. Of course, it's not true multi-threading, as all of Scratch runs inside Flash, inside the browser, on just the one core, but I doubt those using Scratch will be aware of, or care about, the distinction. This does, though, lead to potential difficulties in 'graduating' from Scratch to a text-based language such as Python - young Scratchers who've been used to programming in parallel in Scratch can find it hard to adjust to doing just one thing at a time in introductory Python programming. 

Although you may think mine is a less than serious answer, the best example I have seen for the use of a smart-board in computer science is in a video from De Pauw University, when they implement a time machine to explain program code debugging. I just love it, and show it to my students every year! 

My attitude to this question (which I have often been asked) is radically different to the other answers. I've been involved in recruitment and selection of students for Computer Science degree programs for over 30 years (in one way and another). Parents, potential applicants and their teachers often ask "what feature of an applicants profile indicates their potential..?", which is quite similar to your question. They expect me to say something about their coding skills, or even computer gaming aptitude. No; we rarely look at that. To me there are other very good indicators of a mind set that is successful at Computing and will enjoy it. The classic indicator is Mathematics, but on its own it is a poor discriminator. I found that better indicators were musicianship and modern languages. Being fluent at more than one language and having skills at sight reading music and playing that instrument with others can be an indicator that they may excel at Computing. This combined with enjoying the structure of non-computer games (board games or Role-Playing) also are positive signs. As also noted, puzzle and problem solving is also a good sign. Why do I think this is so? It is the issue of reading a coded notation at speed, as one does in music, develops the mind to handle computer code as another form of instruction notation. The combining this with manual dexterity, as in performance also helps. Understanding that the music notation expresses the communication of the desire from one human to another is so similar to the function of computer code. This analogue also applies to other modern languages; someone who has to translate between languages appreciates the difficulty in expressing meaning in a different notation for others to act on. Why non-computer games? It is because of the reading and understanding of the rules that is required to understand the play. If they can absorb and mentally model the multi-tome rule sets to some of these games then they can read and mentally model large enough chunks of computer code to be successful. I could add more detailed analysis, but I will leave it at that for now. 

A variant on the usual random drill and practice test would be to pre-populate with the questions and answers, then remove question and answer from each as they get answered correctly, allowing players to get more practice on the questions they get wrong. Here's an example for times tables. You could try something for an adventure game, building up an inventory of items collected in a list. Another possibility would be an adaptive 20 questions style game, adding additional questions into a database (of sorts) as the player gets to the end of a branch of the tree. 

Any programming is a two step process: deciding how to solve the problem, then implementing that as code on a particular system: choosing or designing an algorithm is the first step. There are great ways to illustrate how the choice of algorithm matters. An introductory one might be search - comparing random, linear and binary algorithms to, for example, find a missing number, or a word in a (printed) dictionary, or a book in a (physical) library. Another might be exploring different sorting algorithms, for example bubble sort and quicksort using this CS Unplugged activity. Mathematics provides a rich source of contexts, for example asking students to think of an algorithm for finding the greatest common divisor (i.e. highest common factor) for a couple of numbers. Have them try their algorithms out on paper before coding them and then testing with some big test numbers. 

I have been responsible for using performing and evaluating tools for detecting software plagiarism in my academic department. There are several published review articles in the scholarly journals. One such report Culwin, MacLeod & Lancaster, 2001, UK JISC, "Source Code Plagiarism in UK HE Computing Schools, Issues, Attitudes and Tools" gives an overview. Basically, there are published algorithms and methodologies you could implement yourself, open source software you can run locally, or an internet based service you can register and use. One such tool that you can run locally is JPLAG from the University of Karlsruhe in Germany. This has several language syntax implemented, and as it is open source you can amend as desired. The best online tool is MOSS from Stanford which is the one I ended up using. If you wanted to research the various published techniques for detection, Google Scholar is a good source. 

Some interesting projects for those working with block-based languages (such as Scratch, Snap! and Blockly): For Scratch, check out Dr Scratch, which takes a rubric approach to evaluating how much 'computational thinking' is evidenced by a project. Whilst the analysis might seem a bit reductive, it can be used independently by learners and includes some useful guidance on how to progress. The developers describe their approach in this paper. Dr Scratch is built on Hairball, a Python module which does static analysis of Scratch projects. A more conventional autograder, lambda, is being developed by Michael Ball for Snap! It's already integrated into UCB's Beauty and Joy of Computing MOOC, and I think there are plans to make this more widely available. Michael wrote about this for Hello World #3. Chris Roffey has developed an autograder for Blockly used in the initial round of the TCS Oxford Computing Challenge programming challenge, although I don't think the code for this is shared publicly. 

Although there are many good answers, some aspects of this problem have been overlooked. There are other categories of students who put too much effort in memorising every detail, and they could not be classified as overmotivated. I have professional experience of working with both groups. The first you should consider are those on the Autistic Spectrum. I find that in Computer Science this group is often more highly representative than in other academic subject areas. Students on the Autistic Spectrum would have difficulty separating relevant facts and details from the minutiae. They may also have a degree of obsessive interest in the detail of the subject and memorise detail for its own sake. Another group of students who may do this are those that are completely lost or disengaged. They may not have been paying attention in class and their solution to getting grades is to mindlessly try to store everything by rote, without regard to its relevance or purpose. My anecdote on this comes from when I taught a course on computer programming for Arts and Social Science students. Very few of them wanted to be there; the class was large (many hundreds), but passing credits was a requirement of their degree program. In order to reach out to them I used many paradigms of programming that I felt they could relate to. I explained that programs were like cooking recipes or knitting patterns. To illustrate this my slides (and notes) including cuttings from recipes and knitting patterns I picked up at home. The result was that many students memorised both the recipe and knitting pattern, but still could not explain what a computer program actually was. I still grin at it today, as the recipe was Ken Hom's Chicken in Paper. I still wonder why they thought that memorising that would help them pass the computing paper. If you do not have experience in recognising or teaching students on the Autistic Spectrum but you teach computer science, I think you would find further reading or training in this area may be helpful to you. 

When we were drafting the English national curriculum, we found it easier to think in terms of the foundations, applications and implications of computing, all three of which really should be included in any broad and balanced approach to the subject. You can map these to computer science, IT and digital literacy if you wish, although you would need to accept a rather broader definition of digital literacy than that used by the Royal Society Foundations would be about the underpinning principles of computer science (logic, algorithms, data representation, abstraction), as well as their practical expression through programming and more generally in computational thinking. Applications is about skills in using digital technology to get useful work done, including collecting, managing, analysing and communicating data and information and creative work in a range of digital media. Implications is about a critical understanding of the impact of digital technology on individuals and society as well safe, responsible and ethical use. I'd include intellectual property, privacy and security here too. I've an illustration of all three in response to the question 'How does Google work?' Foundations: big data, Page Rank, Big Table / the Google File System (GFS) etc Applications: type your query, click the button (well, these days it starts searching as you type), but also filtering results, advanced queries etc Implications: profile, filter bubbles, advertising, smart creatives, separating costs and revenues for accounting purposes etc 

Although other answers have mentioned aspects of testing language skills for non-native speakers and other reasons why language focussed questions cause problems I felt the case for students with alternate needs in Computer Science specifically needs addressing. I have much experience in working with and teaching Computer Science to students with various alternate needs. In my experience students with dyslexia, dyspraxia and other specific learning disabilities are not uncommon in computer science classes. I could go even further and say they are quite common in computer science classes. I expect to find that as many as 20% of an undergraduate computer science class has these characteristics, even if they have not been diagnosed. Dyslexia is a condition where language cognition is lagging behind other measures of intelligence and cognition. In other words these are very capable and bright students who have physical conditions that impair their processing of language. To discriminate against some of the best students in a class and artificially inhibit their progress because of a condition they were born with seems bade educational practice. You should certainly reflect on your testing methodologies. Learning vocabulary and technical terms is an important part of learning but it has to be assessed in an appropriate and non-discriminatory way.