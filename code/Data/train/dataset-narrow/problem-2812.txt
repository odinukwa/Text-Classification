DisplayBox.SetValue is a function which goes through and sets the texture. This is working! DrawIsoCube() draws the cube (the test model) and this is working too. The problem is definitely something to do with the unreusability of the render target. Pretty simple yet it's not working. It appears that whatever the last image being rendered is, is shown in every image of the allBlockIso array. Anyone know a fix? Cheers. P.S. sorry if this wan't explained well. I'm not very good at explaining :P 

So after a bit of mucking around i sat down and took a different approach to the problem. Now I have it all working, and have put loads of comments in so hopefully anyone else with the problem will be able to use this as well. The only things that need to be changed to put into your own project, is: filedOfView, minZ, maxZ, minX, maxX and groundElevation. 

See the Railing? It should be at the front, but it's covered by the top of the platform. Also, on the side, the shadowed area should be practically hidden from that front wall... Other bits are around the place too if you just look at it... :( I tried the 3 different cull modes, none of them fixed it, so i don't think its the culling (in fact Clockwise made it worse... :P). Thanks for any help. 

Ended up using the example on the site. Realized i was using it wrong and should have used it more like a library. 

Is there any way to have the texture of a model loaded from a Png ? I have a simple prism to test it on, but i just want to be able to edit an image and have the model's texture change. Thanks! 

If a saved game is loaded, the game save object reads this list again and initializes its internal structure with it (the hashtable or sorted array). To indicate the length of the list, you may either store an additional int value in front, that tells the code how the long the list will be or you can terminate the list, e.g. by adding a final entry of objectID to it, where is reserved value (no real object in your game has this ID) and thus indicates the end of the list. Of course not every aspect of your game may be savable that way, so a save game file may contain more information before or after the object state list. E.g. you may want to store how much rubies/bombs your character currently has, which other special item he posses, and so on. On the other hand, you could store all this to the list as well, using special reserved objectIDs. E.g. real objects start with objectIDs from 1000 upwards. If 0 is reserved, this gives 999 special object IDs. objectID 1 could store the amount of rubies, objectID 2 the amount of bombs, objectID 3 the kind of sword the player owns (in that case different values will indicate different swords; IIRC you could only have one sword at a time in TLOZ). I admit that this is a very simply approach, but simple is usually good (think of the KISS principle). It should also be no problem to make this whole think very performant. Choosing the right data structure, adding to the list, searching the list and reading/writing the list from/to disk should be very fast, even on the slowest iPhone it should happen in no time. E.g. you can store everything in a , keys are of type with the objectIDs and values are with the state information. Such a dictionary cannot be stored to disk directly (only dictionaries whose keys are can be stored to disk with a couple of simple function calls), but iterating over a is really trivial. Just add all those 32 Bit values to a and this one can be saved to disk with a single method call. Loading is the other way round, read the whole file into a (single method call again), iterate over the list and keep adding the keys and values to a . Should be piece of cake. I guess the original save format was somewhat similar to such a list, yet as the NES only had a 8-Bit CPU, I guess the values where only 8 Bit (that's why you could not have more than 255 rubies) and the objectIDs probably 16 Bit (16 Bit doesn't fit into the registers of a 8 Bit CPU, but just like 32 Bit CPUs can handle 64 Bit values, 8 Bit CPUs can handle 16 Bit values, it's just slower as multiple operations are required for everything that only requires a single operation for 8 Bit values). UPDATE Since I think this is a cool project, I wrote some sample code to give you starting point, in case you decide to go that route. This would go into : 

Basically i am trying to render a model yet it seems to draw polygons that should be behind something, in front of it. So i end up seeing some faces that should be behind something, totally covering it. Bah, i suck at explaining so here's the pic: 

which disables a second shot from firing, as your game so far only works with one bullet (without this code, the 'old' bullet would disappear and the 'new' bullet would appear). Instead, try implementing an array to hold new bullets, instead of limiting yourself to only one. (Though you may want to implement a cooldown on firing, otherwise space could be held for an extremely rapid fire) EDIT: Quite a few changes to the code had to be made... As i havn't used javascript or HTML5 before, i couldn't really test all of this, though it should be fine. I commented out lines of code instead of deleting them, and tried to point out where i modified stuff. 

Looking at websites such as mixamo.com or some game's development systems such as the animation editor for Overgrowth ($URL$ i see that the skeleton in these situations is automatically being applied to the models. I really don't expect (though wouldn't mind) code that does this, but i really am looking for some sort of pointer in the direction, or how they go about this. If any of you have done this, or know how to, please do reply, i don't want to spend the next week trying to crack it, then another to actually code it :P Thanks all :) Just for a bit more information, i am in C# working with OpenTK with my own custom model loader, etc. but i can easily adjust any given code / concept to fit with mine :) 

Unity supports only , and for scripting. However as Philipp mentioned, if you know Java then you know 90% of C#. I still know only Java and C++ and its easier for me to translate my logic into C# (Given that I didn't know much about C# even after coding for a year in Unity). You can however write plugins in Java for any native feature not provided by Unity or to implement some third party SDK such as ads made specifically for Android platform. Same is true for Objective-C for iOS platform. 

I am not sure where are you calling your method, so I can give you a generalized solution on this. You'll definitely need a second condition before you choose to increment the level count. One way would be to have a boolean field which'll be true as soon as you increase the variable. Check it as another condition in your statement and if the level increases then make it false, so that level doesn't get increased before next increment of . Code snippet 1: 

Google Play Gaming Services are free and doesn't have any limit for any number of concurrent users. The aim of the service is to provide tools at par with Apple's GameCenter. Since GameCenter is free, GPG service is free too. PS: Doesn't this question belong on SO? Just asking. 

I am not sure what would be the more accepted definition, but I and the folks at my previous company considered "any game which looks like isometric 3D, but is rendered via 2D sprites" to be 2.5D. Now let me explain why we did that. Generally rendering a 3D world with a lot of objects in it will create too much pressure on the processing, lowering the FPS count. So to overcome this we generally created objects in 3D rendering software like Maya and rendered them as sprites. Which can be used in the game. Not to mention that the angle were considered while rendering. So to speak about this tech with publisher we normally used this term. A 3D world which looks like it's a 2D world is still technically 3D for us. So we generally didn't use the term for this method. I thought I should share my bit here. 

OK been googling nonstop for ages... My problem is, i need transparent models in my game. After a lot of annoying fiddling around with my code, i changed the blendstate to alphablend. This allowed me to start having transparency in my models. However now i face another problem. Any other part of the same model that is meant to be view THROUGH the transparent part of the model, is not shown. Basically it is only showing the outermost part of the model, even though an inner part is meant to be seen through the transparent part. Any help? Thanks 

I made an isometric game in flash once. Never finished it (unreliable artist) but for me, sorting was simply a matter of organizing according to y coordinate. The further down on your screen the block is, the closer to the top layer it should be. Your character, for example, in the stuffed up picture. The Y coordinate of his foot is greater than the y coordinate of the block that overlaps him. Therefore, he should be in front of it, not behind. Then if you start having multiple layers in your world, each individual layer of the world is sorted individually. Then drawn bottom upwards. Just comment if you need more/better explaining 

For balancing mechanics, Grab some friends, and do it manually, the fun way. If your game is good i doubt they would disagree, just spend a weekend playing your MMO for a bit. This should help get the basics out of things like whether bleeding needs a nurf or buff, whether being crippled needs to slow down a character more or less, etc. For balancing moves and such, try a beta, open or closed and give players the chance to give feedback. Given the fact that your balancing is for the players, maybe players should have a say in the balancing? I know this isn't about documentation, but it is still THE BEST option out. Or i could save my answer by saying "Documents from players beat general guideline documents". 

I would also go for the ID solution. You should give every object in your whole world (not just on the current map) a unique ID. A 32 Bit int should be sufficient. Further every object can store a state value, also a 32 Bit int value. You can squeeze a lot of information into 32 Bit, e.g. you can make 32 flags out of it to store 32 bool values. Or you can use the higher bits for flags and the lower bits to hold a numeric value. For something as simple as a treasure, you only need to store a bool, where a value of 1 means opened and a value of 0 means closed. The you have a game save object with two methods: 

You only need to know which rooms the player has already visited and if he has the compass for this dungeon or not. Easy. Each room of of each dungeon has an objectID with a boolean state, that is 1 if the player has visited the room, 0 otherwise. Same goes for the compass, the compass of each dungeon has a boolean state. Same goes for doors in the dungeons (which may have been opened or not) and "crack-walls" (which may have been bombed or not), each one has a unique ID and a boolean state. All information of this game can be stored in this one simple list... it's pretty amazing, don't you think :-D Here is a very cool web page that has detailed maps of all dungeons of TLOZ, as well as an overview map of the whole overwold. Including information where specific items can be found (including secrets). Also check out the "Interactive Overwold Map", which allows you to navigate a 3 by 3 screens map and show/hide secrets and tips, including the insides of all secret caves. Basically this page contains all the information necessary to make an exact copy of the game, pixel for pixel you like. The game logic is rather simple and the whole game will tun out to need much less code than one might expect. I guess the most time consuming task is setting up all the maps of the game, defining all the object IDs and so. Doing all this "in code" is probably a rather bad idea. I would think of a format that your code can parse, e.g. XML or JSON or maybe something as simple as structured ASCII text. Each map has a fixed number of "fields", so you could store each map as X by X values, where each value defines the content of the field: a tree, water, a coast line and which coast line, rocks and which rocks, a wall and which wall, an enemy and which enemy and into what direction it is looking (most enemies cannot look at a direction, thus you could treat the looking ones simply as different enemies, there are only 4 directions they can look at after all). Values below a certain value represent static objects, those are always the same when you enter the screen, all other values represents dynamic objects (those that store their state) and the number is split into two parts, one part is directly the object ID of the object, the other part the type of object. E.g. dynamic objects have the highest bit set, the next 7 bits define the object type (allows 127 types, e.g. 1 is a door) and the last 24 bits are directly the object ID (allows up to 16.7 Mio objects, you won't need that many), however keep in mind that values below 1000 are reserved as special values. Since creating levels is often the most time consuming task, you may want to speed the process up and instead of starting by writing the game code, you start by writing a level editor for your PC/Mac. This seems like a waste of time, since it will take a lot of time, but trust me, it DOES pay off. Most professional games started by writing at least a simple level editor. It makes creating levels a very easy task (drag'n drop an object where you want it to be, give it an object ID if required, done). So not only it speed up the level creation process dramatically in the end, you cannot test your game code unless you have level data for testing it, since untested code is worthless code. And if you only created dummy level in the beginning, an editor allows you to quickly create them and also quickly change them to test certain aspects of your code. Now go out and have fun young jedi. I wish plenty of luck with this project. Update 2 If you'd like to use all the original artworks in your project, I found them online. Have a look at this page. It contains all the sprites used in the game. Even the original font. Just thought this might be useful for you.