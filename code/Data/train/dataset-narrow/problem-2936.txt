First up, the logistics. I had a detailed discussion with the HOD and also with the students, and convinced all of them to come for additional classes (I called them Bootcamps) The Bootcamp was a 2 day affair ( 6 hours each ) and was held on a holiday. No attendance or anything like that. Students who are serious can come (and 80 % of the class showed up) Taught the basics of OOPS. I essentially summarised the entire semester worth of contents into 12 hours. 

A quick online search led me to this. A Beginner's Guide to Access Technology for Blind Students It covers all the essentials 

We don't have Scheme in our entire country (here in India) but that honour goes to C programming language. For the purpose of my answer, substituting C for Scheme, I keep asking myself, why bother with C. After that 1 semester of C, I have never used C professionally anywhere. In fact, once I step out of educational purposes, C becomes useless. That begs the question, after almost 25 years, why are they still teaching C? Why not something else? I think, why they are still teaching C (in my country) and Scheme (in yours) is probably because it is ubiquitous. there are any number of books written on C. More importantly, the faculties who teach them ( I think most faculties change their jobs once in 60 years) can teach the same thing for the rest of their lives, use the same lab manual, and use the same code, and ask the same questions, use the same evaluations. From a strictly logistical point of view, it makes sense to teach C 30 years ago, and 30 years hence. Can you image the mess, if every five years, the universities change their syllabus? Thats a logistical nightmare (not to forget other challenges) no one wants to deal with. For instance, one university could decide to go with C sharp, and another with Java. That creates all kind of problems. However, if all universities agree (which is how things are now) to simply keep using Scheme (in your case) and C (in my case), life becomes simple. Further, the foundation that you get by learning an ancient language is that, everything that came after it, be default, would be easier. I learnt to ride a bike (as in motorcycle, not bicycle) in my dads old bike which was, well not that good. However, because I drove the tough one, all of today's bikes seem like child's play. Although I don't use C itself, anytime I learn a new language, I unconsciously compare it to C, and learn from that. Update 1 : To add some context, I have been part of the IT industry for 11 years, and 5 of them as a developer/trainer/educator who travels widely. I am sure C is used somewhere, I haven't seen one single enterprise usage of C and I have worked for startups, small companies (less than 100 employees) and for MNCs (more than 2000 employees) and never ever has any division, anywhere talked about C, used C or implemented C. Again, no disrespect to C (or its legion of fans) but I request that my opinion be taken in this context. 

I've been in groups before, and multiple people were supposed to code. It was a system where you had to be on the same computer for it to work. It fairly well approximated pair programming - we were discussing out loud, and one person was watching the other giving suggestions, and the other was coding. The people in the group that I was mostly working with weren't annoying, and a couple were semi-friends. It was terrible. I'd programmed before the class and the other student hadn't, so I was a bit better. That made it even harder, because the other student was less likely to, say, use a function, or make some aspect simpler, or whatever - so I felt like I was taking over too much to fix something, or suggest a better solution, and I ended up doing more of the coding. There was a time limit, obviously, so since I was faster at coding (and I also could keyboard, whereas the other student couldn't), the other student often was like, "hey, we need to get this done, you obviously know how to do it - just do it". The teacher stepped in and put the other student at the keyboard, but since a. the other student couldn't keyboard, (just pecked) and b. both of us now felt even more rushed, because the rest of the group had finished some of the mechanical aspects (we were in an engineering course creating a "elevator" type thing), the whole thing just got worse. 

Rely on intellisense. Lot of students, for reasons that defy logic, don't trust the intelligence. Me though, I insist my students to wait (it takes a few seconds, sometimes more depending on how fast the machine is) for the intelligence to prompt things. This guideline alone saves a truck load of syntax mistakes. 

I am preparing to teach Scheme now, so I need a good reference book. I like books which can dig deep, with none of the beginner level introduction stuff that some books like to spend time on. So, what is the best book to use as reference? Note : In line with my usual style, I would prefer books that are available in both dead tree and online editions, with the online edition having a higher priority. 

A few days ago, I asked a question if I should use F sharp to learn functional programming and the discussion eventually suggested that I take up Scheme. So, I visited the scheme site (which did not say much) and then I ended up at the MIT site. and I also read on the wikipedia that there are several implementations of scheme. So, the question is which implementation ( I have given a reference of MIT implementation above) should I use for my beginner class on Scheme. 

It appears that the student(s) in question don't really want to do what they are doing, but feel like they have to; this answer addresses that. Be sure to consider that maybe your student(s) just really want to learn the extra stuff, and don't block them from doing that. Emphasize the power of summary. In a world with the internet, no one needs to memorize every concept, but just understand the basics, or what to google when you need something. I can't tell you how many times I've looked up details on Stack Overflow, and then using that finished my program. Tell them that the important thing is to understand the big ideas, and be able to implement them. If they don't respond to that, try to spend a couple of days teaching completely without the book, and asking your students to not use it. Summarize up front, hand out notes with the points you want, and then let them go on the lab work. Tell them that the notes you have handed out are all they should need, along with occasionally googling something. If they are taking notes beyond that, tell them there's a problem. Hopefully that gives them an idea of what they need to do. Also - a textbook with every sentence highlighted doesn't point out the more important things - it's just annoying to read. Perhaps you can show a quick example - plain page, overhighlighted page, judiciously highlighted page - in a one-on-one with those students. 

Then, rinse and repeat the above so many times. It took me a while (a year or so) but eventually, I was ready to work in the industry. Now, years later, I switch between working as a developer and trainer, no problem. Since we are talking about transitions, I have found that while I still make a decent amount of money from training, development actually pays more. 

I learnt a lot (like kept hearing about it) about functional programming after coming to this community. I had heard of it before but was unaware of its importance. Then, I started including functional programming in my daily conversations with my students. Now, a couple of students (who are already familiar with dot net) are asking me if I can teach them functional programming. Given that I am a dot net guy, my mentor suggested that I try F sharp. The question is, is F sharp a good choice for learning functional programming? If not F sharp what are the alternatives. Note : Any alternatives that you suggest must have full support on windows as well as Mac. For example, F sharp works just fine on Visual Studio for Windows and Visual Studio for Mac. 

First, try setting up some sort of "coding hangout time" - you and her can practice coding together. You can help her when she gets stuck, and encourage her. It's always good to have a buddy in what you're doing =) Second, start with the right things. Try a little visual programming first, using hour of code programs, or a language like Python, which will teach good practice (indentation, etc) and remove worries like memory control, which make it harder for new learners. Third, start small. The classic hello world program in Python is literally . From there, maybe go to things like adding, or using variables. I particularly enjoy Codecademy's course - problems with instructions. And remind her that you'll be willing to help when you have time, and so will people on sites like stack exchange (Codecademy also has a forum, though I haven't really used it). To conclude - show, don't tell. Don't tell her she can code, show her she can code. 

I'm going to be quite honest. Why the heck do you care? Even if there was such a thing, you could never know if that student was truly in that category of unable, or if it just hadn't clicked for them yet. You could never know if you were biased, if the student had never learned how to learn, if something else was going on you didn't know about, if a previous teacher had mistaught them, if, if, if. Even if there was such a thing, it shouldn't impact your judgement. 

First up, I started my talking to some of the folks who are already working on large projects. I am talking folks who are in the industry for a few years. These experienced gave me knowledge about the kind of tools they use, programming languages they use and stuff like that. After that, I decided to build a 'project atmosphere' right at home. For instance, I was advised about using servers and databases extensively for every project. So, I used Azure to create my own IT department, and then consume all those IT resources in my applications. Another individual suggested that I become 'full stack' developer, so I learnt all the languages/components of dot net that are required to go from a project concept to delivery. then, I decided to fill the gaps in my own learning. For instance, I had realised that without even knowing, I had become extremely good at the basics of programming but throw an advance component, I would falter. So, I grabbed all the industry authored books (the ones aimed at working folks rather than students) and pretty much went through them, essentially relearning things. Finally, for practice of getting that 'team' feel, I had some of my students to act as my project members by create real but practice software projects. I would take upon on the role of the project manager or team lead, distribute the work load, conduct presentations, coordinate code over repositories and then deploy the whole thing myself. 

What is the best way to take notes when self-studying? I myself swing rather wildly between writing down everything and writing nothing. Obviously, neither is a good approach. I also have troubles with the neatness of my notes, especially because my handwriting isn't exactly pretty. What tips do you recommend for taking good, neat, understandable notes? 

The key is to just give whatever it is a whirl. Try, and see what happens. Quite a lot of code might be written, and most of it will break, but that's how you learn - you gain an experience of what methods work and what methods don't and fill out your figurative toolbox. First, figure out what the problem is. What are your goals? Is it just to build a working shell? Or must it be done in a certain language? Often, in school, the problems are defined for you, but in the real world, they often aren't. Figure out your parameters and what exactly a solution needs to be like to be a solution. This is much more important than you'd think. Unfortunately true anecdote: I was writing a program to solve a simple problem. But then I wanted to enhance it. And I wanted to do this and that, and oh, maybe I'll add that - and the code got super unwieldy, with more and more bugs that I needed to work out - and finally I thought about it and realized that most all the code in there was unnecessary for my purposes. I wasted multiple weeks on that project. Second, start breaking down the problem. With your shell, maybe you think, okay, I need a GUI, and I need a way for user input to 'act' as commands, and those commands to produce some sort of output. Here you should be of course check your requirements to make sure the "chunks" of your program can handle everything that needs to be done. Third, the exploratory google searches. I kid you not. When I first wanted to write a GUI, I googled "python GUI". And started reading. I found out tkinter was a common package used. So I googled "tkinter GUI". I learned what things that entailed, and I checked whether the method could do what I needed it to do. I explored some of the difficulties I might have. Make sure, for example, that the package you're using to create the GUI doesn't interfere with whatever things you might be using to get user input, or make it into commands for the computer, or show output, or whatever. Make sure it can handle all the things it needs to handle (check the requirements for this). Fourth, take the plunge and start writing code. Or solving the problem. Whatever. Follow your googlings and your goals and your requirements (those things are important) and your broken-down sections of the problem. When you run into errors, google. When you by chance hit on a better solution, rewrite. Debug and code and sketch out code and google and rethink your design and then tremble in awe at the finished product. Painful? Yes. Hard? Yes. Do you learn a lot? Oh, man, yes. 

Unless the student is some kind of an expert already, lines of code will be a easy way to filter out those who have no idea what they are doing. Lets say the lab manual has about 30 lines for the bubble sort implementation. Leaving out exceptionally talented students, most students would have at least 30 lines, and if they don't they probably haven't written the code. Its the same concept as in reports. Faculties will ask you to write 2 pages, but what if the content only merits 1 page or 4? Its just another way of valuation. 

I faced this issue, a few years ago, when I started taking on .NET development projects. For instance, I would run into a piece of code that I never really heard of, but I see that there would be a lot of chatter about it online forums/stack overflow and so on. The more I continue to work on the project, the more I realised that I simply did not know so many things aka gaps on what I have self-taught. At that point, I decided to go to the official docs of .NET (MSDN), read through the whole thing. Simultaneously, purchased the official Microsoft recommended books on dot net C sharp, and went through the entire book. When I was done with MSDN and the book, I had an entire list of things I had never even heard. One by one, I self-learned them as well, filling in the gaps. I had to do this many times (for windows phone, windows 10, web and so on) and each time, this method has worked to my benefit. 

Firstly, I would say that some things do come before content. Student safety and well being, for one. If you are so focused on content you can't see that a student is having serious problems (bullying, home life, etc) then that's no good. A student must be able to "ingest" the content being presented, and they can't really do that if they aren't well fed, feeling safe, tired, sad, "antsy" or feeling like moving (seriously - ever tried going from P.E. right into a test?), etc. So let's say that first step is fulfilled, and a student is able to pay attention. The next thing I'd say is presentation. This is the difference between plopping up the quadratic formula on the board in Algebra I and having every student write it in their notes and move on, and explaining it, perhaps with some examples, or whatever. In both cases, the students "get" the information, but unless they are devoted textbook readers and question-askers, I doubt they'd actually understand it and be able to use it. Of course, this doesn't necessarily mean just explaining it, this means keeping the student's attention, it means slideshows, videos, activities, demonstrations - things other than just the robot droning teacher. Then, practice. What use is information if it can't be used? Problems, labs, and so on, are just as important as the content itself. You can't have a presentation or a problem about nothing - there has to be some substance to it. But the content won't get through with the presentations and it won't be useful without the problems. But safety and well-being of the students comes above it all. Also, study strategies are important, and so are the prerequisites for the content. These are things, which, if the students don't understand, will make things a lot harder for them. There's probably also things I haven't thought of here - this was supposed to be a general overview and then got a little longer than I thought =) So: is content king? No, content alone cannot do much. It must be coupled with a student ready and able to learn, a good presentation, and practice to solidify the content and make it useful.