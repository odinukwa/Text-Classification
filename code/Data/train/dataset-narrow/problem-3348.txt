Those you will always use in any project you want. The 16 GB SD card is excellent for a Pi. I think 64 GB will make your Pi become slower. Remember the Pi is a mini-PC not a real desktop. The speed will always be a headache. Last thing to mention, always use a 2A 5V Adapter as the peripherals are current hungry. Sometimes if the peripherals don't get enough current, the Pi shuts down as a short-circuit protection. Hope I helped. 

Recently Raspberry Pi has some security concerns with WiFi Connection; don't know why; but there is always a solution for any problem. First of all type in your RPi terminal and look if your router is listed or not. If it is listed then great and you are nearly done with setting up your network. If not, then the problem is with your router itself not the RPi. Suppose it is listed, type and go to the bottom of this file and paste 

I read in the Raspberry Pi Official Documentation that you cannot preview the using and . The doc states: 

Always use a 2A, 5V Adapter. Peripherals are current hungry, so give it sufficient current. The Pi will automatically shut down when it can't get enough current as a protection for the Pi from getting burnt. Stick to the cheat sheet especially in step 12. Sometimes the Pi is unable to handle all the processor cores, and the make process fails to continue. 

As an electronics engineer, I can tell you that a 2A-5V adapter will not affect your Pi in a bad way. Imagine that the voltage is pressure and the current is a rope. If you increase the pressure; i.e voltage in this case; your Pi will be burnt. If the current is less than the required the rope will be stretched to its max and get cut. Fortunately, the Pi has short-circuit protection so when the rope is cut; i.e the current is insufficient; the Pi shuts down automatically to protect it from getting damaged. If you connect more than 2 USB dongles in the Pi, I recommend you use the 2A-5V adapter, as the peripherals are current hungry and will try to get sufficient current to operate, or as a result the Pi will shutdown automatically as I mentioned before. If you try to use the Pi with WindowsIoT with the 1A-5V power supply and 2 USB dongles are inserted in the Pi, it won't boot and you will get stuck in a reboot loop, and the SD card might get corrupt in this case. 

Those probes are almost certainly analog probes. The Raspberry Pi does not have any analog inputs so to read the values you will need some sort of Analog to Digital Converter(ADC) that you can connect to the RPi. You could build one, if you do I would suggest searching for an ADC that has an I2C interface. You could buy an add-on for the RPi like this one which should make things a bit simpler. Be aware that without the datasheet for the analog probe you will need to manually calibrate your the probe to properly map the analog value to a the temperature. 

Yes. You can use the ncurses menu library ($URL$ Which is actually what that python code uses to generate the menu. But making the menu in C will be more work and look exactly the same as the Python version. So unless you have a good reason to use C I would suggest sticking with Python. 

You could run PPP over the serial line. To do that you would first need a PPP server on the other computer and make sure the Raspberry Pi is not using the serial port for the console. Search for Linux PPP tutorials and you probably find what you need to get it working. 

In the second case you are mixing single and double quotes. I suggesting suing format strings instead of the format operator . 

There is no motor that you will be able to connect directly to the Raspberry Pi, so the best type would be determined by the robot's needs. That said, given the limited GPIO pins on the Raspberry Pi I would recommend getting a motor driver that can control many motors with minimal connections to the Raspberry Pi. For example this 16 channel I2C Servo Driver. There is a tutorial about using that board with the Raspberry Pi to control 16 servos. The sparkfun board seems to be designed for wheeled robots so it may not be right for a humanoid robot. 

After some research I found this amazing motion package for Raspberry Pi. You can also check out this method. It works well with good quality webcams. For official documentation and support, visit this link. 

I am trying to access Raspberry Pi from any host, but every time I type , this error comes onto the screen: 

But, I have googled, and I have found a tweak to preview on PC running on . Here is the link. The tutorial uses on . I cannot find for my Windows machine. Is there any way possible to do what I want on Windows. 

After a long detailed research, I have found this full setup tutorial. It has some limitations though, that I've read in a review in another website, but it works very well for my job. 

I don't like virtual environments like the one Adrian always work with. If you would like to try out my cheat sheet. I don't use virtualenv and it works well on RPI 2 Model B. Hope I helped. Don't forget to fork me on GitHub. To try out my cheat sheet you first have to enter the build directory and execute 

I have googled for a bit. I found this wonderful, super duper easy tutorial. Try it out and if it works, accept my answer. 

You should use 2A-5V adapter or even 2.5A. Your Pi 3 requires sufficient current as it has a Wi-Fi and Bluetooth modules built-in the Pi board. These modules are current hungry if you don't support the Pi with enough current it will shutdown automatically as a kind of short-circuit protection. Be aware not to increase the voltage as this will damage the Pi. Keep it 5V. 

There is no simple solution for a raw display like you linked to. That requires multiplexing which requires constant processing to maintain the display. Perhaps with a threaded library you could make something acceptable but I don't know if something like that exists. As an alternative you could use the Adafruit LCD display with I2C interface. Adafruit has a tutorial for using it with the Raspberry Pi and has a Python library on github that seems to be what you want. It even has example code. 

ESCs (Electronic Speed Controllers) are typically controlled just like you would control a hobby servo -- with a PWM signal. There are many guides to controlling a servo that should be applicable to the ESC. Since the Raspberry Pi is a 3.3V device you might need a level shifter if your ESC needs a 5V signal. Here is a tutorial for Raspberry Pi: $URL$ And Arduino: $URL$ 

feh is a simple image viewer that should do what you want. feh requires X11. You can give it a list of files or directories or URLs. It looks like you might be able to use the --info option to display the IP address. For displaying images on the console (without X11) you can use fbi. It is not a full featured as feh but it will do a simple slideshow. Both fbi and feh can be installed via apt-get. 

You could build a boost converter using a TPS61030 boost converter from TI or you could use this product that uses it. Personally I would be nervous using a cheap converter from ebay to power my RPi. 

A good option for managing a service like this is Supervisor. Install the package with . Then you will need to create a configuration for your script in For details about the configuration read the program section in the supervisor docs. Specifically you can specify and Supervisor will automatically restart the process if it stops. 

After reading your clean and very illustrative question. Also I read all the previous answers and I found that none worked for. All the answers are reasonable though. I decided to search about the supported Wi-Fi dongles for RPI. I didn't find yours in the section. This link provides you with all possible working USB Wi-Fi adapters. It's actually a good resource to search for info at. Besides, this link shows some dongles tests, you can also check it. So my main suspect is the dongle itself :D. Try using another one from your friends first before buying a new one if this answer helps. Btw your dongle should be supported as it's listed, but it's listed in the section. Hope I helped. 

Installing OpenCV is pretty much straightforward process, it just take a lot of time. I googled a lot for the last few months to make a cheat sheet, and I made one. You can download my cheat sheet and try it out. I don't like Virtual Environment. It's better, though. It isolates your installation from getting later errors when using after installation. I recommend you install OpenCV for Python 2 not 3. If you want for Python 3 just change the appropriate lines in the cheat sheet. I also recommend that you stick to the cheat sheet especially in step 12. Sometime when you use all the processor cores the process fails to continue. You should always use a 2A or 2.5A, 5V Adapter. your Pi 3 peripherals are current hungry, and if current is not sufficient, the Pi shuts down automatically, as it's short-circuit protected. Don't forget to fork me on GitHub. 

Raspbian Jessie uses systemd which reads the /etc/hostname and sets the hostname directly with a system call. See: $URL$ systemd does not use /bin/hostname to set the hostname. 

The camera port is not a general purpose port. It is connected to the GPU directly and uses either CCP2 or CSI-2 (camera specific protocols) to communicate with the camera. Have you looked at the P5 header that was added on the Rev 2 boards? It makes 4 additional GPIO ports available. 

You are attempting to execute that file which is not possible. You want to view the content of the file which you can do like this: 

It looks like a MCP3008 may be exactly what you want. The datasheet claims up to 200 ksps at 5 Volts. In fact there is a tutorial about using this with a Raspberry Pi. 

The GPIO pin cannot provide enough current to drive the buzzer and the LED. Change your circuit to use a double pole switch with one pole connected to the 3.3V pin to drive the buzzer and LED and the other connected to the GPIO for the Raspberry Pi to read the button state. 

The short answer is, no you can't do this with a Raspberry Pi. The long answer is, perhaps with enough external hardware and a great deal of knowledge of how HDMI works you might be able to do something like you describe. If you want to see and example of a hackable ARM device running linux that can do HDMI manipulation and pass through you can look at the NeTV board as an example. It uses an FPGA to handle the HDMI stuff though.