There's one big thing to keep in mind when setting up a NAS with a RaspberryPi. The Ethernet on the Pi is USB. This means that any data you're reading off a USB hard drive across the network goes down the USB bus from the disk to Pi, then back up it from the Pi to the network. This effectively halves your possible bandwidth. The USB/Ethernet setup on the Pi is also a little bit less than stellar in high performance situations. Ethernet throughput under ideal situations (e.g. sending /dev/zero) will top out at around 80 mbits. You can expect at least half of this (probably closer to 2/5ths or 1/3rd) when reading off a disk, so around 35 mbits, or around 4 MB/s. Backups will be a bit slow, but doable. Streaming video will depend on the bandwidth. Most 720 video will be under that rate as well, but you may encounter problems if more than one person is watching a video at a time. For the price though, the Pi is hard to beat... 

OK. You're on the right track to start with. I believe we can pipe keyboard input into omxplayer from the command line and use that to control it. I'm just going to write it out, then explain what's happening 

What that does is first enable IP forwarding, allowing the Pi to act as a router. The second line is the iptables magic. It tells the kernel networking stack as the final step of the packet routing procedure to bump it up the chain to wlan1 (your net connection), but also to MASQUERADE it. This is to say make it look like it came from this machine and send it on, rather then routing it normally (like bridging would). The "box" will also have to be manually told about the gateway address of the Pi, 192.168.100.1, and you'll have to tell it about some DNS servers. Google's are easy to memorize, 8.8.8.8 and 8.8.4.4. If the static IP addressing is too much of a bother, look into a package called dnsmasq, which does all of that for you. 

When make says that there is no target, that means either that the Makefile isn't there at all, or that it doesn't contain the thing you want to do. It's not a problem with any of the system libraries, but something specifically with FreeSWITCH. I'd start by re-checking the bootstrap and configure line ran successfully: 

I'd guess that you're gaining the delay due to some sort of buffering taking place or due to high CPU load. The later you can check by running the command. The FluidSynth Wiki suggests three command line options you can use to reduce latency. 

As Paul and user12448 have indicated, this is a generic Linux question, and the answer is the same for Rasbian on the Raspberry Pi. To get a list of available networks you can use the iwlist command: 

I suspect what's happening here is that the Pi is over-riding the boot time specified IP address when the networking service starts. If you can mount the SD card's linux file system, try changing the /etc/network/interfaces file to add the static IP, and then remove it from cmdline.txt. 

It doesn't look like there's a way to do it directly, but the xte tool can be used to simulate a key press. 

1) Close. I think the intention of the cron line though is that the file doesn't get saved and output is suppressed, so I think it actually works out to this: 

After plugging in the device, (or after boot if it's already plugged in), you should see in dmesg what the device has been registered as in /dev. The device registration will also trigger a udev call. You can create a custom rule to always assign it to a specific device. For example, creating a /udev/rules.d/90serial file with this should work, and create /dev/myUSBserial: 

At best this sort of thing is sketchy because of radio transmission regulations. Even ignoring that the project would be difficult. While the Pi can FM transmit, there's no receiver. You'd need to find a USB linux compatible one, or add on a USB sound card with audio in from a FM receiver. Then you'd need to make the transmission scripts, decode the received signal... there's a lot going on here. Better off to just buy or build a regular 2-way radio. 

XBMC doing multimedia decoding might be a good test as well as the UI there is in OpenGL. A game that constantly hammers the frame buffer (memory!) while including a numerical simulation like OpenTTD is also a pretty good test. The generic Dhrystone and Whetstone benchmarks might also be good. There's an OpenGL game I'm working on porting called Armagetron Advanced (which isn't really ready yet, sadly) that uses both the GPU and CPU quite heavily. That'd probably be perfect once it's done. On a side note, if you're worried about the Pi cutting out on battery power, it might be worth investigating the MoPi board. It monitors voltage and a daemon running in the background will trigger a clean shut down when it's out of power. 

PiFM is one of those really cool wow projects. I still want to get around to playing with it it's that cool. Unfortunately this means I don't know about the second part of your problem. Still, I have a basic understanding of radio so I can take a stab at what's going wrong with being unable to transmit on 89.7. A simplified explanation of how radio works is that you vibrate the antenna at your frequency, varying it a little because it's FM - Frequency Modulation. Now the important bit here is that vibration. How much the antenna can vibrate is related to the length of it, the longer it is the more it can vibrate, and you can broadcast at a higher frequency. There's a bit more to it than that involving modes and multiples, but that's the fundamental. What I suspect is happening to you is that your antenna is just a little bit too long (maybe 1 cm or so). When you try to broadcast, or vibrate at 89.7, the wave travels down the antenna at a frequency it really doesn't want to vibrate at - there's no resonance, so it wants more energy than the Pi puts out, so you get no signal. There are calculators for working out the correct antenna length, but I think a rough rule of thumb is 300 divided by the frequency, so (300 / 89.7)/4 = 0.836 meters. Not sure about that rule though. Might get away with /8 and 0.418. Note the multiples of 2, that's a resonance/natural frequency thing. 

I suspect that hostapd reinitialises the interface which is what causes this to fail. You can manually add the ifconfig command to the /etc/rc.local file which will auto-execute it on boot. 

It may be over voltage. When they say the USB spec is 5 V it's usually much closer than 5.3. The fact that the power supply ranges so much isn't a good sign. It could be causing continued resets on the Wi-fi or activating its over-voltage protection. Try to see if you can clean up the power-supply's output some (or try a phone charger temporarily?). A 5 V Zener diode should protect more from the over-voltage at least. 

There are 3 ways to approach this. The first way would be to write a kernel driver for a frame-buffer device on the LCD display. This is prohibitively complex. The second way I know would be to create a terminal emulator program (emulating vt100 for example) and then have this launch in place of tty0. The keyboard input would go into the application, but the display would come up on the screen. This would probably be the best way to do it if the vt100 terminal protocol made any sense at all. Unfortunately, from when I looked into this it's miles and miles of spaghetti to me. That leaves the third way, which wouldn't quite work perfectly, but would work "good enough" for very basic usage. Write a program to run in place of tty0 that executes a command, captures its output as text, and write that to the display. Something like the python subprocess command would do this. You'd read in a line of text, execute it as a command, capture the string output of running it, and then display that. I would dearly love it if someone managed to hack vt100 so that that idea would work though... 

Soldering is definitely the most secure connection you can come up with. There's no inherent problem to doing it to the Pi, but it is somewhat permanent though. The important things to watch out for are that you don't accidentally touch the iron to any place else on the circuit board. It may be worth also taking a break between soldering each pin to avoid any possibility of heat damage. Alternative to soldering directly to the pi, full 26 pin GPIO header blocks seat very securely as they involve all pins, but would let you make something that you could disconnect if necessary. Soldering is still required though.