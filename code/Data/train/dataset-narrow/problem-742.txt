You should start by writing all the relationships between those tables. From your description, I could not find out how Partner would be related to Client, Program or User. However, the diagram below is a start based on the information provided. Note that you can't use 1 Link table to link all table from what I understand in this case. EDIT - New ERD based on new requirements 

A user takes zero, one or more quizes A quiz contains 1 or more questions A user provides an answer for zero,1 or more specific question on a specific quiz 

Without knowing the business rules it is generally hard to judge if a model is valid or not. However, here are some quick points: 1-Address relationship to employee should be reversed. An employee could have several addresses. Your address modeling may be valid if you are referring here to work address where multiple employees work at the same location. Similarly, there is an issue with the phone to employee relationship. 2-Self reference relationship in Employee must not be mandatory on the many side. 3-Relationship between employee and leave balance is awkward. An employee should have 1 leave balance per year but your columns don't show that clearly. 4-Phone table, should separate area code from actual number for land-line phone numbers. 5-Naming: DOB Date is a bad name. DOB means Date of Birth, so the word date is redundant. 6-Salary is not related to Promotion from a business sense as you have it. Salary is related to grade, level, etc. 7-Some relationships are mandatory in the model where they should not be, I have already pointed out the self-referencing one but you also have the Employee-Dependant relationship. It should not be mandatory. The same is true for leave taken. From a professional stand point, I think you should not use this mode for a production application as is or even with the remarks I mentioned here because I did not provide a full list. Make sure you consult with a more experienced professional before implementing such a model in production. 

An index is useful if it will be used. This depends on the type of queries you perform, how data is inserted into the parent tables (assuming FK is active) and the size of the parent table. For example, if MasterAdGroupId is a key for MasterAdGroup table, and that table only has 5 rows, defining an index over it would be useless. Also the column called 'Dirty' sounds like a binary column and I don't think you'd gain great value of indexing it. 

There are 2 scenarios to consider. The first is when you have the user take 1 or more questions without a meaningful context such an exam or formal quiz. In which case you solution works. However, the second scenario is about when the user takes a question as part of a formal session. In this case you have the following rules: 

Note: Table names may be different in the solution than from this diagram A1 = Standard answer for question 1 UA1 = User provided answer for question 1 

Few suggestions: 1 - Don't use dynamic fields unless you really have to because they add complexity to your system. In your case, you don't have to. 2 - Don't add redundant static fields like this: Contact: ContactID,...,Phone-1, Phone-2,...,Phone-20, ... This is against normalization and is justified only in few cases (e.g. where the columns are limited in number and rarely searched directly). If you do this you can never find a Contact given a phone number in a decent way and you will have lots of Nulls to deal with also, you could have duplicate phone numbers (if you are not careful in your coding). 3 - If you have a structure like: Contact: ContactID, ... ContactMethod: ContactMethodID, Value, ContactID_FK where a Contact could have 0,1, more ContactMethods, that is a perfectly normal 1-M relationship that will perform very very well if you have millions of rows provided that you have an index properly defined on ContactID_FK. On your client side, you have to be careful what you want to show and how large is the data your are communicating with the server. This is a different issue and I don't think it would affect your case. The option in (3) is probably the best, it has been working since the 80s very well! 

I have the following remarks: 1-According to your question's text, the fk for city and country are repeated unnecessarily in the Address table. given the city id alone, you can find the country and state by a join. Repeating them represents redundant relationships. This desing may speed search by country or by state slightly though. You'd have to include 3 FKs in the Address table if the PK of State is composed of StateID+CountryID and the PK for city is CityID+StateID+CountryID. If you do this, the the FK in the address table becomes the compound key of CityID+StateID+CountryID. 2-Table names should be singular, e.g. City not Cities. 3-The Code column is not clear to me, is it unique? If it is, why use another ID? 4-The 'Address' table is probably meant to represent the address of the resort. However, this may not be quite practical. Some resorts have more than 1 distinct (sub-resorts) that may require different (or maybe the same) address. Also, there could be a management or contact address that is different from the resort address. You need to take care of this if your business rules demands it. Edit - Attempting to show that only 1 FK is a must in the Address table and the rest are redundant from modeling perspective. FK2 and FK3 could be obtained by joinng the Address table with Country, State and City tables when only FK1 is present in the Address table. 

If you have a performance problem, it may be worthwhile to identify the reason for it first before you move to persisting the data. One reason for this is that the base data may change and your persisted acculturation may not reflect valid data over time. If you decide that data base data change will not change the accumulated results, then maybe this data can be generated using a batch job instead of an on-line query. This way, you will have ample window to run your query without resorting to data persistence. Now we look at which row structure to use. I must agree with Mr. Kimball's point. However, it makes sense only if you have all the data values ready once you write the row. You don't want to visit aggregated rows to update their content as a general practice. 

One good case for using MVs is that some times you want to aggregate data and get this summary information from large tables frequently and quickly. Without materialized views, you have to either deonormalize some of your tables and maintain the aggregates via code or repeatedly scan large sets of rows. Either way is not always acceptable specially with dashboard and similar online applications. If you keep the results in a separate tables, you complicate your application code and as @Justin Cave says, you will be in charge of making sure that the manually aggregated data is in synch. with the original table's data.