It's a short enough method that there's not much to comment upon. You could shorten these two lines: 

A bigger consideration is whether the return type must be . You might see some performance boost if you went with . In fact the extension method could be more reachable if you changed the input signature a bit too. Something like: 

Fields should never be public Your first 3 class-level variables are called . They should either be or . For example, will always be 0.2f? If so, it can be a constant. If not, and if you want it to be exposed publicly, then you should make it a property. If does not need to be public, then it can remain a field. Method, Property, & Constant Names are CamelCase Fields & Parameter Names are PascalCase This doesn't YET apply to your original code, but let's combine it with the previous section. Your declarations could now look like: 

Swap Method You really don't do anything with the returned from the method. Plus I see little reasoning in not swapping 2 values that happen to be equal. This method could simply be . You are also encouraged to have meaningful names in C#, so would be better named as . Ditto for . 

UPDATE #2 - Worst Case Obviously we should be working with the largest array allowed. As @PeterCordes states in a comment to @vnp's answer, the list should be randomized. As @Denis states, the worst case for a would be if the only duplicate was the first and last item. An extremely close second would be if the last and 2nd to last item were the only duplicate. Note this second worst case for would be the worst case for @vnp's array solution, so I will use it as my worst case. 

Which is far less messy. I leave it to you to create method to return the appropriate type. The nice thing with the above is that the code should work whether you return an array or a list. 

Choose better names for your objects. a, b, and indx tell me little and are hard to follow. Especially with indx and this notion of pointing to an indx. C# has wonderfully modern features like classes. Something like: 

Search Methods The names should use PascalCasing, example SearchByPublisher, SearchByPrice. There is no reason for the trailing inside each respective . The has already returned an enumerable collection that you will iterate over. For comparing strings, you have no regard for case. Thus "HOBBIT" and "hobbit" would not match "Hobbit". You may want to allow for ignoring the case. Another consideration would be on matching a partial string. Consider if the user enters "dragons" at the console that maybe you want to return "A Dance with Dragons". Going Further As a beginner, be sure you grasp what you see so far. Then go a step further and add a class that implements . Now the search methods could be moved inside the class. In the name of Separation of Concerns, you don't want the searches to also write to the console. Instead, the search should be concerned only with searching. That would mean each respective search would return an IEnumerable, or really just the results of the . 

To answer your (1) in a recursive method ... Eric Lippert does it in Producing Permutations series, Part Three , specifically in his recursive method. I won't dive into your (2) only to suggest that perhaps you read all of Eric Lippert's series to learn more. Braces Need Improving On coding style, your use (or lack thereof) of braces could be improved. The C# convention is to put the opening brace on a new line (this differs from Java). More importantly is that you lack braces on so many one-liners. This is heavily discouraged. I would suggest cleaning your code to change a snippet from this: 

The class has no concern about collision logic. It leaves that to the . I did try a test relying more on getter calculations: it took 30 milliseconds longer for a million move spiral. I leave it to the reader to decide whether a small amount of memory is worth saving 30 ms. Private Nested SegmentPool Class The big lead up finally gets addressed! The collision logic – not just limited to comparing segments for a collision but deciding on the critical -3 and -5 away segments – is all done here. Most methods and properties in the class are fairly short and straightforward, with one notable exception: the method. Some could suggest ways to make that method a tiny bit more DRY but I configure the individual dummy segments one at a time with appropriate comments. 

Couple of things caught my eye. The constructor for and can throw an exception if a is passed in. Just looking at the plus operator, there is a bug if equals in which case neither is less than . Also for subtraction, multiplication even by -1 seems heavy-handed. Perhaps: 

Over the years I’ve seen many C# sieves and despite their varying internals all that I have seen invariably are a static method that returns a , perhaps with the occasional rare exception of an . This is fine for small collections. Granted relatively speaking for some people a 1 million item list is small. But if dealing with very large upper limits, say , you could run into an out-of-memory exception fetching over 105 million items. So I wrote a sieve class that has these highlights: 

BEST ANSWER Also, since you have tagged this question with [time-limit-exceeded], vnp's answer is not just clever, but also the fastest in all tested scendarios, which makes it the best answer (regarding performance). 

I know you are primarily interested in your use of Task. Sadly my remarks are not about that. I think would be better named as . For one, you really haven't scheduled it. Two, the phrase "Pause" is bonded more closely to your method. And three, it seems like a natural counterpart to . You may even consider having be a public settable property. The top of your method has this: 

One way to account for these corner cases is putting several conditionals and checks in place. This makes the logic chopped up. Wouldn’t the problem space be simpler if each and every move always has a -3 and -5 away move? It’s not an impossible dream if we have the load appropriately configured zero length dummy segments (more later). I will do just that: load zero length dummy segments when the is created, and this will guarantee that each and every real move will always have a -3 and -5 away move. The collision checking section will be more streamlined by doing it this way. Plus, for each move you will only check 2 segments AT MOST. This scales extremely well. First 3 moves logic bug Your code for the first 3 moves is missing a critical check. You do not check that the distance for a respective move is greater than 0. Optional General Considerations These next items are purely optional and are general in nature. The better CR answers not only address the heart of the problem you are trying to solve but also bring up other issues that can make you a better, well-rounded developer. Class-level variables My solution will not need any class level properties or fields. I see no need for a or . In fact, can be a and can be a method. Given the special nature of and , I likewise choose for them to be and nested classes inside of . The only things that I have exposed as are those minimal things that truly need to be . Even the constructor to or are ; instead I require you to use the method for them, where is both and . This reduces the ‘surface area’ of my classes to the bare minimum. Named constant for output of -1 I also like assigning the index not found (-1) as a named constant: . Sure -1 works but what happens if someone changes the requirement to be some other negative number, e.g. -9? Do you change your code in 4 places or just 1? Plus the code reads cleaner with since its intent is clearly apparent. Flexible method signature Others have suggested it before that you could make the signature to be . If it’s not apparent to you, this signature will accept an as input. Sure you can say that the original problem required the signature be but you’ve already reworded the original problem to make it your own. So you have the liberty to reword the signature requirement. To throw or not to throw The last general consideration is whether or not to an on bad inputs. Understand that I get it: you have an interesting math problem in front of you and you care most about the logic to solve that problem, and not so much in the finer implementation details of dealing with bad inputs. That’s just ‘finishing’ work after the main task at hand. Some could argue that you code works fine in this regard. To complete the topic, however, I think one should on invalid data, and not simply return -1. To me invalid data is when the array (or IList) is , or when any move is . Having less than 4 moves isn’t invalid since I can imagine it is valid to consider that a critter may travel less than 4 spaces, as long as each move is . That concludes the sidetrack. Back to the meat of the problem. First 3 moves – staying DRY Replacing the 2 lists with a single , I could load the first 3 moves this way: 

It's much easier for someone to follow what you mean. And once they can follow that, they will be better positioned to comment on the algorithm. 

The last line contains a magic number, so you should consider making a constant for it. You can also get the same effect different ways (shown for example, not necessarily a better practice): 

You will note the class and method are both . There are not class level properties or fields. The method contains instances for a and . All moves are handled in one loop, and there is no special check based on move number. Private Nested Segment Class A segment can be characterized as and an . Or it could be a , , , and . Whichever you go with can derive or calculate other properties. I personally like , , , and . Yet below I set everything during and don’t worry about read only getters. This is a tiny bit of bloat on an instance, but since I have at most 6 instances, this bloat is okay by me. If I have a million moves, I don’t have to perform 1 or 2 million getter calculations. 

The has a minor and major issue. The minor issue is that you don't check to see if is null. The major issue that should probably have a lowercase . I see the linked code and you correctly have it lowercase there, so its a typo here.