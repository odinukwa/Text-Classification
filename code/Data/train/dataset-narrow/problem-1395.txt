Concerning your question about the usage of : yes, this usage is correct and it roughly respects the principles of functional programming. However, I would recommend a few changes to increase the readability of this piece of code: 1) appears three times: it needs to be extracted into a dedicated method. 2) The main valid return case starting with should also be extracted into a dedicated method. 3) The condition should also be extracted. After this refactoring, the code will resemble something like 

For a first try in Scala, this code is a nice attempt. There are not so many rudiments of imperative style programming, which are usually frequent. It is also quite concise and structured, which produces a good overall impression. However, there are of course a few things to adjust and to improve. I'll divide them in two categories: 

may now return directly Java API We are now in the era of , so I'd recommend to avoid by all means. Just forget that the old objects exist, they are evil! 

It's just a cleaner practice: prefer interfaces over implementations. Bug or Suspicious Comparison of Dates The old are compared with , which will lead to unpredictable behavior, because they are compared up to milliseconds. So two s created within even a short delay will not be equal. Just try this simple test: 

Otherwise, a test failure will produce the message "false was not true". And of course, if you choose to extract message builders in separate implementing classes, there should be separate test classes corresponding to each builder. 

Some more observations (excluding the nice remarks about the interfaces). Naming: and are excessively long names, why not just and respectively? toString(): patterns such as look like if they were written in Brainfuck. More readable alternatives are: 

The principle is: when the first element is found that contains the specified , it redirects to the overloaded function with this element; otherwise it does nothing. Please note that the equality is checked with , which is equivalent to Java's . The same kind of changes can also be done with function, but it doesn't seem to be used throughout the code. The function is not necessary at all. It looks like a sort of Java's residue; already has public access and the reference is immutable. Generally, I'm not sure about the validity of the choice to use and the exposed for field in class. This sort of mutability is somewhat against Scala's principles, but I don't see yet how to work it around. 

There are some things to improve in this code. Especially when it's underlined that "if it can be maintained later on". SQL query The columns where the data will be inserted should always be defined, for example: . It's the same problem as for , that should never be used in serious queries. That's because the table definition evolves over time; tomorrow there may be new columns added, other removed or reordered. There is absolutely no warranty that the meaning of what is behind the question marks in the example will be valid after the next feature implemented into the software. Another reason to define them is just to help yourself: it's very difficult to remember which is the natural order of columns in the table for the thirteen question marks. PreparedStatement There is no need to recreate the instance on each loop. Indeed, one of the reasons they are made for is the possibility to be reused. And their creation is sometimes quite costly. The third line should come just before the loop. Parameter Indices From the point of view of maintenability, calculating/incrementing the parameter index ( variable) is not safe. It's just almost like the columns ordering issue above. If is incremented, the order of the lines with parameters setting is crucial and prone to errors. To solve, some readable (local) constants may be introduced, for example: 

Or, better 2) If you are using Jersey behind your JAX-RS annotations, add an exception mapper class: 

This is a nice idea and those classes can indeed be reused on many occasions, unless and are generated with utils like lombok. Here are some suggestions of how this code can be improved. General Design Currently, these classes contain lots of methods, which means that calls like look rather ugly and are too verbose in usage. But these entities can become more flexible and easily pluggable if transformed into abstract classes or interfaces. For example: 

Nesting Using nested functions is not a bad practice per se, but all depends on the concrete case. Often they are used to enrich the parameters, to share with locally scoped values, or to hide the from other members of the same object. In many cases, they are just equivalent of functions with private visibility. But when too much nesting appears, I'd suggest to flatten the things for the sake of readability. In this example I don't see any special reason to make the function nested. It does not use any of the values available to . Keeping it nested would not be a mistake, but the flat approach seems cleaner: 

The idea to separate it into a dedicated class is not clear. (BTW, it's not a good practice to include much logic into constuctors, neither to throw checked exceptions from them). Its only role is to wrap , so why not producing them in a utility method, ex. ? And there should be a try-with-resources wrapping the initialization of . To check whether a file is hidden or not, is not reliable, because a file name may begin with a dot without the file being hidden. A better way to check is . 

The drawback of this approach that I already see is that map will be progressively filled with references to all the resources that were accessed. Emptying this map from time to time would be a solution, but I don't have an idea of the logic of resources handling in your cache. 

Naming and Initialization It's very hard to read when many variables are initialized on a single line. naming pattern is also confusing. Since they correspond to coordinates, why not name them like this? 

I think that this method should be defined elsewhere, because it does not correspond to the functionality of . It's a good idea to use inside it (and even better would be instead of it). Since this is a public method, the validation of the arguments should be done on non-nullability of and . The existence of the files will be checked in , with the respective exceptions thrown. The target object can be created easier with , no need to instantiate a . 

The advantages are significant: 1) flexibility and separation of concerns; 2) tests are much easier. The private methods , used by all the builders, should be grouped in an abstract class and be accessible from the implementations, so the builders class headers should finally be like . should be abstract and implemented for each concrete message builder, without the conditions. Other Issues Args Validation Multiple not-null checks might be extracted: 

method seems to be a bit outside the principle of its fellow opposite . Why does it take a as argument? I'd expect a here also. Although is now a functional interface, it is more often associated with multithreading than with functional style. And if the intention was to use its threading abilities, the call in the method body is incorrect. should have been used. Another remark, much less important. Since this wrapper class is very short and has only one field, there is no much sence in hiding the one-arg constructor allowing only the builder method publicly available. Both may be left public. 

The letter 'X' is not there, because it is common for all cases. Don't need to repeat it in the matrix. Repetitive concatenation is also an evil, even though in your example it's just single characters. Use for such cases. And the body of the method becomes something like: 

The idea to extract SQL queries from the code into in a separate resource is good in general. Its main advantage is that when there is a non-substantial change at the database side, it might be enough to change the resource file, without recompiling the code. However, it slightly reduces the readability: the query is in a separate file, you do not have it immediately visible near the instructions that process the . That can become confusing if the query is passed to a with a number of parameters, but everything finally depends on each case. This discussion can easily end up with arguing whether inline SQL is better than using an ORM :) For the solution that you submitted, I can observe the following: 

Parameters Mapping There is absolutely no way to know the meaning of the values that are retrieved from the . Since it looks like a object, here is a way how an explicit mapping can be created. Define a by extending, for example, the and map the values you need with their respective getters: 

Well, the contents of this method is really too complex and firstly should be split in two parts (dedicated methods): 1) parse arg in order to extract , and ; 2) invoke method on the target object. Parsing 

Moreover, your method may then go directly into this class, named something like . The loop in would look like this: 

the code will still compile and work: looks like is not really meaningful in this implementation. I suggest to create a dedicated type that will provide a means of evaluation of expressions expecting two args: 

Logic According to the tests and the implementation, ranges like (1, 10, -1), (10, 1, 1) are considered as empty. This choice looks a bit weird, because these ranges have valid bounds, but the value of the field is inconsistent with these bounds, making them senseless. I think that the constructor arguments should be validated, with an thrown for such cases. And what about ranges like (1, 10, 20), (10, 1, -20) ? Are they also empty? If the current implementation does not correspond to a strict requirement, I'd suggest to define an empty range as a range where the and the values are equal. P.S. please remove the method from class. There is already for that.