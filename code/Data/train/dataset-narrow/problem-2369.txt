Consider the decision problem which decides whether a given binary input $x$ of length $n$ is a non-palindrome. There is a pretty standard communication complexity proof that a single tape TM requires at least $O(n^2)$ time to solve this problem. On the other hand, we can also solve this problem using a nondeterministic algorithm with a $\log(n)$ length witness $i$: the algorithm accepts whenever the $i$th bit from the start of $x$ differs from the $i$th bit from the end of $x$. Identifying the $i$th bit from the start or end of a length $n$ bitstring can be accomplished in $O(n \log n)$ time on a single tape TM. 

The principle of deferred measurement (see $URL$ tells us that measurements in the middle of a quantum computation can be simulated by using additional quantum gates instead. In particular, instead of measuring a qubit, we can apply a CNOT gate to that qubit and another qubit (which is used only at this point of the computation). 

In my first answer, I addressed the NP-hardness of this problem. Here I address the approximability. Overview Below, we reduce the Hub problem to the Set Cover problem such that the choice of sets in the Set Cover instance corresponds with a choice of hub vertices. Then any approximation algorithm for Set Cover can be used to approximate this problem (to within the same factor) simply by following the reduction, approximating the resulting Set Cover instance, and outputting a selection of hub vertices which corresponds with the selection of sets in the chosen set cover. For completeness, we also reduce Set Cover to the Hub problem such that the choice of sets in the Set Cover instance corresponds with a choice of hub vertices. In much the same way, this proves that any approximation algorithm for the Hub problem can be used to approximate Set Cover to within the same factor. Thus the Hub problem is approximable within some factor in polynomial time if and only if Set Cover is approximable within that factor in polynomial time. Under the assumption that $P \ne NP$, Set Cover is not approximable within a factor of $(1-o(n))\cdot \ln n$ where $n$ is the number of elements in the universe (according to wikipedia: $URL$ Since under the reductions below every element in the universe corresponds with a start vertex, the Hub problem is inapproximable within a factor of $(1-o(n))\cdot \ln n$ where $n$ is the number of start vertices. On the other hand, if a $\Theta(\ln n)$-approximation (where $n$ is the number of start vertices) is of interest, this is certainly possible. In particular, an explicit approximation algorithm for the Hub problem can be constructed out of any approximation algorithm for Set Cover together with the Hub Problem -> Set Cover reduction provided below. Any $\Theta(\log n)$-approximation algorithm for Set Cover from the literature would serve. Hub Problem -> Set Cover reduction For this reduction, we start with an instance of the Hub Problem. This consists of a graph $G = (V, E)$, an assignment of lengths to the edges, a partition of $V$ into start vertices, exit vertices, and vertices that could be hubs, and values $\gamma$ and $\delta$. First conduct an All-Pairs Shortest Paths search to compute the distance between every pair of vertices. If we replace the given graph with a complete graph whose edge lengths are the shortest path distances, the problem clearly remains the same. The benefit of doing this is that removing a vertex (and all of the edges incident on it) will not affect the distance between any two other vertices. Thus if we are certain that a potential hub vertex will not be chosen as a hub, we can remove the vertex while preserving the answer to the problem. Conduct a breadth first search of all of the vertices starting at all of the exit vertices that searches to distance $\delta$. This allows us to quickly split the vertices of the graph into two groups: the vertices within distance $\delta$ of at least one exit vertex and the vertices that are a distance of greater than $\delta$ from every exit vertex. Any potential hub vertex in the second group can never serve as a hub between a start vertex and an exit vertex since the exit vertex will be a distance of more than $\delta$ away from the hub. Thus it is never necessary to select a vertex in this second group as a hub. As a result, we can remove all of those vertices from the graph while preserving the answer to the problem. If we do that, we find that every remaining potential hub vertex will be within distance $\delta$ of at least one exit vertex. Then it is sufficient to select a set of hubs such that every start vertex is within a distance of $\gamma$ of that hub. If we do that, clearly every start vertex will be within a distance of $\gamma$ of a hub that is within a distance of $\delta$ of an exit vertex. But then, if we remove all the exit vertices and also remove the constraint regarding exit vertices, the answer to the problem will remain the same. At this point, we are left with a complete graph on some set of vertices that can be partitioned into start vertices and potential hubs. Each edge has some length, and we wish to select vertices from among the potential hubs such that every start vertex is within distance $\gamma$ of a selected hub. Note that since the distance between two vertices is the length of the edge between them, we have a very quick way of determining whether a start vertex and a potential hub have distance at most $\gamma$. Now we construct an equivalent Set Cover instance. The universe being covered consists of $n$ elements where $n$ is the number of start vertices. There are $m$ sets with which we could cover this universe, where $m$ is the number of potential hubs. Each element in the universe is associated with a start vertex and each set is associated with a potential hub. In particular, the set associated with a given potential hub consists exactly of the set of elements associated with those start vertices that are within a distance of $\gamma$ of the given potential hub. Clearly, since shortest paths, breadth first search, and removal of vertices from a graph are all polynomial time operations, this reduction is polynomial time. Furthermore, as argued, the original problem is equivalent to the problem of choosing hubs in the final bipartite graph (with parts for start vertices and parts for potential hubs) such that each start vertex is within range of a chosen hub. The reduction maps the potential hubs to the sets and the start vertices to the elements: the Set Cover instance requires a choice of sets (potential hubs) such that each element (start vertex) is contained in (within $\gamma$ of) at least one chosen set (hub). Thus the reduction is answer preserving. As we see the reduction is polynomial time and answer preserving. In addition, the choices of hub vertices correspond with choices of sets and $n$ corresponds with the number of start vertices, as claimed in the overview. Set Cover -> Hub Problem reduction For this reduction, we start with an instance of Set Cover consisting of universe $\{1,..., n\}$ and a list of sets $S_1, S_2, ..., S_m$ with $S_i \subseteq \{1,..., n\}$. We wish to construct an instance of the Hub problem such that the number of hub vertices necessary to create a hub is equal to the number of sets $S_i$ necessary for their union to be the entire universe. Construct the instance as follows: 

We will show that a trail of total travel time $D$ has a weight of at least $M + C$ if and only if the answer to the given knapsack instance is "yes". This is sufficient to show NP-hardness. There are two possible types of trails: those that use edge $e_{ii}$ with $i = k+1$ and those that don't. Call this edge $e'$. The maximum weight gained per unit of travel time over all edges other than $e'$ is $\max_{i = 1}^k \frac{c_i}{s_i}$. Thus, any trail that does not use edge $e'$ will have a total weight of at most $D (\max_{i = 1}^k \frac{c_i}{s_i}) < M$. Thus, trails that do not use edge $e'$ will have total weight less than $M$. Clearly, some trail (whose travel time is at most the deadline) has total weight at least $M + C$ if and only if a trail using edge $e'$ (with travel time at most the deadline) has total weight at least $M + C$. Using edge $e'$ requires reaching vertex $k+1$ from vertex $1$. This requires using a travel time of at least $kH$. Then using edge $e'$ requires an additional travel time $H$. After that, there is not enough time left in the deadline to use edge $e'$ again. Thus, any trail whose travel time is at most the deadline and whose weight is at least $M + C$ will use edge $e'$ exactly once. Since traveling between vertices adds no weight, it should be clear that the optimal solution will always spend the minimum possible travel time between vertices. Fortunately, this is possible without bypassing any vertex (by going through the vertices in order $1, 2, \ldots, k+1$). This means that there is always an optimal solution to the produced trail max-weight travel instance in which we pass through the vertices in order $1, 2, \ldots, k+1$ taking one self loop at vertex $k+1$ (in particular edge $e'$) and some number of self loops at the other vertices. Traveling between the vertices has travel time $kH$ and weight $0$. The self loop at vertex $k+1$ has travel time $H$ and weight $M$. Thus, in order for this optimal solution to reach a weight of at least $M + C$ within a deadline of $D = (k+1)H+S$, it must be the case that the total travel time used on the self loops at vertices $\{1, \ldots, k\}$ is at most $S$ and the total weight gained at those self loops is at least $C$. Since self loop $e_{ii}$ has travel time $s_i$ and weight $c_i$, this is exactly equivalent to the knapsack instance we started with. simple path max-weight travel is strongly NP-hard We reduce from the following NP-hard version of the Hamiltonian path problem: given graph $G$ and vertex $v$, decide whether there exists a Hamiltonian path in $G$ starting at $v$. Suppose we are given an instance of this problem with graph $G = (V, E)$ and vertex $v \in V$. Then we build an instance of simple path max-weight travel as follows: 

This problem with $k=3$ is coNP-hard (and therefore coNP-complete). To prove this, I will reduce from 3-SAT to the complement of this problem (for a given $NC_3^0$ circuit, does the circuit enact a non-bijective function). First a preliminary definition that will be helpful: We define a labeled graph to be a directed graph, some of whose edges are labeled with literals, with the property that every vertex has either one unlabeled incoming edge, one labeled incoming edge, or two unlabeled incoming edges. The reduction Suppose we have a 3-SAT formula $\phi$ consisting of $m$ clauses, each containing three literals. The first step is to construct a labeled graph $G$ from $\phi$. This labeled graph contains one copy of the following gadget (sorry for the terrible diagram) for each clause in $\phi$. The three edges labeled L1, L2, and L3 are instead labeled with the literals in the clause. 

Correctness Let $x = [~x'~;~x''~]$ be any vector of $0$s and $1$s expressed as two subvectors $x'$ and $x''$ of lengths $k+1$ and $n$. Suppose that the dot product of $x$ with vectors $a$, $b_1$, $\ldots$, and $b_{k+1}$ is positive. Then consider the two vectors $a$ and $b_j$ (for some $j$). These two vectors are almost exactly negatives of each other. In particular, they both have $1$ as the $j$th component but are otherwise negatives of each other (this is easy to verify). Then if $x$ is a vector of $0$s and $1$s with a $0$ in the $j$th component, the dot product of $x$ with $a$ is the negative of the dot product of $x$ with $b_j$. In this case, these two dot products cannot both be positive. Therefore, $x$ must have a $1$ in the $j$th component. The above logic can be applied for every $j$ with ($1 \le j \le k+1$). From this, we can conclude that if $x$ has a positive dot product with vectors $a$, $b_1$, $\ldots$, and $b_{k+1}$, then $x' = 1(k+1)$. Furthermore, we know that $x \cdot a > 0$, and $$x \cdot a = [~x'~;~x''~] \cdot [~1(k+1)~;~-1(n)~]= [~1(k+1)~;~x''~] \cdot [~1(k+1)~;~-1(n)~] = 1(k+1) \cdot 1(k+1) + x'' \cdot -1(n) = k+1 - |x''|_1$$ where $|x''|_1$ is the number of $1$s in $x''$, so $k+1-|x''|_1 > 0$ and $|x''|_1 < k+1$. Similarly, $x \cdot b_1 > 0$, and $$x \cdot b_1 = [~x'~;~x''~] \cdot [~e_1(k+1)~;~1(n)~]= [~1(k+1)~;~x''~] \cdot [~e_1(k+1)~;~1(n)~] = 1(k+1) \cdot e_1(k+1) + x'' \cdot 1(n) = -(k-1) + |x''|_1,$$ so $-(k-1)+|x''|_1 > 0$ and $|x''|_1 > k-1$. Together the above implies that $|x''|_1 = k$. To summarize, we have shown that if $x$ has a positive dot product with vectors $a$, $b_1$, $\ldots$, and $b_{k+1}$, then $x' = 1(k+1)$ and $|x''|_1 = k$. In fact, it is easy to verify that the reverse is also true. In other words, $x = [~x'~;~x''~]$ has a positive dot product with vectors $a$, $b_1$, $\ldots$, and $b_{k+1}$ if and only if $x' = 1(k+1)$ and $|x''|_1 = k$. From now on, consider only vectors $x$ of the above form. Notice that there is a one to one correspondence between possible vectors $x''$ and subsets of $\{1, \ldots, n\}$ of size $k$: in particular, $x''$ can be put into correspondence with set $X \subseteq \{1, \ldots, n\}$ with $|X| = k$ such that $(x'')_i = 1$ iff $i \in X$. Under this correspondence, we can consider the necessary and sufficient conditions for $x$ to have positive dot product with vectors $c_1$, $\ldots$, and, $c_n$. For any $j$, we can expand $x \cdot c_j$ as $$x \cdot c_j = [~1(k+1)~;~x''~] \cdot [~-e_1(k+1)~;~s_j~] = 1(k+1) \cdot -e_1(k+1) + x'' \cdot s_j = (k-1) + x'' \cdot s_j.$$ Notice that the value of $x'' \cdot s_j$ is exactly a sum of $k$ components of $s_j$: in particular, $x'' \cdot s_j = \sum_{i \in X}(s_j)_i$. If these $k$ components are all $-1$s, then this sum is $-k$, and so $x \cdot c_j = (k-1) + x'' \cdot s_j = (k-1) + -k = -1 < 0$. If these $k$ components include at least one $1$, then this sum is at least $-1\times(k-1) + 1\times 1 = -(k-2)$ in which case $x \cdot c_j = (k-1) + x'' \cdot s_j \ge (k-1) + -(k-2) = 1 > 0$. Thus, we see that $x \cdot c_j \ge 0$ for a specific $j$ if and only if $X$ includes at least one $i$ such that $(s_j)_i = 1$. Remember that $(s_j)_i = 1$ if and only if $i \in S_j$. Thus, $x \cdot c_j \ge 0$ for a specific $j$ if and only if $X$ includes at least one $i$ such that $i \in S_j$, or equivalently if and only if $X \cap S_j$ is non-empty. Then $x \cdot c_j \ge 0$ for every $j$ if and only if for every $j$, $X \cap S_j$ is not empty. Notice that the latter condition is exactly equivalent to the condition that $X$ is a solution to the input set cover instance. In summary, we see that $x$ is a vector of $0$s and $1$s with positive dot product with all the vectors produced by the reduction if and only if $x = [~1(k+1)~;~x''~]$ with $|x''|_1 = k$ and $x''$ corresponds to a set $X \subseteq \{1, \ldots, n\}$ with $|X| = k$ such that $X$ is a solution to the input instance of set cover. In other words, a solution to the set cover instance exists if and only if a solution to the instance produced by the reduction exists.