That depends entirely on your viewpoint. You certainly don't have to have a UserEntity, UserRepository, UserFactory, UserFinder, Email, Username and Password Value Objects, AuthenticationService AuthenticationAdapter and implementations. But you could have. Also, we could (no, we should) argue, whether storing the password hash in the user is a good idea. You'll only need it to authenticate and then never again, so that's one time in the application. After that, you can use a token or set a flag in the Session. There is no need to store the password then, regardless of where you do the authentication (a separate component sounds fine to me. You could inject that to the User and then delegate the call). The most important thing is that the code does what the enduser thinks it should do. However, it should also be implemented in a way that won't come back to haunt you, should your ever need to change the application. So whether it's "okay" or not pretty much depends on the scope of your project. Ask yourself: "is it good enough?" 

The time complexity of searching a value from a is close to O(1) while a typical looping mechanism is O(n). The speed becomes times slower as the size of the collection increases. You also have a lot of duplicate code in the two statements. To resolve that I'd recommend extracting out the logic outside and calling a common function with a single loop. Something like 

The class would store Earth's G in a constant, because it does not change in any planet's calculation. The constructor should require the planet's own G value and it's name (for the Print statements, discussed further below). You can also add a method to calculate the resultant weight based on a given value, to follow along with the Object Oriented approach. 

Using the array has a massive advantage here for the output statement. Since the corresponds to the planet's position in the array, you can simply call the appropriate planet's method as . Following two lines will suffice the purpose of the previous . 

Yes, always. Except for when you can reasonably justify not to. Following SRP will make your code easier to maintain in the long run and will increase reuse possibilities. Once you assign multiple responsibilities, you will have to have the same set of responsibilities in another project if you want to reuse the class. And the chances for that are smaller than for single responsibilities. 

No. Having many small classes is perfectly fine. It's a matter of appropriateness though again. I found it helps to keep things separated and small. However, it also gets harder to visualize the code flow in your head then the more classes you add. 

A good general set of rules to follow is GRASP. Another easy test is to look at what the class does and then check that the name matches that what it does. Your User apparently loads things from the database and checks passwords. Not exactly what I'd expect from a User. 

I am creating user profile logic for a blogging platform. I have the model and then two separate models, and to control the user's various social media contacts (i.e. Facebook, Twitter, Google+, etc...). I am looking for feed back on the execution of the methods used to new . Is this the way you would handle it? Is there a better way? What are some of the issues you see with my methods (specifically in the service class)? The Models 

The stored procedure requires you to pass it the log table, the source table and the primary key that ties the two tables together (usually the source PK). And is a temp table created before this is executed in the stored procedure that simply stores column names that match between the source table and the log table (not all fields from the source are being logged). Now this code behaves as intended, the problem is the query takes about 10-20min to complete (just this part of the stored procedure). The heaviest query this is used on is looking at 48 fields in a table that only stores 300K records. There has got to be a way I can make this query faster. 

That gets us right back to the first question. If we assume User to be a class holding business logic, then technically, putting the db access into the User is a violation of SRP. However, when the impedance mismatch is small or doesn't exist, then using an ActiveRecord'ish pattern might be practical. So check how much impedance mismatch you have. When you notice your User to turn into a ORM, consider using an ORM instead. The other option would be that your User doesnt have any business logic and is really just a Gateway to the storage engine. Then it's okay to have db logic in it. It just shouldn't be called a User then though. 

Having individual setters has a couple of advantages: A dedicated setter allows you to put dedicated validations for these properties. You could obviously put them in the bulk setter as well, but that will make the bulk setter large and unwieldy very quickly. You want methods to do one dedicated thing instead. That keeps them maintainable. Dedicated setters clearly communicate which properties can be set. With a bulk setter, it needs documentation or a look at the source code to learn what I can legally set. I usually don't want to look at your class code. I just want to look at the public API and understand how I can use that class. That's not to say bulk setters are bad per se. If you know folks are likely to set two or more values after another because they naturally go together, you could allow for a method. But as you can see, that's still much more explicit than a generic . Also one could argue that if you need to set arguments that naturally go together, you rather want them to be in an object of their own and pass that object then. On a side note: Your bulk setter will create properties on the fly for those keys that are not properties in the class. While you could consider that a feature, it makes debugging harder because a developer has to know the object's current state at runtime to know what properties it has. On another side note: a base class is usually a code smell. It tends to amass unrelated functionality and turn in a God object quickly. It also hampers reuse because all your classes will depend on it then. 

There are many different design-oriented ways to produce a good solution, as demonstrated in the other answers. So I'd like to suggest something different. One should make use of framework classes whenever possible. It avoids potential bugs, reduces the lines of code and standardizes the code. There is an in the called . It has an ordered list of the days of the week. All you need to do is parse the as a as detailed below 

I would start from the declaration of . You are an from it but no other class will handle it. You should put your inside a and handle the exception properly. I would also recommend reading everything from the files at once and use that of data in your code logic. A locks the file until it's finished with it. Furthermore, you don't have to call just for the sake printing a new line. Use the escape sequence for doing the same