I wanted to see if this could be seen using the . I was surprised to see that it couldn't see my microphone when I wanted to change the soundcard. Next, I checked to see if it was visible using . But no capture devices were detected. This was the only output that I got. 

For some reason, my WIFI dongle doesn't want to connect to the internet anymore. It was not too long ago. But I think something happened that caused it not to work. I can't figure out what's going wrong but I think it has something to do with me uninstalling the package. I have a strong feeling that removing that package somehow messed up my WIFI connection. It was working perfectly before that. If anybody knows what to do about this, that'd be great. I even tried to connect to my pi through an ethernet connection but I still have no luck with it. I can't even scan it on my network. I know for a fact that the WIFI was configured correctly because everything seemed to work fine until not too long ago. I have absolutely no clue what I did. Let me know if you need anymore information than this. Thanks for any help. It's appreciated. 

If anyone needs more information on how to get this done. Leave a comment and I'll try to get back to you. 

Generally, most likely causes for not booting are issue with SD card or issue with power supply. If you have an extra SD card, try imaging it with Raspbian. If it boots, you'll know the issue is with you current SD card. 

In general, no - GPIOs don't have a variable voltage output. If they did, we'd call them a DAC. As suggested by xPino, you might be able to use a PWM pin - but I suspect that the backlight pin on the LCD is going to have higher current requirements than can be provided by a GPIO (or PWM) pin on the Broadcom. You'll have to look at the LCD datasheet to find out. 

As you've created a tkinter program, I'm assuming you're running it in X windows. So the question is more 2 questions: 

Its reasonably likely that you blew the fuse. The Raspberry Pi has a polyfuse, which will "blow" if you draw too much power from the Pi. A quirk of polyfuses is that they can take a long time to reset. Set your Pi aside, and try using it again in a few hours, or tomorrow even. Google "Raspberry Pi polyfuse" for more info. 

The Pi doesn't have external access to high speed interfaces that would normally be used for something like this. However, for a relatively low speed like 1MHz, you may be able to get away with using the SPI bus: 

Before I start, I'd like to tell you that I've used in the past with the Raspberry Pi 2 using the same USB Microphone and it has worked just fine. For some reason, it doesn't seem to work anymore. I need some help looking for where the error is. I'll give you as much information as possible. The error started when I tried to use . It gave me the following error: 

Which means everything was installed successfully. The problem is, when running on my apache server, it says that it's still using PHP version . It's still loading the module from . I don't know where the file was installed during my build of but I've looked all over the place. I can't figure out how to build the apache module. 

Note: If you want to edit the files on the recovery partition, you have to put the Micro SD card into your computer. The text files can be edited with any text editing program. Good luck! 

I've tried making a build directory in the /lib/modules/4.1.19-v7+/ directory, but all it does is search for a non-existant Makefile. Here's what the Makefile looks like for anyone who would like to check it out. 

If this didn't work, try taking a look at this to see different solutions and for more information on this subject. Good luck. 

Well, I've fixed it by restoring from another backup I had. I don't even know if I should keep this question up. But just in case there are people out there who are as clueless as I am. DO NOT DELETE THE PACKAGE EVER Never thought I'd be saying that. Nobody in their right mind would delete their network management software, right? I learned the hard way. Took a lot of work getting the computer back to normal. Fortunately, there is a much better solution for other people that may run into this problem. Here's how you can install the package without a connection. 

Given your issue seems to be with the messiness of restarting fbi, which is intended to be interactive program, here's a (perhaps) better approach (but still simple): Get imagemagick: 

TL;DR - That cable is probably NOT HDMI compliant, but likely still works. As you said, you do need an active converter to convert from HDMI to Analog (VGA). Analog signals are not provided by HDMI. However, some cables (like the one you linked) do not have an external power source. If that's the case, then they are powering from the HDMI cable themselves. The HDMI spec says that you can draw at most 55mA, which I believe is far too little for a VGA converter. I suspect that cables like the one you linked are not HDMI-compliant, but still may work. Note: here's what the HDMI association has to say on it: 

You can add additional storage only though USB or Ethernet, as these are the only external high speed interfaces available. If you are looking for something small, consider USB flash drives. You can get them up to 128GB, for a total of 512GB on a Pi. Note, though, that its possible that you won't be able to use as many as 4 USB flash drives in the Pi if they draw too much power, but you're probably okay. Another option for something small is a USB Wifi adapter - it is small, and allows you to remotely have access to storage on other machines on the network. In that case, your storage is effectively unlimited. 

All this command does is mount the boot partition on your SD card. Which explains the error. looks for the which is located on the boot partition. If the boot partition isn't mounted, will not be able to find your file. Thus, no configurations can be made. That should do the trick. However, if that doesn't work then there's another problem. Good luck, tell me any other information about this problem if it comes up. 

About that warning with the files list file for package 'fail2ban', I removed that file in attempt to fix this problem. I tried to use but it says that it's already on it's newest version. Even though it's not working. Here are some other things I've tried. 

I've finally got it working again. I downloaded the fail2ban package from the debian package repository using . Once the package was downloaded, I used . Then following that command, I used . And finally, I used . Everything seems to be working great now. 

Everything should work as planned. This is a great way to use on debian wheezy. Good luck to anyone else trying this. I hope that this helps you out. 

I checked to see if it knew I had the USB microphone plugged in using . It gave me the following output: 

Check if your boot folder is empty using in a terminal session. If so, you should be able to mount it to the SD card using a simple command. 

To start X windows, you can enable "boot to desktop" from raspi-config. To start an app automatically when X windows starts, add a line to /etc/xdg/lxsession/LXDE-pi/autostart. It should look something like: 

Yes, just as a point of reference, I have a SIIG serial adapter (based on FTDI's FT232BM chip) that works fine. Check out: 

If you are using matplotlib, then you are using Python, correct? If so, then for FFTs, you'll likely want to look at scipy or numpy. For generating WAV files, Python includes a library called wave that can generate wave files from raw samples. 

Total speculation: it's reasonably likely that the Raspberry Pi wires the 5V HDMI directly to the Pi's 5V input. If so, the VGA converter will have power equal to 1A minus whatever the Pi uses. 

Another datapoint, if its useful. I regularly shutdown via ssh, but I run ssh from the command line (not via Putty). The following shuts down my Pi and powers off (HDMI out becomes disabled, but always on Power LED stays on). Note: this is on Raspbian, and I ran uname to show you my version. The commands below were run remotely from my Macbook. 

As concern over long-term SD card reliability is frequently mentioned (and is a valid concern, especially for low-quality SD cards), there is another approach: initramfs (or initrd). This requires a little more dirty work, but essentially you need to rebuild a kernel with your own initramfs (or separately build an initrd). The initramfs would include everything you need to run your application. As the Raspberry Pi 2 has 1GB RAM, there is ample space for most applications that do some "basic automation and statistical generation". Of course, if you need some larger application, like X or Mathematica, all bets are off (but 1GB can still handle a lot of stuff). Of course, the SD card is still used - but it would only be used at boot time. In fact, Linux would never need to use it at all, only the bootloader. If you want to keep the initramfs very small, a common approach is to use a GNU replacement, like busybox. There is lots of info on both initramfs/busybox out there, and it is not Raspberry Pi specific. 

Download the package here. Move the .deb package onto a usb drive. Plug that drive into one of the PI's usb slots. To mount the drive, use this command . sda number will vary. Move the .deb file into your home folder. To install the package use the command followed by the command . Restart the Pi. Hopefully, your internet connection will be working once again. If it doesn't work, there may be another problem. 

I've recently picked up a device that happened to use a CH340 USB chip on it. Of course, for this to be able to work on the Raspberry Pi, I'd need to install the required driver for it. I found the driver on this website, and followed the instructions on this github repository. Unfortunately, this didn't work out, and it gave me the following error. 

I'm already trying to avoid brute force attacks from bots by putting my server on a port other than 80. I don't have much experience with apache servers, but if it's possible, I'd like to learn if I could use something to avoid brute force attacks on that port. An example would that I use Fail2Ban for my SSH servers. Although this may not be important, I'm running Raspbian on a Raspberry Pi 2 with Apache 2 and PHP 5. 

I have no idea what I should do from here. Any help with this would be awesome. I'm running Raspbian Wheezy 7 on the RPi 2. 

How to modify the Beefcake module to make it compatible to 3.3V logic The Beefcake NPN transistor has a current limiting resistor R2 of value 1K. This resistor limits the base current at Arduino 5V logic high level. The base current within limit, after amplification (usually hFE > 100), is big enough to engerize the coil. Calculation of Arduino 5V GPIO current into Beefcake relay module: Arduino current i ~ (4V [Arduino High] - 1V [Vce(sat)]) / 1K [R]) = 3V / 1K = 3mA However, the Rpi's logic High signal is lower than Arduino, so the corresponding limited current is smaller and after amplification is not big enough to drive the coil. Rpi current i ~ ((3V [Rpi High] - 1V) / 1K = 2mA The modification is simple - just replace 1K R2 with a smaller resistor, say 510R. Rpi current i (after modification) = (3V - 1V) / 501R = 4mA I am making education guess based on circuit analysis and experimentation. I think my guess is 90% likely correct. Risk Analysis Though the small signal NPN transistor 2N3094 can be used for small load switching, it is not that reliable. For relay switching, it is safer to use power transistors such as SS8050, UDN2981, specially designed for inductive loads. The OP wants a safe method which would not fry his Pi, so for reliability, a source driver such as UDN2981 is the way to go. / ... # Solution 2 - Using UDN2981 to drive the Beefcake relay module # The comments point out that the OP's Sparkfun Beefcake relay module is high level trigger, therefore the commonly used sink driver ULN2803 cannot be used. A driver similar to ULN2803, but current sourcing, rather than current sinking, should be used instead I think UDN2981 is a suitable driver for the OP's relay module. I verified successfully UDN2981 driving a high level tirgger relay module similar to the Beefcak, and ULN2803 a low trigger one. Below is a summary. UDN2981 controlling High trigger, NPN transistor input type relay modules I first manually tested UDN2981, without connecting to Rpi, to blink 4 LEDs, to make sure the circuit is working OK. 

Generally, yes. In Android, the question about whether or not an LCD will work, and what you'll have to do to set it up, is really a Linux question. Do you have drivers for the LCD? If you have drivers, and can build them into your kernel, and configure them correctly, they will in general expose an interface to /dev/fb. Android will automatically find that interface and use it as your display. 

Use it to convert images as needed directly to the framebuffer. Depends on your framebuffer (which you can details on in /sys/class/graphics). Lets say the framebuffer was 640x480, and color depth 8:8:8. Then you could use a single command line something like (untested): 

There may be some trickiness if your fb is 5:6:5 format, as I believe imagemagick does not support that. Note that because imagemagick's convert utility understands practically every image format, you can replace my_image.png with most any image. (Imagemagick has lots of other nifty features, too, for example if you wanted to add text or other overlays). 

If you are looking for something extremely simple, consider using netcat (this is similar to the ssh approach, but likely a little faster). netcat is including in Raspbian by default. On the "server" RasPi (the one that will be setting a GPIO, assuming GPIO4): 

The bigger issues are going to be how useful the data received is for analysis. Things like clock jitter, bits of resolution, and probably most importantly the analog front end will strongly effect what you can do with the data. For example, if you have a specific signal you are searching for, then the details of your implementation will very well matter. But, if you just want to use it to get a rough assessment of the signal, the above will work fine.