Your constant time function looks very much run-of-the-mill constant time, which in this case is great :) I don't think HKDF warrants a function where and are compared using a random key - but now you know about that neat little trick. Note that you may want to make sure that you document that the comparison needs to be done in constant time or include it in a verify function (beware of truncated values - you did this in your code, but you need to consider it in the calling code as well!). 

This lets you easily create a parser that returns an implementation of the interface. But if you just need to test your code you can simply create a direct implementation of the interface, if required using an internal or anonymous class. 

As for handling large amounts of data: implement streaming using calls to update. I presume that this is for relatively small strings, but you may want to document that. 

The class has too many fields; either split it up into multiple classes or you should keep your variables local. Decide how much state your class really requires and keep the number of fields to a minimum. The class has too many imports, which means you should split up your class, e.g. using implementation classes for specific functionality. The header part could be factored out into a class. Cancelation is allowed for the header and before writing the blocks, but the operation that takes most of the time / resources apparently cannot be cancelled. Calling the add method with as parameter requires you to check all the properties within the method; it should be given e.g. an interface with getters instead. It seems that too many parameters simply contain of strictly formatted strings, do not use code: convert to a parameter class or simply use multiple parameters. If you use a string parameter with structured content, then at least create a method to validate it rather than validating it inline. The method doesn't actually add anything; it just creates a block it seems. The only side effect is that to , and that's one that should not be altered. Your class doesn't seem re-entrant. Having a single object be able to be used by multiple threads seems a good idea. Exposing the internals through getters is a very bad idea; implementation specific details should be hidden. Methods such as are specific to class and should therefore not be in a class (do not create circular dependencies!). Similarly, contains code that is package specific and should therefore probably be in another class / location. Don't overuse a class like ; just use private (static) methods instead if it is specific to a class. 

I was afraid that you were implementing PBKDF2 yourself, but you seem to be correctly using the proper crypto calls. 

The idea that you need to pad keys supplied by the users is very dangerous. It lets users believe that their key is secure, while it should be either 16, 24 or 32 bytes for AES. There is a reason why PHP / mcrypt is being deprecated, and this is one big reason why this is the case. 

You are sometimes assigning a null pointer to a variable, even though you immediately assign it to something else directly after. This kind of double assignment is generally not required. You are sometimes calling public methods from other public methods. This is dangerous if you allow overriding your class. Sometimes you are calling public methods instead of directly assigning the variables. Calling is not necessary; it won't do anything but setting the next pointer. 

The header doesn't seem to be authenticated or encrypted, leaking info and allowing alteration. should be using a password hash such as PBKDF2, scrypt or a secure variant of Argon2. It doesn't make too much sense to pass a specific and ; better just use a protocol version and use a specific cipher / parameters. parameter should just be . There doesn't seem to be any integrity protection (although using GCM as cipher may be possible). Each block should use a different IV, so using a statically set IV will break the confidentiality of your plaintext message (i.e. the stored files). The cipher class should always be local to a method; you don't want to share the cipher state over different public methods. 

A note on password verification PBKDF2 with SHA-256 should be restricted to 256 bits of output. However, that would still leave you with 128 bits. You could use this to verify the password is correct by including it to the ciphertext. The other bits of the key would still be independent from it, so this is secure. It has the advantage that you don't have to decrypt all the data - say a DVD file of 4 GiB - before you know that the password was indeed correct. It could also be used to distinguish between broken files (e.g. incomplete ones) and bad password / keys. Of course an attacker could alter the ciphertext to simulate either situation. 

Disclaimer: I'm focusing here on the things that can be improved. There are certainly good things about your code, e.g. the naming of identifiers is generally good. Design: 

The order of your calls is a bit weird, you can create salt and key outside the code block. is a magic string - it is probably better. Your encrypt and decrypt functions aren't symmetric, even though they seem to be. They should be byte array to file, then file to byte array. 

Running your class through a static code analyzer or two (CheckStyle & FindBugs, to name just two) seems to be a great idea, just like using a code beautifier. 

Otherwise the crypto seems fine and the constants make sense. I don't see too much other things wrong with it. 

First of all: your coding style seems good to me. I presume that you didn't include all comments as more comments are of course necessary. But the code itself looks OK to me; it is easy to read. Design issues: 

Yes, that's OK, if you use this to store password hashes. If you use it as a (encryption) key then you should avoid text, as it can be hard to destroy the result. 

may return a larger (for decoding) or smaller (for encoding) than the amount that was base64 encoded because of the padding; it's arguably better to create two methods rather than to determine the length, one for encoding and one for decoding, similarly for - there is hardly any code reuse anyway. : the looks like a bad way to fix the code and it is not specified why it is used (OK, after reading the code you'll find that it is because of the null-terminator, but still). making the number of iterations and including it into the result would be a good idea; another would be to include a protocol version instead (do please create a protocol description, even if just in MarkDown or similar) - note that 32Ki iterations is already on the low side. you could directly encrypt to , having an additional buffer / copy seems wasteful (see also the next point). instead of you should simply use pointer arithmetic to set the location of the salt, nonce and ciphertext. you do not need a nonce if your key always changes: and the salt will make sure of that. Just use an all zero nonce (but document why it isn't required in case somebody "fixes" your code and uses a static salt or similar). after use you may want to zero out the password and key so they won't remain in memory. 

, no need to define your own (note also that using that enum within doesn't generate an exception). Exception handling: don't just throw Exception but handle all exceptions locally, except possibly those that depend on the input. Use or one of its derived classes to handle code specific exceptions. Do not use Pok√©mon Exception Handling. All your constants are . Only expose those constants that are specific to your class and useful to the outside. Using and without braces is considered bad coding practice. You need inline comments in long methods such as to at least indicate what you are trying to do. use instead. Do not re-purpose local variables such as to mean message length in function. Don't leave commented out code without TODO: task or similar and always explain why it is commented out. Use Java New IO (NIO) and 's instead of and byte arrays. 

The salt size is 32 bytes, which is fine if you can spare that amount of bytes. However, a size of 16 bytes is more than plenty for PBKDF2. The salt is only required to avoid collisions, and I presume you're not going to reuse the password more than 2^64 times. If you generate a random key then you don't need a random IV, not even for CBC mode. Not all ciphers are created equal; you might as well standardize on one, e.g. AES-GCM which adds authentication (AES-CTR is unfortunately not available by default). However, that uses an IV of 12 bytes and adds a tag. CBC is vulnerable to plaintext / padding oracle attacks, so don't use this for transport mode security. is incorrect, it should be called . You should define your protocol and add a protocol version, so you can change your protocol later on. For instance, you may want to re-encrypt using a different hash or iteration count in the future. This can be represented using the protocol version. You may want to validate that the derived key is correct before decryption. Note that CBC doesn't add integrity protection. This also means that the decryption may not fail even if you supply the wrong key (resulting in garbage plaintext). You extract 256 bits from PBKDF2 which defaults to SHA-1 with an output size of 160 bits. That means that the entire function is repeated for the last 256 - 160 = 96 bits. This will double the amount of work on your server. Better specify SHA-256 or SHA-512 as hash. Why not use instead of ? Then you can use hardware acceleration in native code when available. Also see this question. Note that I haven't tried the speed of either of the mentioned classes, but you may want to give it a try for large files.