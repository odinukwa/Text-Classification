I've encountered experienced C and C++ developers who are convinced that Java is pass-by-reference for objects. One example I've used is this one: 

I would recommend starting with Processing.py for the first class, then "graduating" to using "pure Python" on the command line in the second course, and introducing more advanced IDEs towards the middle of that second course. 

For example, if a student has written their whole project without testing it, and wants to know why something isn't working, then the answer could be that they need to start over and only add a few lines of code at a time, so they can test it in small chunks like they should have from the beginning. Or if a student wants to know why a function isn't working, then the answer might be to ask them which line of code is behaving differently than what they expected. If they don't know, then it's time for the student to break out the debugger to narrow it down. It's up to the teacher how strict they want to be about the above rules, but at a bare minimum, teachers should spend some time really explaining the first two points. Coming with a "question" about 100 lines of code that you haven't debugged at all is a non-starter. 

I really liked that approach because it offered a little something for everybody. Students who were itching to dive into the code didn't have to listen to stuff they didn't care about, whereas students who weren't as confident in their coding ability (like me) could get a little more hand-holding without feeling like they were holding up the rest of the class. I think this format could work really well in a club setting. I'll also say that I think you should invest as much time as possible in project work. Students should spend more time coding than they do listening to you. Give them enough info to get started, but then let them do their thing. On the other hand, I also think you should allow some time for "show and tell" so students can show off what they've done, and see what other students have done. So, I would use the above format for each club meeting, where you go over some topics or steer students through the stuff you want them working on. Then set aside a day towards the end that's just for show and tell. Maybe make it interesting by having them rate each other's projects in various categories: funniest, most technically challenging, most artistic, etc. 

If the students haven't encountered these problems, then honestly they probably aren't ready to use an advanced IDE. They don't have a need for it, and they should probably stick with whatever works for them. Another consideration is that students need to understand what's going on "behind the scenes" before jumping into using an IDE. At a bare minimum, they need to understand: 

Bigger isn't better. My guess is that it's more accurate to say that novices have trouble working on projects that are useful and interesting in real life, which is not necessarily the same thing as larger projects. In fact, a common trap that I've seen self-learners fall into is taking on projects that are too large! This leads to burnout, stagnation, and a bunch of unfinished projects. As a specific example, I see a lot of novice game developers get stuck thinking they need to develop a game engine. They'll spend months (or years!) working on the engine, without ever developing any games. What they should be doing is working incrementally on smaller projects. Start with Pong, not with a game engine. So, at the risk of mu-ing your question, my answer is: don't work on larger projects. Work on a small project, and get it "shipped" before starting the rest. Put a link to it on your online portfolio. If you don't have one, then your first small project can be building your online portfolio page! Put a bow on that code, and then start over on the next small project. As you learn, you'll find that code you look back on looks pretty terrible. "Oh man, I was an idiot 6 months ago!" This is a completely normal feeling, and it's a sign of how much you're growing. But it also means that you don't want to spend a ton of time (more than a few weeks) building up a codebase, because you'll either have to rewrite it a bunch of times as you improve, or you'll be stuck building on crappy code. IMHO, it's much better to give yourself a blank slate pretty frequently. That being said, the other half of this is finding projects that will be useful and interesting in real life instead of all of the disconnected snippets you're used to writing from tutorials. This isn't an exact science, but I think the best thing you can do is incorporate your non-coding interests in your programming projects. Here are some examples: 

Students are often faced with a feeling of "I don't even know what this is asking me to do" when given an assignment. That's where long-term planning comes into play. Maybe have them rewrite the assignment in their own words, or ask a series of questions that help them understand what's expected. Stuff like: What's the input? What's the output? Short-term planning involves questions like: 

You could extend (heh) your lesson to include custom painting. Basically, you do this by extending or and overriding the function. This is how "real" Swing components draw themselves, and it gives students a window into how everything works behind the scenes. You could have them draw basic scenes, animations, or even games. Or you could have them create custom components like circular buttons (disclaimer: I wrote this example). If you have enough time, you might want to split this into multiple lessons: start with basic Swing, then do a lesson on input listeners, then do a lesson on custom painting. At the end of those lessons they'll have enough knowledge to create some pretty fun programs. I'd also urge you to stick with functional GUIs instead of using a non-functional chat application. Make a fun calculator that does something like convert dog years, or create a basic game that plays rock-paper-scissors. Encourage students to make these as interesting as possible. IMHO this is much more engaging than a non-functional example gui. 

I don't think you should teach the loop and then point out all of its "flaws" when compared to a traditional loop. You should treat them both as tools, and different tools are used for different tasks. Maybe teach them a bit of the history (traditional came first, then was added in Java 5) and show them an example of when it would be best to use each. Also note that you seem to be skipping over a third looping mechanism, which the loop is based on: the . Compare two tasks, like printing out every value in an and removing all elements that match a certain criteria (for example, values that are less than 0). Show them how you'd do (or how it's not possible to do) each task in all three types of loop. With the simple printing task, the loop is perfect. Using a traditional loop or an is probably overkill for this task. But with the task of removing elements, the loop will throw an exception! If you're using a traditional loop, you have to loop backwards or be very careful about which index you're looking at (otherwise you might skip elements). And an is probably best suited for this task. The point is that everything in programming should be treated as a tool. A tool isn't inherently better or worse than other tools, it's just better suited for specific tasks. Talk about those tasks. 

It sounds like you've already answered your question, but I'll throw in my two cents: It depends. Does every software engineer need to simulate the differences between direct-mapped, 2-way set associative caches, and 4-way set associative caches? Absolutely not. I've been a programmer for about 10 years now, and I think I have a pretty successful career, and I have no idea what those things even mean. However, should some students, who are particularly interested in these kinds of things, take a deeper dive? Absolutely yes. So, it comes down to a question of: is this course designed for students to get a high-level overview of computer architecture, or is this a more specialized course designed for students to get more information about the low-level details? In other words, is this a breadth or depth course? You might want to give students a high-level overview, and then point particularly interested students at further reading, more advanced courses, or specialized fields they might study in grad school. 

Like other answers have said, you should make it clear that asking questions is a good thing, and not something to be embarassed about. You might encourage this by asking specific questions: 

None of the above require any advanced knowledge of computer science to at least dip your toes into the water. As a CS educator, you might volunteer to "guest lecture" the class, give them a basic demo, and have them work on some basic projects that introduce the above concepts. Or you could even "teach the teacher" and give them a lesson that they can then deliver to their students. The real point is that there is no shortage of intersection between computer science and other fields. It's all over the place! Just take examples from real life, and think about the most bite-sized introduction you can come up with. Show that to the students, and you'll have a bunch of "oh, I didn't realize programming could be so interesting!" 

Most things in programming should be thought of as tools. Languages are tools. Algorithms are tools. Various approaches are tools. Different tools are for different jobs. A carpenter learns about a hammer, a saw, a wrench, etc because sometimes the hammer will be the best tool for the job, sometimes it'll be the saw, and sometimes it'll be the wrench. Sometimes, the best tool will be something the carpenter has never used before! But the more tools they already know, the easier it'll be to learn about new tools. Having learned about a wrench makes it easier to learn about a screwdriver when you need to. So learning about a tool is never wasted time: even if we don't use the tool every day, it helps us learn about stuff we need to know. That's why we learn about a bunch of different things in programming. Sometimes a loop will be the best tool. Sometimes a recursive function will be the best tool. Sometimes we'll even come across new ideas and approaches! And we can use the tools we've already learned about to help learn about these new tools. So even if recursion doesn't solve every problem (just like a hammer doesn't cover everything a carpenter has to do), it's still worth learning about because it adds a tool to our toolbelt. 

Have you considered submitting your teaching materials (lesson plans, homework assignments, etc) to open-source teaching initiatives? This helps less experienced teachers, as well as experienced teachers who don't have a CS background. Search for "open source teaching materials" for a ton of results, including: 

You shouldn't teach from just documentation or just a textbook. You should teach from both. You should also include in-class live coding sessions and general lectures as well. Each of these things is a tool that covers a different aspect of what students need to be learning. Textbooks can be great for providing a high-level overview. Documentation can be great for providing more details when you need a reference. Live coding sessions can be great for showing the students how to actually write code, and lectures tie it all together. I will say that including documentation is a great idea. Students should know, from day one, how to look stuff up in the reference, how to consult JavaDoc, and how to read online tutorials. Properly using these resources should be a part of the very first homework assignment. This is a crucial step that I think a lot of programming curriculum leaves out, so kudos for including it. The problem with documentation is that it's often incomplete from a learning perspective. It's meant to be a reference, without the background knowledge that's required to truly understand how to actually write code to solve a problem. The documentation you cite provides a very brief overview of the various topics, but it doesn't take the deep dive that you need to actually learn about OOP. That's where a good textbook would come in handy. 

In addition to working on the assumptions of both your students and yourself, I'd also advise you to consider the needs of students from "non-traditional" backgrounds. More things to consider: 

You could also try searching for something more specific like "open source java teaching materials" if you have Java material. 

But taking a step back, you might want to teach the meta-lesson of finding data in the real world. There are a ton of APIs and open-source data repos out there, and finding them is a very important skill by itself- plus it give students a way to actually use their skills after the class ends. So instead of just giving your students a flat file, have them come up with their own. Maybe they use an API from a product they use, like Twitter, Spotify, or YouTube. If that's too advanced for the students to do, then maybe you spend a class coming up with the dataset together, with you writing the code and the students talking about what would be interesting to see. Or just searching for "XYZ datasets" returns a ton of results. Have the students come up with datasets related to stuff they're interested in. 

Imho, emergence is one of the coolest things about computer science. Swarm Behavior From emergence, you also get to talk about swarm behavior, including programs like: 

Meh. This seems like trivia to me. Do I need to know any of the above to solve the problems I'm having? 

These types of change have to start with you. I don't agree with a lot of the assumptions in the question, and I encourage you to take a harder look at some of the assumptions you're bringing to the classroom (which your students pick up on and perpetuate). Fix those, and you'll be able to help your students fix their own assumptions. 

This program shows a window and draws a 40x50 oval at coordinates . There are other functions in Processing. Have the students draw a basic scene. Then I'd talk about using variables. Processing has a few predefined variables that come in handy: 

The "design problem" that you were hoping they would find also depends on the context and usage of the class. We have no idea whether the users of this class are obeying your JavaDoc. In fact, I could see an argument that your "design problem" is invalid because anybody who violates the JavaDoc is going outside the bounds of your design in the first place! Compare that to the functions with no JavaDoc, and honestly I'm more convinced by your students' answers than I am of your intended answer. Asking "what is wrong with the design of this class" is too broad. You need to provide more context: perhaps provide the class and then another class that uses it incorrectly (by creating a new instance for every user, for example), and then ask what the design problem is in that code and how it could be prevented in the future. If you want a specific answer, you need to ask a specific question. All of the answers your students provided sound perfectly reasonable to me.