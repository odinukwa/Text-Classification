You can then apply this speed to the heading direction, you'll get the velocity vector (if you need it). Now be aware that if you brake your speed will need to be capped to zero: 

So for each sprite, you also need to create a set of collision circles and collision boxes that are moved (transformed) around the same way your sprites are. The rest depends on your implementation and the implementation of the collision engine you'll use. This will not give you pixel perfect collision, but it's a basis for more complex physics simulation. 

If you use an enum, how will you describe the other differences between a Robot and a Zombie? Will you have a variable to hold a reference to the graphics representation and another to hold a reference to the behaviour? If so, do you really need an enum and hard code all your enemies? If you use a parent class and inheritance, what is so common to them now that there is the need for a parent class? And if you use that, and you turn out needing a friend Zombie, how will you hack your way to avoid code duplication and have your zombie act as a friend and as a zombie? And if you decide to have a hoover enemy Zombie, will it inherit from Enemy <- Zombie? If so, how many inheritance levels are you ready to have before you consider you're really entangled in your architecture? 

So you can't just use what's provided by Google. You can use it as a reference for building you city by your artists, but you can't just download the data, transform it, and put it in your game. Unless you get a specific authorization from them. tl;dr Without a specific authorization: 

Keep in mind that with all the operations done with matrices, the order is important. I join the whole test program if you want to play with stuff. 

No, gameState and gamePhase should not be the same. Your design is correct. You can have a state machine within a state of another state machine. Keeping the concepts separated like you did is the way to go. The only issue you might encounter is that the wording you use might get confusing. 

I think what you need is Bresenham's line algorithm. From what I remember it is used to determine what point should be coloured, not how much each point should be coloured. 

One of the approaches you could take: If you could organize your points into 'objects' or logical group of some kind, you could then compute each object's bounding volume (either an axis-aligned-bounding-box (AABB) or a bounding-sphere), and with that, do a quick rejection based on the frustum of the camera and the bounds you've calculated. This strategy will leave you with some points that will not be in the frustum of the camera (because their friends are). Now it's not clear why you need to know if the point is in the frustum of the camera. If it's to reduce the load of things sent to the camera/rendering pipeline or to reduce the load of work to do on theses points, it could give you a sufficient boost that the extra work done on the points that are not seen but are not culled could be negligible. If you really need to remove all of these not visible points, you could do a second pass to see if the bounding-volumes are not completely inside the frustum (or even flag it during the first pass); if they are not completely in the frustum, then check specifically each of the 3d points to see if they're in the frustum. 

Some aspects of your issue are a little unclear, but it appears you're using a windows very not-so-precise time, and calling it many times in a row. There are a couple of ways to work around this: 

Now if A and B collide, and B and C collide, and A and C collide, you have a more complex collision. What do you do? Collision detection and physics simulation are quite complex subjects in their own. You can do some in simple ways in your implementation, you'll have to leave some more complex situation out for the sake of simplicity (for instance, don't manage the A and B and C intersection as a single collision, but 3 separate ones). Or you could try and find and integrate a collision/physics engine that is readily available and integrate it to your software for increased realism. 

Because you don't need more frames per second. Most computer monitors I know have their refresh rate around 60 Hz. Going beyond that, you would not notice the difference. More FPS for physics means a smoother simulation, but there is a point beyond which you don't gain much. Also, having more frames to pack in each second means you have less time for your game logic each frame. Locking the frame rate means the programmers know how much time they have for each task during a frame. 

The intent of your code is unclear; adding comments would help us know what you're trying to do, and making sure that we don't have to scroll horizontally would really help. The first thing I notice, though, is that you check your system AND your update it at the same time, which could result in the behaviour you have: For balls A and B, if you inspect a collision between ball A and B, and there is a collision, you change the behaviour/state of A immediately without changing the behaviour/state of B, that is, you make A bounce off B, then you inspect a collision between B and A, there is no longer any collision (because you've just moved A in the same loop execution) so you don't change it's behaviour/state. They will still collide the next frame because B is keeping on going on its trajectory and it's going to keep pushing A away in an unexpected manner. Maybe what you could do is two passes: 

You seem to be mixing polygons and vertices in your question. Polygons generally refer to triangles. As for the load on the graphics, you should probably aim for a "minimum requirement" device and see how it handles your game, graphics wise. This is going to be your maximum number of polys. 

Is your true maximum frame rate on your PC really 60 or is it more? NVida drivers limit the frame rate to the maximum draw rate of the monitor, typically 60 Hz; this is due to the fact that there is no need to ask to draw faster than what the monitor is able to process. By asking your driver to not limit to the VSync, you'll be able to see how you're doing on PC. Input/output operations () typically take a lot of resource, so this might cause slowdowns and show more on your phone than on your PC, especially when testing with the print-outs. Are you sure your bottleneck is GPU bound? Did you try to profile the rest of your application? Phones GPUs are not the only parts of a device that are less powerful than on PCs, CPUs and memory are also less powerful. I would suggest you show us first that your issues are really related to how you use the GPU, otherwise, chances are you're probably barking the wrong tree. 

This is a pure c++ error and in the future it should be asked on SO, but I'll answer at the end of the post. 

Check everything that collide and store the pairs into a list. You should avoid checking A with B, then B with A, as the result will be the same. Parse the list you build in the previous pass and resolve the collisions by modifying the position/velocity of each ball of the collision. 

You will need a forward vector which represent the forward direction of your ship, and the velocity of your ship. 

I'm lazy, so here is the way I'd tackle this issue: it would be by coupling the graphics with a collision/physics engine. You could try and find a basic collision engine for your language and implement something like this for your collisions and graphics: 

And they are done in two distinct phases, and let the user do something in between. The "something" is generally creating a 'contact joint' between the two bodies so that they physically react one to another. That is, if you want them to react. If you only want to detect that there has been a collision, you don't add a joint, and the solver does not push them around. So in your situation, what I'd do: Frame x: 

You ask the last copyright holder :) Depending on the company, however, you'll probably have to hire a layer to ask them, because their legal departments won't waste their time with non-layers. (From a webinar with a game-industry lawyer, companies like EA will ask you "Are you a lawyer?" as their first question. The source for this is here. The rest of the video is quite interesting.) It does not cost you anything just to try and talk with them. Depending on the company (and your company) you could work a deal or something.