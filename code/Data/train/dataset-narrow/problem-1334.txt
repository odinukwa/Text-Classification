No validation at all of $_GET and $_POST? It doesn't look like namespaces support relative navigations, but that seems a bit dangerous, except if you can Always Trust User Input. The "init stuff" could be put in another file and required. Ã‰NS is a bit weird for an application name (private joke, sorry). 

have a real module put your current class (renamed as ) in it add those functions in the module, not the class fix the return type to return what lxml returns 

Unfortunately there's not much you can do here. Unless you try the difficult but efficient approach at the end of my answer, your for loops won't go away and you will need to understand what takes you time inside those loops to get small wins. Micro-optimizations You need to profile the code to understand what takes time: 

Better CoffeeScript First of all, if you're going to use CoffeeScript, then use its full potential and do away with : 

I'm not a Delphi programmer, but here are a two comments based on what I understood. Use an enumeration type instead of characters ('n', 't'...) to determine the type. It seems that TArray is a dynamic array, that is, it shrinks and grows automatically and in a smart way based on usage. "Smart" here means that the array size does not change too often: when you need more space, the capacity is doubled, avoiding costy reallocations. It guarantees a small cost for such updates. That's a part of TArray that you did not 'emulate'. 

You should use only for mutually recursive types. Concurrency could as well be defined just above . Returning unit is implicit and not needed. Pattern matching 

Since lxml is written in Cython, I think you can't monkeypatch lxml directly anyway, so subclassing is the way to go. lxml could have chosen to make things easier by using just like numpy does for facilitating ndarray subclassing. 

Mixing SQL and HTML makes the code a bit hard to read. This applies to all your code: please indent in a consistent way. Make sure that your code works without JavaScript: provide an action for the form that will do mostly the same thing than Ajax. is unnecessary, use . 

Can I ask why you're trying to do this? If this is homework or a way to "practice Java/Object-Oriented programming", please say so. If it's a real question, the best way to represent XPath input is actually a string. XPath is way more complicated than what you've (XPath 2.0 even more so), and you would need a lot of more work to model this properly. If it's a subset of XPAth, then what subset? Edit: A few examples. 

See how this gets down to the essence of it? Of course this can be made much faster by using numpy arrays (and ndarray for more than one more neuron). So, now, how do you implement XOR? :) Use the Tensorflow playground to try and get intuition about this. 

returns a , not an . Tell scanf you only want 9 characters (+ ): if you want to avoid a buffer overflow. You should test the return of . Calling twice is surprising. Why don't you store the return value of ? You could print errors on the standard error stream: -> -> -> . Typo: it's multiply, not multiplye. 

You should return the string here, instead of echoing it. This is better design for a number of reasons: 

This one is useful! is clearer than . This answers your first question: it depends! Use new variable names when they do make thing clearer, but never use dummy names like , , and so on. By the way, I may be mistaken, but are you certain is necessary? Java should do autoboxing. I would simply write . 

They key here is to to be able to abstract common functionality away. You're not expressing "node[i] is in the neighbor array" nicely. Simply write a function which does it for you: 

Oh, so maybe they are different variables after all. is better than , but you can probably find a better name. second = Label(text=var,fg='black',bg='white').place(x=200,y=40+adjust) adjust+=20 Do you need to assign here? 

It seems you got this one correctly looking at your code. (If not, never leave non-working code in a way that suggests it works.) 

welcome to Code Review and thank you for your question. You need to profile the code to see for yourself where it is slow. Firebug and Chrome can do this. Only then will you be able to optimize your code. Side note: Be careful about variable names, some of them seem to be in French (dossier). 

At this point, even when quickly looking at occurrences of "chance" in the rest of code the code, I have no idea what are. This deserves a better comment. 

Did you consider making this a REST API? Read more about The Good, the Bad, and the Ugly of REST APIs and REST APIs must be hypertext-driven from the creator of REST (this is one is a bit special, no need to follow it). Aslo try explaning how your API is better. Perhaps that's obvious, but it would still be good to explain it a few points for someone just stopping by and wondering if he should use it or not. Anyway, here are my observations. Feel free to discard them whenever you don't agree. I'd be glad to discuss in the comments: 

It depends on a lot of factors, there's no universally "optimal" size. 512kB is probably good enough. If you want, you can always benchmark it for various buffer sizes: this will let you know what the best option is for your computer and OS. 

Disclaimer: I don't know Ruby but code in similar languages. This looks "dried" enough to me. What would enhance readability though is to write this one simple line. It would show in a very explicit way that you are simply building one string (and would also make this shorter). Is it possible to make a one-liner out of this in Ruby? Also note that "DRY" in Code Review stands for "Don't Repeat Yourself", your title is thus a bit ambiguous. 

either you simply set to True, which can only have an effect when the thread goes through your statements, so it won't interrupt the processing: you don't want that. either you also , but this is can interrupt both the processing and the upload... and you don't want that either. 

Testing JavaScript code in jsFiddle to make sure it works is suicide. The difficult part about JavaScript is really cross-browser compatibility, which means you just can't just test in one browser to say it works. That being said, the name makes me think that you want to return true/false, which is not what you're doing. You should use DOM's , which already implements what you're trying to do. It's DOM 1, so it's safe to use and will work in any browser supporting JavaScript. By the way, why are you using this funky syntax to create your function? Is there a good reason not to use ? (You should accept seand's answer, though, I didn't know it wasn't supported until IE 8. You should also consider using something like jQuery which will help you avoid mistakes like that.) 

If you only expect one result, the is not necessary. Also, be wary in general not to mix SQL and HTML: different parts of your application should be responsible for querying the database and printing the output. However, for such a small script, it's OK. 

Please use braces everywhere, the code you're using is known to lead to difficult reading and subtle bugs. Consider: 

Your code is correct. What can be improved is readability and speed. First thing first, don't mix up the computation of the function and the computation of the derivative. I understand that passing to the function to get the derivative can be convenient, but consider doing something less confusing. 

I think the helper methods are useless since there is no abstraction: it just does two separate things. This does not help that much, and it's better if opening the file is explicit: the code is easier to read. 

It actually should be put in the view. I don't know how RoR implements it, but the submission status should be retrieved by the controller and transferred to your view. The view will then decide which CSS class to apply. You could use a substitution test to know whether it should belong to the view or not. If you were to substitute your current view by an entirely different one (eg. an iPhone app), would get_status_css belong in your model? I guess not. This is not too important when you only have one view or if your views are all web applications, but can help separate concerns. 

Yes, microtime is designed to be used for this. The PHP documentation mentions this use case for . Consider putting this into a loop and print out the average result: if the measured time is too small, you can't provide a reliable estimation. Concerning the MySQL request: you should switch to mysqli or PDO. 

Use offsetExists in offsetGet instead of repeating yourself? Consider using instead of null, and instead of true, even if they are case-insensitive. forgot a semicolon? Don't use return if you're not going to check the return value. 

I don't know if it is considered idiomatic PHP or not, but it seems more readable and less error-prone to me. PDO and exceptions already gave you a way to get rid of the first in , but it's not enough, you should also remove the second one. I assume it comes from the possible exceptions in and . The issue is that you're catching the exception but doing nothing with them. You should instead embrace exceptions. :) A good first step is the call. Since there's nothing you can do to handle them in the factory: you should instead let the application code decide what to do if something fails: for example, display a warning message to users and send an email to the administrator. 

Those functions only complicate your code since the abstraction offered is not enough to compensate the added complexity. 

While it's possible to do handle each problem individually, I think it's much better to use something like Kubernetes, Docker Swarm or Mesos to do this. It's more complicated at first, and it forces you to do things as the authors of the tool consider they should be done, but it also avoids a number of headaches. In those cases, the configuration is done through environment variables, which works very well for static configuration across dev, test and production environments. (Also, receiving live configuration changes is something I've never heard about. Configuration does not change that often, and I believe it's simpler to start a new container when it changes. But it probably provides other benefits too.) Okay, now that I have said this, I'll consider in the rest of my answer that using Consul was indeed the right choice for reasons that are specific to your team. The code itself This will be shorter since the code is actually good, surprisingly so for someone who says to be new to Python. asyncio is well used, but that's less surprising if you come from C#! A few comments: