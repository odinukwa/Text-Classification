All good answers. I'd like to add my two cents to @deepee1's answer. If you keep the FoodItem class he provides (with a constructor), you can create a list of food items and then create everything else with completely DRY code. You can even easily move the definitions out of the code. Not to mention creating n different UI's with the same "logic". Here's what I'd do: (Forgive any mistakes, long time since WinForms :) ) 

I wouldn't presume the metadata information gathered from reflection as mentioned by w0lf will be handled completely if you reference the Model property directly from the lambdas. 

I've done something like this a few times (a lot even), but most times it was a complete waste of time. You will probably not earn the time you save by not doing WebForms markup, even if it's terribly boring. If you have like 100-200 entity types to display in similar lists, it might be a useful path, but if it's 10 - go with good old aspx/ascx markup. If you don't need a lot of business rules and/or scalability in some form, go for markup only with SqlDataSource and WYSIWYG listviews. If you need a fancy UI, go with Telerik. Given you actually have multiple customers with different list needs for the same entities in the same product, this might be "the only" way, though. With regards to your code, it seems slim and clean enough. But beware when going further with this - you might get a lot of conflicting requirements. As you say, it's a good thing to separate responsibilities, so keep doing that if you really want to make something "re-usable". (It won't be, but still..) 

Good, you made it this far. If you're anything like me you should be almost translucently red with anger by now. Please understand that I was in the same place as you are now - probably worse, as I didn't know much about NaCl or authenticated ciphertext. Unfortunately I don't think your code has any value. You should see it as a good learning experience and a reminder not to write wrapper classes. And you should not do this even if you're going to be an absolute expert in crypto. Otherwise you are going to spend a significant amount of time in the future trying to remove your wrapper class from the code base. Been there, done that. 

A different idea of handling this (for you to ponder over). Define your protocol somewhere and store a protocol version in your hash string. You could even use that to replace the salt size, iterations, hash type etc.. Then if you choose a higher iteration count you could just update your protocol version. 

Property will expose the current value on postback by it self. You could also expose an event on your control that you refire in the ValueChanged event of the hidden field. 

You could possibly swap with . If you can, you should generally try to avoid too many subqueries. At least attempt to indent them properly. You could also benefit from having a look at common table expressions. These can help you group up the subqueries in predefined results for your query. Makes it a lot easier to read. $URL$ 

If you do this, you'll probably see some pattern emerge. I can already see two classes, or rather instances of a- instead of one. Maybe something like Strategy? 

Instead of wrapping the proxy creation in a concrete service proxy implementation, I'd write a concrete service factory instead which in turn uses the ChannelFactory. The service factory class could also use an interface for creation, so you can have multiple concrete factories. $URL$ That way your code can continue to depend on the interface only, and you can change the way the proxy is created without writing concrete proxies. You could also have a "local service factory" which doesn't go over the wire. Usage would be something like this instead: 

In general you should try and avoid floating point operations for any cryptographically specific code. Floating points have issues with regards to precision, and even I don't see any issue for this specific code, they always require special attention, e.g. during reviewing of the code. Similarly, using recursive code is strongly discouraged for cryptographic algorithms. If your code can be coded using loops and only local variables you should really do so. I imagine that goes against the idea of Rust (and is thus up for debate), but crypto code generally requires special attention. If you keep to recursive calls make sure you document them as such, both inline and in the function description. Although you nicely implemented the destructor it makes more sense to create either a class with just a (now called I presume) or simply keep all the data in parameters / local variables. The idea of just keeping the is that you may reuse the object to derive other keys using the function but with different salt / info. In that case you obviously need to retrain the to clear the input key material. Note that the internal key handling (padding, initial hashing) of HMAC is always the same. So a sneaky speed up is to perform pre-calculation on the salt which acts as the HMAC key (mainly useful if there is a lot of output expected, this speedup matters more for e.g. PBKDF2). 

Entity Framework implementation assembly References Model and the Entity Framework / System.Data.Entity assemblies 

I would refactor it into a plugin that takes the content as an option. Then you will have two instances of "dialog controllers" each with its own events. Have a look at the "plugin with data" example in the jQuery docs. $URL$ You'd set it up like 

Overriding the property in modifies the behavior of . Which means you've broken the OCP. Besides, what do you expect to be if you have just set it to 10.0? (Does it even compile when you only override get?) What you could do is employ the template method pattern: 

As a sidenote, I'd look for another name than "BaseClass". It doesn't say anything about what it does. 

Not entirely sure I got your schema right, but something like this should be possible. (omitted a bit of ordering, and I assume you only have one current year) 

You're creating a CBC wrapper, but your wrapper uses HMAC for authentication. This is great, but you would not expect HMAC for a CBC class. Even worse, you're making the mode of operation part of the interface. This is the wrong way around: a mode of operation uses a block cipher to be implemented. And a block cipher certainly doesn't include HMAC. Furthermore, you're also adding HMAC for CTR mode, which has many uses for specialized encryption constructs, which would not be available for your class. I don't think you should do this, but if you do you should do this by creating a separate class that performs the calculation of the authentication tag. Inexplicably, you're not adding HMAC for the old CFB mode that nobody uses anymore. That means that your code is not symmetric. Fortunately you do use encrypt-then-MAC. So your complete design is off, to the point that it should not be used. 

Or better yet, build the initial list based upon content in a dictionary. That way you don't run the risk of having typos in the switch or the initial setup: 

I don't immediately see any efficiency issues with your code. It's simple and concise. But I do notice that you don't follow all the best practices for plugin authoring described here: $URL$ I guess you'll do something else than alerting ten times in production? ;) 

Of course you can expand on that by employing the template pattern for the extra parameter settings. I would also look into extracting the parameters to a "parameter object" instead of several parameters. 

Even though the code is short and pretty enough, I think you'd benefit from reading about the strategy pattern and state machines. Go ahead and google it for a wealth of resources on good programming techniques. You'd also be much more confident in how it works and how to arrive at those patterns by employing unit-testing and test driven development. (JUnit is a good start) Good luck with your assignment! 

You are allowing direct access to the elements rather than just the content. This allows the user to create any kind of structure, including lists that keep going round. Instead of going through the elements by exposing them, I think you should create an iterator that allows you to go through the elements and then retrieve the contents. If you remove the first element with a specific content then you should probably call that function . Note that you are combining two things here: searching for an element and removing that element. Although a linked list is generally not fast when it comes to indexing elements, you could still implement indexing. Keeping the size is definitely a good idea. This is obviously a bit of problem if you allow direct access to the elements. Functions like are dangerous as you don't know the size of the list or its elements (besides that, how do you know that T enables this function, am I missing something?). If you allow direct access to the elements then you may be able to delete the element while an outside user still holds onto a reference to it. 

You aren't renaming it either, you're naming the parameter for the anonymous function the lambda expression represents. But if you don't like the lambda syntax, there's also overloads taking the property name as a string. 

I'd use enums. My suggestion presumes you are able to refactor your existing code a bit. If your control can be modified to keep the position value in one property of the following enum type, this will work. 

You don't have to use x as the parameter name for the lambda. You can call it model with a small m for instance. 

AFAIK, you won't get client-side validation of VG2, but otherwise I can't see that it shouldn't work. (There is probably a client-side event and a method you could call to duplicate the behavior for the client)