I take it your various applications are available via HTTP/HTTPS. In that case you have a couple of common options. 

DKIM is so frequently mis-configured that I don't reject on it. Many signers don't publish their public key. Both SPF and DKIM data are used in generating spam scores for message that haven't been outright rejected. 

It may be better to generate the key on the client system(s). You may end up with a larger authorized_keys file, but it is easier to disable a compromised system. If you migrate the server's private key, you will need to regenerate and migrate the key to all the client systems. Each client should have it's own key. Putty uses to generate the key. will also provide the public key in the correct format for pasting into the client system. It is best to protect the key with a passphrase if it is being used for login access. or can be used to hold the unprotected key in memory so that the passphrase does not need to be reentered on each connection. Once you have added one key and set the protection, you can add additional keys with needing to reset the permissions. I usually upload the public key from the system with a name like where example is the name of the system the key belongs to. Many implementations have returned to using as the key file. This file can be used to restrict the system the key will be accepted from, force a command to be run, limit access, and other things. View the page for more details. In some cases, it may be useful to have multiple keys on client system. This can be done to support batch processes which run with keys which don't have a password. 

None of the tools you are considering provide guarantees against concurrent modification. However, do you really need a point in time snapshot. If so use the LVM snapshot option given above. As you have given rsync as an option I assume that disk to disk backup is an option. Least secure is dump which takes a copy of the disk blocks as they are read. Given the size of your data there is likely to be significant differences between the directory information and the data. For disk to disk backup you could consider dd to partitions of the same size as an alternative. Both solutions do essentially the same thing and have the same problems. Tar will read the files one by one and will read to the end of each. If a file is renamed or deleted while tar is backing it up tar will back up the file it started reading. It is a reasonable solution for log files. Rsync behaves like tar, but only copies changes. Essentially it will copy all changes to the directories. With a date based log rotation scheme (logfile.yyymmdd) instead of the common rotated version scheme (logfile.1 logfile.2gz ...). It can efficiently backup your logfiles. 

The simplest setup is to use your domain registrar's name servers. This will work well for a simple domain. Is also means you you don't have to learn how to secure a public bind server. These days you need to secure the server against use in amplification attacks in addition to the standard infrastructure security. Also you need at least two name servers preferably in different geographic locations. There are services which will provide secondary servers for you. If you use your own name servers (ns1, ns2...), you need to register both their domain and IP address with your registrar. They will provide the IP addresses as additional information records for name server requests. EDIT: For subdomains like www.example.com you don't need to provide additional name servers. Just register the subdomain in your domain's DNS data. The name servers for a domain will serve all subdomains not delegated to other name servers. Only sub-domains delegated to other domain administrators require name servers be specified. 

Plug everything into the switch. Give the server an fixed addess which has apporpriate access to the Internet and an address on the 192.168.100.0/24 subnet. Set the default route on server to the Firewall. Block access the 192.168.100.0/24 subnet access to and from the Internet on the firewall. 

I don't believe supports split DNS. The normal way to do this would be to configure the device that should pass through to use external DNS servers. can be configured to send different hosts different resolver lists via DHCP using tags. If you aren't using DHCP for the server, configure the server to use external DNS servers. It seems like you may be configuring a proxy server. They usually have configure options for the DNS servers the proxy will use. can be used to specify the auto-configuration file that specifies the proxy address. 

Most email servers can be configured run in queue only mode. If you also disable the queue runner process, mail will be accepted but not delivered. You can check for outgoing messages by examining the queue. If you know the email addresses you don't want to sent email to, you could create aliases that drop the messages. Exim uses a target of to do this. You may need to configure the mail server to include or ignore the domain name in the alias lookup. Disabling the mail system listener may work, but some programs invoke sendmail directly and don't need a listener. This may annoy your programs though, and some may try to find a working relay server. Blocking outbound traffic on port 25 using iptables is another option. This will annoy your mail server though. It will retry transmissions, and eventually try to return your messages. Automating the cleanup in combination with one of the above would be the best approach. 

In a case like this, I would send an Inform message. If that fails, then I would try a Request. In either case, I would sniff the network to see what traffic is being passed. Before trying to get this information I would ensure there aren't any other programs listening for responses. They are likely to get the responses you are looking for. 

You should configure DKIM and SPF for the domain you are sending mail for. Given the subdomain . it is likely sending traffic for the domain, and has email addresses like . In this case, you need to configure DKIM records under rather than under . The SPF record for could be as simple as . There is no reason why the mail server cannot send mail a different domain such as and/or . For each domain configure DKIM relative to that domain and an SPF record for that domain. It is useful to define an SPF record for the mail server domain like . This allow SPF validation of the host address. You should also consider configuring DMARC records. These are defined relative to the domain in the sending email address rather than the domain that is sending the email. I have posted on Securing your Email Reputation with SPF, Implementing DKIM with Exim and other subjects. The DNS details for DKIM are applicable to all mail servers. 

@Hubert's solution should prevent email from being delivered. You could also configure the email server to redirect to the new domain and send a fake bounce message indicating the new domain. This approach is discussed in the Exim documentation. You may also want to setup an SPF record indicating the site as not sending e-mail would be an additional indication that the domain is not involved in e-mail exchange. I like the concept of being able to specify the domain as non-email with a null MX. It would help determine if incoming mail is arriving from a bogus domain, or is being sent to a bogus domain. SPF does a good job of this but the null MX would fill in some edge cases. I also validate incoming servers using SPF and refuse email the SPF record exists, but the server is not allowed to send email from the originating IP address. This is outside the design, but fits the requirements as the mail servers need to be able to send and receive administrative email. 

I have run into three cases with various init scripts. user@host has the privileges to shutdown apache2, but apache runs on port 80 which requires it be started by root. Use sudo to restart apache2. user@root should be able to reload apache2 though. If user@host can start apache2, then you likely ran into a timing issue where apache tries to start before all the children have exited. Reload can be used apply many configuration changes, and does not require the old children to exit before the new servers are started. See the documentation for . The PID file got changed to a different PID by running start when the server is already running. Stop tries to stop the process from the PID file, but it is no longer running because it failed to get resources used by the old process. 

Your mail server is not configured to allow unauthenticated senders. This would be normal on port 587 (Submission) but is incorrect for an MX which must allow unauthenticated user to send mail (but not relay to other domains). 

There are a number of recent changes to both server and client software designed to resolve issues with SSL/TLS vulnerabilities. It is possible one of these is causing an issue. If your certificate has only a SHA-1 signature this may cause it to be rejected. 

If you want to verify that the destination is valid, you can use callouts. However, Gmail may end up blocking you if you do so. The following code from the standard configuration does recipient callouts. 

Don't put the gateway line on the server with the Internet connection. Its 192.168.100 address should be the gateway address for the other hosts. See for information on the interfaces file. 

Your email looks spammy to me. Even if I had registered, I likely wouldn't open your link. You need a lot more detail in your message. 

Scan the files in for the invalid addresses. You can mark an address as delivered with a command like (use the invalid address) . You can clear the messages with the command . This will try to deliver all messages in the queue. You can block incoming messages to old addresses using an alias in like: 

If your mail server identifies itself as , that should be what your PTR record has. It is perfectly fine, for your mail server to identify itself as when sending and receiving mail. You have an A record for , and that is the address which will pass rDNS validation. Given your pointer record, you should configure your mail server to identify itself as . You can leave your record pointing to as mail servers shouldn't be verifying the name of the server they are sending to. Most legitimate mail servers pass rDNS validation, as yours will when using . Consider setting up SPF records to protect your domains. Domains not sending mails should have a policy which prevents their use by mail servers or as sender domains. In your case I would allow mail from and , and not allow mail from . If you are using as convenience to access your mail server to send and receive mail, then I would consider not allowing it to send mail. (Mail will originate from . You could change your record to , which is a more traditional server name. In that case, I configure SPF to prevent mail from , and allow it from . Once you get this working to your satisfaction, look into adding DKIM and DMARC functionality. 

The router on the 192.168.1.0/24 should have a route for 192.168.2.0.24 via 192.168.1.30. You could add this to individual devices on this network. The wireless router should be routing all traffic to 192.168.1.0/24 to the router with the address 192.168.1.1. However it may be Masquerading (NATing) traffic. Disable masquerading for traffic to 192.168.1.1/24 if you want devices on 192.168.1.0/24 to be able to connect to devices on 192.168.2.0/24. Add the route in the control panel of the router on 192.168.1.1, save and apply. This should make it persistent. Adding the route by executing a routing command will not be persistent. However, if you can add commands to run on reboot, that would also be persistent. 

EDIT Something like this should forward all unhandled mail for local domains to notlocal.host.ref.example. Mail for root is not forwarded. This router has not been verified, and does not handle address validation. You may need to remove the cannot_route_messages from a prior router. 

IPv6 addresses are not precious, although hosting services are unlikely to want to become tunnel brokers. IPv6 should not require NAT although there are experimental implementations. The major advantage of IPv6 over IPv4 is that NAT is not required. If you are trying to get IPv6 on your LAN, configure your LAN for IPv6. The disadvantage is you need to firewall appropriately, as you no longer have NAT protecting your network. You could use 6to4 to create an address based on your LAN's external IP. This will give you a /64 block for your LAN. You could then route this over your VPN to provide IPv6 access to your server. This would not be globally routable, as external hosts will route to your LAN. (You could try the same on your server.) I documented my experience with Implementing IPv6 6to4 on OpenWRT, which is mostly applicable to other Linux based servers (configuration is different). However, I would recommend using a tunnel broker. They will provide at least one /64 block, and will provide additional blocks on request. Skip using a VPN for IPv6 and use Firewalls to limit/permit access appropriately. I switched to a tunnel broker and documented additional setup in Implementing IPv6 Part 2. 

Use your exchange server as a relay to send your email. Unless you do the correct DNS and SMTP server configuration, your Linux server will likely look like a spam source. This will cause you problems delivering email. EDIT: You can setup a server on the Linux server using the Exchange server as a smarthost. 

All authorized mail servers should be listed in the SPF record. As you now have a new authorized mail server, it should be added. Some SPAM checks differentiate between listed (A, MX) and permitted (~all), and will not treat unlisted address as a pass. This penalizes senders who don't send via an approved server (often spambots). The policy indicates that the user doesn't really care who uses their domain, as compared to the policy that could get the email blocked or quarantined. The alternative approach is to configure the new server to relay messages using the existing server. It is common for applications to allow an email relay server to be configured. In python, you would configure your VPS server name instead of localhost. Whichever server is sending email, it should add the required headers when receiving the message from your application. Alternatively, you can add the headers in the application. There is a defined format for the date in the Date header. The Message-id header has a defined format, but it not as strict. Message ids resemble an email address, but the left side should be a unique id.