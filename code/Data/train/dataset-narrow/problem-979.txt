In doing this, you now know exactly which dimensions you should be applying to your filter - only those that pass this validation. How you decide to handle cases of unexpected parameters or validation failure is really up to you, but clearly in those cases, you would not want to apply filtering on those dimensions. 

...into their own classes or logic sections. This code really is a bit of a mess to be honest. You one attempt to implement an object (account) is sort of ill-conceived in that it is really no different than just using a stdClass object. There are no meaningful methods on the class and no encapsulation of data. Many of you functions have to instantiate their own dependencies (i.e. DB connection) rather than just have the dependency passed to them. So you end up setting up and tearing down DB connection way more than needed (you probably should only need to do this once.) You have coding style issues around: 

I don't think database retry logic should live in this one central place. To me that is logic that should reside with any given model in that there may be some cases where a retry is needed and some cases where it is not. I would also favor other methods to prevent/resolve deadlocks rather than just blind retry. If your table gets into a bad state, just blindly retrying queries over and over could actually exacerbate the problem. 

Or something of this sort, such that you don't have to traverse this multi-level template structure. You just seem to be wasting a lot of iteration looping over the template because it may not be structured in an optimized fashion. 

I would strongly encourage you to familiarize yourself with PHP's and related classes. They are much more powerful in working with date manipulation than the old procedural functions. This can eliminate large portions of your script where you are doing things like manually building date arrays and finding first days of months and such. 

From looking at the rules in your class, I actually question if there is really much value here, as really the only validation rule you have here that could not be better fulfilled by built-in PHP validation functionality is you validation. You could just as easily use or here. For example: 

Should this be a concrete class at all? These seem like they should be static methods. There is nothing that you are doing here that would seem to necessitate a concrete instantiation. 

In your output, consider keeping spaces around all used for concatenation. This helps make code easy to read and allows for good visual line breaks in editors if a line does happen to go too long while editor is using "word wrapping". Also, I think using objects (as mentioned in data structure comment above) instead of associative arrays helps in readability. This along with suggestion to use constants might yield code that looks like the following: 

You have some cases where you seem to unnecessarily create new variables. Some examples follow: There is no need for here: 

Why should any one concrete model determine when the DB connection is discarded as is done in your method? What if there are other models still active in the system that need this connection (you are trying to use a singleton after all. Again, just pass the PDO dependency to this class and leave the management of connections elsewhere in your code. 

I would consider whether you should assign value to those URI path segments in this class (i.e. which segments specify controllers, actions on controller, parameters, etc.) You should leave it up to your router and controllers to assign meaning, not the class that is simply trying to encapsulate the state of the request. 

Your search query will not be able to leverage an index on the fields you are searching within. This is because you have a wildcard at the beginning of the search string and a default B-Tree index only works for prefix match use cases. So when the LIKE condition has a wild card at the beginning, you will need to perform a full table scan. Full table scans are REALLY bad from a performance standpoint. It looks like you use case would work best with natural language full text search (MySQL link here - $URL$ ). This would require change to both your query and the database schema. You also do a lot of individual single table queries here. My guess is that you can possibly optimize this by utilizing joins to get date across table with a single (or fewer queries) vs. reading data from one table, then another based on that result, then another based on that next result, etc. 

I think you are abusing the singleton pattern. Have you considering taking the approach of dependency injection? By doing this you can invert your execution logic and clean up the weird behavior. IMagine a call pattern like: 

So, now that we have established that you are not truly getting "everlasting" sessions, let's get into the security aspects. Here are a few PHP documentation links I will refer to: 

Good comments from @Magnus Jeffs Tovslid that I would like to add to. It seems like you have at least three logical layers to the user experience. First, you have what you call the , which doesn't seem to have any "room" behaviors at all and whose relationship to s is unclear. What is the function of the room? What is the meaning to the end user? Why does it even exist? Is this really more of an abstract class that you will use as the prototype for concrete rooms in the application which inherit form this prototype? Is simply a bad name to indicate what this class is for? Then you have the . I don't understand the difference between and properties on the . Your written description that users fill the queue until there are enough to fill a game, at which point a lobby for that game is formed, does not seem to be matched by your code, which seems to spawn a every time a user joins the queue? Perhaps my confusion is because you are not showing your complete code (something frowned upon here actually). Finally, you have the . I don't understand why would extend at all. This seems to be a totally different construct used for a totally different purpose (of actually managing game state?), and in fact holds a one to many relationship to a given and has no apparent reason to extend from at all. The truly owns the and even injects dependencies into it, so I actually like the instantiation pattern that Magnus suggests which more truly reflects that s own the logic for instantiating the .