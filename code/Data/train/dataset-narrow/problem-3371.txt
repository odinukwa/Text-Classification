QEMU has an ARM emulator. It's a SW emulator and you should have a powerful Linux box. I personally use QEMU to run a test suite on raspbian to test a shell script. I didn't try to run a web application. But I would give it a try. I published the steps I executed to create the QEMU image on my Linux desktop on this page. Hope it helps you to get a QEMU raspbian image up and running very quickly :-) 

The exists a nice tool called pishrink which reduces the size of a dd image as much as possible by shrinking the root partition. If you start up the restored image the first time the partition is expanded to it's maximum size again. If you run Windows just use your Linux on your Raspberry to shrink the image. 

By accident I detected this question. raspiBackup can also be be used to restore the backup created by raspiBackup (See $URL$ So I'm wondering why you're asking how to restore the backup. Anyhow - a main design principle of raspiBackup was it also should be possible to restore everything with just plain Linux tools. raspiBackup saves the boot partition in an img. The root file system can be saved with dd, tar or rsync. So in order to manually restore the backup 1) you have to recreate the partition layout with the information available in sfdisk file 2) format the root partition 3) restore the img into the boot partition 4) restore the root partition with dd, tar or rsync Hope this helps even my answer it's quite late :-) I suggest to place all questions about raspiBackup on the website in a comment because that's monitored by me. Update 11/5/2017: One user of raspiBackup manually restored a backup and described the steps in detail. See here for details 

Run terminal on your mac and do You should see two lines, one with local loopback (127.0.0.1) and another one with the IP obtained from the router (192.168.XXX.XXX) Check that the IP you are trying to reach is within the same subnet with yours (only the last number on the IP should be different) Another way to check if you are on the same network is doing a traceroute to this IP - should be one hop, not many. SSH to it and answer "yes" when it's asking you if you want to establish the connection. 

I checked on my RPI and it looks like executable permissions is set automatically by g++, so you might be missing the './' bit before the program name you are attempting to run if you are in the same directory with the binary: 

Are you editing /etc/crontab or /var/spool/cron/crontabs/*? can you copy the output for the whole file? 

Shared hosting is not that bad - their servers and infrastructure is much more reliable than your RPI or your internet connection are. If you don't need the history of data and only want to display current figures - why not have your Arduinos UDP-broadcast temperature data or send it over to a message broker hosted on RPI and just display current figures on the screen. This approach enables you to plug and plug a data logging device into the network and log the data at any time without having to rebuild/change anything. If you need the history, take a look at RDDtool, database targeting the sort of data you are wanting to manipulate. It provides integration means for different languages - whatever you find easier to code. 

You are probably going to get your best answer from official RPI web site. There are hints in their FAQ section that kind of give clues to what your chances are: Will you sell a self-assembly kit? 

There exists a backup tool for Raspberries called raspiBackup. If you restore this backup on a different SD card you're actually cloning your Raspberry. 

The exists a nice tool called pishrink which reduces the size of a dd image as much as possible by shrinking the root partition. If you start up the restored image the first time the partition is expanded to it's maximum size again. If you run Windows just use your Linux on your Raspberry to shrink the image. 

I don't suggest to use noobs which makes a lot of thinks much more complicated. Install Raspbian on a SD card instead. Next create a file called 'ssh' on the boot partition. If you have a Linux box handy mount the SD card and partition mmcblk0p1. Then just execute 

Assuming pi_0 has IP 10.0.1.1 on the external network and www is the connection to the internet. Just enable routing (add net.ipv4.ip_forward=1 in /etc/sysctl.conf) on pi_0, define a static route on the router to the pi_n subnet (route add -net 192.168.1.0/24 gw 10.0.1.1) and set the default gateway to pi_0 on all pi_n (route add default gw 192.168.1.1 eth1 ). 

Update 7/13: This is an important issue for me. That's why I posted the same question in this forum and consider that post as the primary post for my issue from now on. 

Check whether your ssh daemon is up and running and listens on all interfaces. Execute following command as user pi on your Raspberry sudo netstat -tulpen | grep ssh 

You also can use tar to backup your root and boot partition. tar will backup only used space. To backup the root partition you can use following command: 

I never used etcher. Whenever I prime a SD card I use the dd Linux command. Windows guys use win32diskimager. Anyhow: The etcher doc states it's checking the cloned images. If that's true then it seems the image you use is somehow broken. On the raspbian download page the sha1 is listed. Please use sha1sum to verify the sha1 of the downloaded zip file matches to the published sha1 and download the image again. 

But in my python code when i import cv2 i am getting the error as no module named cv2.I have checked my usr/local/lib/python2.7/site-packages and it is empty. How to solve the issue? 

Eclipse is installed and i am able to open the IDE through VNC.But there is no run configurations set in eclipse.It is asking for new run configurations. Even in the run configuration there is no JRE option. 

Anyway the code publishes to node red for first 20 values then stops. My Nodered workflow is as follows.. 

I am using my python code to publish messages to node-red via mqttc. The problem is after 20 mqttc publish,the data is not getting published to nodered. Here is the python code i used for posting to node-red. 

I am trying to play a wav file in my raspberry-pi using pygame. I am able to play the music in the speaker.But the sound is very low and many noises are coming along with the sound. Is there some specific setting i have to do with raspberry-pi to make sounds work. My code is as given below. 

Just a single word change and all is working fine.. Figured it out. Instead of 1 in mqttc.publish 3rd argument tried with 0 and all is well. The parameter for mqttc connect is Quality of Service $URL$ MQTT defines three levels of Quality of Service (QoS). The QoS defines how hard the broker/client will try to ensure that a message is received. Messages may be sent at any QoS level, and clients may attempt to subscribe to topics at any QoS level. This means that the client chooses the maximum QoS it will receive. For example, if a message is published at QoS 2 and a client is subscribed with QoS 0, the message will be delivered to that client with QoS 0. If a second client is also subscribed to the same topic, but with QoS 2, then it will receive the same message but with QoS 2. For a second example, if a client is subscribed with QoS 2 and a message is published on QoS 0, the client will receive it on QoS 0. Higher levels of QoS are more reliable, but involve higher latency and have higher bandwidth requirements. 0: The broker/client will deliver the message once, with no confirmation. 1: The broker/client will deliver the message at least once, with confirmation required. 2: The broker/client will deliver the message exactly once by using a four step handshake. 

The way to boot from USB has changed. The latest raspbian image 2017-04-10 supports direct boot from USB and you just have to copy the downloaded image via dd or windisk32imager to your USB device. In the past you used an SD card to boot and then switched the root device in cmdline.txt to /dev/sda2. That's the way for Raspi1, Raspi2 and Raspi3 to boot from SD card but run everything else from USB stick. Raspi3 doesn't need the SD card any more. There is one important step you don't have to forget when you want to use Raspi3 to directly boot from USB: You have to enable boot from USB only once in your Raspi3. It sounds you didn't do this. You wrote you want to setup a clean system. So I suggest to execute following steps: 

I have a very nasty issue with Jessie :-( Background: I wrote a tool called raspiBackup which backups and restores a Raspberry and because it works fine for me and helped me multiple times to recover from a SD card failure I decided to publish it. It's already used by a lot of people. Issue: When I restore the clone/backup of Wheezy created with tar the system comes up with an IP address. When I restore the clone/backup Jessie created with tar the system doesn't receive an IP from my local dhcp server. If I start the original image everything works fine. When I restore the clone/backup Jessie created with rsync the system works fine. Backup options used with rsync: -rlptgoDWDEHAXx Backup options used with tar: -cp --selinux --acls --xattrs I also compared the two logs /var/log/syslog from the original Jessie system saved with tar and the restored Jessie system which doesn't get an IP. Original image: 

Unfortunately you need console access and a connected monitor which is very inconvenient because raspiBackup is used most of the time on headless systems. Another solution is to use networkd on Jessie. It seems somehow be related to systemd which is new in Jessie and the different way a backup is created with tar and rsync. Does somebody have an idea what's the root cause for the issue? My goal is to have the restored Jessie image to start again like the original image with an IP without any workarounds. Update 6/25 I started two Raspis - the original and the clone image, enabled debug on dhcp and extracted all dhcp messages from /var/log/syslog. I noticed 

There are quite a few posts raising pretty much the same issues as yours I believe. Here are a couple. Most advice that you make 100% sure your power supply suffices RPI and the HDD needs. Not only your HDD needs to be supplied enough power but the RPI, too. Disconnect everything from the RPI, leaving just the network and the HDD and see how this helps. I don't know what your hub make/model is, but mine has two ports that provide 1.2A each whilst rest of the ports on it only do 500mA and will require a Y-cable to connect to HDD. Check into that to see if that helps. 

Is there a board that has a few different sensors sitting on top of it and able to talk to RPI via I2C/1-Wire? 

I downloaded and installed LibreELEC 7.0.3 onto RPI2 and it won't connect to WIFI. I can't even view logs via KODI standard UI. The power button on the left bottom does not have 'exit' option - only reboot and shutdown and custom shutdown timer. Is there a way to exit to command line or boot to it? 

Is there a way to programmatically control LCD brightness of the screen connected to RPI over HDMI? As far as I could figure there is really no way to achieve this with RPI over HDMI. What about RPI HDMI to LVDS boards? Does this method give this control? There is a board by chalk-elec that mentions this capability yet I would still like to understand if getting this board is my only way of controlling the brightness of the screen. 

A better way to organize this would be setting up a media client as mentioned above. Here is a good article on this. 

I'm currently building an application core for my smart home project - there will be 6 to 10 devices on the network each controlling its own area and performing different tasks and operations - security, notifications, sensors reporting, controlling lights and devices, et cetera. RPI can be treated as a regular computer able to run regular and odd operating systems. It does meet your requirements although you seem to mix hardware and software requirements into a single stack which is bit odd. It is not clear from your question what the primary focus of Internet of Things you are attempting to build. I see two key fields Internet of Things is valid for - knowing/sensing and controlling/operating. Both are possible to a good extent with RPI in its current hardware and software state. Sensing and computing for anything complicated may not be always possible with RPI - things like face/voice identity and recognition without assistance of other hardware will be either slow or impossible, reading data off sensors and controlling servos and lights is easily done - most of stand-along solutions for this types of tasks being sold are done using hardware that's way behind RPI specs. I'd suggest that you identify your key priorities and look for example implementation with RPI.