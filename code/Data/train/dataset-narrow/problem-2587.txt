The most solid option seems to be checking for overshoot and correcting. Note: The simple code I provided doesn't account for the movement speed lost when arriving at each tile. 

I am developing a game, but as I am working on it alone, the amount of content I can create is very limited. Because of that I want my game to be modded, for this purpose I am planning to create a complete modding API which would be exposed for lua scripting. I would also create tutorials to get people started. And the "Original" game would also be a "mod"(similar to Warcraft III maps) . My question is: What can a developer do to encourage modding of its game? PS: my game is a sandbox-ish multiplayer survival(most things are procedural). 

The only tip I have is to make the conversion in one place and only one place. If you start having to do inline conversions all over the place from one coordinate system to another you're going to run into a whole host of problems. 

The only person who can determine the return is you. Are you learning something new? Are your skills improving? Are you looking at it from a "how many more units will this potentially get me" perspective? Would you get a better ROI by starting a new project? There isn't an easy way to answer that question in the general case. 

Usually what I do in these kinds of situations is basically do what you do in the first loop, but insert an abstraction between "frame number" and "texture asset" (or UVs, if you will). Basically, change to do a lookup in a table that you define for a given animation. You can set up a data structure that still works in "frames", but maybe with a higher frame rate to give you more precision. A simple example would be something like this: 

If you need to, you could use the Assimp file import library's 3ds export function to create the 3ds files directly. The procedure would be as follows: 

First off, I think using the GPU is not suitable. Your usage defeats what the GPUs are made for: One program running on a lot of threads. Also GPUs don't support intercommunication and conditionals very well. But your expectations are quite low. 20Hz for lets say 10 000 computers. Nowadays you can count with a 3GHz CPU, with multiple cores. For simplicity lets assume you only have a single thread for this virtual simulation. I am also going to assume that the Lua code(or the one of your choice) is 10 times slower, than compiled C/++ code(Can be improved with LuaJIT, but will be worse due to constant switching between computers and cache misses, etc.). 20 * 10 000 * 10 = 2 000 000 Hz needed to simulate your virtual computers. or 2 000kHz. or 2 MHz. And you can safely assume a computer with a ~3GHz core. Please bear in mind that due to cache misses, memory operations, and because you probably underestimated your instruction needs you will need much more than 2MHz, but you are safe as long as you don't need more than ~1500 times more power. I think this idea is viable performance-wise. I would recommend using Lua, so you don't have to reinvent the wheel, and have a solid base to build on. Its also easier to program for starters(if you want your players to program them). This is pure speculation. If you want a real answer, profile it. As to whether you should research further or not, you should create a simple prototype(throwaway), which will test both if your game is fun and if its viable performance-wise. 

Here's a visual way of looking at a problem. The original problem set is circle vs. rectangle (gray in the image below). This is equivalent to point vs. rounded rect (shown in black). So this is a multi-part problem. You're testing your point collision vs. 4 lines (extruded out from the edge of the box by the radius of the original circle) and 4 circles (at the corners of the rectangle with the same radius of the original circle). With the rough velocity in your original image, the point will hit the bottom right corner circle. All you have to do is figure out the point on the corner circle that you would hit, calculate the angle of that, and reflect off of it. 

where is the device resolution and is the size of play area in meters( in this case the latter is ) Note: This is just a very simple implementation, and needs some refinement, but I hope that you get the idea. Note 2: I assume you are using floating point numbers to represent coordinates.(should be the case already with lua.) Edit: In the example above (the position of the object) ranges, which means . So for example an object in the middle of the screen would have the coordinates 

EDIT: To answer your comments, there is no reason to precalculate the matrices. But I see no problem in doing so. But if you also want to interpolate... It doesn't look straightforward. Maybe you could store a matrix for every frame but that would be quite a lot of data. Well To expand on this here is some calculation: Assuming 4x4 matrices of float(4byte) data. Lets assume you have 16 bones in your model. And you want 200 animation frames. And you want interpolation so you do 2000 animation frames instead(10 subframes)(Assuming a bad case scenario). This would require 2000kB of memory/disk space. Thats not a lot.(Except if you are doing skinning on GPU, then if you consider 100 different models, this is 200MB animation data, which is quite significant.) But you could just easily calculate it on the fly with even more accuracy, and don't need to have larger files. And mainly: write, test and maintain the extra code to do it the other way around. So the more I think about it the less feasible reasonable it seems. 

Usually what you do in this case is let the sound system handle it. So somewhere there's a collision happening. And where that collision happens you call a "play bounce sound" function. In pseudocode just change your sound class to do something like this 

The formulas that you define are the game design for your game. You can specify whatever it is you want it to be. You would probably do something like define a "base" hit rate based on your level compared to the enemy's level. Maybe have weapon expertise play a role (if that's a stat in your game). That kind of thing. But if you want an example to work from, there are a lot of pages of people doing things like deconstructing the internal formulas in World of Warcraft. Like this one, for example: $URL$ 

I think you are over-using the component model. While what you are saying could be accomplished and would work, the general way of doing this is making the camera a global thing. Sometimes it is just much easier to make an exception than to try force everything into a rigid view of "everything must be a component". So I recommend making the camera not a component but rather a property of the RenderSystem. There you could even have a list of cameras, and the RenderSystem would have much more control to optimize the way things get rendered. 

To clarify things a bit: I want to create a kind of database for my game, that simply is a class that stores all game-state information like object positions, player scores, etc. The main problem I am facing, that the whole game is to be scripted, to the level of the (lua)script controlling what members should the database have. The reason for this is that I want to create a game that gives modders complete access to the game via lua scripting.(its one of the core features) For this to be viable I need to be able to add custom elements to the database. I want to avoid using a 'real' database and roll my own solution. For example I want to be able to do the following in the script file: 

I think it's pretty much universally agreed that simply mapping the analog stick to rotational speed of the character is not good enough to make console first person shooter feel good. So what are some input paradigms that make a modern FPS on the console work well? 

Why couldn't you just tag the two sets of walls (horizontal and vertical), and then do tag check in for horizontal or vertical as a wall check compared to the rotation of the world? So, for example, if the world is rotated by 90 degrees, you "hit a wall" when you collide with something that was marked as horizontal. 

Lost Garden General essays on game design theory. A good example read is an article on visualizing the creative process 

Basically its what @DanielHolst said, you can use negative coords and expand in all directions. As for storing your loaded chunks for fast access and checking you could use , Just , then your code looks something like this: 

Picking in OpenGL can be done, by rendering the primitives you want to check for, assigning each one a unique color, based upon which you can look it up. Then you can check what color is rendered for example on the center of the screen, this way getting the object pointed at. This was done in older games, but is frowned upon, because it can be a huge performance hog. 

Edit: From the video it seems you are overshooting the position you are aiming for. There are three ways to solve this: 

Instead of just using deltas, have you considered just linearly mapping the distance from the start of the touch to some rotation value? So let's say you start at position and your knob is currently rotated to point to angle . As long as your finger is held down, you update the current angle of the knob. At position you figure that you moved distance (using manhattan distance so you can go negative), which you then multiply by some scalar value to give you how much you should rotate the knob. Say 1 radian of rotation equals 100 pixels movement (so = 100 in this case). So I probably would do something like that first before going for angle checks and things like that since, as a user, if I want a knob to increase I'd probably just want to drag it to the right instead of having to drag around in a circle. If you went with the angle, the user might get into a situation where dragging "more" doesn't increase the knob as expected, assuming your knob rotates more than 180 degrees.