Since the arrow is rotating around a center point (the same point of the bow), when you draw back on the bow, you need to keep the center point at the same point as the bow, but move the arrow back across it. That way, you're rotating both the bow and arrow around the same point. 

You can further save bandwidth by only updating every so often and lerping $URL$ between the updates. I believe XNA has a lerp function inbuilt. As such, you'd go something like this. 

Acceleration is in units per second per second; it is the change in velocity over time. So you have to multiply it by time to get the change in velocity (units per second). Similarly, velocity is in units per second; it is the change in position over time. So you have to multiply it by time to get the change in position (units). You are not multiplying something by twice; you are multiplying the acceleration by to get the velocity change and adding it to velocity, then multiplying the velocity by to get the position change and adding it to position. 

Regarding the jumping problem: You need to incorporate the time since the last frame into your calculation when you apply velocity to position. Assuming you have perfected things for 60fps: 

Ogre Battle (SNES) does this, with the player having the option to cast powerful spells which are of limited quantity. 

You mention that you want this to smoothly slide from one location to another. Using a simplistic linear function, aka velocity/speed will not accomplish this. It will result in a jerky start/stop. If you want to have a smooth slide transition you will need to implement a cubic curve or something similar. The class provides an implementation of this curve through the method. All you will need to do is provide it your start and end values and a between 0.0f and 1.0f representing the elapsed time of your animation. It will return the appropriate intermediate value. 

There are likely to be other ways to deal with network optimization. Really though, you cannot update faster then your ping time and only within the limits of your upload and download speeds. Don't forget that the max throughput of a connection is Download/Ping and Upload/Ping. The data you can send will be less due to losses from header information, packets that arrive out of order, lost/dropped packets, incomplete packets, etc. We never really can update fast enough, but we can fool people into thinking that it's happening. 

I like the book Programming Role Playing Games with DirectX (2nd edition) for its scripting section; I haven't really seen a start-to-finish tutorial on making a scripting engine elsewhere. And of course, being a book, it will walk you through step-by-step creating the scripting part of the engine (and the whole rest of the game engine that he establishes throughout the book, of course). Unfortunately the source code isn't available online. Once you have a scripting engine, I would keep separate the 3D models from the scripts. Scripts are typically in the logic side of things, while 3D models are most certainly the presentation/view side of things, and those shouldn't really be mixed. When a script commands a character to "walk to (3,5)", it doesn't need to say "load walking animation, set velocity to (-1,1), wait 3 seconds, set velocity to zero, load idle animation"; you'd typically just have a function available to the script, and the intermediate code would take care of 3D models, animations, etc. But hey, if you really need to, then define your own functions in your scripting interpreter which get 3D models and do whatever you need with them. I think you're thinking a bit too far ahead; worry first about writing a simple script interpreter, and then add the necessary functions to the interpreter as you're writing your scripts. 

Any slowness in this situation would be caused by the switching of texture states, as another poster also mentioned. If you are finding that you have performance problems you can combine all of your small textures into a larger sprite sheet texture to eliminate the switching of which texture is on the GPU. You will just need to use a rect to access the correct portion of the sprite sheet when you make the call to ContentManager.Load(). 

Choose a random number, and then write an statement to return the appropriate new object based on the number. I'm not an ActionScript coder so I don't know if this is correct, but generally it would look something like this: 

It sounds like this might be best approximated by circle-circle collision. Store the balloons in terms of a center point and a radius (of a circle which closely matches the balloon art). Given this, collision checking is simple! Remember your pythagorean theorem. If one balloon is at (x1,y1) with radius r1 and the other is at (x2, y2) with radius r2, then: 

When a block moves, add it to a list that needs checking. When you check a block remove it from the list. First, decide if lines of 4+ count and if not, which set of 3 takes precedence in a row of 4. Have your algorithm check in 4 directions instead of 8. (Horizontal, Vertical, and 2 diagonal) Assuming you first check horizontally and allow matches of 4: 

I experienced some problems with in XNA when I tried to mix two different SpriteSort modes. (Begin with deferred, end, begin with BackToFront wasn't sorting properly.) I've settled on just giving everything I draw with SpriteBatch a depth value. To that end, what is the smallest increment I can use on the floating point variable that will be used as the depth parameter without running into rounding problems? The valid values for this float are between 0.0 and 1.0. It is a float, not a double, and the language is C#. UPDATE: My testing has shown that 0.008f is the smallest amount I can change my depth value by and be certain the sorting will work. I'm guessing there is something else at play in BasicEffect or SpriteBatch. What I am trying to use this for is the rendering of my game's map grid. I want to make heavy use of transparency and overlapping to create a specific visual look for the tiles, the doodads, and the characters. Essentially, I am using a painter's algorithm to draw the tiles in order from the back row to the front. I have them numbered so I know the ordering is correct. The doodads I am trying to draw on top of the map are not appearing when my depth decrementor is set to a low enough number to draw everything I will need. It only works properly in a range where I can only access about 100 unique depths. UPDATE about SpriteSortMode problems (as requested): Thus far in my project I have got by just fine using SpriteSortMode.Deferred for everything. I have all of the standard UI components you would expect, windowing, clipping, etc. working. Now I am attempting to draw my map grid. Like windowing/clipping this requires things to be done in a specific order to look right. The grid tiles draw in a certain order. To accommodate overlapping, doodads/characters draw on top of a tile before the next tile is drawn. No matter what I did, my doodads/characters would always be drawn under the tiles. Changing the order of draws had no impact. Even drawing all of the tiles and then drawing the doodads resulted in them showing up underneath the tiles. Especially odd was that my UI elements continued to appear above the problem tiles as I scrolled around the map. I switched to SpriteSortMode.BackToFront and with a high enough depth difference (~0.01) I see things drawing on the grid as expected, but this depth difference is way too high to support every visible tile of the map. I am searching for a better solution than to write code that will End and Begin a new SpriteBatch every time ~100 pieces are drawn. 

I'm still somewhat new on this, and so I may of missed some things. However, I'll try help regardless. How is simply sending a position "not enough anymore?" There will always be lag and nothing can be done about that. A game network protocol is generally unique for every game because only the people making the game knows what needs to be sent and how often to send it. Note that there are a few game engines that send all object data, and as such require virtually no code for networking. This is usually a bad idea for all but the most simplest games due to the amount of data being sent, it quickly faces scaling problems. For example, you don't need to send individual particle data across a network, but such an engine may just do that depending on how the game is coded. As such, it's rather difficult to make any such tutorial on this subject. Since this is a sandbox game, let's assume that messages have to be guaranteed since latency isn't such a big issue and most messages need to arrive safely. Let's have a look at what the minecraft protocol says about player position. $URL$ The player position packet has PacketID, X, Y, and Z. The rest isn't important right at the moment. X,Y,Z are doubles, and PacketID is a Byte. So the Packet is bye + (double * 3). The client sends this to the server at specified intervals, and then the server sends this to the other clients. You may or may not wish to send an "Ok" packet back from the server to the original client. That's really all there is to it at the basic level of a protocol. You don't want to send the position every frame as you'll flood your bandwidth. The number of updates really depends on the game. There are more advanced techniques to dealing with lag, such as prediction. $URL$ There are two kinds. First is the client doing actions without checking if it's valid by the server. Generally you want to do this for everything, because otherwise you'll have to wait for the server to respond before you jump or move. Not good. The second is predicting what other clients are doing. If someone is falling, it's pretty easy to predict what's going to happen - he'll keep falling until he lands on something or falls out of the game world. As such, you can predict his current position before the server can even give it to you and then update as needed. 

Ludum Dare 18 is coming up and I'll be participating in it. I've done a couple other short-term game competitions in the past but this is my first big one (and my first solo one). I am REALLY excited for it, but I'm wondering if there are any tricks to preparing for this sort of thing, and any advice on what to do while in the competition. So... How do you best prepare for, or participate in, a short-term game competition? Your answer can be specific to Ludum Dare but I'm really talking about any game competition, as long as it's short-term -- not the month-long ones where you casually develop your game and release it; I'm talking high-pressure, finish-in-time, pull-an-all-nighter type competitions. The Global Game Jam fits here as well, if you participated in that earlier this year. Also any tips in the context of a group of people (each working on their own solo game) would be great; I will be with the game development club at my school for most of the 48 hours (only a few other people, not a huge group). 

Most levels in 3D platformer games are built on a 3D grid. The old Tomb Raider games are very obvious about this. (Press forward and the character moves one square every time, you know you can jump 3 squares if you are running but only 2 if you are standing, etc.) Even more recent examples, such as Darksiders 2 follow the same idea. The character has a defined set of abilities with regards to how far they can jump and run. The environment is built out of pieces that are relative to those measurements. Fluid animations will hide them. Another thing to consider is that for the most part, you can simplify the movement paths in your game down to 2D when you are designing it. Consider the ball sections of Metroid Prime, or how most of the time you are moving along a corridor or climbing the side of a wall. You rarely need to turn 90 degrees in the jumping sections of those games. Usually that is reserved for the arena fights. To make it easier to restrict the player from going off the expected path, newer games often severely restrict movement-enhancing items and abilities. Today, a grappling hook is only useful on specific points deliberately placed in the world. Contrast that to the hookshot in Zelda 64, which can be used on any wooden surface in the game. Other examples include only being able to wall-run or place portals on specific wall textures. Some tips for designing a platformer/adventure game that can be applied to 2D or 3D: