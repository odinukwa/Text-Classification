I guess there are many feasible design approaches. For me what has worked best is that I created two classes: GameCamera and GameInit. GameInit holds all possible resolutions and is fairly technical, but passes the essential stuff, such as the best available screen resolution, monitor ratio etc. to the one and only instance of GameCamera. Now, you may now (perhaps rightly) say: "Are you kidding me?? GameCamera, a singleton?! Nope, I dare to say there are actually few things where a singletons can be useful, and that is if you know absolutely sure that you will not need a second instance of the class and you provide an additional 'initializer' and 'updater' functions for your game objects that will collect the essential global data from the singleton(s) (and where inheritance would be rather cumbersome to implement as you just don't want your bullet to be also camera or mouse...! To make things work, you gotta be careful though. I use in all my other classes two essential functions: Simplified that's which is called only once after all classes have been initialized, and which is naturally placed in the GameLoop. instantiates all the static global data for your object. In this function, you will instantiate your member data by copying all the essential stuff from GameCamera, e.g. etc. The advantage is that, (1) if you break my rule and dare to create a second instance of GameCamera, you could exceptionally help yourself by calling again the function or its overloaded instance where you only update the new camera stuff, without worrying that somewhere in line 14291 in your collision algorithm of your 12th .cpp file there is the need to find again the edge of the universe; (2) all access to this singleton and other global data is clean and tidy in that one function and thus easy to find/modify if you ever revisit your code. The other, copies all member data that is dynamic, such as, Zoom, Scroll etc. They get updated in the Gameloop, although GameCamera may return prematurely if there is nothing to update. Hence, your collision objects that bounce around access dynamic members of GameCamera through a pointer call in UpdateData() and update their own member data through that. For example, GameCamera holds stuff like Zoom(), ScrollEdge() etc., so the bullet's object own private member myZoom is updated when needed within . Note that there is no other call to GameCamera anywhere in my class, except by the power of those two functions--tame your singletons! However, I felt this is also not an ideal design when dealing with different resolutions on different computers when we have to deal with static "HUD" (head-up-design) objects like radars, message screen, messages etc. I thus added secondary screen-percentage units as a member function of GameCamera (going from 0 to 100) for positioning of HUDs. For example, I want a radar always to be on the top right corner (=90,90) and no matter the resolution of the screen. Now since the screen is probably more wide than high, x units are automatically adjusted by this ratio, but not the radar size (10 units) as it would appear stretched. Naturally, in my class, I have the aforementioned function that initalizes through that the necessary members, but no , as I do not need anything dynamic like Scroll, Zoom etc. from GameCamera. This ensured me that I have the same design and same game feel, no matter the prevailing screen resolution etc. I have faced no issues so far in terms game design (currently 35k lines code) and can reuse my code in other projects, as I just refurbish my UpdateData() and InitAllGlobalData() functions. But, to be honest with you, I have not plunged into networking yet, and Update() may need some additional thoughts when coming to synchronizing at runtime, but I will update this post once I get to that stage. 

(The tool uses BgSize_B16_256x192 when used like this, but libnds doesn't define that constant, so I've changed it.) There is some chance that the actual console or some emulators will still break with this, because you're allocating beyond the 128KB limit, but as long as you don't try to write beyond, you should be okay. If it turns out that it still fails, another option would be to use this: 

In both of your calls, you're asking for the two different parts to use the same mapBase and tileBase - in other words, the same area of VRAM. To make matters worse, you're actually asking the console to overwrite its own memory - it'll use the same VRAM for the map and the tiles. There's a very handy tool online for checking these VRAM allocation conflicts, and you can fiddle around with it to find some good numbers for you. However, there is one big problem: your 256x256 background is going to use up a full bank of VRAM. The NDS has 2 graphics engine, a "main" engine and a "sub" engine. The main engine has access to much more VRAM than the sub engine, which can only use one 128KB bank for backgrounds - and the console also counts as a background. You will therefore have to exploit the fact that the screen is only 256x192. The simple way would be to just move the console to the end of the bank, but that isn't possible on the sub engine. Instead, you'll have to move your background deeper into VRAM, say to map base 1 (16K), while the console occupies base 0 for the 4KB of tiles and base 2 (4KB in) for the 2KB map. Note that you must limit your background with this approach. That means you'll want to do the following initializations: 

Where trend is a random number between - 4 and 4 that remains constant for, let's say, 50 iterations of i. You may wish also to have int(50/aPower) iterations and pow(trend, aPower), where aPower is a random number 1, 2 or 3 to have the mountains a bit less boring and occasionally very steep. And finally, you may play with going an iteration back for a few steps by a small random chance to have an overhang. 

Edit: The OPs comment has been skeptical about the efficiency of the suggested negative circular bound check to improve the algorithm in order do checks whether an arbitrary 2D point lies within a rotated and/or moving rectangle. Fiddling around a bit on my 2D game engine (OpenGL/C++), I supplement my answer by providing a performance benchmark of my algorithm against the OPs current point-in-rectangle-check algorithms (and variations). I originally suggested to leave the algorithm in place (as it is nearly optimal), but simplify through mere game logic: (1) using a pre-processed circle around the original rectangle; (2) do a distance check and if the point lies within the given circle; (3) use the OPs or other any straightforward algorithm (I recommend the isLeft algorithm as provided in another answer). The logic behind my suggestion is that checking whether a point is within a circle is considerably more efficient than a boundary check of a rotated rectangle or any other polygon. My initial scenario for a benchmark test is to run a large number of appearing and disappearing dots (whose position changes in every game-loop) in a constrained space that will be filled with around 20 rotating/moving squares. I have published a video (youtube link) for illustration purposes. Notice the parameters: number of randomly appearing dots, number or rectangles. I will benchmark with the following parameters: OFF: Straightforward algorithm as provided by the OP without circle boundary negative checks ON: Using per-processed (boundary) circles around the rectangles as a first exclusion check ON + Stack: Creating circle boundaries at run-time within the loop on the stack ON + Square Distance: Using square distances as a further optimization to avoid taking the more expensive square root algorithm (Pieter Geerkens). Here is a summary of the various performances of different algorithms by showing the time it takes to iterate through the loop. 

And regarding movement, I was thinking maybe interpolating the player's position between one tile to another, but he had this to say: 

Here's a different approach, taken by electrolyte, from the TIGSource forums. He was making this platformer project (some footage here). Here's some of his explanation: 

To get the coordinates for the center of the screen I'm using the VisibleRect class from the TestCpp sample. It just uses sharedOpenGLView to get the visible size and visible origin, and calculate the center from that. 

Alright, after more digging I finally came across a more definitive solution. I posted the solution in my forum post on the issue on cocos2d-x's forum, but I'll post it here too just in case. So the real issue is that on iOS devices, device orientation isn't reported correctly, and on Landscape mode, the screen coordinates will have the width and height values swapped. To fix that, I basically used the solution described by Tim Closs in this forum post for rotating the projection matrix, with minor tweaks: New method in AppDelegate: 

assumes the background uses base 0, which obviously is no longer the case. Instead of using BG_GFX directly, store the return values from bgInit and bgInitSub and send them to to get the proper starting address: 

The really old games - written for NES, Game Boy, SNES, and even older systems like the Atari family - were usually written in assembly language. This was necessary because C compilers of the time were either non-existant or not up to the task of generating sufficiently efficient code. They were able to squeeze all of that stuff into small cartridges - for NES, even 256KB was a lot of data (though larger games existed) - because they used clever tricks, such as tile-based and low-color graphics, enabling a lot of data to be stored in very little space. Additionally, specialized chips for video and audio made it possible to handle these things more efficiently, without having to do everything in software. Over time, C compilers became more efficient and devices became more powerful - N64, GBA and later devices all used C or even C++ by default - and assembly was reserved for small pieces of code where extra optimization was necessary in order to consistently meet the 60FPS target (or whatever framerate the game runs at). 

I'm using cocos2d-x alongside with Marmalade and running some tests and tutorials before starting an actual project with them. So far things are working reasonably well on the windows simulator, Android and even on Blackberry's Playbook, but on iOS devices (iPhone and iPad) the positioning seems to be off. To make things clearer, I put together a scene that just draws an image in the middle of the screen. It worked as expected on everything else, but this is the result I got on an iPhone: 

So, after a few trips to the Physics section of Khan Academy for a refresher on momentum and some more research, I've found this series of articles on the matter: 

The only thing that should be noted with this approach is that ideally, you need a fixed timestep in your updates. I think the "Constant Game Speed with Maximum FPS" solution in this article would work pretty well. 

One funny thing is that I tried to deploy the TestCpp sample project to some iOS devices and it worked reasonably well on the iPhone, but on the iPad the application was only being drawn on a small portion of the screen - just like what happened on the iPhone when I tried using the ShowAll policy. 

Since Hearthstone is written in Unity it is trivial to decompile the scripts (because .NET), and this does in fact allow us to see the algorithm for deck building. The algorithm (found in ) is actually very simple. It basically tries to pick random cards to bring the deck to the following distribution: 

but scroll the background down by 32 pixels () and make sure you either have 32 unused rows of pixels at the top of your 256x256 image, or load your 256x192 image into the appropriate place in VRAM. The console will still clobber parts of the memory allocated for your background, but it will be a part that won't be shown, so it won't be a problem. EDIT: There is one thing I forgot to point out; this block: 

There are a number of reasons why a PC port can take a while. (I apologize if I seem to be repeating myself somewhere; this is sort of written on the fly.) Adapting controls and gameplay When you're playing on a console, this alone puts certain limitations on what you can do, since all the user has is a gamepad. Just creating 1:1 mappings between keyboard keys and controller inputs is not always a good idea - if even possible - so sometimes it takes longer to figure out a good solution. Hardware abstraction/Fragmentation When you develop for e.g. a Wii U, you know exactly how a Wii U behaves, because all Wii Us are identical. This is not true for PCs; you have many different graphics cards and CPUs, and sometimes something won't work on some of them. It takes a lot of testing to uncover these bugs, and fixing them also takes time. If you've never used your engine to make a PC version, you also need to code your hardware abstraction accordingly. Some games want to support multiple DirectX versions and OpenGL for Linux/Mac, and all of that takes time to write if it hasn't been done before. Resource contention On consoles, the game doesn't have to compete with an OS for resources, etc. - not a whole lot of stuff goes on in the background. On a PC, you have the OS running, you have a plethora of background programs, and this all means you won't get as large a share as you were hoping for. This means you sometimes need to perform additional optimizations, especially for players on lower end systems Improving assets With a console, you have a fixed target, so you write shaders, etc. to match that target. On a PC, some graphics cards support more advanced features, and maybe you want to use a better shader for those. Well, that means you'll have to write that shader. Platform-specific stuff Console SDKs may have a lot of convenient features that don't map over easily to a PC - for example, it might provide access to hardware timers or a good sound API. Those things aren't usually available on PCs; you need to use other ways of accomplishing those things and maybe that changes how you have to abstract the platform differences. 

Eventhough the idea seems very clear to me, the actual implementation of it raises a lot of questions in my mind. For some of them I feel I have very complicated solutions, while I have no idea how to solve others. For starters, the basic mechanism for moving: if the player presses right, the character will enter a "walking right". While on that state, the character will move from the starting tile until the next one, even if the player releases the right key; if the player is still pressing the key when the character reaches the next tile, the same thing will happen. However how exactly should that movement inbetween tiles work? Should it be just a regular speed being applied to the character's x position? What should that speed be in order to assure that the character will stop in the precise location in the next tile? And should that speed work with the update's delta time? Another thing that has me at a loss is how much of the sprite's positioning has to be done by the actual x,y positioning and how much should be done inside the sprite. For example, in the case of a running jump, which is, as noted, a special case of linear movement, should there just be empty space below the character (and position the sprite by its bottom) or should the y position be adjusted accordingly? I'd really appreciate some help with implementing this kind of platformer. That article above is the only thing I've found that sheds any light on how to do it, and I'm struggling to figured out the rest on my own. 

The function takes an argument to specify the number of cards to pick, and it will attempt to randomly pick that many cards matching the first unmatched criteria in the list above; if it cannot pick enough cards from matching that criteria, it moves to the next one and continues until it has enough cards. If all criteria have been processed, it just picks random, valid cards regardless of the type or mana cost. When asking for recommendations, it picks 3 cards; if you ask it to finish the deck for you, it repeatedly picks one card until the deck is full. This only applies to personal deck building; cards for Arena decks are picked by the server (see class ), and might therefore follow a different algorithm. 

Fundamentally, WarioWare DIY provides you with a very high-level rules engine - each rule (called an Assembly Instruction, or AI) consists of a trigger and a series of actions that are performed when the trigger is... well, triggered. Rules are in other words statements of the form "When A occurs, B happens", and they define the basic gameplay of a game. Obviously, A and B can be significantly more complex in a "real" game than in WarioWare DIY, but the principle still applies. There are many different game development tools out there, and different engines provide different layers of abstraction in how you define the gameplay. Something like Multimedia Fusion 2 works on a similar level to WarioWare DIY by having you define triggers and actions - but of course, there are limitations to that approach, since not everything is easily expressable in the framework provided by the engine. Using a more general engine like Unity, where you write code to express the gameplay, offers more flexibility - but you also have to handle more things on your own, so it's a tradeoff. By only having these ~5-second microgames, WarioWare DIY is able to apply a very high abstraction level. This makes it very easy to dive in, and this allows you to get some practice in actually seeing the rules that make up the game, and converting them to something the program can understand. With enough clever thinking, you can even do some very non-obvious things. In that sense, then yes, WarioWare DIY can teach you some skills that will help you to develop more advanced games. However, you still need to do a lot of thinking to convert those rules into something meaningful, and there will almost surely be a lot of things in that process that don't make any sense in a microgame - WarioWare DIY isn't going to help you much with those parts - and you also have to remember that some of the tricks you can do in DIY might not be appropriate or even necessary in a "full" game. 

The original solution also defined the virtual dimensions on marmalade's icf file, thus overriding cocos2d-x's scaling system, but I chose to stick with what cocos2d-x provides and it works just as well. The biggest difference was explicitely setting the angle to 90 for all iOS devices, since the original problem is that landscape orientation wasn't being detected in the first place. Also it should be noted that after implementing this solution, all my other workarounds for this issue became unnecessary, thus had to be removed for the correct behavior to take place. Hope this can be of help to someone! 

(These articles originally have a linearity to them, and there's more articles in between those listed above in the series, but those that I listed are the ones that relate to the problem at hand.) The solution above deals with the scenario of balls colliding, so it isn't exactly perfect for cars, but I've found a decent way around that: I store the resulting velocity from the collision in a different vector than the velocity vector from the car. Then, the car will follow the direction of the of both the collision vector and the velocity vector. Just so there's some actual change to the velocity vector after the collision, I use the projection of the collision vector onto the velocity vector as the resulting velocity of the car. Here's the bulk of the resulting code: