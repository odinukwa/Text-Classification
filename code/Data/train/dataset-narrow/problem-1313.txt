public methods The only method you call in your tester class (which should start with a capitalized T), only calls the method. Reduce the visibility of all other methods. Depending on how the type is used, the user of the API will see too many methods, he only needs one. And beside that: It's a common principle to hide as much implementation as you can, also known as 'information hiding' Hope this helps, slowy 

I tend to use enums as a thing to represent states (open/done) or constants (monday/tuesday/...). In my opinion, the calculation of a price should be in a separate type and represented by an interface, and not implemented or even delegated in the enum itself. If there's just one thing you have to consider for the calculation of the price, e.g. - maybe a stupid example - an exchange rate, you would have to call the method in the enum with an additional parameter and change all your code. If the calculation is represented in a seperate type, you just inject something like an into it, and the callers do not care. And: It's easier to test your code, since you can mock it and you won't test the calculation of the price implicitly (for those maybe hundreds of occurrences: that means, if something changes within the enum, potentiall all your test cases which call the enum, can fail). And: In mdfst13 example: The Side does know about Order, while the Order holds a state of Side, that's a bi directional dependency and is very tightly coupled... that's okayish, but imo should be avoided. 

So what would happen if a user input a negative number? This would definitely give you output, but is it valid or even usable? Overall, your code is alright. But try to avoid uneccessary spaces or excessive blank lines, it results in code that is tedious to scroll through as the program becomes longer. Try to implement the DRY Principle as often as you can, it will result in elegant code that maximizes re-usability. Putting my suggestions together and leaving some work for yourself, is the code below: 

The biggest problem in your code is that you have literally everything in one method. This is a BIG maintainability concern and makes your code really difficult to reuse and debug if something ends up going wrong. Break your code up into many small methods, this way if something breaks, or you find a bug, you know exactly where to look for the fix. 

Looks good, except: activateObject/passivateObject method: I don't see any usage of the running variable? Beside that, you don't need to do anything in that method anyway, that will be called, before the object will be returned, I don't think that is needed for a Cipher instance, isn't it? But why I'm actually answering: I'm fairly certain you won't gain any benefit by using a pool for Cipher instances. The management of the pool, the synchronizing, the maintaining of the code and the additional library will use way more ressources. A general rule is, "by definition": More code means less performance. Of course, that's not entirely true - what I want to say: If you want to improve performance, you have to measure, before and after your changes. And not only millis, but also cpu, memory, gc, io and so on. You have to be sure, you're changes actually did make an improvement and not the opposite. Hope that helps,... 

Your overall code is good, I do agree with Wenqin that a more class-oriented approach to the shapes could prove beneficial to the structure of the program. Anyways, onto the review. You are right about the use of your statements in the beginning. This can be handled in a much easier way if you just make a to store this and call it from a single statement. That way if you make changes later, it's easier to maintain and it's definitely easier to reuse. 

If this method doesn't actually do anything, it shouldn't be in the code. I would say that having copy constructors can be very helpful... If the method is properly implemented. The point of a copy constructor is that you can pass an object, which is already instantiated, to another object of the same type to instantiate it. The benefit to this is that you don't have to worry about passing a bunch of values to the object manually. You literally create the copy of the object with the values that it contains. 

The is a plain static Factory which actually creates 's and 's which use 's and 's - pretty straight forward. You can call it overkill. I call it super sexy! :P Hope this helps... 

, and instead of putting the listener and the consumer to the map, I use the consumer as key and value, wouldn't I achieve the same thing? If yes, I think you should be able to use this one: $URL$ 

I think it's too much to ask, to point everything out or give more or less exact statements about what you may need to refactor to what and why, since with some reading about the presentation patterns, you should come up with your own pattern decisions which you then will implement. I think that needs a few iterations ;-) (Check Passive View, MVP, MVVM/Presentation Model, that's the most common used, imo, or check for open source projects). Comments 99% percent of your comments are obsolete. First, they explain what the code is doing - don't comment what you are doing. They will lie one day, for instances the comment. One day it will be 30, or dynamic, or whatever. If you comment, comment why you are doing something. But in general, even that is often not necessary. In enterprise applications, it's usual because of "business illogic" / absurd requirements. Naming Try to be as clear as possible when it comes to naming. For instance, in , you declare g, d and dt, I see from the constructor, what those are. But when I have for instance a bug to fix and I know it's in , I read the following line: . I have only a clue about what dt, g and d would be. If you'd name it better, it could read which is much more clear. Also be consistent. In the name of the parameter is , which will be assigned to . So you have three different names for the same thing which makes it much harder to read. double precision I recommend to use instead of doubles, because of the preciscion problem, I think that could be a problem in the future. See wiki's "Floating Point" page, why I mention that. direction / position You might want to wrap direction and position into vectors. The main benefit would be, that you have a lot less parameters to pass and set, and it's usually quite clear, what a Vector is. Also not really sure if the calculation of the positions should be within the Projectile, since those are very common calculations - you might want to calculate those in a separate "MyMaths" type, or even in a Vector itself, maybe. The "maybe 3d in the future" problem should then be easier to implement (I have to admit, I suck at maths, so not quite sure if that would really help) Other 

Also, you should always use brackets in your statements, even if it's just one line. Not using brackets makes things harder for other programmers to read your code and increases the probability that unintended bugs arise. 

You can remove two if-statements altogether if you think about it! Also, you don't even need your first edge-case if you do this: 

I have been working on a script that automatically checks on the state of 2 services that I require to be running 24/7 on a server that I manage. The script works as I need, but I would really like to optimize it if possible. Specifically, I find that I want a way to reduce the need to type the command: 

Be more clear about what you read. And if you read something into something, make the method name clear. And why does the start() method read data? Is it because the comment (Model Initialisation) is more correct than the method name? 

The code looks very nice! However, here my small complaints: Tests The tests are good, but you're testing the implicitly, when you test the . The itself does only the following things: stream, filter with the given predicate, and count. The static methods im should be tested separately, as should the logic of the . The problem is, if the test fails, you don't know if the problem is the or the . The more "implicit" things you test, the harder is it to find the bug. You're testing with too many values. The logic itself should be the same with two values (one is a palindrome, one is not) as with four values (two palindromes, two not). If the behaviour for two or four values is different, then it's two different test cases. The lists to count/filter can have a better name. To make a test case more readable, it's usually split in the three blocks given/when/then, separated by an empty line. Setup the test data / perform the action / assertion. Also, I recommend, but that's personal preference, to static import static methods, at least the assertion methods, so it looks a bit more clean. What's missing (at least what I couldn't find): 

I have an AngularJS function that is used to determine which associative array variable is to have data pushed into it. I would love to be able to remove the switch case entirely if possible but haven't been able to envision a way to do that! My overall goal is to both improve performance, but more importantly reduce the overall number of lines if possible I also considered perhaps some type of variable interpolation, but that seemed like an investment with little return on my effort. The directive is called in my HTML like this: 

As a side note, look at how much easier it is to read! Think about what it would be like to read your code from someone else's perspective; would you think it's cluttered? Confusing? In your , this can be broken up into methods based on shape (unless you decide to create a class for each shape). This helps in maintainability also and builds on what I stated above. 

Since the http requests will be the main bottleneck, I'm not sure if the asynchronous http calls will improve the performance. The asynchronous call will be executed in a separate Thread again, which takes ressources, but your main app will have to wait for the backend anyway, right? Again: Measure. 

We actually do know what the type is, not 'compiler-time-ish', but runtime-ish... for a heads up: I'm really bad at generics and I'm not sure if that's either a bit of a misuse of generics or if it's way too complicated (or could be done much easier)... (edit: and someone should review my posted piece of code, too ...) I just introduced a TypeParser interface to support the different types (Integer, Double, String) and made the static methods instance methods (so they do bind to the type, which was the main problem, I think) and I'm sure there's room for improvement either way,... 

Input validation You do this for your statement, but not really anywhere else. While this doesn't make a huge impact on this particular program, it could on another one you write and you need to get into the habit of checking anything that you receive as input from the end-user. Here is a simple example of what I mean: 

You have this copy constructor in your class, which is confusing because your class is mutable. Typically, we only need a copy constructor if an object is immutable. If you wish to keep the copy constructor, remove the setter and getter and change the copy constructor to this: 

Another copy constructor that just takes up space without providing any added functionality or benefit to your program. I would remove it if you don't use it (unless it is required) Finally, the reason that your professor added the extra methods was to force you to protect your data. This is a normal practice in Java, but you really don't see accessors/mutators as much in a language like C++, for instance. 

First of all, it's very well written and I can easily understand what's going on. I also want to point out to another post which is similar to yours with a lot of good code, answers and comments: Object Oriented Design of Card Deck However ... What 'hurts' the most is the very long main method. A lot of things in the main method can be moved to separate types/methods, for instance, the loading of the Deck: Consider writing something like . It's still quite clear what you should happen, but it's written / summarized in one line. As others have mentioned, it's better to move the 'game itself' to its separate type. Why? Assume you want to provide a GUI for your game - what do you have to change? Yeah, a lot, because a lot of the code is not reusable. I think, with that in mind, you will have a total different approach of writing the game, its classes and methods and the control flows. And by how your posted code looks, and how you are already "thinking in objects", I think you can do that without me pointing out every single tiny thing I see - so I won't go into detail about what part of code you should refactor to where and why - which would really take a lot of time. Now, some smaller thingies: