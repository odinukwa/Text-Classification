My assessment of the code is that, as a Util method, it is poorly named too. The methods are not self-documenting. I read , and with two lists as inputs, where is the Id? What does 'updated' look like? I am at a loss. What I can say is that there is some black-box function that does some update, but, does it manipulate the data in first, or second? Why is 'second' specified first? Why is it not: Also, why does an function return a value, and not update something? it should be called or just . Or, does the function do both? Does it update values and also return values? Yuck!. The function. Does it subtract the first value from the second, or the other way around? I presume this method has the signature: 

Still, that is potentially buggy if the last line has a terminator, since it only strips 1 char. Your version may be better, but it's still simpler with the pre-stripped input file: 

It's interesting that you chose to put the code in its own package. I think it's great - but it does make the code a little more difficult to run as an experiment, or on ideone, or something. So, I encourage you to use packages, but remember that the main function/entry point will need to be in a different directory. Now, as a package, there should be no reason to have an exported function . Why have you capitalized it? It should be . Then, working through your functions, the next most striking thing is the poor choice of variable names. x's that are "lines", y's that are "triangles", etc. Worse, you use the variable in two different ways in the two different functions. Renaming some variables made it easier to read. Finally, the tool will re-format your code to conform to go conventions. You should always do this for your code. It helps when sharing go code with others. With those changes, I would consider your code to be reasonably good. On the other hand, I did mess a bit with the method to use instead of direct index assignment. I feel the append helps by making the at the beginning and end of the line more obvious. I also moved the special-case of the first row outside the loop of the method. This makes it clearer, I feel. So, your major issues are code style, and naming. The actual code is otherwise OK. Some tweaks may help readability - but that's something you should decide whether it's better. I put those changes together in a runnable format in ideone. 

Note, doing things this way means that a lot of the hard work is only done if the message is actually going to be printed. IO operations @Tim indicates that re-reading your config file each time is slow. He's right. Reopening your log file each time is also a problem. A better way to do it would be to open the log file just once, and then to flush it after each write to it. That way, if your application dies, it has already flushed all of it's logs. Low-Latency The process of actually printing and writing out to file is really slow, especially in code that is otherwise performance sensitive. A good solution to this is to use multi-threaded logging.... Have one thread that listens for events on a queue, and your application just dumps stuff on the queue when a log is required. The cost of dumping an event is much less than the cost of actually writing and flushing the IO. An is a good option. You have a thread that simply does: 

The concrete implementation of the Abstract is somewhere else (often un-documented). Examples of this type of factory pattern are: 

Then there is no need to indent, or so on, for the remaining code. The remaining code looks relatively good. There's no error handling on the operation though. One last thing, your first comments are duplicated: 

Generics can only go so far to help you, and, this is one of those times where it just does not help all that much. In essence, you have the following: 

Your solution of converting to is novel, and effective, but it really should have a comment on it explaining that you are going to re-split the String and parse the new as part of the integer, rather than as an operator. Leaving it as it is required some detective work on how it functions. Bug: Your system will fail on things like: (ignoring the whitespace). Your inner workings of the and is a bit messy, though. A logical progression for your challenge would be to add, say, a operator.... which would require a complicated change. Operators of equal precedence should be handled together. treating specially when compared to makes it awkward because you have to test all combinations inside the breakdown.... I would suggest using a smarter split expression, one that splits on the gaps between the operators and the values...: 

EDIT If you look at the math, you will see that, we can do much better than , and can determine that if we find a value that is a multiple of both and that the final result will be a multiple of that value. If we can use that value as the 'step' then we will go faster than just using . Similarly, if we can find a multiple of all , , and then that would be a good step too. So, consider the following: 

the second stage involves processing the KEY_FRAME records, and identifying where the Second_Packet records are. From the map, order the requests to happen in byte-position order from the stream. Here we scan the file again, in order of the Second_Packet byte positions and the KEY_FRAME instances they belong to. 

Why build your own implementation when you can use the features available in the Java standard libraries? IdentityHashMap gives you all the features you need, and a Java Stream/collector will allow you to extract the map easily from your collection.... 

Use the 'repeat' as a flag set to negative for nothing. This allows for input like which will output (which would be impossible without the 0-repeat option). Note that the repeat is now also used as a flag for the isDigit check. a do-while loop instead of a while-do loop (as per Josay's comment). 

Sub-Categories The sub-cateogory option is not awful, it is done by grouping related parameters together. For example, the two times could be one class: 

Note that methods should do one thing, and one thing only. Your rollDice was rolling the dice, and also printing the result. Printing the output should be the responsibility of some other method. A switch statement will help your turn methods: 

Now, this client/server setup is simple. It is a call-response type only, with a 'success' indicated by 'OK'. Anything else is a problem. The protocol can be set up that the client pushes the arguments, and then closes that stream.... and then waits for results. Closing the stream has the advantage that we can read the arguments nicely (wait for end-of-stream): 

In general, the code is not primed for a sight-unseen review. I would need you sitting beside me so I can ask questions as I go through. That is not really suitable for Code review. As an aside, I believe having a class that represents the sequence that is being used would make a really big difference for this code. You need to extract out the class, and iterate it to find 'the spot'. 

That replaces all something-stars-something patterns with nothing. Note, this pattern will have the following results: 

Data Storage The best way to store your data will depend on the system you choose to store it in. Right now you are undecided. That's OK. Your Reminder class is flexible enough for it not to matter right now. You can adapt at the time it happens. 

I would expect the second stream to produce the same results as the first, but the second stream will produce..... from what I can tell, the same content, plus an extra copy of the start URL. It will also re-scrape the last THRESHOLD number of pages (but assuming the pages did not change, it will ignore the scraped URLS). Odder things will happen if you call multiple times, from multiple different threads... You have a race condition in your analyze code. The following is broken: 

Your expectations are unrealistic. It is not reasonable, with current mobile technology, to brute force a password in any realistic time frame. There are three factors that you should know here, though... 

Because your code uses the StringBuilder.insert(0, ...) mechanism, and because that is an \$O(n)\$ operation (because it has to move all the other characters that come after the inserted value), the overall complexity of the code is not \$O(n)\$, but rather \$O(n^2)\$. Changing to an append will bring the code back (closer) to \$O(n)\$, where each character is copied only once.... See the differences between: 

With this code, there is no need for the 'Top' sort method at all, it's superfluous. Your recursion entry can change from: 

The Code for the Branch class will need to allow you to track the branch weight, and to add Items to the branch. Then, at the end, return the Items too. 

Trick 2: The precision of standard integer data types are not able to accommodate the size of factorial numbers up to 20 or so. You need to adjust your calculations to do manual overflows, and so on, when you calculate this way. I would consider using a long-form arbitrary precision multiplier for it. Code Style note that it is no longer good practice in C to pre-declare your variables at the top of each method. You should be declaring them where they are used. Additionally, capital-case single-letter variable names are not friendly. and should be and or something. 

does not add the second value . You only add the on the second time through, when and .... Your code above is equivalent to just: 

Once you have the class instances in the map, you are singing ;-) That's enough for the reflection, but what about the rest? Your runAllProblems() does far too much. At a minimum I would expect a method that contains: 

Your question is not very clear... but, the way I understand it is: Collect all the unique values in , and count how many of those unique values appear in . Interesting problem.... instead of a straight join with all the conditions, which may lead to an internal cross-product (thousands of joins and results to run comparisons on), I would state the logic as a couple of subselects ... which represent the two sets of data... the unique values in t1, and the unique values in t2. Note, the 'union' operator does a distinct as part of the union.... 

creating a new short-term is not perfect, but is still very fast (it will be cycled out by the garbage collector very quickly, and not impact that very much at all). There are perhaps better ways though... I don't use the commons library, so was not aware that the FastDateFormat class was thread-safe (it probably does what I suggest above), but, at the same time, the extra log-method is a good idea because it brings all the different log places in to one spot so you can change formats, etc. with just one changed line of code. 

Types Given the description, I would assume that the return value is supposed to be instead of .... ... but, you are not using the more general value, but instead the . Always use the most general class type for your interfaces. Also, by keeping the data as Integer values, you are doing a lot of boxing, and unboxing in the loops. Really, you should keep the calculations as Java primitives (), and then box the results if needed. Conditions Your code has a special-case for row 0, where it returns . By preference, I recommend not having special cases, although it is a rule I bend often. Still, after the special case, you then check to see whether it is . This does not make sense because the case returned from the function, so the other condition is useless. Well, not quite useless, it avoids an error condition for negative values. But, the negative-value condition should have been checked at the method start. Basically, it is a useless check. Consider this restructure: 

And suddenly you will no longer be constrained by memory (though it will be pretty damn slow still). 

I think that you have confused yourself with your code, and the way that data structures are intended to be implemented. What you have done that is unconventional, and causing the confusion, is that you have exposed the Node class as a public class, and you have a constructor that takes Nodes as input. Node is normally an implementation detail of a data astructure (your KDTree) that is transparent to others. Consider Java's LinkedList, that has Node instances, but you never see those Node instances, just like ArrayList has an internal array, etc. Your KDTree should contain the Node class as an inner (nested) private class, and the users of your KDTree should never be able to see/access those nodes. Your KDTree class should abstact that interaction away. The constructor for your KDTree should be able to construct off the base values of the node, or be an empty constructor, and have an add method that takes the base values. Consider something that looks like: 

Similarly, there are a lot of other places where you can reduce the code footprint using the loop. Switch on Enum With your buttons represented as enum members, your big switch statement can become: 

But, in reality, I would use an Executor service.... Executors. Executor services work best with Daemon threads too. Here's a method that creates a Daemon thread for an Executor service: 

Put them together with an or condition, it says: split the input on the gaps before and after or . Now, you can just initialize the result to index-1, and then loop through the rest.... : 

while we are on it, you have successfully turned your Java semantics in to Perl... was that the intention? If so, there's better ways to handle problems like this... an is the better/right solution. try-with-resources is your friend, learn to use it: try-with-resources Know your standard libraries... Java can do a lot of what you are doing in it's native libraries. Learn them.... use : 

Then, your code is not as general-purpose as I was expecting.... Your code only ever finds solutions where the position (0,0) is a queen. Now, that's not to say that solutions with a queen there are wrong, but, are you sure? What if there is no solution with a queen in the corner.... If you know for sure there will be one, then you should at least document that..... if not, then it's a bug. All in all, your code could use some more help to get it readable. 

Your concrete TwitterStatus class would, in a single-threaded application, be OK for the purpose of having a single-set ("lazy set", or "set and freeze") mechanism. Two concurrent threads each setting the value, or one thread setting, and another thread getting the value may cause problems though. The situation can be relatively easily resolved with an AtomicReference value though... Consider the following value that replaces both the and fields: 

To me this indicates that the best way to manage this problem is 'the hard way' of typing in the method name. Using the stack-trace is not used by any popular system. Now, a second issue is that Logging is enabled, configured, and diverted based on the 'key' used for the log message. This is typically set as the full class package.Name. Your code is losing that information, and using just the one Logger instance for the LogUtils class. Thus, there is no way to configure the method entry/exit logging for just one class in your system. For your LoggingUtil class I would consider the method: