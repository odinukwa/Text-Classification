By pseudo-polynomial we mean assuming bounds on $|c_i|$ and $|p_j|$, can a polynomial time algorithm be achieved? It's clear that if $(2)$ pseudo-polynomial solution $(1)$ will also have a pseudo-polynomial solution, by iterating over various values of $C$. Therefore in some sense $(2)$ is a more difficult problem. Moreover, knapsack can be seen as a special case of $(2)$ if we set $f_j=a_j$. Therefore it can't be strictly polynomial. But I can't tell much more about the complexity of these two problems. 

Suppose we are given a directed Graph $G=(V,E)$ and there is a nonnegative weight $w(u,v)$ is defined for the edge from $u$ to $v$. The task is to partition vertices to $A$ and $B$ (partition means $V = A \cup B$ and $A \cap B = \emptyset$) such that the following value is minimized: $$\Sigma_{u \in A, v\in B} w(u,v) - \Sigma_{u \in B, v \in A} w(u,v)$$ Here the difference with the classic notion of min-cut is the presence of the negative term. Otherwise, a max-flow algorithm between a pair of vertices would have been the answer. Can this problem also be formulated in a flow framework? Besides that, is the best way to do max-flow on all possible pair of nodes, or there is a smarter way to do it? 

This is simple. You have basically a Hasse diagram on which you need to perform a topological sort to determine the order in which to complete a set of tasks, some of which depend on others. Each subset of the tasks for which order is not significant can be executed in parallel. You can divide these into your "cells" (threads?) however you please. So, for example, based on the graph you gave, you ought to get a list of sets: {C, A, B}, {I, E, F, G}, {K, L, H, J}, {D} Each set contains all tasks that must be completed to fulfill the prerequisites of the tasks in the next set, and all tasks in a set can be executed simultaneously. 

I think I might have a solution for this. We build a graph $G=(V,E)$ consisting of nodes $V=\{a_1, ..., a_n, b_1, ... , b_n\}$ and edges are consisted two separate sets $E = E_1 \cup E_2$, which are defined as: $E_1 = \{(a_i,b_i)\}$ and assign $w_i$ as weights to these edges. $E_2 = \{(b_i,a_j) | b_i < a_j \}$ and assign $0$ as weight to these edges. Lemma: This graph is a DAG. Because every node is only connected to a node that has a strictly bigger value. So there is an absolute ordering for the graph. Lemma 2: Any non-overlapping subset of intervals corresponds to a path in the graph $G$ and vice versa. Moreover the length of the path equals to the sum of the weights of the intervals. a) subset to path: Each subset of intervals will be equivalent to choosing their corresponding edges in $E_1$ and then these edges can be connected to each other using the edges in $E_2$. Because edges in $E_2$ have zero weight the total weight of the path is equal to sum of the edges in $E_1$ which is the sum of weights of the intervals. b) path to subset: Because the graph is a DAG the path doesn't contain two of the same edge. Moreover if two edges $e_1$ and $e_2$ are on the path the cannot overlap. Therefore any path will be equivalent to a non-overlaying set of intervals. Also the sum of the edge weights in $E_1$ is clearly equal to the sum of interval weights in the subset Therefore, the problem of maximum non-overlaying subset is transformed to maximal path. In a DAG there is an algorithm of $\mathcal{O}(N+E)$ that computes the longest path. Now since we might have added a quadratic number of edges this will be $\mathcal{O}(N^2)$ solution. The rest of the complexity (including the sorting part) will be lower. 

Using BNF with your unique-repetition operator, says that an is an instance of symbol , optionally followed by an instance of set , itself optionally followed by an instance of set , and so forth. If is the number of possible , and is finite, then is the number of possible . It's not really meaningful to talk in terms of the computational power of the language being described, since this is about static semantics, in the twilight between syntax and ordinary (dynamic) semantics. The expressive power of the grammar is extended, since it has a formal means of expressing a particular type of input adaptation. Specifically, it provides a means of accepting a permutation of a subset of a particular set. I don't think there is any existing name for this class of language. It's certainly not context-free, but the context requirement is at least pretty strictly controlled. If you need a term for it, just coin one. I suggest context-respecting for the class of languages that cannot be described by a context-free grammar without additional embedded information about static semantic constraints, which to be fair are vaguely syntactic in spirit. The most useful application of this particular extension is probably just the ability to introduce unique-key constraints, but it also lets you describe such interesting sets as , which matches any octal number of 8 or fewer non-repeated digits. As for the complexity of it, determining whether an element of the set has been seen is no worse than logarithmic, and the frequency of checking is linear in the number of elements matched, so the operator is indeed decidable in worst-case linearithmic time. 

Suppose we have $n$ weighted intervals (positive integer weights). Can we find the subset of these intervals which are non overlapping and has maximum sum weight? What is the most efficient algorithm that does this? More formally, suppose that we have intervals $I = \{[a_i, b_i]\}$ for $1\le i\le n$ and $w_i$ which is the assigned weight to each interval. The goal is to find the subset of $S \subset I$ which satisfies $i\ne j: I_i\cap I_j = \emptyset$ and $\sum_{I_i \in S} w_i$ is minimised: $$\arg\min_S \Big\{\sum_{I_i \in S} w_i \Big\}$$ 

Suppose we have an undirected connected graph $G=(V,E)$ that has several minimum spanning trees. We say two trees $T_1, T_2$ are connected if they share exactly $|V|-2$ edges(*). In other words $T_1$ can be obtained from $T_2$ by removing exactly one edge $e_1$, and adding another edge $e_2$. Now suppose we draw a new graph $H$ that its vertices are the MSTs of the graph $G$, and there is an edge between them if they share $|V|-2$ edges. The question is, is graph $H$ connected? One can view the problem also this way: can we obtain other minimum spanning trees by greedily looking for edges that can be replaced with another edge, without increasing the total weight along the way? (*) Given that trees have $|V|-1$ edges, two distinct trees cannot have more than $|V|-2$ in common. So this is the maximum number of edges in common they can have. 

I have a language in which types are unboxed by default, with type inference based on Hindley–Milner. I’d like to add higher-rank polymorphism, mainly for working with existential types. I think I understand how to check these types, but I’m not sure what to do when compiling. Currently, I compile polymorphic definitions by generating specialisations, much like C++ templates, so that they can work with unboxed values. E.g., given a definition of , if the program invokes only and , then only those specialisations appear in the compiled program. (I’m assuming whole-program compilation for now.) But when passing a polymorphic function as an argument, I don’t see how I can generate the right specialisation statically, because the function could be selected at runtime. Do I have no choice but to use a boxed representation? Or is there a way around the issue? My first thought was to somehow encode rank-n polymorphism as rank 1, but I don’t believe it’s possible in general because a formula in constructive logic doesn’t necessarily have a prenex normal form. 

Suppose we have a set of binary variables $a_1, ..., a_n$ that $a_i\in\{0,1\}$. Now we define $m$ and functions over a subset of them: $$j\in\{1,...,m\}: f_j=x_1\land x_2\land...\land x_k$$ in which $$\{x_1,...,x_k\}\subset\{a_1,...,a_n\}$$ Suppose that each variable $a_i$ has also a cost $c_i$ assigned to it and every function $f_j$ has a profit $p_j$ associated with it. Both variables are non-negative $\forall i,j: p_j,c_i\ge 0$. The problem is how to maximise profits minus costs over the set of all possible $a_i$s: $$(1) \max_{a_1,...,a_n} \left\{\sum_j^m p_j f_j - \sum_i^n c_i a_i \right\}$$ Another related problem is to maximise the profit with constrained costs for some constant $C$: $$(2) \max_{\sum_i c_i a_i \le C} \left\{\sum_j^n p_j f_j \right\}$$. Now here here the questions I have: 

Can $(1)$ be solved in a strictly polynomial, or pseudo-polynomial way? Can $(2)$ be solved in pseudo-polynomial time?