When I learnt Eiffel, I realised that a single return at the end of a function is the way to go. Eiffel does not have a return. You just set the value of the Result variable, and it is returned at the end of the function. The Eiffel style of programming makes this natural. When I learnt Scheme, I realised that return early was the way to go. In scheme we created cases, and each case would return a different result. The scheme style of programming makes this natural. When I program in other languages, I use one or the other, depending on my needs. However I Use one or the other I don't use something in between. Therefore either do a switch-case-return, or return at end. In between is a mess. For teaching. Remember there is more than one correct way. You will probably want to teach one at a time. And it would be better to choose a language than supports the style that you are teaching. (There are however infinitely more incorrect/bad ways to do it. I am not saying that all ways are good, just that there are more than one). 

If you are to do summative assessment, then it is important not just that their are a wide spread of grades, but also that the correct people get the correct grades. Ensure that the questions differentiate correctly. That is high performing students get hard question correct, but everyone else (usually) gets them wrong. All but the weakest students get the easy questions correct. If you can, do formative assessment. This means that the results, also have to tell you something about: 

I have been adding: “make lots of mistakes” to my student's lesson objectives. I have been asking “What does it mean when we make a mistake?” [That we are learning. That we are trying hard.] When programming: “What strategies can we adopt, to help us when it does not work?”. When a pupil asks what angle should the turtle turn to make a triangle. “What angle for a square? Is it bigger or smaller than that? [smaller] Try it? [Oh that went the wrong way]. Try bigger then. [That is still not correct.] Ok so it is bigger than 90 and smaller than 180. Let us write these two numbers here. What could we guess next? (At the end of this, they have done a binary search. Have learnt how mistakes can be used to get where you want to go. And can reuse this strategy, so are more independent.) We have a merit system, so I always give a +1 to any pupil that spots a mistake I make. I also model programming the may I do it, with lots of mistakes. But lots of testing so that the mistakes are caught early. I don't always present code that is done. There is a creative myth that people create things in one big bang. Where in reality we do lots of tiny steps, and correct at each step. Model this to your students. And explicitly tell them about it. Get a volunteer (preferable one that thinks them do not make mistakes), put a blind fold on them, and get them to walk down a corridor, with out touching the sides. To touch the sides is a mistake. Then discuss why they can do this when their eyes are open. Is it because they 100% avoid deviating, or do they correct errors? 

Link to real life “Who has came to school by bicycle?” “OK so we need to know how to make a bicycle” “What time did you get up? It must have taken a long time to build the bicycle?” Take it to the limit; be absurd. So the pupils tell you “You don't need to know all this to get to school.” Agree with them. “Any one here ever fix a bicycle?” — “yes” “So you have to fix it every time you ride?” — “no” “But you do have to think about how it work, the inner tubes, the oil, the gears, every time you ride it, right?” — “no” “Why not?” Link to past experience, in subject “Now what about a statement, we need to know how that work to be able to use it, right?” — “no” “So over the next few days/week we are going to be looking at a more complex system than before. We can not hold it in your head all at the same time. So I am going to ask you to do what the professionals do: don't try to remember/understand it all at the same time. We only need to understand ‘how’ for the bit we are working on. It is enough to understand ‘what’ for the bits that this uses” 

Footnotes: Growth-mindset / fixed-mindset, are from research by Carol Dweck. Dweck's work shows that a students belief about whether they can do it has a massive effect on outcome. I think some one else said “Whether you believe that you can do it, or that you can not, you are correct.”, this sums it up. 

Subroutines/methods are a way to reuse code. As is iteration (loops). They are also a way to document what code does. Therefore show how they can be used to reduce the amount of code: to make the program simpler, and to make it more readable. Note that there is often resistance as a new concept: as, temporarily, it does not make sense, so is not simpler. In my first year of teaching, for my python class, I did turtle graphics, as having a visual output can help with understanding. We added procedures for drawing basic shapes. And functions for calculating angles. And eventually complex shapes such as a house, with windows, a door, and a roof. At first we did it simply: 

The value of planning If you want them to plan, then they have to see the value of planning. I think that we often do too much up front planning (I have worked on projects, where we did months of planning, then on the first day of coding, we learnt so much, that our plans were obsolete). We need to plan, but we need to do it «just in time», and planning has to be useful. If it is not, then we should plan a different way. Therefore show your students a variate of planning techniques, that they can choose from. Tell them that the technique that they use, will depend on the situation, and on their preference. Techniques should include: 

Local consistency Style must be locally consistent, and preferably globally consistent. Global consistency may suffer if there are more than one person on the team. But local consistency must never suffer. Nouns, verbs, adjectives Variable name should be nouns or for booleans adjectives. Procedures should be verbs. Functions should be as for variables. Full command/query separation is not easy in as you would have to program Object Oriented. 

For any language/compiler that supports tail-call optimisation, there is no use of the stack for recursion. So you can implement recursively. In these languages recursion is used more. In python it is used less, unless the depth is (as you said) O(log n). However the design may be easier done using recursion, and you can always convert recursion into iteration. Some languages/compilers that support tail call optimisation. 

In another lesson you could add , , . I would also start using other techniques at or after this stage. 

The timeless way of building — Christopher Alexander ($URL$ This is a 3 volume book that includes A Pattern Language. This set of books is probably one of the most influential book from outside of computing to affect computing. It was the seed that started Patterns. The volume A Pattern Language has about 250 pattern on architecture, ranging from world scale, through countries, regions, towns, building, shelves, to screws. (It also states that by no means is this all of them. Where as the 1st pattern book on programming had about 20 patterns and declared that to be all of them. It got better after that.) The Nature of Order — Christopher Alexander ($URL$ This explores nature and architectural styles, and demonstrates: 

Add a smallest possible test (that will fail). Run all tests and see if the new test fails. Write the smallest possible code, to get test to pass. Run tests, to see that all tests pass. Refactor code. Repeat. 

Note I have now changed my view, somewhat, on pseudo code, but not on flowcharts and goto see my answer below. Please add your own answer, if you have I different perspective. 

The problem that is causing the confusion is that we have effectively two functions. taking a string, and taking a float. They both do different things. 

Spreadsheets are probably the most popular functional programming language, and is is some what visual. I have taught it for years 7 to 9, but not part of a qualification based course. Things to be aware of: 

Your tennis racket question, is not good. As tells as that is is abstraction, then focuses on the form, when the most important aspect of a tennis racket is its function. Therefore the answer is non of the above (those are all implementation detail, and you asked for an abstraction). A good abstraction is hitty thing. The 2nd question, is very long, and can be summarised as, “guess the word I am thinking of”. While all answers are plausible, non are obviously wrong. Unless I my notes and see that “Thinking Abstractly” is the only one of these phrases that the teacher has used. This is my attempt at an abstraction question. Based on what I learnt on page 24 of Hello, World issue 3. 

Use a language that has no jumps. C, C++, Java, C# all have jumps (, , ), though they have eliminated the most harmful jumps (even in C, you can not leave the subroutine). Most languages still have return. Eiffel is a good object oriented language that has completely eliminated jumps, and many other harmful language features. At the same time as being easier to learn and use, it is more powerful that most other OO languages. (the down side is the lack of some special purpose libraries.) 

My thought on types of references in Object Orientated Programming. See $URL$ A reference is free or fixed: 

1st remind pupils of BIDMAS, they learn this is arithmetic class, around the age of 11years old. Though in programming it is usually BIMDAS. Though this only makes a difference when there are rounding errors. When teaching boolean algebra, use a+b (or), a.b (and), as opposed to a∨b (or), a∧b (and). The second makes much more sense when relating boolean logic to set theory. However the first makes more sense when relating to algebra. The precedence is the same. All of the algebraic manipulations are the same, except 1+1=1. Now show that all of the rules in the book can be derived from these. Back this up by creating truth tables. Then practice. Then add de Morgan’s Theorem. Then practice. When mixing logic, and arithmetic or any other complex combination (if you are not 100% sure, Or think that other will not be, or other languages do it differently, or you suspect that the may do, or just because you want to), then use parenthesis. 

Here is a short list, of some ideas. You could not teach them all fully in a short time, some you may only introduce, discuss, compare: 

Lint I would not program in without a lint tool e.g. or /, unfortunately the latter two are proprietary. However you need to show that error/warning messages are your friend. There are not an accident. Someone spent time writing them, to help you. Read them, and fix the underlying problem. Often I have seen people finding ways to get the error/warning to go away, but changing the code in a convoluted way, that makes it worse, but has no error. Brackets {} are not an option. I don't care what the standard says, always use brackets. Comments Well written code with good names, is better than code with bad names and comments. Use procedure/function names, and variable names to comment your code. Bad 

What I am saying is about the ethicalness of the software, not of the user. Free Software has nothing to say about money (except to say that you must be free to charge money for it). Artificial consciousness Just a small paragraph to counter what I said above. If some one interfaces a biological brain to a computer, and gives it power. That is the ability to do harm, then it probably will. Any disembodied brain will have no empathy. 

While I think that it is correct that a professional programmer does not need pseudo code (as other high level languages are available), and that management should not encourage programmers to design in pseudo code. I do think that there is value in education. Some exam bodies views AQA “Questions in the written examination that involve code will use this pseudo code for clarity and consistency. However, students may answer these questions in any valid format.” — $URL$ AQA have also stated that they have tested there pseudo code, by building a compiler. And that they compile and test all code that is used in questions. OCR “The following guide shows the format pseudocode will appear in the examined components. It is provided to enable teachers to provide learners with familiarity before the exam. Learners are not expected to memorise the syntax of this pseudocode and when asked may provide answers in any style of pseudocode they choose providing its meaning could be reasonably inferred by a competent programmer.” — $URL$ WJEC “Is there an agreed convention for writing pseudo code in this course? There is no agreed convention, and appropriate pseudocode is rewarded with marks.” — (Can't find link) Summary Therefore these exam boards do not insist that students write in pseudo code, an answer in python can receive the same marks. Pseudo code is just the exam boards way of having one language for all in questions, and of being lenient on syntax of answers. AQA's (and may be the others) pseudo code, as used in questions, is a real high level language, nothing pseudo about it. A learning perspective. Just as pseudo code was useful in the past, before compilable high-level languages existed. It is of equal value today when learning your first language. For a learner, they have no compilable high-level languages available, as this is what they are learning. Therefore it can be useful to be able to express themselves in pseudo code. When I was learning to program, I would first write it in pseudo code, then convert it into comments, and then one line at a time translate it into the language that I was learning. This translation phase, involved a lot of looking stuff up in a book. I still sometimes, but infrequently, do this. It is important though to note, there is no point in formally learning a pseudo code. This results in the boot-strap problem (we learn a to help us learn b, but first we have to learn a, but a is no easier to learn than b). The pseudo code that the student uses will evolve, to become more and more like the language that they are learning, and will become less and less used.