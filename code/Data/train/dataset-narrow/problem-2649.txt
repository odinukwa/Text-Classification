A high score list in which player can see their rank relative to other people may give some motivation. I am not sure if this works for your game, but it may be possible to collect stats like total number of right answers summing up all played matches. If you use an internet based high score list, it may be a good idea to split it into "recent players" and "all times". The standard approach of only displaying a all time list has the issue that it will be really hard for new players a couple of month after release. 

The problem, your type of game faces, is that it needs to be extremely responsive. On first glance World of Warcraft may look like a highly complex game, but there is far less information that needs to be transferred to the client and status updates can be a lot less frequent. The math look correct to me, but Kibibytes (1024) are only used for RAM, network traffic is described using normal Kilobytes (1000). You said that the server has to sent the package from the clients back to each one. That's probably the first thing you can optimize by just removing this step. The client should know what he told the server so there is no need to sent this information back to it. 48,000b/s upstream + 216,000b/s downstream = 264,000b/s in sum. That is 120 MB/h. Another optimization is to only sent information from the client to the server, when the user does some action such as pressing or releasing an arrow key. 900 bytes per status update seems large. Without knowing details, I'd expect 

The first option has the disadvantage that it does not scale for large number of clients. While non blocking IO can be done by checking inputstream.available(), it may be a good idea to look at the New I/O API. Wikipedia has a good article on NIO with sample code. You can find additional information in the JavaDoc for the NIO package. And on a quick glance this tutorial seems helpful. You might get away with doing smart things on the client side, such as sending a dummy message on every "turn". This, however, means that a rouge client can freeze your server. So you should not go into this direction. 

One very important aspect in MMOs development is achieving scalability and allowing for load balancing. Authentication users by checking credentials, ban status, counting recent failed logins, etc. is a task that can be done without knowing anything of the game logic or game data. So it is very easy to move that to its own server cluster. Furthermore the login servers are a well known "entrance" for the client to contact. After successful authentication they can dispatch the client to the appropriate server in the game server cluster. This dispatching can be done by forwarding the network connection to the right game server or telling the client to open a new connection to a right game server. You should think about cuts of your system for distribution early on. It is very easy to run several pieces on one server. But it is quite difficult to split things that have been developed as one unit. 

Try to keep this as simple as possible and interfaces well defined and documented. Maintaining and debugging a complex system in production easily turns into hell. So if there is a simple and a complex approach, think twice before you go with the complex one. Defining Services I think the first step is to identify services and their dependencies: Static Content, Authentication, Local Chat, Global Chat Channels, Regional Chat Channels, Friend's List, Guilds, Bag/Inventory, Auction House, Global Map, World, ... Then for each of these services decided if the client may talk to them directly. For example it is pretty easy to let the client talk directly with the servers responsible for Global Chat Channels. The world servers don't have to be involved in chat messages at all. Regional Chat can be implemented in the same way, but the world servers have to tell the chat servers when players change regions. Again, they don't have to care about the messages. The third step is to think about load balancing within a service. For example global and regional chat channels can be split across multiple servers based on their name. It is probably a good idea to not hard code this split into the client, but provide a lookup service. World Servers The most difficult part are usually the world servers, so I am starting with a simple approach. It is probably a good idea to let the client talk directly to the server responsible for the region he is in. So on login or region crossing the client has to be told to which server to connect to. The simple approach is to split the world into independent regions. With independent regions I mean that a player cannot look from one part into another and monsters cannot cross parts. Those regions are different from the regions player see based on the landscape and story of the outside world. Usually most monsters are in dungeons and players tend to accept that they have to walk through a gateway to enter a dungeon. Especially if those dungeons are instantiated on a per player group basis. Other examples on the outside world are different continents and valleys enclosed by high mountains. A continuous world approach gets complex really quickly, so it makes sense to plan it well: What information does the client need? Which information do the servers have to share? The player will mostly interact only with the objects (including monsters and NPCs) in the same region. You can cheat by placing objects out of click range from the zone border. This means that the client is mostly interested in read only information for neighboring zones. For these cases the zone servers don't have to coordinate anything except for the permission check that the player is close enough to connect to a neighboring zone. This leaves only a very small number of difficult cases in which objects or actions have to cross a server border. Which is a good thing because those cases such as arrows and spells are performance critical. It may be a good idea to split combat into attacking and defending. So the server of a spell-caster will define the attack parameters including the position of the caster. The server of the defender will get the message about the attack and calculate the impact. The server of the attacker does not need to know about the impact; the client will learn about it using his read only connection. Depending on how complex your player model is, it may take a couple of seconds to transfer it to another server (Second Life has a huge problem with this). The issue can be mitigated by preparing the transfer in advance when the player gets close to a virtual border. So that most of the player data is already cached on the destination server when the actual handover happens. Summary Divide the problem by defining different services that can be split across servers with little dependences. As next step look at how to do load balance within the critical services. Delegate balancing work to the client by instructing it to connect directly to the relevant servers (obviously the servers have to check permissions). Keep it as simple as possible, document the responsibilities of the various services and servers well, provide the option to enable debug output. PS: Some of these techniques can be used to improve reliability. And you should keep that in mind because using many servers implies a much higher risk of things breaking; not only in the software but also at the hardware level. 

Is there a website which has recent information on which technology works in which browser? Are there javascript libraries which provide a common cross browser interface that hides the messy details? (Yes, i know that it still requires me to write multiple server sides, but that is rather easy. And more important it is easy to write automatic tests for the server sides). 

$URL$ Stendhal Stendhal is a 2D RPG which has been developed by about 5 people in their spare time. (I am one of them). The first version was released after 3 month spare time by one developer. But it was rather basic back then and more a prove of concept than a playable game. After about 6 month to one year it was fully playable and quite fun. Nowadays it is under heavy development and patches are released regularly. You can have a look at our release history (click "Read all the news items" at the bottom). It nicely shows how the game was improved from patch to patch since 2005. 5 years may seem like a really huge amount of time, but you have to keep two things in mind: First it is a spare time project. Second it was fun to play after about a year. We spent the last 4 years of adding to an existing game by releasing patches. Ohloh has some nice statistics about commits: $URL$ 

I am not sure if you are asking about how to get the data or how to draw the chart. In the second case you might want to have a look at Google Charts drawing service: $URL$ 

Flash is a lot more than ECMAScript. Although there were attempts to introduce some features of ActionScript into ECMAScript version 4, those were abandoned. JavaScript only got usable for most type of games very recently. JavaScript in HTML5 nowadays offers: 

I guess the normal way is to have multiple state machines. This way you can stick to atomic states which often makes your live a lot easier than having to deal with complex states. For example: 

In the sample diagram it is easy to see that the frame rate is a lot better in the home town than in the dungeon. And there seems to be something very fishy going on in the desert; likely a memory hole.