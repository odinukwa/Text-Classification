I'm currently preparing a unit on the implementation of hash tables for a data structures and algorithms course (this is a university-level class, if it matters). Specifically, I'm focusing on preparing a lecture on different collision resolution strategies, focusing on mainly on separate chaining, linear probing, quadratic probing, and double hashing. My question is this: why do we teach quadratic probing at all? I initially added quadratic probing to my todo list mainly because previous instructors of my course taught it and because it's listed in several textbooks I consulted (Data Structures and Algorithm Analysis in Java by Weiss, and Introduction to Algorithms by Cormen, et. al.) However, I'm not really seeing the pedagogical value of doing so. While it's true that it does offer some minor theoretical speedups over linear probing which I suppose might be interesting to discuss, I don't think those speedups are actually "good enough" to be used in the wild (especially once you take into account things like cache locality, which can sometimes make linear probing surprisingly competitive). Based on my (admitted informal and ad-hoc) survey of hash table implementations in popular programming languages, people seem to either use separate chaining (Java and C# (sort of)), double hashing (gcc's C++ stdlib implementation), or a linear congruential PRNG (Python). In that case, is it worth bringing it up at all? I wouldn't mind covering it if I could use it as a vehicle to teach some more general CS concept in some way, or if it had interesting theoretical properties worth exploring, even if only briefly, but at the moment, it just doesn't seem worth the class time. I suppose at best, I could use it as a stepping stone to bridge the gap between linear probing and some slightly more complicated technique, such as double hashing, but that's all I can think of. Is there something I'm missing? 

I find that there is no real way to explain it without drawing it out. Usually, when I teach this, I've already covered basic HTML and CSS syntax, including a few properties (e.g. ). I like to give the example of creating a span with some text inside, so I draw on the board: 

In addition to this example, without using classes and ids you make the DOM much harder to manipulate using javascript and you make it impossible to use pseudo-elements and some of the really nice CSS selectors such as and , to name a few. 

The second phase is actually getting feedback on the code you wrote. This can be tricky to do as a self-learner, since you have no direct way of getting feedback, but there are a few things you can try. One resource to try is CodeReview.SE, though it's probably best to submit relatively small programs for review. Another idea is to contribute to an open-source project. The more popular projects tend to be relatively picky about following best practices and idioms and will code review your submissions before accepting them. As before, start small: try and find a small and easy bug in their issue tracker, and start with that. It can also be valuable to try googling "open source for beginners" -- that reveals plenty of resources and websites that attempt to connect projects looking for help with beginners. 

I do see a bimodal distribution in my intro CS classes, especially on harder tests. I also see something very similar when I teach statistics, and (to a slightly lesser extent) calculus. I think it has much more to do with student preparation coming in, rather than innate ability. I also think it has to do with "test anxiety," since it's much more pronounced on tests rather than on labs. Are you aware of stereotype threat? This is the observation that, if you put a minority group into a situation where there is a stereotype about how they will perform, then their performance will bias towards the stereotype. For example, if students get the idea that your tests are testing their innate abilities in the subject, then students from groups that are usually perceived as "bad at" math/cs/stats (e.g. women, non-Asian minorities) will do worse, even when you control for actual differences in skill between students (e.g. via comparison to non-test grades in the class). This has been demonstrated by study after study. And the sad thing is, there's almost nothing you can do about it. It's not like you only "trigger" the stereotype threat by saying something when you hand the test out. The threat is already there in student minds. For my classes, one thing I've done is get rid of "test" and replace them by "quizzes" (which are still worth 30% of the course grade). Each quiz is lower stakes (three equal one test), so I hoped the threat would be less. It doesn't seem to have worked. I also try to convince students in data science that no one is innately good at this, because it's a brand new field. This seems to have helped much more. I did the same in calculus, pitching the course as "totally different than what you did in high school", because of it's computational and conceptual focus. This seems to have helped. So, I guess my suggestion is to try and shake students out of the mindset that there are "those who can and those who can't", to de-emphasize exams, and to make sure the intro class is designed to also accommodate students with weaker high school backgrounds. This may reduce the bimodal distribution. 

In a pass by value language, I'd have to duplicate the document and give you a copy. You'd then make your changes and give your copy to me. I'd then have to use your document rather than mine, because your copy would have the changes. In this case, there would two copies of the document. They would have been then same when I gave a copy of my document to you. You'd have to give a different document back to me with your changes. Importantly, we end up with two different documents. In pusdo-code: 

And of course, once they're done, students need to successfully use the data structures they've written to complete some other task which might have even more layers of abstraction. Ideally, I want students to develop the ability to selectively "abstract" and ignore different parts of a project when implementing something to reduce mental overhead. Some students seem to intuitively grok this idea but others instead try and hold the entire data structure (or project!) in their head, have a compulsive need to read all instructor provided code, etc, and quickly become overwhelmed. In this particular case, I've observed students seem prone to becoming confused by where the hashing logic lives, or losing sight of what the map ADT is asking them to implement in the first place. Some of this is certainly solvable by just explaining hashmap more effectively, but my core question is this: What are some strategies for helping students become more comfortable working with multiple layers of abstraction? How can I help students develop the meta-skill of being comfortable with abstraction? I'd welcome answers discuss potential strategies in context of this hashmap example as well as answers that address the more general question. 

While your ideal order makes sense, you really should try to plan the course based on the limitations of the language that you're working with. In this case, instead of thinking about the different conceptual loops, you should think about the different loop syntaxes that the language provides. In this case, the order in @Bryan R's answer (if/else -> while -> arrays -> for) makes the most sense to me. Then, once you've finished teaching all the different sytaxes for loops, you can talk about how some loops are equivalent, for example: 

As a college professor, I am often asked for letters of recommendation by my CS majors. I have templates, for whether the student is applying for grad school, for an internship, for a scholarship, etc. Each of my letters ends up being 1.5-2 pages. When I read letters, they are often much shorter, sometimes only a paragraph. I have no experience with CS jobs outside academia, and I'm starting to worry the letters I'm writing are too long (though I do have a good track record of students getting what they applied for). First question (with an eye towards CS internships or jobs especially): 

I'd put a slight tweak on your analogy and go digital: email. In email, your email address is your IP address. It comes in multiple parts, similar to IP blocks. There are many addresses under one domain, there are many domains under 1 TLD. When a message is sent to an email address, it gets sent something pretended to the title, for example "Re" and "Fwd". That's similar to the port. They're all going to the same place, but it indicates something about the email that the computer can use to help process it. 

There have been many great answers so far, so I'll be brief. The students of mine who have difficulty with accepting criticism are often in a "fixed mindset" rather than a "growth mindset", with terminology from Carol Dweck. Most of my students have been high achievers all their lives. Some have got their self-worth bound up with being "good at" computer science (this is a "fixed" mindset). For those, criticism is interpreted as an attack on their self-worth. The other answers are trying to give ways to phrase criticism so it won't be interpreted in this way. I propose, trying to change the students (switching them to "growth" mindsets), so that they realize that they can always get better, and view constructive criticism as a way to do so. This is obviously a lot more work, but I think it's possibly the most valuable thing we can really teach our students. Our college president is a big fan of this work of Dweck, so he made a campus-wide push to help students make this switch. They learn about Dweck's work during orientation, and then students are put into "advising circles" that meet once or twice a week for their first semester on campus. The circle has a faculty advisor, and 12 students. It's 1 credit (1/4 of a full course). The advisor can give students things to read, or journaling assignments. So far, it seems to be helping. Our retention rate is up, and there are fewer confrontational students. Generally speaking, if I have a problem student, I think one of the best ways to change his behavior is to put him in a situation where his peers point that he is the only one with a problem. The advising circles help with that. Incidentally, I think the president initiated this move with the writing program in mind. Many students are resistant to criticism about their writing skills, and humanities professors have been dealing with this forever. I'll bet there is a lot we can learn from them, and I wonder if they also have journals for humanities-educators, where we could read what they've come up with. 

In that case, public methods can change levels of the tree in either direction, and private methods cannot exit their level (or move to a different class in their level. This part is clearer with boxes). 

Then I'll explain that the browser need to how much space to give the element on the outside and how much space it needs to give the content, which introduces padding and margin, and finally I'll add a border, finishing my explanation.