The ball, by pretty much the law of Pong and physics must either be going towards player one, or player two, not both. You could use this to switch interpolation priority between the two players. When the ball is heading towards player one then use player one to synchronise your information, as he is the only one that can affect the outcome of if the ball manages to either bounce in the opposite direction or score for player two. Once the ball starts bouncing in the opposite direction (either because player one succeeded to hit it or player two scored and the next round began) you can then use player two to synchronise your information with. Which ever player has to interact with the ball next, is the player that should report where they and the ball are. This way the lag is only significant against the player who doesn't need the accuracy at that time. 

Please note: as you are using Update and not FixedUpdate that you should multiply your last Lerp argument by Time.deltaTime to attribute for frame stutter. If you want it so this only occurs when your character moves then you can lerp the position of the child empty game object in another script so that it moves from 0 to N units when the player is moving. I am assuming the axis is the Z axis for the tracking helper being 5 units in front of your player and that this script is attached to the helper itself: 

I'm working on my first multiplayer game as well. It can be daunting just learning the problems specific to multiplayer, so I highly recommend that you get good at making single player ones first. First, see if any of the game/networking engines fit your needs. For an Android game especially, starting with a well-developed toolset is almost always a good idea. Here are some of the popular ones that I know of: 

Instead of making full copies of every entity in the world, just save the entities and attributes that are relevant to what you want to lag compensate. For example, in a first person shooter, often the only thing to lag compensate are the bullet shots. To calculate whether a bullet hit, you only need to know, (a) the positions of other players and, (b) their hit boxes. That's all you should store in the history buffer. When you need to lag compensate, update the positions and hit boxes of the players, without touching anything else. Additionally, you can be intelligent about which entities you choose to lag compensate. If you know your skill has a maximum range of and players can move at a maximum speed of then don't bother lag compensating any entities farther than distance away, since you know that they won't be hit by the skill. P.S. I'm also working on an MMO that uses lag compensation. Just because it's not expected by MMO players doesn't mean we should deny them a good experience! WoW is over 7 years old now. 

Firstly, you need to use a switch case statement and decide which direction overrides the others, for example, if they press all four buttons, which button should be listened to for input? This gets put in order within the switch statements. Edit: For clarity about the above statement. You do need to use a switch case statement (or similar structural logic) to stop the following from happening. 

Record the vertexes as lines on the edges where a shapes points lie. These will be used to match up to points/lines on the other tiles each time a tile changes. For example: Above the blue lines on the top two tiles, A and B, have been calculated/saved for each edge of the tile according the shape it contains (note even though they are on different sides respectively you can extract the line for comparison using simple integer values ranging from 0 -> X.) In the broken example the lines do not match so you could say the image is broken. Store the data as extra information in the tile to then use for comparison. If you have a set number of edge types (full edge, half edge, etc) then you could even create an enumerator for sides A,B,C and D on each tile and compare appropriately. In our example our edges can be compared from values 0 -> 10. 

($URL$ Now it makes sense to me why the origin can't be in region 4, since we just came from there. However, I can't think of any case where the origin would be in region 1 either. We just traveled from B to the origin, and if we didn't reach the origin, then we know there was no collision. So won't the origin always be in 2 or 3? Why does every algorithm always check whether the origin is in region 1? 

The GJK algorithm depends upon a function in its loop that updates the simplex and search direction for the next iteration (which is often called something like or ). In order to find the next simplex, the algorithm divides the current simplex into regions, and determines which region contains the origin. Here is an example of the regions for a 1-simplex (i.e. a line). In this example, the simplex previously only contained point B, and then point A was added in the direction of the origin. 

The Separating Axis Theorem (SAT) makes it simple to determine the Minimum Translation Vector, i.e., the shortest vector that can separate two colliding objects. However, what I need is the vector that separates the objects along the vector that the penetrating object is moving (i.e. the contact point). I drew a picture to help clarify. There is one box, moving from the before to the after position. In its after position, it intersects the grey polygon. SAT can easily return the MTV, which is the red vector. I am looking to calculate the blue vector. 

Now looking at your diagram is actually all we need to do to show why using the red square is the best convention and why having the dead zone arcs at north east south west positions of that square are necessary. I'll use my best PhotoShop skills to show you. If I have a game which my speed is linear in each direction based on the raw individual values from the stick for both x and y (let the range on the red square x and y be -100 to 100) then I have this situation: Bob is wearing a magic hat that allows him to float in any direction and at a constant x and y speed (because his hat has thrusters on the north and south sides as well as on the east and west sides) meaning he can move 100 units/s in both north and east directions at once. 

This is a lot easier when you put an emplty child object on your character for the camera to track instead. Imagine your player is being pulled by an invisible dog whenever he moves and when not moving the dog sits next to the player. If your camera is lerping its position to that invisible dog instead of the player, the result is your character still moves and is controller by your character controller but your camera tracks ahead to the empty game object (or our invisible dog called Bingo.) If you want the camera to always be ahead of the character then child an empty game object to your player and place it N number of units ahead of your character (however far you like according to your prefences.) If you want it to return to the player when he isn't moving then leave it at 0,0,0 local position. In your script (which I assume is attached to the camera) you can reference that objects transform using the Unity3D insepctor instead of using your player transform so your camera will lerp toward where the player is looking. 

My current solution performs a binary search between the before and after positions until the length of the blue vector is known to a certain threshold. It works but it's a very expensive calculation since the collision between shapes needs to be recalculated every loop. Is there a simpler and/or more efficient way to find the contact point vector? 

Let's say you're creating a single-player game where you expect the player to go through 10 levels and get a new skill at the end of every level. In that case, you don't need a complicated system for managing skills. You could simply create a new class for each skill and hard code specific methods for each skill (e.g. , , ). On the other hand, let's say you're creating a multiplayer game with a release cycle of a new skill every week, and you expect to have hundreds of skills. In that case, you need an easy way to deliver new skill definitions to players, so XML or some binary format makes sense. Additionally, skills will likely share a lot of features, so a component-based entity system makes sense. The same logic applies for your question about the fireball skill and particle system. Is the fireball skill the only class that will be using particles? In that case, just hard code the relationship. If many skills will be using particles, then you may want to use a message passing system, so that any entity can request a particle to be created without needing a reference to the actual particle system object. You could use dependency injection if you expect to have multiple types of particle systems. There's no correct answer to code architecture, just a bunch of tradeoffs that you decide upon that best fits your game and development team. 

This is brilliant! Our controller square input allows us to do this and more importantly should Bobs hat magically only have one thruster that can go a maximum of 100 units a second well that's okay. We can then give him a direction using inverse tan: 

Well now - what a simple but interesting question to tackle. When reloading a level there are so many factors that need to be taken into account that the answer can go many ways. If your level state contains a large list of assets it can be more practical to start from a clean slate when reloading a level back to a save/mission state as this maintains the accurate state of the level upon reloading but doesn't take a lot of processing. However it is more efficient to reset the assets alone if there are only a few to take into account - making sure you can restart the action quickly on these smaller levels. The latter is especially so when you don't need to preserve anything in the scene or it isn't affected by your choices in game - if you didn't need dead bodies to be preserved from your first run through a village they would not need to be reloaded on your way back through that level, thus conserving processor time and save/mission state access time. A good example to think of would be a First Person Shooter that used terrain destruction / bullet decals that had a persistant state during that playthrough but wouldn't stay if you restarted that checkpoint or level. If you were to rewind the level instead of destroy and reload it you would have to trace each and every state changed. If you shot a hole in the wall with a rocket you would generate terrain gibs from the pieces falling off the wall, the model of the wall would change to produce the hole and you would have particle effects that had been generated to make it look pretty. To clean this up by rewinding it back to a "restartable" state you would have to: 

I discovered my answer. If the origin is in region 1, then it is a termination condition. It means that the origin isn't inside the Minkowski Difference, and therefore the shapes are not colliding. We just return the single point so that the next loop will terminate, and we can keep our support code general, without any special casing for exiting early. 

One way that I've found helps alleviate this problem in platforming games is to prioritize which axis gets checked first in your SAT algorithm. For example, even though the x distance is shorter than the y distance, you can adjust your algorithm to always push on the y axis first. That way, even when your character is standing over the edge of a platform, he gets pushed upwards. Performing multiple collision tests between the start and end positions is a fine solution if you're not having any performance issues. You can optimize it somewhat by moving the maximum distance you can get away with instead of a single pixel at the time. For example if your shape is a circle with radius 40, then moving 20 pixels at a time would work (half the radius so you don't go through thin objects). If you want a more robust and faster solution, then you should use a continuous collision detection algorithm. Instead of intersecting with objects and then correcting, a continuous algorithm takes velocity into account and determines the time of impact, which you can then you to position the object where it needs to be. It's actually not too difficult to implement continuous collision detection using SAT (assuming no rotation). The algorithm that you're using probably has you moving the object, then checking for collisions on multiple axes by searching for overlapping ranges. To modify this to be continuous, don't move the object first. Instead, you can calculate collision time on multiple axes by finding the distance between the closest points on each axis and dividing by the speed that the object is moving (on that axis). The minimum time will be the time of impact for the object, and if it's less than zero, then the objects are already colliding. 

With so many resources to trace for rewinding a level it is often less processor intensive to simply destroy the entire level and reload all the assets again in their default or mission specific states. Having to reset specific objects involves searching a list of the objects in the scene and then accessing their properties to reset them. Instead of that bullet hole in the wall being repaired by cleaning up, you don't need to caluclate any clean up actions, just delete the whole level from memory and reload it from scratch. This means reloading a level is dones from one state object (a save game file or a mission script) and not needing dynamic caluclations. For consoles this is exacerbated by the loading times involved with discs. It also helps PC games as it can take into account computers that won't have the procesing power to make the loading times acceptable. So for large content levels - Loading a single state instead of calculating and "rewinding" one: 

And place that object in the first and foremost room of your game, mark it persistent, and make sure there are no duplicates of it. You're done, and now have nice, crisp scaling =D 

I'm assuming that this is a platformer game and that your character collision shape is a rectangle. You didn't give enough information for me to definitively say what the problem is, but I can guess. Your character will look like he's sliding down the slope if you are applying gravity every frame and always project out the shortest intersection distance. Instead, you want to always move him up on the y axis. I drew a diagram that can explain my thoughts better than words: 

The way I handle lag compensation in my game doesn't involve recalculating the entire world state from a past state. That would be extremely hard to manage since it means data you sent to clients in the past was actually stale data. For example, what happens when a player with high latency heals a target player just before the target dies? To the server, the target player is already dead by the time the heal packet arrives. If you recompute the full world state you'll have to revive that player. But what if you've already sent a packet to the target player and he's already seeing the "You're Dead" screen? These problems aren't unsolvable, but could become a big issue, so you'll have to decide how to handle them on a case-by-case basis. What I do for my game is, every tick, save only the positions of all networked entities. When I turn lag compensation on, I use the client's ping and interpolation amount to rewind to what the client was seeing at that time. In this rewinded state I only run commands that query the world, not mutate it (e.g. , ). I store the results of these queries, then revert all the positions back to the current time. Then I move forward as if those queries were run in the current tick. In this way, nothing ever gets undone. In the example I gave, if a player is dead then he'll stay dead and it's essentially the burden of the high latency player to heal earlier.