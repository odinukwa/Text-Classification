It looks like the game is just using a fairly simple particle fluid simulation. Basically, the "water" consists of little balls that move according to Newtonian mechanics, fall under gravity and repel each other over short distances. The blobs of water are then drawn around the particles using something like metaballs to smooth the surface. 

while this one recalculates the target time directly from the desired frequency and the number of updates using integer arithmetic (demo on ideone): 

It might help if you'd post a simple code example demonstrating the problem, but I'm going to take a wild guess and suggest that your time resolution is too low. In particular, consider what happens if your simulation loop takes, say, 0.02 seconds to run, but your timer only counts whole seconds. So, for 49 out of 50 loops, the delta time you'll calculate will be exactly zero, and so the simulation time will not advance — but then the timer ticks over, the delta time becomes 1 second, and the simulation loop suddenly goes "Oh, wow, that last iteration sure took a long time! I'll have to use a huge time step to catch up!" The best solution is simply to use a more precise time source. However, if you really can't get the time resolution you want (or if something else is causing unavoidable jitter in your loop timings), you can stabilize the timing prediction by averaging the delta time over several iterations, i.e. instead of doing this: 

There are several ways to deal with this situation. One way is, whenever the player is standing on something (a platform, a monster's back, etc.), to work (conceptually) in a reference frame moving along with whatever the player is standing on. So, as far as the player's movement is considered, the platform they're standing on isn't moving — the rest of the world is. Of course, this means you need to keep track of what (if anything) the player is standing on. It also means that whenever this changes, e.g. because the player jumps, falls off or steps from a moving platform to a stationary one (or vice versa), you need to change reference frames; depending on your implementation, this typically means e.g. adding the previous platform's velocity to that of the player when they jump off it. One convenient feature of this method is that you don't need to worry about gravity except when the player is airborne. In fact, you can make jump physics and walking physics as different as you like, which is often useful in games — the approximations that work well for (semi)ballistic motion in mid-air are not the same as those which work when you're in contact with a solid immobile surface. Conversely, one thing that may be a problem with this approach is if the platform your player is standing on undergoes rapid acceleration. (Think of a spring-loaded platform that launches the player into the air like a catapult.) In that case, you may need to include extra checks to see if the player should fly off or slide along the platform (or fall over, if you model that kind of stuff). (In principle, the player should be tossed off if the downward acceleration of the platform they're standing on exceeds gravity, and should slide if the sideways acceleration exceeds the total downforce (sum of upward acceleration and gravity) times the coefficient of friction. Of course, many games essentially assume infinite sliding friction and otherwise neglect most effects of horizontal acceleration. In particular, if your platform moves horizontally and suddenly reverses direction, that should cause anyone standing on it to stumble — but I've never seen a game actually do that.) 

Based on your stated requirements, it sounds like you want a BSD-style permissive open source license. The only slightly unusual part is in your wish to "require accreditation visible to players". I'm not aware of any existing permissive licenses that would include such a requirement (although that doesn't necessarily mean there aren't any). The GNU GPL does include a somewhat similar requirement (see section 2(c) in GPL 2.0 or 5(d) in GPL 3.0), but the GPL is in other ways more restrictive than you seem to want. What you could do, however, would be to take an existing permissive license (like, say, the 2-clause BSD license) and just graft an extra clause requiring player-visible attribution onto it. Since it's your own code you're licensing, you're free to include any such restrictions you want. However, a word of warning: if you want your license to be officially accepted as an open source license, you may want to be careful in how you phrase the requirement, lest you inadvertently end up recreating the BSD advertisement clause problem. Specifically, the old 4-clause BSD license used to carry the following requirement: 

Edit: After you clarified the question, I see that you're concerned about the time taken by the computer — not the player — to solve the puzzle. As you've noticed, using A* to solve the 15 puzzle can take a while; the problem is that, unless the solver happens to find a particularly good solution early on, the search space quickly branches out into a huge number of partial solutions with identical scores. The obvious solution there would be to dispense with the A* search and instead implement a systematic solution method like the one I linked to above. Such methods won't produce an optimal solution, but they do produce a solution to the puzzle very quickly. (As a bonus, the solution they generate will be of a type which the player can feasibly imitate, whereas the optimal solutions found with A* tend to seem "magic".) Alternatively, you might try using A* in stages — that is, for example, first use A* to find a sequence of moves that solves the first row of the puzzle, ignoring the other tiles (i.e. treat them as identical and don't include them in the heuristic), then restart A* from the result of that solution to solve the second row, and so on. (Remember that the last two rows will need to be solved together.) This should produce something similar, but possibly a bit more efficient, than the purely systematic solution. 

So, to apply Jump Point Search to your orthogonal grid, you'd need to decide which points should count as jump points on that grid. After thinking about this for a moment, I think — but have not proven! — that the following rules (based on Definitions 1 and 2 in the paper, somewhat rephrased for readability) may work: A node y is the jump point from node x, heading in direction d, if y is reachable from x by moving straight in direction d, and is the closest such node to x to satisfy at least one of the following conditions: 

Short generic answer: use digital signatures. Specifically, the master server should have a private key for a suitable digital signature scheme (RSA, DSA, ECDSA, etc.) and should somehow securely relay its public key to all the clients. Then the server can sign any data it sends to clients with the private key (or possibly use it to negotiate a shared secret usable for symmetrically encrypting and/or authenticating communications between it and that particular client) and the client can use the public key to verify that the signature has been generated by the server. Of course, your next problem is distributing the public key so that a rogue server can't spoof that and substitute its own public key. That might not be so hard if you can do it in advance (e.g. distributing the key along with the game executable), but it gets tricky if you have to do it later, for example because the identity of the master server is not known in advance. One standard solution is to distribute some other public key (whose corresponding private key is known only to you) in advance to all the clients, and then sign the message containing the master server's public key with that other key before broadcasting it. In fact, you could even extend such signature chains further — say, have one super-secret master private key, which is kept locked in a safe somewhere and whose public key is known to all clients, and another "daily use" private key which is used to actually sign the server keys, and whose public key is itself signed with the super-secret master key before it's locked up in the safe. This is not that useful by itself, but it becomes potentially very useful if you also include some mechanism to revoke compromised keys, so that e.g. if your daily use key is leaked, you can just revoke it and generate another one. What I describe above is a rudimentary kind of public key infrastructure. Actually implementing one securely can get quite complicated, but fortunately it's been done before. In fact, whenever you connect to a website (like Wikipedia) using HTTPS, this is pretty much exactly what you browser does: it receives a public key certificate from the server, verifies that the certificate matches the server name in the URL, is not listed as revoked and has been signed by a known and trusted certificate authority, and then uses it to negotiate a temporary symmetric encryption key known only to itself and to the owner of the private key corresponding to the certificate. This symmetric key is then used to encrypt and authenticate all data sent between the client and the server. In particular, you really should take a look at existing SSL/TLS libraries (which typically come with an X.509 PKI implementation), or possibly at SPKI. These are still somewhat complicated, but probably easier (and more secure) than trying to roll your own. 

MickLH's suggestion of fitting a smooth function to your chosen point values is a good one. However, you do need to exercise some care in choosing the kind of function you want to fit. For example, if, as I presume, you want the player's base score to remain above 1 (or at least above 0) no matter how much time he takes, then using a function of the form may be a poor choice, since the logarithm will eventually grow larger than : you'd at least have to modify the calculation to always clamp the result above zero. A better choice might be a function that naturally tends towards a limit, such as or . Both of these tend towards the value as increases, so it may actually be best to fix at the limit value we want (e.g. ) and only vary and to achieve the best fit. For example, I tried the following code in gnuplot (which has a nice non-linear fitting feature): 

Among these matrices, the 90° rotations are those which swap two coordinate axes while negating one of them, i.e. those that have a single 1 on the diagonal and one 1 and one -1 off the diagonal. This matrix representation allows you to use straightforward matrix multiplication to combine rotations, and to apply those rotations to point coordinates. Since all the elements of the matrices are integers, you don't need to worry about rounding errors. 

Representing your states as bitmask like you write, you can just translate your descriptions of the constraints into code: 

I couldn't find an actual sprite from an old video game to illustrate this (although I think e.g. some of the digging animations from Lemmings were like that), but it turns out that the "glider" pattern from Conway's Game of Life makes a very nice illustration: 

The quick fix, which works for low altitudes, is simply to extend the skybox texture further down. Of course, you also need to make sure that your terrain actually extends all the way to where the horizon would be from the player's viewpoint. Skybox or no skybox, having the terrain just suddenly cut off isn't going to look good. The real problem, however, is that if the player can fly, you can no longer safely treat everything in the sky as being infinitely far away. Just as an obvious example, the player should presumably be able to fly through a cloud; that's not going to work too well if the clouds are just textures on a skybox. Instead, my suggestion would be to render clouds as actual objects in the game; you can use tricks like billboarding to keep them simple, at least as long as the player doesn't fly too close to them, but they should still be actual objects with a real 3D position. Your skybox should be reserved for things that can be safely treated as being infinitely far away, even from an airplane, such as astronomical objects like the sun, the moon and the stars. As for the blue color of clear daytime sky (and the red and orange of sunrises and sunsets), that's actually somewhat tricky. In reality, it's caused by sunlight scattering off the air all around you, and its hue does depend on altitude (among other things) — the higher you go, the darker the sky looks above you. You probably want to include as part of your skybox, but generate it dynamically based on a formula that takes altitude into account. For realistic high-altitude horizons, you'll also want to apply some distance fogging to your terrain (and other objects) to simulate aerial perspective (which is also caused by atmospheric scattering).