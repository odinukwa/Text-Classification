In this function you get information from the object. You do some calculation then I would expect you to put the result back. But you never update the object (which is weird). OK ignoring the weird part. You can have a method that manipulates the state of the object when two players are fighting. 

Technically you don't need to test all the numbers less than the number you are testing. Some have pointed out the easy optimization of only testing up to the square root of the number. But an even better solution is to only test the primes below your number. 

What happens for Also pass the string parameter by This allows remporaries to be passed to the function (otherwise the above call will not work as the compiler can not construct a temporary std::string object and pass it to isNumber()). Other issues: 

Is much better and type safe. This code does not have any type safety and thus does not give me any confidence in its usage. Also the comparison is a string compare (not very efficient). Also completely different types are comparable and do not generate a compiler error. 

Also please also use braces '{}` around sub blocks. This will save you one day. As not all code is obviously one statement (especially if you compress it to one line). 

By making you destructor virtual you are indicating that this class can be extended. But you have no virtual methods. So I see no point in using vvirutal here (it is also misleading). Pass by reference rather than pointer: 

OK. For doubles passing a reference around is fine. But this is supposed to be generic. You also need to allow for move assignment. 

This puts all the query parameters and headers into two arrays. We use these arrays to build all the parts we need: 

The problem with C casts are they are exceedingly dangerous. Basically you are telling the compiler to override the type system (designed to protect you) and do as you say (even if what you say is stupid). But to compound this C casts are exceedingly hard to spot in the code. So even a good code review may miss very dangerous casts. The C++ casts are designed to stand out. They can be just as dangerous as a C cast (though because they perform specific subset of operations each not quite) but because they stand out they are much easier to spot while reading the code and thus review and check that you have got correct. If I see a in the code I usually go and start picking through that code with a fine comb. Stop using malloc/free/realloc C++ has its own memory allocation functions that are built into the language. 

If and are equal there is nothing to check. You have gone beyond the range. So You need to do a test here. If these two are equal then you failed to find the data. Note: That is one beyond the end of the range you are checking. For the very right hand end of the vector this means beyond the end of the which means that accessing it is undefined behavior and likely to cause a crash. This value is always false. 

Casting to void*. Once this is done the only valid operation is to cast back to the original type. Annything else is undefined. 

The method is a validated access to a container that throws on failure. If you already know that you are not going to access out of range then you should use . 

See Why is “using namespace std” considered bad practice?. There is a reason the standard namespace is called and not . Its so that using the prefix is not that much of a burden. Global variables are a code smell. Don't use them. 

Why can't you compare against Nullable? The cast operator does not help you here as it potentially throws. Yet it is still logical to be able to compare or it should throw if either side has as . 

It access members that should potentially be private. Best to make it a member. Also why are you passing by pointer. Best to pass by const reference. 2) You use pointers where you should use objects. 

If you must do this its because you have badly named members that are being shadowed by parameters or locals. Having shadowed variables is a really bad idea as eventually there will be a mistake. Turn on the warning that tell you about shadowed variables. Then you can safely use members names explicitly (it also looks neater). You don't need an function anymore. C++11 introduced constructor chaining. 

Sure it works. But initialize variables on declaration (). And scope your variables () so there lifespan does not exceed their need. Also your control loop is all messed up (you are incrementing d not the value you are testing in the condition!!!! 

In most cases the has already been checked and guranteed to be inside the range . Look at the standard use case. 

I prefer the second one because it can be used with normal compound stamens without modifications or accidentally being used incorrectly. 

You remove the item from the list here. But I don't see a call to delete so I suspect you are leaking a node here. 

As a result the parameter should be marked as a . Also you are passing by value. Your object contains a vector so this is forcing a copy of the object just so it can be printed. So pass by => . 

But it can be done with C++. You just need to manual check that the charter separator is a ':' character. 

Especially since you have very little (none) vertical white space. This makes the code very hard to read. Please one variable per line. 

The others have pointed out a lot so I will not repeat them. But part of programming is spotting code that can be split out into other functions for readability. You have a few places were functions would make the code more readable: 

The result of re-alloc should be assigned to a temporary. You only overwrite your variable on success (otherwise you just leaked the memory that was originally pointed at). 

Note the use of '[' on the left and ')' on the right. It is mathematical notation indicating that 0 is inclusive and BIT is not included in the range (it is common in both C/C++ documentation). 

Even though you pass around a pointer to a pointer (for re-alloc I assume). You don't actually do any reallocation. So I would simplify the code and just pass a pointer. 

Think of a 2 * 2 matrix. This is located at so one past the end is at but your function returns . device_matrix You break the rule of three. You have an owned memory resource. But you don't define the correct copy semantics. Thus you will have multiple calls to when copied objects go out of scope. You should use a shared pointer and define the destructor just like you did in . class device_matrix { private: std::shared_ptr _data_pointer; std::shared_ptr> _matrix; const size_t _width; const size_t _height; 

Two of the main problems with C programs is forgetting to check pointers are NULL and the error state after you have called a function. Your program is guilty of both of these. 

Prefer nullptr In C++11 we introduced to replace . This is because is the integer zero and can accidentally be converted to an integer type without any warning. on the other hand has a type of and can only be converted to pointer types (not integers). Design. When building linked lists I prefer to use a object. This removes the need for checking for in your list and thus makes the code easier to write and understand. There are a lot of C++ code reviews on linked lists where I explain the principle. Node should be private You declare publicly. There is no reason for people to know the implementation details of your linked list. Make this a private member of so show that this is an implementation detail. Prefer to use initializer list: 

There is a lot of copying from to . This provides some good error checking and correction ability. But does slow the code down. Replacing the above with 

Personally I would go with a join even if they are currently the same speed. This way your code automatically gets upgraded when the DB gets upgraded (ie when a new index is added to the DB or they decide to partition the DB by latitude/longitude). In this situation if you are using a Join your code will automatically benefit from any improvement. 

The main(): In C++ we try and use objects and RAII to make the code exception safe. Any time you have init() followed by a dest() pair it is an indication that you should have wrapped in a class and done the init() in the constructor and the dest() in the destructor. Also note you never actually initialize so if it fails to initialize you end up deleting an invalid pointer. 

Also there is a slight chance that different types could get a positive match!!!!! The only reason I can see to use this code is for streaming an enum string, but there is no mechanism to convert that stream back into the correct type so you can't read it back in. So that is a fail (and there are better ways to do that). Code Review 

Very nice overall. Don't see anything technically wrong. I agree with @ratchet freak that your variable nameing (and comprissing multiple values onto a row) is a not great. I would prefer better names and one variable per row. Things I would change for efficiency: 

There is no reason to have an array of pointers. You could just have an array of object (thus you don't need to manage the individual cells). 

This way if destroying the old stuff causes problems you don't leave your object in an intermediate state. You should probably look up copy and swap idiom. It will help with this. 

Also if they are already defined is it OK to continue? Do you think everybody has the same definition as you. If either of these is already defined I would error out rather than continue. 

So now you have two people pointing at each object. So who is supposed to destroy them? You have not defined the ownership semantics thus we do not know who is responsible for deleting the pointers. Even worse if they are deleted via one method the other pointer points at an invalid location (as there is no feedback) between the pointers. boost::ptr_list would hold and take ownership of the pointers very nicely. Cleanup outside a destructor!!! 

The namespace is deliberately short so that using the prefix is not that inconvenient. Prefer to prefex items in the standard namespace with . Variable Names 

But in C++11 we introduced move semantics which is potentially faster than copy semantics and Veridic template also allowing you to build the object in place. 

On containers like the erase(it) is very expensive. As you have to move all the elements down by one place each time you call erase. This is why the erase-remove idiom does it the other way. It moves elements down as many places as they need to go in a single shot without having to do multiple copies (one move per element). 

You are also doing a recursive call without checking. At some point you may end up hitting a NULL and trying to de-reference it. 

I main issue with this code is that it is not C++ (it's more C like). But you asked for a C++ review. So here it is. ========== Overall Design: You don't encapsulate you list. 

First pick a language. Either use C or use C++. Do NOT use a mixture of the two (its sloppy and can introduce bugs). So first off you should have picked a language. You seem to have picked both: 

Your destructor checks then calls which checks . This is a bit redundant. You could have a private version of pop that does not check empty. 

A function that returns a the function is . Note: The readability is one (of two) reasons why I buck tradition ("normal" usage) and Bjorne and don't put first on the line. 

OK. You mention in a previous post you are using an old compiler. So fine if you have to use an old compiler this will work. But moving forward this should really be done using . This class is not needed though. 

Code Review General Comments Be careful of identifiers in all caps. It is traditional to reserve all caps for macros (which can cause problems when you get clashes as macros do not respect scope). 

Assignment operator. The assignment operator is not 100% exception safe. You should not modify the current object while you have not yet finished making the copy. 

In this case it makes no difference (I will admit). But not doing it will make you classes more brittle in for future modifications. So it is always a good habit to get into. I would argue that this constructor should test for nullptr 

One Up'ed me Well you have gone one step further than I have. I have been planning adding the "Make-Depend" step but have not got around to it. Layout One thing you don't do is build your executable/objects in a different directory that the source. This is generally best because debug/release binary are not guaranteed to be compatible and thus you should compile them into their own sub directories to make sure they do not get mixed up. I have found separating my header files from the source a pain. So I keep these with the source and automatically install them as part of installation. Any header files I don't want installed go into sub directory called details. So my structure looks like this: 

Prefer Standard containers Arrays are limited. They don't work well with a lot of other constructs in the language as they quickly degrade into pointers just by looking at them funnily (them people start worrying about memory management). 

In C++03 I would have a std::stringstream object that I now use (which can then be used in the same place as the std::string object). 

The just hides errors. You still want this to fail. Make has a special prefix that makes it ignore errors and continue. The following has the same affect: 

It should be noted that the implementation of this layer is currently very basic. One of the improvement points is implementing a more efficient version of this package stream. PackageBuffer.h 

This is because the threads remove there object from serverInfoVector. There is a race condition here where you might access an element just as a thread removes it from the structure. Note: main() is special. If you do not provide a then C++ will implicitly add a for you. Thus I always leave this out of main. Note: This ONLY applies to main you must return the correct value from all other functions. 

Design. Looks like perfectly good but its not . You should create a class that wraps the node and acts as the interface to all your operations and handles all the resource management. None of these essential parts are currently done. I would expect an interface like: 

The space after and before is part of the name (as defined by the standard). If this is working you are relying on compiler specific behavior. Using namespace std This is bad practice (and a bad habbit).