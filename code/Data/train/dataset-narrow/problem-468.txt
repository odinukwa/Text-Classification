Note that to avoid the problem of a position being defined for a department and a classification that are in different companies, I've expanded the keys of both and , which is good for the reasons you can read about at length in Todd Everett's answer. BEWARE The model above presumes a simplification. Specifically, it assumes that each position is recorded only once. This may or may not be suitable to your business rules. If you need multiple records for the same department and classification within a company, then you can introduce a surrogate key in . 

Sales/excise/VAT tax rules can be very complicated. There can be different rules about the applicability of different taxes based on things like: 

Raladical, as I noted in my comments to your question, I think that what you are trying to build is perfectly suited to the relational data model. Here is a quick data model sketch: 

What you are describing is an example of the general situation entity sub-typing. There are two basic ways to handle entity sub-typing: One method places common attributes in a table and distinct attributes in separate tables, linked using 1:1 relationships to the common table. Some other considerations: 

A system scope / boundary diagram is sometimes also called a level zero data flow diagram or a context diagram See here for the Wiki on DFDs and here for System Context Diagrams. Whereas an ERD is a model of data at rest, DFDs are a model of data "moving" through processes. Before RDBMS was the predominant data storage mechanism, data was kept in files that were accessed sequentially and was processed a record at a time. Each time the data was processed it was written into a new file. In this way, you could think of data "flowing" from one place to another, transforming as it went. Each data store was shown - often as a rectangle. Processes were shown as circles ("bubbles") and flows were shown as lines or arrows. The level zero DFD shows the whole system as a single bubble. Outside of the bubble are external actors (e.g. users of various types) other systems, and any other data sources and sinks that you might be concerned with. The idea of a DFD is to incrementally decompose your system into smaller and smaller processes, until the whole system is described. The level 0/context diagram is the starting point and you drill into each bubble as deeply as necessary to develop a complete system description. In modern systems, especially where data is stored in RDBMS, the data flow paradigm is not always an especially good fit. However, the context diagram, or level 0 DFD is still useful for describing the scope or boundary of the system in terms of data sources and sinks. 

Here there is only one potential cycle to be concerned with, instead of the several that are in your current model. Fewer potential cycles means less extra work that might need to be done with triggers instead of declarative referential constraints. This keeps your system simpler and more maintainable. 

In your case you could pick either approach. Which might be better depends on your preferences and on exactly how many distinct columns there are per sub-type. 

How many rows you need depends on how your code interprets the data. You could have very simple code which interprets each permission strictly at face value. To do an administrative task, the user would need an 'A' permission. To do a publishing task, they would need a 'P' permission, etc. In this case an administrator would need three records per site (one each of A, P, E). Similarly publishers would need two records per site and editors only one. There is a risk in this approach that data consistency errors could creep in, like someone could be a publisher, but not an editor (by virtue of the 'E' record being missing). Alternatively, you could make your code more complex, in which case each user only needs one permission record per site. In this scenario, administrative tasks require an 'A' permission, publishing requires an 'A' or a 'P' and editing requires 'A', 'P', or 'E'. The advantage of this approach is that there is less data to maintain and you won't have inconsistencies. Note too that you do not need to have the column. If an administrator has an 'A' permission for a site, that automatically gives them control of all of the users for that site. 

A text file just has text. There aren't any rules in a text file. You can put in anything (or take out anything) that you want. That means you can make mistakes. These mistakes are the corruptions that your books are talking about. A database has controls that, if you use them correctly, provide a significant amount of protection against recording bad data. 

Computers don't get tired. Nobody has so many employees that the summation over a well-indexed set of rows of vacation actually taken would grind their servers to a halt. What is a problem is precalculated data getting out of whack with respect to your raw transactional data. If you're tracking vacation you're going to need to keep a list of days taken no matter what, for audit purposes, if nothing else. What happens if an employee challenges your calculation of their vacation taken? The only way you'll be able to justify your number is to go back and show the details. Since you'll already have the transactional details, there's not much point in keeping a precalculated sum of these details. From a code complexity/maintenance standpoint you're not really saving anything. You write the code that calculates the remaining vacation entitlement once. It's a single select statement that has three or four more keywords in it than the single select statement that would read a precalculated row. That's not much of a savings. What you're thinking about is often called pre-optimization and it's something to be avoided, because it actually makes things worse more often than it makes things better. 

You should keep your waypoints (midway cities) in a separate list, with the trip key and the sequence of the stop as the primary keys. Consider the following ERD: 

Redundancy is not about columns or rows for that matter. Redundancy is about functional dependencies. If you have predicates (i.e. columns) that are transitively dependent, then you have redundancy. Hunting for redundancy is a bad approach when optimizing a logical data model. Trying to decide what is and isn't redundant is tricky and frankly a little bit beside the point. Focus on normalization. This will eliminate your redundancy along with other potential problems along the way. When you move from logical model to physical database, you can then determine whether managing some redundancy is worthwhile for some reason. 

Your proposed design is alright. Being derivable is not quite the same thing as being redundant. Semantically, registering for an event is different from committing to attend that event at a particular location. This is true because everyone who is going must commit to the event, but they don't have to commit to a location. The only issue that your proposed design should deal with is the potential for logical inconsistency between the chosen location (if any) and the event. This could be handled procedurally by your application, or you could use a solution such as the one suggested by ypercube to impose this constraint declaratively. 

You can't tell the functional dependencies just from the schema. If you knew that the schema was in third normal form (3NF) or higher and you knew that there are no other candidate keys other than the primary key, then you would know that every non-key attribute was fully functionally dependent on the primary key. Except for this particular situation, there is nothing about a schema that conveys functional dependency. The purpose of a schema is to convey table structure, not functional dependencies. 

Based on your stated requirements, your model is in pretty good shape. Here are some suggestions for improvement: 

The way to manage this is that your sub-types have to be determined by the super-type (i.e. the PK of the sub-type is also a FK from the sub-type to the super-type.) The challenge is understanding whether something is truly mutually exclusive or not. The attributes of sub-types should apply only to those sub-types, but it may well be that some sub-types are mutually exclusive and some aren't. If you have some mutually exclusive sub-types, then you can use a partitioning attribute on the super-type to indicate which of the (two or more) mutually exclusive sub-types apply. This partitioning attribute can be used in with constraints or triggers to enforce the mutual exclusivity. If you have sub-types that are not mutually exclusive, then they can exist without using any partitioning attribute. Consider this data model: 

On another subject: Your model indicates that a can be written by many s. I'm not sure that this is really possible in your system, since you don't say anything about collaborative authorship. However, one thing that is almost certainly a problem is that each user can only ever author one post. I'm sure that's not what you meant. To fix this you either need to move the foreign key in the relationship between and to the post side or you need to create an intersection entity if posts can have multiple authors. Similarly... Your business rules state that posts can have multiple and assignments, however, your model doesn't reflect this. In your model each post can have exactly one of each of these. To fix this you need to implement a many-to-many relationship for each of tags and categories. This will result in an intersection table in each case. Lastly: Why is some of your user information segregated into another table with a many-to-many relationship to the main user table? There may be good reasons to keep password information in a separate table from other user information, but I don't see any reason stated in your business rules. Also, it isn't likely that password will be many-to-many with your user record. 

NoSQL databases are for unstructured data or unpredictably structured data that is often queried using full-text searching. Capturing time-series statistics for graphing sounds like a pretty well-structured data set to me. What do you have, three tables? Users, Servers and Measurements? It sounds to me like you have data which is perfectly suited to a relational database. It may be that you need to think about whether your relational database is going to be fully normalized or partially denormalized for reporting performance. That's something you can decide is necessary once you do some load testing with production volumes in order to see whether denormalization is helpful. 

There is no earth-shattering difference between a data model depicted in UML notation versus a data model depicted in any of the many common ER notations. They all depict the most important elements: entity types and relationships. Depending on which graphical convention you choose, there may be other features of the model which are conveyed, such as the attributes of entity-types, relationship cardinality, strong or weak associations, etc. The point of the model is to communicate your design. You should choose the graphical convention that is most expressive of the information that you're trying to convey with the least "noise" (unimportant information). You should also take into consideration the needs of your audience. No matter how artfully your diagram conveys the information you intend to transmit, if your audience isn't comfortable with the notation then you will have not achieved your goal. If your audience is familiar with IDEF1X then use that, if they are most comfortable with Martin or Chen then use those. If UML does the job and is what is familiar, then UML ER notation is best, otherwise it isn't.