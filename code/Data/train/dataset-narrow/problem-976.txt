Use meaningful names. This code is littered with examples of questionable naming choices, starting with the name of the package itself (). Is this a framework for testing? Just because it may be experimental in your mind at this point doesn't mean it shouldn't be named according to what you intend it to be. Think about it. What have you named your Github repository (hint - the word is nowhere to be found)? Why introduce this test nomenclature throughout your codebase (which could end up confusing a reader of your code or someone who might be considering using your Composer package)? Why is the main application bootstrap class called ? Why do you have models nested under a directory? This is now causing you to introduce into your namespaces even. This is bad naming. Name these things what they are. 

Why conditionally encode JSON? If you are sending header, you better well be sending well-formatted JSON to the client (why would you break your own API contract?). What about passing objects? JSON allows for encoding more than just arrays. 

Why is this in "database handler" class? You should have knowledge on model or helper class for each type of object you are modelling to get the latest id. 

I echo the sentiment mentioned in comments to question above that I am really not quite sure why you would want to roll your own solution to this problem. 

The two different code examples are not the same in that the cart array is build differently in each. The first would build a numerically-indexed structure at like this: 

I agree with other answer about removing styling for into CSS. You don't use this DOM collection anywhere else in your code, so why have it in JS at all? 

At least with this approach you have a single point of entry to this required data such that you can perform appropriate validation before attempting a DB insert. Your current approach of using magic getter/setter and setting of object properties eliminates your ability to validate the data being set on these fields before insert. Note that I also used a static method call here. I honestly don't see a use case for you to have to instantiate an object in order to then perform a database insert. Your use case seems more aligned to provider or factory pattern usage. 

My first question with regards to your implementation is whether you should truly be setting some of the configuration values like session name, use of SSL cookie, inactivity timeout, etc. at runtime. Do you really need to change these things at runtime, or should these be derived from application configuration and/or be set as class constants? If you derive these items from configuration, you can probably move away from repeated calls to inside most every method, as you already know that the configuration is already set up the way you want it to be. 

Why are "includes" exposed publicly? Is this really an "include" at this point or actually a true API endpoint? Can I call and spawn a bunch of zombie connections to your DB? 

I am concerned that you seem to be looking at a JSON-based REST API, but you have made no provisions at all for reading JSON as input. Your API seems to assume a form-encoded content type being sent to where , would be populated as it is in a standard form-based web application. If a REST client is sending your GET/POST with content type, PHP will not auto-populate these superglobal variables. You will need to read input manually from standard input using something like: 

Since Places is such a hard dependency in this process, I would consider passing that as a dependency rather than breaking this up across multiple steps. I would even question the need for whether needs to be a concrete class vs. a simple statically accessed factory. Usage in this case might be like: 

You might consider separating the logic for hiding/showing slides into a separate method from . This allows to just focus on setting current slide index and calling appropriate hide/show methods. 

Note the suggested use of dependency injection for your . I assume the controller has access to the already, so why should this class have to know how to instantiate it? Note that you only have happy-path case here for logger. What if instantiation fails? Agree with other suggestion about using PSR-3 compliant logger. 

In POST path, there should be no reason to try a select against the DB to see if the short code already exists. If you have this table properly implemented with a unique index on the short code field, there is no reason to pre-select. You could go directly to insert and check for duplicate index violation error and retry with new code if this fails. This makes it to where happy path use case no longer takes two queries against the DB, it would only take one. 

You should not even attempt a database insert without knowing you have been passed valid data that has been appropriately sanitized. Some other thoughts: 

Which would work with a set of validation functions like this (note I am using arrow functions here which seem to lend brevity to this code). 

Or maybe, if you find that to be too much code in a single class, split out the ini file read/write functionality into a class or trait that is injected or composed into the ini management class for its use - not as a base class to be extended upon. I thing I like to suggest when making decisions about using composition vs. inheritance is - "what makes most sense in the real world?" In real world terms, is an INI configuration manager an "extension" of file systems operations, or does it really just need to be given the ability to operate against the file system to perform it's job. If the former, inheritance is likely the best answer, if the latter (which I believe to be the case here), then composition is likely your best bet. Now, let me talk about static vs. concrete, as I don't really understand why you have a static class that does exactly the same thing as the concrete class. Sure you may have different application contexts, which may need to operate against INI configuration data in different ways and your application may need to operate against multiple such files. I like that you are thinking about how an application might need to work with data from a number of these files in different contexts. But, let me ask you, why do both the static class AND the concrete class BOTH need to deal with all of these potential use cases? Let's think about what a meaningful concretion truly is. I would suggest that the concrete object really only has meaning as a 1:1 representation of a single ini file (which seems to be the intent of the design). So why would it need a method? Would you not just pass it its file dependency in the constructor? Why would it need a method that takes file information as an argument? Shouldn't it already know the file it is associated with? (If this is to be able to rename/move or copy the file, perhaps there should be separate methods for that.) On the flip side, from a static context, why do you need to do individual file level operations in that context? Your use of should be a strong indicator to you that you are really working with a concrete instance of an ini file object. From a static context, perhaps it really only makes sense to specify files to be loaded via a method like and then return concrete ini objects you can operate against. I suppose you could make individual file-level changes statically, but just be honest about what is really happening, you are providing a static convenience method with really instantiates an ini file object to operate against. As such, I would suggest that you either just provide a static method on the concrete class which can be used to instantiate an ini config object, or if you find yourself truly wanting to expose more static functionality, than have a separate static class that focuses on instantiating or working with concrete ini objects, not on also being an object. Think of the difference between a library and a book in real-world terms. That is analogous to what you are dealing with here. Your library (static class) may provide means for you to find a book (ini config object), check out a book, or even get excerpts from a book (in an electronic sense). But it doesn't need to have all the methods and properties that a book has. Similarly, an individual book doesn't need to know how to find other books in the library. Here you have built two classes that do the same thing and I would challenge you to rethink that approach.