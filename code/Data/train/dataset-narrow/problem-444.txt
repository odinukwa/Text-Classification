Typically you would design the database such that someone coming into the database alone could get a handle on how the application worked. Had they seen such a foreign key they may not be aware of it's implications. You could approach this in two ways: First, you could do as you mentioned. Create two separate tables and handle them there. Second, and the way I would recommend, you would create a table to handle all the common fields between the two, and then two other tables, one for internal-specific data, and one for external-specific data. Each of those tables would have a primary-foreign key to the common table. I.e. a Guid or ID. The downfall of the second method is the application would be required to be aware of the two different tables, and depending on the method you are using to implement it (.NET, PHP, Python, etc) you may find one method easier than the other. I personally use .NET and C# or VB, depending on the project, and in this situation I would go with the three-table design, as I would create an abstract class ("Event") and then two classes to inherit it and all the common properties ("ExternalEvent", "InternalEvent"). The Event class would handle the interaction of the shared properties, and the InternalEvent and ExternalEvent would handle the logic specific to them. The upside to this approach is the polymorphism of it. If you add a common field to the two in the future (for whatever unprecedented reason) you only have to add/change it in one location. 

and then when you look at the code your mind kind of fills in the parenthesis where you think it ought to be. Whereas order or precedence rules actually perform it thus: 

Might be a little quicker. Essentially it ought to behave much like your original working query did. 

Another workaround, which seems to work quite nicely - place a parent group of the group you want to selectively break on, then in Group Properties for that, group on a derived expression of either the group field, or a fixed value. And then tick the box for that grouping as per your screenshot. e.g. Assuming a parameter called "BreakPages", and a grouping on a field called "MyGroupField", you group on: 

Horses for courses. Works pretty much the same as your method. I'd write it your way in this instance if I were me. But it IS a good conceptual exercise to try to think of and compare different approaches like you're doing. Keep it up! :) One thing to note: you should really reference the source table in the SELECT clause. To avoid ambiguity or future complications: 

(Yes, I know technically that's wrong from a consistency standpoint, but it's what would be desired in the situation.) Edit: Small updated, I did change the structure of the table, and drop the column from it, and replace it with (which is now renamed to , and all relative Foreign-Keys and and relationships updated). From a technical standpoint, this is a more appropriate setup in my opinion due to the fact that the table is limited to ISO 639-1 codes, which are unique to begin with. Tl;dr So: the question, how could I modify this query to return everything from and then return either for that , combination, or the if it did NOT exist? My initial thought, is that I could somehow cast the current query to another temporary type as another subquery, and wrap this query in yet another statement and select the two fields I want ( and ). If I don't find anything, I'll just do the standard method I typically use which is to load all the into my C# project, and then with it run the query I have above manually against each . Thanks for any and all suggestions/comments/critique. Also, I apologize for it being absurdly long, I just don't want any ambiguity. I'm often on StackOverflow and see questions that lack substance, didn't wish to make that mistake here. 

You're cross joining to your "inp" query, but then using the results from that in the where clause for the subquery of your main where clause. Effectively then the subquery will run once for every row of the zip table. Which will slow things a tad. I'm slightly rusty as to what you could achieve with any PL/SQL around this, so in pure SQL you could write it as: 

OK, just to follow up my correct (yay!) comment answer - in my experience almost everything along the lines of "weird issue" involving data selection, involves a rogue, unparenthesised "OR" somewhere in the where clause. It's always the first place I'd look. Typically you write some code along the lines of: 

since, you're future-proofing against someone adding to the code later and accidentally writing something like: 

If I rm() the dataset containing the imagine data frame at this point, it still won't let me delete the working file. Has anybody solved this? Or anyone more familar with R offer any assistance? 

So here's my scenario: I'm working on Localization for a project of mine, and typically I would go about doing this in the C# code, however I want to do this in SQL a bit more since I am trying to buff up my SQL a bit. Environment: SQL Server 2014 Standard, C# (.NET 4.5.1) Note: the programming language itself should be irrelevant, I'm only including it for completeness. So I sort-of accomplished what I wanted, but not to the extent I wanted. It's been a while (at least a year) since I have done any SQL s except basic ones, and this is quite a complex . Here is a diagramme of the relevant tables of the database. (There are plenty more, but not necessary for this portion.) 

All relationships described in the image are complete in the database - the and constraints are all setup and operating. None of the columns described are able. All the tables have the schema . Now, I have a query which almost does what I want: that is, given ANY Id of and ANY Id of , it will return either: If there is a right-proper translation for that language for that string (I.e. -> exists, and in , , and combination exists, then it loads for that . If the , , and combination did NOT exist, then it loads the value. The is a given . My query, be it a mess, is as follows: 

You might then be able to edit the datatype directly in that text stanza and trick SSRS into sorting itself out 

And works fine. Except that the working file, the one with the name generated by tempfile() remains in the working R folder on the server. All the other working files get cleaned up at the end of the process. Im my case, I don't want the image file to remain on the server, as it potentially contains sensitive information. -- I'm pretty new to R, so I've been experimenting with the code in an interactive line-by-line fashion in R console: I find that before running that line with the call to readBin() to assign the contents to the output data set, I can simply use the R command 

Here's the trick you're after - use the CTE to build a list of each region, cross referenced with every region which counts towards it: 

Knowing, and understanding, different options to obtain the same results is key to getting familiar with SQL, IMHO. No matter how obscure and esoteric the problem might be. Anyway, I know I'm late to the party, but here's a different take on a subquery method.. 

The problem is that it is not capable of providing me ALL of the and their respective if it exists, OR their if it didn't exist. It is perfect at providing any one of them, but not at all. Basically, it's to enforce that if a language does not have a translation for a specific key, then the default is to use which is of translation. (Ideally, it would not even do that, but instead load the translation for , which I can do myself if pointed in the right direction for the rest of the query.) I've spent a LOT of time on this, and I know if I were to just write it in C# (like I usually do) it would be done by now. I want to do this in SQL, and I'm having trouble getting the output I like. The only caveat, is I want to limit the number of actual queries applied. All columns are indexed and such as I like them for now, and without real stress-testing I cannot index them further. Edit: Another note, I'm trying to keep the database as normalized as possible, so I don't want to duplicate things if I can avoid it. Example Data Source dbo.SupportCategories (Entirety): 

I've used SSRS for a subset of this kind of activity. It's not great for using as a full-on data input program for obvious reason, but there's no particular problem with running insert/update/delete statements inside datasets. What I've tended to use it for is more "clicky" kinds of updates. Where clicking on a hyperlink within a report causes something to happen - be it insert something in to the database, update a value somewhere, etc. And the activity that happens is controlled by the hyperlink passing in the various parameters to control that. I've tended to use a report where the hyperlink runs a new instance of the same report, but controls what gets updated by passing in new parameters. Mainly so that all the code is in a single report. I've made a quick demo report to demonstrate the technique in action, if that'll help? Available at: $URL$ You can do quite sophisticated stuff within the confines of this technique, but it's definitely not a data entry portal for entering entire rows of data. I'd be interested to hear if anyone's really used it for that in earnest.