Last time I used the Facebook API they didn't provide any multiplayer or gameplay functionality. I'm pretty sure you have to write that yourself. You can still leverage the Facebook API to publish scores/achievements and find friends of a user. Eg. You can get the user-names, profile pictures from FB and also use the Facebook API to post something on the users wall to draw more attention to your game. Achievements and scores are also a part of the Facebook API now. The tutorial you followed is pretty much all there is to it. Facebook gives you the "social" data of users, everything else is up to you. To find friends for a multi-player game (as your question suggests), you could use the FB API to find the friends of a user which are currently online and send a request. Your server-application will have to handle the creation of a multi-player session when requests are being accepted. 

You can use any format that's convenient to you. works fine as you can easily parse it into data-structures without the need of external libraries. Also something like or plain would work. If you write a level-editor yourself, you can use any of these formats. You don't have to write the level editor yourself though. Since your game is row/column based, a tile editor like Tiled works just fine. Cocos2d directly supports Tiled maps. I guess any other tile-editor will work fine too. If you don't like Tiled and rather wish to freely position sprites, have a look at CocosBuilder. 

There's an excellent article out there that explains the 3D rendering of these games in detail. And you'll also find a complete implementation in JavaScript here. The basic idea is as follows: You divide your screen into a number of strips and use perspective-projection to calculate the texture-coordinates (scaling and y position inside the road-texture) for each strip. Then you draw the portion of the texture into the strip, resulting in a road that vanishes in the distance. 

If you don't mind using a Flash-Game-Framework such as FlashPunk or Flixel, I suggest you have a look at the Flash Game Dojo. It's not a very extensive site, but a good place to start. 

You could build the entire game in JavaScript for sure. Be aware that the source-code will be visible to the user. So if you're concerned about cheating (probably a non-issue if it's just a single-player game), then you should have your game logic on the server. JavaScript and PHP is definitely going to work. If I were creating such a game, I would do the following: 

For future reference, I had a look at the Slick2D code and resetState() calls replay() and replay() also calls reset(). So, if you want to restart the particle burst use resetState() since that covers all the bases. 

For any basicgame or gamestate that you write in Slick2D, you have to override the render method and so you always have control of what renders and when. You can build in logic to only render if something has been changed by a user at that point. Alternatively, the call to render() in each loop is done from within the AppGameContainer (which extends GameContainer). In theory, I guess you could override the methods there to control when rendering takes place from that point rather than in a given basic game or gamestate (i.e. for the whole application as opposed to on a per gamestate basis). Either way, that could be a lot of work if you have a lot of things to track in your level editor just to reduce the rendering overhead. If the application is PC-based then what is the problem with restricting FPS to something like 60 or 30FPS and letting it run? I am developing a game that has level menus in between live-action rounds and in the menu states the application barely uses any CPU at all. I see about 4% cpu usage when scrolling around a map on-screen for example (that's on a 2.4Ghz quad-core system, but it works just as well on an old laptop). Also, if your level editor is gui-based (i.e. a real-time, drag and drop affair) then won't you need regular graphic rendering anyway? And finally... I have just tested stopping the rendering after setting up the screen in one of my applications and the screen just goes blank. So that leads me to assume that the render() method is also ensuring that the screen is refreshed or that something at the AppGameContainer or GameContainer level is clearing the screen before each frame. Overall, I'd recommend just restricting the FPS to something relatively low, e.g. using: 

I got around my problem by re-writing my code to remove ComponentListener. Doing this I got a single response to a left-click (or right-click). This doesn't differentiate between left or right-clicks - it just picks up clicks, but that works for me. My test code is posted below. 

I have then just disabled or enabled the length option (which gives a fixed duration to a particle burst if enabled) depending on whether thrust is engaged or not, i.e. if thrust on then disable length, otherwise enable it (I have this set to 10ms in the xml config file). This gives nice, organic puffs of thrust when I 'feather' the thrust control, which is exactly what I wanted. (From my ship class) 

Make sure your code is error free. The flash player that's usually installed in desktop browsers is quite forgiving in that regard and sometimes continues to run, even if an error was thrown. Install the debug-version of the flash player for your browser and check if you get any error messages (usually they will open in a popup-window). Mobile devices tend to have a lot less memory available for apps than the average desktop PC. Make sure your game is memory efficient and doesn't leak memory! You can leak memory with flash pretty easily, even though it's managed code. 

The Strip 2 is the dirt and Strip 1 is the grass. As you can see a small grass-texture will be mapped to each quad of Strip 1, whereas the texture coordinates of Strip 2 just add up and generate tiling (you can see the approximate horizontal texture coordinates below). 

It's certainly possible to create an endless Bejeweled game. PopCap have done so themselves with the latest Bejeweled 3 (the mode is called "Zen Mode"). First of all, you need to make sure there's at least one valid move when you first generate the board. Whenever a player makes a move, you have to calculate the resulting board and search for valid moves. If there are none to be found, you have to control the gems that will be spawned to restore a valid board. Since (at least) 3 gems will be removed with one move and you'll have to spawn 3 replacement gems, you can ensure that these 3 replacement gems will form another valid move with the current board. Endless mode achieved. Of course it's not ideal that the new move will appear with new gems, but it's a cheap way to always ensure a playable board. And since creating valid moves actually means to swap positions of gems, it won't be long before other moves will become possible. As already mentioned, bombs and other means to clear large parts of the board will add more variety to the gameplay, but they are not needed to ensure an endless mode. 

Instead of manipulating meshes in Unity, I'd use a Shader instead. It gives you more control over the appearance of your gauge and will perform better. For starters, you could use the built-in alpha cutoff shader and use a circular gradient as your cutoff ramp. Something like this should do the trick: 

You can use a jailbreaked iOS device for testing, but you won't be able to sell your App on the Appstore. And you won't be able to test the app on other (non-jailbreaked) devices. To do that you'll need the developer license. The reason why this is so, is that every app needs to be signed (with the certificate you get from Apple when joining the developer program) to be run on iOS devices. Non-signed code will run on a jailbroken device, but not on any other device. Also a non-signed app cannot be sold in the Appstore. 

After a lot of research and continuing development using Slick2D, I have decided that the only way to do this in libGDX would be a fundamental re-write. After some tests, it also turns out that this is a Good Thing. The solution I have tried is to hold the data for the graphics in arrays, use TreeSet indexes to be able to quickly locate which items should be on screen at any one time and then draw these once per loop. Per loop, this removes the getSubImage() call and repaint of this sub-image to the main graphics canvas. Having tested the approach with both the old graphics-based class and the new array/TreeSet-based class the difference in performance is significant. Using the graphics approach the game runs unchecked at about 205 FPS. Using the new array/TreeSet approach it runs at around 280 FPS. I've included an edited version of my Stars class here to show how this works in practice. This is the simplest case since the stars are simply dots on screen. It gets more complicated for other shapes, but the logic is essentially the same except for having to check for objects being partially on-screen, i.e. check all vertices. I've also included a small class below that I use for the TreeSet indices used to search for on-screen objects. Both use dyn4j (physics engine) co-ordinates for the stars and also for the edges of the screen (picked up as an Observer of another class) to calculate what should be shown on-screen. 

Solved it. The second line below fixes the problem (I included the first for clarity). By default, if the emitter completes its cycle it is removed from the ParticleSystem. Disabling automatic removal means that you can restart the emitter. (From my shipflame class) 

... which either do nothing (no particles) or give a short burst of particles at the start of the program (for the initial emitter length if emitter length is enabled), but then do nothing whenever I press the thrust key. The last option (running 2 emitters) causes the particle system to run out of particles after about 10 seconds. Is there a way to stop and restart a particle emitter that will give the effect that I want? Just to cover any initial questions, I have read and re-read the javadocs (which are, as ever, reductive and unhelpful) and have read what I can find on the internet (mainly FrumsNL videos on youtube, which mention but don't cover this case) as well as doing my own trials as per the list above. Any help gratefully received. 

The algorithm would produce 3 rectangles for your specific example. To get a result with only 2 rectangles, you would have to alter step 3 so that it only stops at a background pixel and ignores already visited pixels. This however would potentially result in a lot of overlapping rectangles. So step 3 could be optimized further by keeping track of unvisited and visited foreground pixels. If the last pixel (before the background pixel) is a visited pixel, use the last unvisited foreground pixel to get the . Update: I went ahead and implemented the algorithm I proposed. Here's an interactive demo where you can try it yourself (click "Play flash full screen", if the display is too small). Controls: Click and drag in the black area to draw pixels. Hold Shift and draw to erase. Double-click to clear the canvas. Here's the full source of the flash demo. 

There are several ways to achieve what you want. The easiest way would be to paint a colorized rectangle above your grayscale image and use one of the following blend-modes: , or (which is a combination of screen and multiply). Here's how these blend-modes look (red rectangle over grayscale image, using multiply, screen and overlay): 

Finding these cuts (seams) is something that is usually done by artists, as there's no algorithm that creates good cuts for every type of mesh. The most primitive approach of unwrapping would be to simply project every triangle to 2D. You can even have overlapping UV coordinates, so every triangle could have UV coordinates of . That would look horrible though... a slightly better approach would be to have coordinates that correspond to the triangle size. But that will still result in visible texture seams at the edge of every triangle. If you just have basic primitives like a triangle or rectangle, then generating the UV coordinates should be trivial. You can project the primitive to 2d (by looking from the surface-normal) and calculate a (2d) bounding-box of the vertex coordinates. The longer side of the bounding box will map to 0..1. Then every vertex will get it's UV coordinate proportionally to the bounding box size. 

I believe that in a lot of cases it's not worth investing huge amounts of time into optimizing assets to shave off a few MB of your final game. Sure, if you need to stay below a certain size limit (eg. 100MB for Apples policy for apps to transfer over cellular-networks), then it's reasonable. A general optimization you can do is making use of some PNG optimizers (here's a tool that combines several of them). This can reduce the file size of a PNG considerably. In your case, you could save even more space, by removing all redundant assets. You could remove all smaller variants of the circles. Simply scaling the sprite in unity is going to be enough to create the smaller circles (downscaling of sprites is usually fine and pretty much the same as pre-creating the smaller assets). I'd probably even go further and just put one single circle into the sprite-sheet. Something like this: