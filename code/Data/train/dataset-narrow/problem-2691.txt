Economics Principles learned in economics are very useful in many parts of game development. I'm not only talking about money either; economic principles apply to decisions players make about about everything from whether or not to pick up the health pack to choosing which path to take, and thus knowing economic principles can help make your game designs much stronger. 

Assuming you want to work for a big established company, note that there is a lot of overlap between enterprise applications and games on the back-end. On the front-end they are very different domains, but on the back-end of a large MMO they have pretty much the same concerns going on with the database architecture, user data security, etc. 

Neither is really better than the other, so try both and use whichever you prefer. Or rather, go with whichever is most convenient to learn on (eg. one is already installed on computers at your school) because it doesn't make a whole lot of difference. For the record, I learned on 3ds Max but later switched to Maya when that became available on Macs. I still consider them about the same however and actually at my current job I use 3ds Max occasionally because that's what they have. 

Canvas and DOM aren't mutually exclusive, although they are fairly separate. One good approach would be to render the main game area (eg. the falling pieces in Tetris) using Canvas, and do all the UI (eg. score display) with DOM elements that are overlapping the canvas element. That said, such an approach isn't really necessary for a primitive game like Tetris. Canvas is useful for more advanced graphical effects, but if those aren't required then sticking to DOM will give you wider compatibility; not all browsers support HTML5 Canvas. 

You can't stop memory editing cheats, so design your game so that such cheats won't matter. For an online game, sensitive data like money on your own server, and don't rely on the client to have the correct amount. That way it won't matter if players change the amount of money displayed on the client, because when the player purchases stuff the game checks the amount stored on the server. 

Different tools approach that in different ways, but the way Blitz3D does it is to wrap the code and an interpreter into a bundle. Then when you run the exe, that launches the interpreter and passes in the bundled code. It's pretty much the same as how, say, Python works when using py2exe. In many game development tools, the code that is bundled along with the executable is simply raw text that the interpreter parses. However some take a bytecode approach like Java, where the source-code is turned into an intermediate form that the virtual machine uses. I think Unity uses this latter approach but I'm not sure. Off the top of my head all game development tools I can think of that package executables are either based on this approach of a core interpreter/virtual machine and then packaging it with the code, or are libraries that you compile in Visual Studio or whatever. 

That's not using GetComponent() on the class GameObject, it's using GetComponent() on the result of GameObject.Find() GameObject.Find() is a static function, but it returns a specific object. Note that Code 2 is also using GameObject.Find() but then you store the result object in a variable. Code 1 uses the exact same functions but doesn't store the result of GameObject.Find() that's the only difference. 

You can use Moai to develop iOS and Android apps from Windows, Mac, and Linux. However, you're going to need a Mac in order to deploy or test your app. 

I think you should try developing something small in Unity and then in Ogre and see which works better for you. Set yourself a small, specific project to do (since you're totally new to game programming, just make a cube on a plane ground that moves around) and do it in both development tools. Those are two of the better indie game development tools available and they take very different approaches to how development is done, so this'll tell you pretty quickly what you will be most successful learning game dev using and thus where you should focus your energy. Ultimately I think it's pretty misguided to ask others to decide this for you, so here's how to evaluate engines and decide for yourself. 

In this way the Dictionary of objects maps different objects to different lists. (Michael's answer also mentions Dictionaries, but isn't very specific about them) 

Floating point errors will start creeping in if things are WAY bigger than Unity expects, but just 4 times bigger should be fine (assuming of course you're consistent with everything!) I'm talking more like if you tried to simulate the entire solar system at 1 unit = 1 meter. 

Keep in mind, it will be simpler for you to get 2D art assets to practice with. So while I don't think learning 2D game development is a prerequisite to learning 3D game development (either way the game code on top of the graphics code is pretty much the same) I would still recommend most beginners start with 2D games unless you already have a solid resource for 3D graphics (eg. you'll be learning alongside a buddy who is a 3D artist). Code-wise, the difficulty depends on what you are trying to learn and what engine you will be using (and in particular if you will be writing your own engine). Low-level 3D graphics code is much more complicated than low-level 2D graphics code, but if you will be using an engine like Unity then you won't be writing low-level graphics code. The code for a 3D game built in that engine is no more complicated than the code for a 2D game. Indeed, it may be considerably less complicated, depending again on the specific engine you are talking about. 

Well first off, the particle images you're using appear to have a black background, resulting in the dark fringes in that second image. Don't do that; that is, don't draw the shape of the particle on the color channels. Instead, the image should be solidly colored and only define the shape in the alpha channel. Doing that will improve the look of alpha transparency considerably. Then you can further improve the look of the overall effect by having the particles change color over their lifetime. Like, the base image is very bright, giving you that central bright yellow area. Then tint the particles reddish orange and increase the tint over time. That way the particles will darken as they move out from the center. 

I'm not familiar with XNA specifically but most 3D development tools allow you to refer to bones in the model. In 3ds max just put a bone in the gun and then refer to that bone's position in your code. 

People always bring up boids because that gives very good results, but implementing boids may be overkill for your specific purpose. In the past I've gotten very good results by simply randomizing the target position within a small circle. For example, for a demo I built in Unity I used its command Random.insideUnitSphere to do flocking puffballs 

Incidentally, I wasn't using any of the engines you mentioned, but any 3D graphics engine that supports multiple cameras (which almost certainly includes all the game engines you mentioned) should do. Because CAVEs generally exist within academic settings, the graphics engines usually used also come from academic settings, like Ygdrasil or Electro 

I wouldn't do the turn-based gameplay in a separate loop. Instead, just have the one main game loop like any other game, and that loop checks if it's time to advance a turn yet. 

Now, while animation blending works best with skeletal animation, you can also do it with vertex animation (eg. MD2). This is more of a historical note because few modern game engines use vertex animation, but you can set the vertex positions in the same way, as a weighting between the vertex position in two different animations. This could result in some weird looking interpolations (eg. parts of the mesh collapsing or turning inside-out) if the two animations were too different, whereas skeletal animation ensures that the various parts of the mesh stay whole.