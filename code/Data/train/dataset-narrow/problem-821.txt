For something as important as a remote server connection, I would want to make sure that you have covered the appropriate magic methods such as and to make sure you have enforced behaviors to close connections when the object is de-referenced, prevent attempted object cloning, etc. 

Your code id very happy-path oriented. For example, you just assume all your database operations will work as expected as there is no real error handling around them. For example, what if does not return a value? You are already passing this directly into another function, just assuming a user ID is returned. 

I think you should consider some of the edge conditions of input in addition to just reviewing your logic. For example, you might consider validating both inputs as arrays. You can also bail out of the function early if the "needle" is empty or its size is greater than the "haystack" array size. I also think you can pre-prepare your haystack array to deal with the looping back to the beginning of the array. Finally, you can leverage the method as the means to iterate the haystack the seek out the first index that meets your match criteria. This basically means you can encapsulate your comparison logic in the callback to this function. Putting it together might yield something like: 

Your prepared statement initialization should happen before this loop. Prepared statements were meant to leverage this use case, allowing a single prepare, then executing it multiple times. This skips some overhead on the MySQL end with not having to make a query plan for each execution. You can also perform your parameter binding here as well, as there is no need to perform this operation multiple times either. 

Then it would seem the ##.## number is behaving somewhat like a key to determine the parsing template. So shouldn't your "template" use these key for lookup like: 

In class A, why your config? It should be considered very unusual to have a require inside a class like this. The require should be somewhere in your bootstrap sequence prior to where this singleton is first used. Then you just use the constants as you are currently doing since constants are global in scope. 

I think @Ext3h gives some good advice around perhaps making the test more meaningful, by exercising key elements necessary for proper site operation and for looking at multiple vectors (including logs) for overall site health. I will add some comments on the code itself. I have added comments within code context. 

If you take suggestion of moving this to more "class-like" structure, you would need to replace references in your methods from (the class) to (the instance). 

Should this be a ? I would think you would want your application to fail loudly if a class is unable to be loaded. 

If you properly validate the data up front and use in combination with prepared statements, you don't need to perform on the data. 

Hard to give full answer without understanding the ReaderFeedback table definition. I will point to some areas of concern. 

You may consider moving towards a dependency injection approach to your framework. Right now, your framework exhibits poor encapsulation and division of responsibility, which is something that proper instantiation and passing of dependencies could help to address. For example, right now, pretty much your whole application logic boils to to the constructor method. You get to the point of calling this method before: 

Why should the collection hold a method for rendering the command? You already have the command living properly on the object, so isn't this basically a method? For example: 

You should be using if not specified as such in your ini file (this is not shown here obviously,so I am not sure what your current approach is). This will help mitigate against session fixation, but will not help if an attacker uses one of the sessions id's you are collecting as cruft. 

On PHP side: I would strongly consider using PHP's and related classes (in this case specifically, ) rather than the procedural functions. Over time I think you will find them much more powerful and flexible in usage. This also can help move you away from the concept of resetting your default system timezone, which I don't think you want to overwrite here, but rather use as fallback. There may be other parts of your code that do things like insert records into database datetime fields or something like that where you want to use a consistent system time, not the end users timezone. I don't think you have an appropriate use case for changing this setting (at least from the context shown). Let's show an example of how this might look using : 

UPDATE Do your values really need to be stored in hidden input fields? What is the value of doing this versus injecting these values right into javascript variables? They can't hold any value for server-side validation, as a user could easily modify these so why make it so painful to extract these configuration settings from a DOM element as opposed to just: 

Consider replacing this with - $URL$ - or have this function used within validate_form operating against a configuration passed into the function as parameter. This function allows for both validation and sanitization depending on what filters you apply to each passed parameter. This a more reusable approach across various pages with forms in that it allows you to avoid having to have several different validation functions for different forms. Instead you have a single function which can perform your POST validation and you have form-specific configurations which you can pass to that function. 

There are some major concerns with this approach. First, why rebuild all the DOM elements every time there is a change? Your universe of different countries, provinces, districts, etc. is static right? You could either render all DOM elements needed for the page up front (probably the simplest approach), or if you find this is too much bandwidth to download on initial page load, lazily load different options on the tree as the user's selections warrant. But in any case, once the element is added to the DOM, there really is no reason to ever overwrite the DOM element. You should then just be working with DOM manipulation (hiding and showing to filter options, setting/unsetting which options are selected at each level, etc.). Second, you have added a lot of complexity by having the entire selection tree handled in a single event handler. What you really have here is a recursion problem. The central action that is taking place when a selection is made at any level in the tree, is that all descendant nodes in the tree need to recalculate. Let's think about how we might be able to solve this problem using recursion. Finally, you really should take advantage of caching your jQuery collections, so you don't have to traverse the DOM using selectors every time the change event handler is fired. I will show an example of how this might all fit together. Note that this example assumes all DOM elements are loaded up front (and probably all but root elements are hidden). Here I am keeping it simple and just using order of elements on the page to determine tree hierarchy. You could decouple the parent-child behavior from HTML structure using data attributes, but I won't do that here for simplicity sake. Instead, I will only focus on using data attributes to relate options to their parent option within "parent" select. Let's assume simple HTML structure like this: 

This is consistent with your usage in in inheriting classes and consistent with iterator interface. This also allows for override of in inheriting classes if there ever was such a need for this. 

In your function you are both outputting and returning an error message. This is odd behavior as typically a function should do one or the other, not both. Why would you return the error message to the caller if a message had already been output. I would suggest that typically you would not want a function like this to directly output to standard out. Leave it up to the calling code to determine how and when to message the user, as it is better positioned to do so. This sort of spurious output can also be problematic when building more complex applications, as you may need to do things like set headers (including cookies) and such throughout your code and having spurious output like this (rather than all output being delivered to browser at one specific point in the application) is going to make your application hard to maintain. 

You are really only doing the minimal amount of data validation available when working with your method arguments. Perhaps consider more meaningful data validation (beyond just type hinting), especially on your public methods. You for example, when passing in table name as a parameter, you should likely validate that the string is not zero length. Some of your integer values might need better enforcement (positive values only? unsigned?). You should fail out of these methods early before doing things like trying to operate against the database, when you know you have invalid values. 

I think @GregBurghardt has given some good commentary as to why this is not truly a factory as well as a good example of what a factory may look like. I will not re-hash that commentary here. Instead I will focus on other areas of your code (more of a full code review). I have included thoughts below. 

First, it is really unclear from your example what the point of the removing select options is, as the example does not have any dates in the past. I would guess that this list of options is being created somewhere, and maybe wherver that logic lies is the proper place to address this problem, rather than first adding and then removing options from the select. What if you just never add inappropriate dates to begin with? This problem just goes away. That being said, let me provide some feedback or what you have: 

First, I would consider splitting the upload/record creation endpoint (POST use case) apart from the view/retrieval endpoint (GET use case). Why introduce the complexity of managing both of these endpoints within a single script? There is basically nothing to lose into splitting these endpoints, and a lot to gain in terms of simplifying your code. A rule of thumb you can think about is that the more indented code you have in a script (via conditionals, loops, switches), the more likely you are to have bugs. So in this case why deal with two wholly different codepaths with different expected results within one script? 

In you might consider not trimming input, but rather making sure that looking for whitespace at edges of string are part of validation. Do you really want to enable the caller to send you a malformed string, with the class silently correcting them vs. having the caller send correct strings? 

I guess my first suggestion is that, unless you really understand cryptography, you really should not be writing your own encryption libraries. Use an existing one like libsodium (or something based on it) , or, if you can't install the libsodium extension in your environment, perhaps the defuse/php-encryption library which is well-regarded. Now on to your specific code... I would start by not having your in your codebase at all. Any sensitive information - passwords, encryption keys, etc. should never be placed in your code base where these items can be visible in your revision control systems. Ideally, you can derive this from environmental configuration and inject the secure material during environmental deployment. Stylistically, you should consider starting all PHP class names with uppercase letter (which is pretty much de facto standard) and stay away from mixing camelCase and snake_case in your code libraries as you are doing here with camelCase class name and snake_case method and variable names. I know PHP is not good about this within it's built-in classes and functions, but that doesn't mean you shouldn't be in your own code. From a use standpoint, is there really reason for a class like this to be instantiated, or should these be static methods? 

The answer provided by @ThijsRiezebeek gives really good information about moving your class towards using a singleton pattern. Since you mentioned dependency injection (though you are not currently using it), I figured I would provide some commentary more geared towards that approach, which many people would prefer over using something like singleton (especially in complex applications). With dependency injection, you have to really embrace a different approach with regards to how you deal with dependencies. Rather than having calling code or classes need to instantiate or create their dependencies (for example a database connection), you look to instead make the dependency available to the code that needs it as part of the executing that section of code. Take for example a class that needs a database object to interact with the database to do something like interact with a user record. An approach that does not use dependency injection may need to instantiate the database object itself in a constructor. Let's give an example that utilizes a singleton to provide the DB object. 

Do you really need to be arbitrarily creating objects/arrays in your data structure the way you are doing with arbitrary levels of nesting? Taking this arbitrary retrieval/assignment approach to this problem of working with the desired data structure seems like a problem in how you have conceived your implementation. By my brief perusal of the specification you linked, it would appear that you are dealing with a much more specific data structure than this arbitrary get/set approach conveys. For example, I am guessing that you might need individual methods/functions managing the different nodes on your data structure (page, product, user, cart, etc.) so that you can actually enforce proper behaviors on those subelements on the data structure. 

Indent your code properly. Your code is really hard to read. Everything inside curly braces, should be indented one level. Even if you have control structures like conditionals without braces (which would be non-compliant with PSR-2 style guide), you should indent the following line so it is clear that the line is within the control structure. Example: 

Neither of these is the use case here. The stored procedure is giving you no benefit at all. You could just as easily have that logic in your application and not "hide" it away from your application developer. Second, Don't use views in MySQL. They perform horribly. Finally, I have inserted code review comments into your PHP code. They are within multi-line comments below. 

The real problem here is that you are querying in loops (almost always a bad pattern) because you are relying on built-in Wordpress querying functions, rather than writing raw SQL to query all this data at once. My guess is you can do a single query to get both the paginated results and the total number of rows without limit being applied (by using ). You might consider opening StackOverflow question specifically about the multiple/slow query problems along with information on your database tables relevant to these queries to get a suggestion on how to write an appropriate query. 

You might be able to optimize for performance and/or memory utilization by implementing loops and counters, but you must decide if it is worth it.