The first parameter is the position of the rotation, the second is the axis you want to rotate around, say up, left, right, etc.. And the third is the amount you want to rotate it by. 

This is good because, if you ever have 10 Attackers battling 9 Defenders, you have a larger bias towards the attackers (because they have more troops) and yet it still gives the possibility for there to be a stalemate. As you see these results below show how each of 10 battles turned out, with the attacker having 10 troops and the defender having 9: 

A quick and easy way to do this would be just to pass in the object as a variable. Creating a public GameObject variable in a script will allow an object to be handed to it from the Unity interface. 

As expected, the attacker has won most times because they have a greater amount of troops, and yet there is still a small chance for a draw to occur. If your troops all have different stats, you can then just take and add them to the result variable as you please. 

First of all, I would make your troops into just an integer: the number of units. If you don't want to do that, just use the array length as a gauge for their troop sizes. Now the easiest way to do this would be to just take the amount of attacking troops away from the amount defending troops. If the result is negative, the attackers win.. yet if the result is positive, the defenders win and if it's 0 its a draw. Then to add random casualties, you just add a randomly generated number from -1 to 1 and add it to the result. 

I am trying to filter a category in my ray casting (jBox2D within libGDX), which should return the closest object that does not belong to the category . I've tried a plethora of approaches, but none of them seem to work. This post, for example, instructed me to do so: 

I want to save my game in libgdx, and I have no problem using Kryo to save everything, except the box2d Worlds and the RayHandlers from box2dlights - these are not Serializable and do not have default constructor, ruling out most of the methods. I have no idea how to save them, but I'm aware the most used approach is JSON - which I'm ok with. I even found this, but it seems to be specific for jBox2D alone, because I'd have to change all the names and packages in the code to match libgdx's box2d version's. Also, it uses the famous original JSON lib for java, whereas libgdx has it's own internal JSON handler and parser. So, I could just convert everything, as I said, it's all opensource. But it is such an absolutely essential task (serializing), present in every single game, that I think libgdx might also have something to do this. I can't, however, find anything about it, anywhere. Can someone put a light on this? Just some background: my game happens in a galaxy, and every single planet has it's own World for handling. But I only load one planet at a time in the memory: when the player leaves, I save it on a file. So my save consist of one main file with player data, galaxy structure, anyway, everything else, and a folder with one file for each Area (planet's map). This map contains some objects and data plus the World and RayHandler from box2d and box2dlights. I'm using JSON (libgdx's default) already for the Area class, but if the world and rayHandler fields are no transient, I get a StackOverflow, probably due to circular refences not supported by JSON writers. As I said, I can't use kryo due to the lack of private default constructors in most classes, and JSON does seem to be the standard approach for this. The lack of a solution built-in in libgdx, however, is really making me wonder what I'm not seeing in all this. 

Also, the transform variable already supplies you with useful functions that you can mess around with, like Translate and RotateAround. To rotate an object around an axis, use 

Then when you go back into unity you can see a new box appeared in the script module. You can then drag the object you want to manipulate into that box that says and it'll be passed into your script as that variable. 

A good way to do this would be to have a game object that generates the blocks from a script, then generate a box collider for the whole thing and render it all from one game object. That would remove the need for a huge amount of game objects. All you would need to do from there is pass the map-generator some sort of block-map. Of course, any unique blocks that could be uncommon within the game can be kept as separate units. 

To then manipulate that object's position, you can just use its transform and do as you please. It's the object's transform variable which determines its position, rotation, etc. 

The first parameter of ResourceLocation is your Mod-ID/assets directory. From your image I can see this is "thundrial". This should find your assets correctly. The second parameter is the path from to your image. My second point is, what you're doing wont render your background image. The method is used by MC to draw the default options menu and not your own custom background. The parameter is a UV value, not an image id. For as far as I know the easiest and most simplistic way to do what you're doing is to render over the background by using the bind method: and then using the gui's to draw the image over the top.