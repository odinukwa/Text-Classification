I'm sure your colleague has their reasons for wanting to keep the code as it is, but lets put it like this: If I were to write this code from scratch, I wouldn't write it like this. First of, the code has obvious duplication (eg billing and shipping addresses), which really hurt readability. The main issue for me would be that it is a lot of code that does widely different things: it handles addresses, payments, product info, and so on. If you want to change something, you have to look through all of that just to find what you want. If it is handled everywhere like this, that will take quite some time. The benefit of templates is that you can separate these different things into different files, and reuse them. For example, I'm sure that you need to display the billing address in the backend as well. Or in the user profile. Or ... Same is likely true for a short product overview, etc. Because of this, I'm guessing that you also duplicate code across files, which isn't good. It makes code less readable and a nightmare to maintain (you have to change it in every file, or everything looks - and works - slightly different everywhere). I'm not that familiar with magento templates, but just one thing: I'm pretty sure that magento doesn't have automatic XSS protection in their templates, so something like looks open to XSS (that's just one example, it happens all over the place; sometimes you do use , but not nearly everywhere). 

In the future to avoid this, whenever you copy-paste code, try to immediately think of a way to do it better (it's easier to do it correctly the first time, than to find the small differences in 8 methods). First of all, you could extract the code that is exactly the same (this will make it easier to find differences in the remaining code): 

Your alternative method of having a class is definitely not the correct approach. Your class doesn't work without a db, so if a caller doesn't call it, it will cause problems. Either pass the db object in the constructor, or pass it on to the various methods. 

Note also that I removed the unneeded variable. It will probably not increase performance, but the code is nicer, I think. I don't know what values and could possibly have, but I would assume that you can somehow save checking (and possibly some of the other bounds checks) each time. You could also try to save and in a local variable to save the computation/accessing, but I would assume that either the compiler optimizes this for you, or that the introduction of an additional variable offsets the performance gain. I don't think that is the bottleneck (although it would be good if you would profile this), but here you could also save the result of etc in a local variable, instead of saving as you are currently doing ( is never used anywhere except as argument for , so this would actually make sense and should result in nicer code). 

Yes, definitely. Currently, you have SQL in the model and the controller, which isn't a good idea. It makes it hard to make out what the actual query will be, and splitting up one functionality (database lookup in this case) in multiple classes is not a good idea in general. SQL should be part of the user model (or DAO), so create a method called there and use that. Security You are completely open to SQL injection, as you put values directly into your query as column name and like clause. When putting variable content into queries, you should always use prepared statements to defend against SQL injection if possible. When it's not possible, for example with variable column names, then you should prepare a whitelist of your columns, and check if the user input is in it. 

Extract Method You can extract the method to retrieve a string. I think that this makes the code a bit more readable, and you get method for free. 

It doesn't matter if was checked on the other server, I would not trust it. Maybe the code there changed, and users can change their name, and the check there is forgotten. Who knows? Using prepared statements for the id is just for uniformity. It doesn't hurt, and when there are no variables in the query at all, it is really easy to find forgotten once that really don't belong there (even automatically). Security: Opening Database for remote access If this script is the only reason that the remove server opens its entire database for remote access, I would just write an API that exposes this data on the remote server (with an authentication mechanism of course). That way, you minimize damage done to the remote server in case the database credentials are retrieved either from it, or from your other server. Or you could only open the remote server to this server (come to think of it, that's probably what you are doing). This still leaves the remote server vulnerable in case this server is compromised, but that might be acceptable for you. Performance As @Pinoniq said, using prepared statements correctly will mean that they are only prepared once, which will increase performance. Additionally, you are running a query on the remote host on each loop iteration, setting the time last checked, which is probably slowing down your script considerably. This does not seem necessary. Just insert the last data after the loop is done. Although this seems a little off. Why is the registration date of the last user relevant? You don't sort users by registration date. So either do sort the users, just insert the current data (minus some amount as buffer), or keep track of the latest date in a variable, and then perform one update after the loop is done. Misc 

SQL Injection You don't have to use PDO, but you have to use something to defend against SQL injection, and isn't it (for one because MySQL is deprecated, and also because it's way too easy to forget to put around the variable in the query, and once it's forgotten it's hard to see that it's missing). Using prepared statement isn't hard (see here for mysqli and here for PDO). Early Return If you return early, you can often reduce the nesting of if statements: 

If you don't want to duplicate the encryption parameters, saving those in the class may be a good idea. I would also pass the key to the function instead of hardcoding it in the function itself. Return values and error handling The return values do not seem that well defined. The function returns: 

But you can see that most of these renames are not necessary or would be obvious if the functions were moved to a better context. Comments Your comments are helpful for people learning PHP, but if this isn't code for a tutorial, you should remove them. Inline comments shouldn't duplicate what the code already told us, but explain why the code is written the way it is. Your function comments would be better as PHPDoc comments. Also, some of them could be a bit more in-depth (eg : how does it "deal with errors"?, etc). Misc 

Here is a nice overview of what HTTP methods should be used for what. Reduce Method Complexity Currently, your and methods are a bit complex, because they handle the single case and the multiple case (), or the update and create (). This leads to multiple checks on the id ( and ). Your code would look better if there would be separate methods for each case, eg: 

As I said in my comment, your code should run in O(n). the first loop is , is constant, is constant, the second is again , which leads to 2*n*c = O(n). So timing wise your code does pretty well. I don't have many other complaints about it either, just a couple of small points: 

Validating HTML5 Code It seems that you are new to HTML5, so it's a good idea to validate your code. You have 14 errors and 5 warnings in your code: 

Performance I cannot offer any mayor improvements, just some small things: You should save results of a calculation or action instead of doing them over and over. For example: 

I would (at least in the places you are using it). It makes your code really hard to reuse. And it can easily lead to problems once your requirements change. Personally, I would just use exceptions, and let them bubble up to wherever you want to handle the problem (I usually follow MVC loosely and do this in the controller). Security Yes, your code should be secure. You are using prepared statements, and you are using them correctly. Additionally, you prevent XSS, which is also done correctly. Two small things: 

First of all, it's great that you want to do this. Prepared statements are always safer than escaping (and your current script seems to forget to escape some values, which would be a lot easier to catch with prepared statements), and it's actually important even in a script like this, which doesn't accept direct user input, because of second order SQL injection. You didn't post your class code, so it's impossibly for us to tell you how to do it with this class. On the other hand, the class doesn't seem to be all that great (you can/must do something like , etc), so you might as well use PDO directly. The complete intro to PDO can be found here, a shorter one about prepared statements here, and if your problem is how to actually write insert queries, see here. Also note that if you perform the same query multiple times for different values, you only have to prepare once, and can then execute multiple times (which will increase performance). If these links, and the link posted by KIKO in the comments do not help, I would suggest that you try to write prepared statements, and post the non-working code on stackoverflow and ask why it's not working. Misc 

You can defend against XSS by using when echoing data. Nesting Personally, I don't like these kinds of nested ifs. It's hard to see which clause the different statements close. With just two, it's still manageable, but when the code is extended, it will become very difficult to read. A different structure might look like this: 

For a session cookie, you really want to set to true, and possibly if you are using HTTPS. Note also that isn't timing safe and that it is always better to use instead ( values are always treaded as string, so you won't have a problem like , but it's just good practice). Misc 

There really isn't much that you can do wrong here. You correctly tell the browser to delete the cookie, and there isn't more that you can do. But if this is all your logout code, you are vulnerable to CSRF logout. It is debatable if this is a security issue; some argue that it is not, as cookies may be forcefully deleted by overflowing the cookie jar, but that's really a browser issue that may or may not exist on the client side, so to be on the save side, you should add CSRF protection. As a matter of best practice, you should also always die after a header redirect, as a client doesn't have to follow the redirect and code afterwards will be executed. This doesn't seem to be an issue now, but it may be in the future. Other than that, your code is fine, but I would remove all your comments, they are just repeating what the code already says. If you want structured and named code blocks, just add functions. 

Naming , , , , , , , , are all bad names. There are very few situations where one (or two) character names are appropriate. Basically just i/j for a loop variable (but just where a better name doesn't make sense), x/y for coordinates, and well-known variable names in mathematical/physical equations (and even there I may prefer eg velocity to v). In your situation, it is for example quite unclear how t and u and s and e relate to each other. Better names for the strangeSort function variables may be related to what they actually do (so something with and in the name). Formatting You should paste your code into any IDE and let it format it for you. While you are mostly (although not completely) internally consistent, there are many oddities which make the code harder to read, including minor things such as odd spacing and multiple assignments on one line, and more important things such as missing newlines. Unnecessary Code 

But in general I think it's also fine the way you have it. It's not the most readable, but adding too much complexity to have nicer unit tests doesn't seem like a good idea. 

Security You should use prepared statements when putting variable content into an SQL query, and you should encode special characters when echoing variable content. It' hard to say if this is actually exploitable at the moment, but I could imagine various possible attacks, eg for SQL injection (a simple attack; depending on the allowed characters when registering, this might be a bit more complicated): a user registering under the name (assuming that the admin is named , this would not be a duplicate name, and it would result in this user gaining admin privileges). For XSS (this is a little far-fetched, but still): create user called , then - if there is no CSRF protection on the login - log the victim in as that user and make them visit that page. Misc 

OOP OOP wise your code is pretty good. I would change the piece type (and probably the color as well) from strings/boolean to enums, as they are easier to handle. I would also separate the model and logic from the actual displaying of the board (you can leave your current method though, rename it to , and use it for debugging purposes), the advantage will be that you can easily switch how you present the board if you separate these concerns (ideally, you create interfaces). I would also extract the code to get player input from the model of the player (again, with interfaces), so that you can easily switch how you get input. Your class is a little odd, in that it accepts in the constructor, and then in the setter for the same field. Also, it is the only place that your setter returns the object itself. Naming