If you already have a good PC, you could indeed turn it into a Hackintosh (dual-boot OS X or whatever) to run Xcode and do the programming, and then transfer your code to a low-powered Mac Mini when it's all ready. It is of course against Apple's terms to actually publish an app from a hackintosh system (whether they actually detect it is another matter; I don't know the answer to that), but code is code. It's just text. Who's to say what you wrote it on? You could write an iOS app on a clay tablet, and as long as you transcribe it into OS X before the final compile and publish, you'd be fine. :) (IANAL, just speaking from common sense.) 

I have no preference towards Ruby (or Python), I'm a Java person myself. But UnknownDevice's answer about how Ruby is somehow "not really for games" and Python is, frustrated me. I do hope he will clarify. I know Pygame exists and has been around, and I recognize that Python has a larger userbase than Ruby. But to be honest, neither of them seems like a language "for games". Neither does Java, and that's my game programming language of choice. (and when I say "of choice", I do mean by choice, not because it's what's taught in school or because it's something I "know"). And really, what is a language "for games"? Well, speed is a factor, and obviously it must have libraries for graphics and other game systems (audio, input, etc). As far as speed goes, it seems to be a tossup between Ruby and Python. Do some searches and you'll quickly find benchmarks and arguments for both sides of the spectrum, and various configurations which put one or the other ahead. Python with something called "Psycho" seems a popular speed demon compared to Ruby, yet regular Python seems to be a bit slower than Ruby. In the end, if you're choosing such a high-level language you're obviously not concerned with native speeds anyway; go with the language you know best. And obviously you know Ruby best, so I encourage it! The other factor is whether the technology is there to create games; whether it can support drawing to the screen and collecting input and playing audio. Ruby can do all of these. In fact there are a good number of options in this respect. There's a ruby-opengl package at RubyForge which will give OpenGL support to Ruby (or it might be included by default?). Alternatively, Chingu provides "lightning fast OpenGL accelerated 2D graphics!" according to its homepage; it builds extra features on top of Gosu, which you could choose to use if Chingu is too much for you. Or for 3D graphics, if you don't want to use ruby-opengl, try G3DRuby, "a very clean set of wrapper classes for many of the more advanced OpenGL features". There's even Rubygame, which I can't find much information on but it claims to be "a cross-platform multimedia library" and given the name, must have emphasis on game development. If you are familiar with the popular SDL library for C++, there's Ruby/SDL or RUDL, both of which are Ruby wrappers of SDL. Or if you prefer the newer, more object-oriented SFML, it is also available for Ruby! There is no reason that Ruby should be less of a game programming language than Python; if there is one, I'd really like to hear it so I can argue against it. If you feel most comfortable programming in Ruby, and you are aware of the pros and cons compared to other popular languages, then by all means you can certainly develop games in Ruby! 

How about using background music instead of sound effects? Animal Crossing is a real-time game (meaning the game keeps track of the time), and it had a different background tune for each hour of the day; the tune in the middle of the day is upbeat, "friendly" sounding, and the night one is very quiet and slow with some extra percussion sounds thrown in. I don't recall any bird chirping sounds, though there is the sound of water running when you walk near a stream and the sound of your own footsteps when you walk around (specific to the material being walked on), and there definitely was the pitter-patter of rain when it was raining. 

It totally depends on what type of GUI you have, but often games have things anchored along the edges of the screen and in corners, and then they might have a box in the middle of the screen for a modal dialog or something. If that's the case for you, then might I suggest using a scheme where you specify an anchor and an offset (x,y)? This would be similar to Java's BorderLayout (but maybe with the four corners, four middles of edges, and one center of screen). So for example, you could specify an offset of (0,0) from the top-left corner; then the element would be anchored exactly in the corner of the screen. And then no matter what resolution, aspect ratio, etc., you would have the health indicator in the corner of the screen. But then if you anchor an element to the top right corner, the element would naturally be anchored relative to its top right point (instead of top left), so again it would be automatically anchored to the corner of the screen no matter the resolution. I definitely recommend against normalized 0.0-1.0 coordinates; these could vary based on floating-point accuracy. GUIs should be mapped to pixels, unless you have a 3D GUI. 

Your framerate should be as low as looks good, but I think you're in a tough situation if all of your sprites are moving constantly. You should try your absolute hardest to keep a consistent framerate; a low, consistent framerate is better than a high but randomly stuttering framerate. Then turn it down until it doesn't look good. Consider matching the framerate of movies on the big screen: they are only 24 FPS. But again, they are precisely consistent, which is why people are okay with just 24 FPS. Alternatively, if your sprites have an animation sequence and that has a FPS value, try matching that or a multiple of it. For example if they animate at 5 frames per second, then maybe try 25 or 30 frames per second so that the sprite animations can be precisely timed and make the game appear more smooth and consistent than it really is. I think the best option in this case is to try out some framerates and find a good default, and then put a setting in your options menu for the user to be able to turn it up or down according to the user's desired battery life. 

You can reduce the bitrate; this is most likely what you did (without knowing) when you moved to m4a. This has a direct effect on filesize but does quickly fall off in quality. The bitrate is the number of bits per second that the music plays; as you can imagine, if you allow it a higher bitrate or a higher number of bits per second, it will use those bits to represent more detail in the music and so the music will sound better. It's perhaps synonymous to "resolution" of an image (but if you kept the image the same physical size). You might also try the ogg (Ogg Vorbis) format, it's an open format that is supposed to compress pretty well, certainly better than mp3 but I don't know how it compares to m4a. Finally, you can try switching the tracks to mono; this will halve their size. You can then perhaps use an algorithm to dynamically "spread" it back out to stereo in realtime. Typically, however, this makes it sound pretty terrible. Try it and see what you think. In any case, don't use WAV or AIFF files; they store raw, uncompressed audio waves. You absolutely want to go with a compressed format such as mp3, m4a, wma (yuck) or ogg. 

I love XNA. I really do. As president of the Game Development Club at my school, we use it and I teach it. But I'm worried about it. I've always wondered, are there any signs that XNA will ever become more than just a prototyping/arcade game language? I've always gotten the feeling that Microsoft is on the cusp of abandoning it, like they did Managed DirectX. The Xbox Live Arcade is an amazing idea but it's shoved off to the side, well overshadowed by the "real" Xbox games when I feel like it would've had so much more potential, had Microsoft given it more emphasis. Now with XNA 4.0 CTP for Windows Phone 7 only, it seems to be morphing into some sort of phone-only thing. I'm really unsure about exactly why they are doing that. What's the current state of XNA, and where is it headed? Is it going into mobile-only, or will 4.0 eventually be released for Xbox and desktop usage? In other words, is it a language to invest time and money into, or should it be only tentatively developed on, with the constant fear of abandonment? And when I ask this, I'm talking about desktop and Xbox games, as I can pretty clearly see that it is the game framework of choice for the Windows Phone 7 platform. Since this question is somewhat subjective (but I'm really looking for facts alongside your opinions!) I am making this a CW. 

If you think it's a standard file format, then I suggest you just quickly rename the file to different mesh formats and double-click until you get one right. This is assuming you have a 3D editor installed, of course. You might just go down the Wikipedia List of 3D graphics file formats; start with the common ones like blend, max, 3ds, ma, mb, ac, wings, md2, md3... Also please don't forget to mention what the answer is when you find it, in case by chance someone else has the same question! But really, either you try all the different formats, or we have to create sample files in each format and open them with a hex editor and look at their headers. I certainly can't find a place that lists all of the 3D format headers. The only one I know off the top of my head is that a Milkshape 3D file starts with the characters "MS3D000000", so yours is not a MS3D file. 

If you mean drawing, you can certainly use OpenGL ES on both Android and iPhone, and OpenGL on PC (and if you also opt for DirectX you might get a bit better performance in Windows netbooks). It is just as functional for 2D acceleration as it is for 3D. But I presume you mean computation. While I cannot give any experience in using GPU for computation, here are a few things you might not have thought of when optimizing your application: 

Don't get caught up on the concept of a "game engine". While it is true that game studios often have some sort of game engine which they create in order to speed the process of producing games, many independent developers get hung up on trying to create a game engine that they never actually make something that works. A game engine can be whatever you want it to be. If you find enough in common between your games that you can subclass an class like your example, that's fine. If an "engine" is really just a small library of functions which you've found to be handy in past games you've developed, that's great too. Whatever it means to you, the concept of an "engine" is just reusable code to help you make more games. If you're trying to make a game though, don't focus on making an engine. Make a game. Once the game is done and you're ready to make your second one, start making the second one, and you'll find bits that you already made in your first game; then you can extract those bits into a library or engine, to be shared between the two games. That's how an engine should be made. It's not typically something that you decide to write before making a game, because you'll end up with tons of code which is untested and you are essentially writing things before you know you need them (therefore you might not even need them). This is like premature optimization, but worse. So to directly answer your question, basically a game engine is a reusable "thing" (library, tool, framework) which a game studio uses to aid in quickly producing games, and they typically create it with specific games in mind or after having created several games, extracting out the similar bits and moulding them into an engine which they know can be used in future games. It should almost never be created without either retrospect (two or more games already created) or EXTENSIVE planning.