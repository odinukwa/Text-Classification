Render your scene to a texture of the desired size. Render a full-screen quad with that texture applied. 

Well, it's deprecated, so that's the biggest reason you'd want to avoid it. All it does is sit on top of other Windowing APIs (Raw Input in particular) and never really provided a significantly useful abstraction that justified bothering with it, especially since for everything except (non-360) joysticks and whatnot, everything you could do with it you could probably do more efficiently and more readily with Windows messages or Raw Input itself. A Windows game has to have a Windows message pump anyway, so you may as well use that. DirectInput additionally had poor internationalization and multi-window support (which in practice could become an issue if you ever embedded your game engine into a tool, for example). 

In parallax scrolling, you're moving multiple pieces of content (foreground and background layers) differently in proportion to their "distance from the viewer" property to make it appear that the background is displaced more per unit change of the "viewpoint" (even though the viewpoint may not actually be moving, you're just scrolling the background by). 

Because this type allows for tools to be added and removed from the available set, a plugin can define an entirely new tool that conforms to the interfaces, such as a for example, and install that tool in the toolbox during the plugin's loading callback. Similarly, you will want to remove the tool (and probably release its memory) in the plugin's unload callback. This approach can be applied to any number of different things you'd want to extend. At the heart of it you: 

In general, it does make good sense to own and control the things that are critical to the success of your business, and to outsource those that aren't. For some studios, the design or storytelling aspect of their games may be the critical resource they expect to capitalize on for success. For those studios, it makes sense to simply buy technology that will allow their designers to realize the appropriate vision. For others, technology may be the foundation for success. Studios that build MMOs, for example, generally will need to build that infrastructure themselves because it is critical to their success (and existing middleware is generally inappropriate, at least for larger, "AAA" titles). Note that some of the studios you listed (Crytek and Epic in particular) have basically stopped trying to be dominating forces in the games market directly, and almost certainly make far more as middleware vendors than they do as game developers. 

The canonical middleware for loading and manipulating FBX data in C++ would likely be the official FBX SDK from Autodesk. 

You can perform analysis on the image to locate the bounding rectangles of each sprite, sort those bounding rectangles (perhaps by increasing minimum X, then Y) and you'll have a set of bounding regions that correspond to the frames of the sprite sheet. Because this process can be relatively expensive, you will probably want to do this offline, for example as part of the build process for your game. You can then serialize the bounding region information into a file that you store with the corresponding sprite sheet image. At runtime you load both the image and the boundary definition file and you have the information you need to access each individual sprite. That is easier said than done, though. Essentially you'll want to do feature detection and specifically blob detection which are machine vision problems. You could also threshold the image (to black and white) and use an edge detection technique. The relevant math behind those techniques is explained far better on those links than I could, and in the case where you don't feel up to implementing that math yourself, there are a few libraries available that can assist you. The following set of links seemed the most promising to me: 

Basically, they are the same thing. Displacement mapping is a technique for adding surface detail, like bump mapping. Unlike bump mapping, however, displacement mapping is about actually deforming the geometry based on some input height map (essentially a grid of elevation values). "Displacement mapping" is basically another, more technically accurate, term for what is colloquially known as "height mapping" (strictly speaking, "height mapping" probably should refer to the process of generating the grid of elevation data from some source material, such as a 3D scanner, that will be used in a displacement mapping implementation -- but in practice most people just use the terms interchangeably, if they even say "displacement mapping" at all). The technique is not directly tied to adaptive tessellation, which is itself about controlling the breakdown of a mathematical description of a mesh (such as a sphere) into the concrete collection of triangles that will be used to render that mesh. The "adaptive" bit means that the tessellation detail will change based on some input criteria, such as view distance. In the sphere case, for example, you can tessellate that sphere very crudely (effectively as a cube) when that sphere is very far away, but use more detail when the sphere is close. Often you will see techniques like displacement mapping discussed in conjunction with tessellation because the tessellation will affect how you want to map the elevation map to the geometry to perform the displacement (or which resolution of the elevation map you want to select, et cetera). 

Build your inventory as a list of item stacks, and not items. Individual items (or items that cannot be stacked) are simply a stack of one. For example: 

You need to store the high score in some kind of shared persistent storage, either one you provide yourself or one provided by the portal hosting your game (if you are going that route, you'll want to consult their developer documentation; for example Kongregate's documentation on their leaderboards et cetera is here). If you provide this yourself, you typically use a file or a database. There are projects, such as assql, that provide a mechanism to connect to SQL storage (in this case, MySQL) from ActionScript. You can also use ActionScript's methods for working with external data to hit a URL that is backed by a simply PHP script on your server which talks to a database on the server and recovers the high score. There are a surprising number of tutorials and posts about this scattered around the web, for example, this one. The advantage to the PHP-based approach is that it puts all your database access on the server, rather than connecting to a DB directly from the client, which helps isolate you from a whole host of problems. You will of course want to further lock this down and make sure that users cannot submit bogus high scores simply by hitting, for example . 

, , et cetera as subclasses of sound like inheritance abuse to me. Fundamentally these types of weapon differ only in data (how much damage they do, what type of damage it is, what sprites or animations or effects are associated with the weapon, and so on). Consequently I'd advocate for an approach where you flatten this hierarchy away, leaving just the class. This provides more impetus for your suggested approach of giving weapons a flag and giving classes a set of types they can legally equip. If you implement this type flag as an enumeration organized like a bitfield 

I have found that the D3D SDK documentation does have a reasonably good, and relatively API-agnostic overview of the transformation pipeline. The thing to remember is that while references may show you how to set matrices with API-specific alls, nothing about the form or values in those matrices is API-specific -- it's all just math under the hood, and you can make it do whatever you need it to. In addition to the two links David Lively provided, there's an MIT Opencourseware graphics course here. You can also find a fair number of references -- of perhaps unknown quality -- by searching for "computer graphics pipeline" and omitting specific references to APIs. However, for the deepest forays into the theoretical graphics pipeline fundamentals, I would submit that books are still the best way to go. I am particularly fond of "Fundamentals of Computer Graphics, 3rd Ed," and "The Geometry Toolbox" (the latter is primarily a discussion of the linear algebra behind the graphics and not so much the graphics itself, though). 

I think that you can absolutely benefit from expanding your knowledge base and experience, especially as concerns other disciplines within the industry you work in (as a professional or a hobbyist). However, if you are talking about spending years of your life and tens of thousands of dollars to do so, and you're not really expecting to take that investment and capitalize on it to achieve a return (which is to say: get a job as a game designer), it's probably a waste of that time and money(*). You'd be better offer perusing the curriculum of any interesting-looking programs and investigating the relevant topics on your own, in this case. (*) True, some people spend a lot of time and money on hobbies, but that doesn't mean you should spend that money unwisely. "Game design" and "game development" degrees can be an unwise expenditure even for somebody who wants a career in the field; they are often very poor or have very poor reputations within the industry. 

In this loop, if your game runs at 60 frames per second, every object is also updated 60 times per second. However, if your framerate increases or decreases, the rate at which objects update increases or decreases as well. Typically this is undesirable because the wall-clock time (that is, real time) is still exactly the same, so the user perceives the game objects moving much slower or much faster. Old games typically did this, which is why if you try to run some of those older games on modern CPUs (even under emulation), they run way too fast to be playable, because your modern CPU can execute many more instructions per second. By contrast, a framerate-independent loop which relies on delta time might look like this: