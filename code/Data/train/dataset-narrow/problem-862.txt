There is, the public APIs. If the initialization didn't work correctly you will get invalid results from them. 

This returns the first interface that I use to chain other extensions to finally get to the operator I want to test: 

You cast it into a concrete dictionary but you never use the types anyway so go directly with objects instead. That's all. You don't need any of those s. 

The components necessary for the changes I describe here are not released yet and the new features are still in beta but they are very interesing and worth trying. 

The poor :-( I wouldn't put so much code in there, it gets ugly. A new helper method would be cleaner. In fact, the could implement a method. 

Helpers If someone would like to test it I include here the whole set of supporting types that make the entire thing work and provide a strongly typed fluent api. I will not comment on this. They are just a bunch of builders to make it easier to use and to eliminate magic strings. 

There's no need to the collection for because it expects an . Calling you loop over the collection twice. 

There are sometimes situations where you have a couple of related classes with fields or properties but you cannot access them via because you cannot define interfaces for memebers. I thought I write a helper that by utilizing allows me to do that anyway. It is implemented by the generic overriding the relevant APIs of its base type and throwing exceptions when a member isn't static or is an indexer. 

I'm writing a parser and I need to iterate through text vertically (down to bottom) and horizontally (left to right). This alone would be easy but some text parts need to be rescanned by another parser and for this I need to reiterate over random lines or a text range. I wrote two enumerators. One for enumerating all lines or only some of them: 

I've been experimenting with other designs and after a couple refactorings I completely rewrote the API (and of course incorporated the suggestions too). This is how it looks now: 

To speed up the paging you could group the items by page. If you then it you can access each page directly without reiterating the collection each time: 

I wrote a simple validation tool that allows me to quickly define validation rules and check my data objects against them. I know there is this another tool called FluentValidation but... I'm not a fan. So here is my small alternative helper. 

We cannot prevent everything and sometimes it's just easier and quicker to use the simplest solution like tuples in this case. You can always switch to something more complex if necessary but it's good to start by following the YAGNI principle. 

This is not a good idea. Try to implement those properties on the appropriated objects instead of having one that nobody knows what it actually means. Side note: Don't abbreviate the names. Use and not . It's the only But I see have even more multipupose properties e.g. the has a property and says it stands for: 

I've also written a few unit tests but I'll just post some for the part as they are all quite similar. 

It means that the user needs to know quite a lot about the internal implementation of each class/property to be able to use the builder properly. If he changes some property implementation then the build process might break somewhere at runtime which are the worst bugs to debug. I wouldn't use it for production code. 

The medium level adds some new stuff like new controls and card-click logic. Use the method to extend the form and the event handler to implement the custom card-click handling. 

When working with Excel and writing to cells the most common performance issue come from the sheet being constantly updated in the background while the script is running. In order to gain more speed you should save the state of a few properties for as long as the script is running and restore their values when it finishes. For example: 

As a user I don't really want to know where the object comes from (unless there are more sources and here aren't any other). A simple or would be enough. should be . 

If you don't want to use a generic message like This field must not be empty. then you can use the property to specify the key for the string: 

I think this method doesn't need to be . Generating tasks in not something you'd like to implement in each derived class. Consider changing its name to as this is what it does. Generate sounds like it would create some random tasks. 

I'm not sure whether it's really necessary to use a dictionary for the regexes. In most cases the static is sufficient and it already does the caching thing: 

I cannot give you an exact and perfect solution because there are several parts in your code that I do not understand like the and I haven't worked with AD yet but I think I can give you some hints. The class definitely does more then one thing. The most obvious indicator for it is the parameter and the four different initializations at the end. You should split it into those four queries so that each query prepares and maintaines data only for its own use. 

It would be much easier to optimize and use it if you refactored it into specialized structures/methods. 

I wouldn't call this structure a Queue because it isn't one. There is no and it doesn't work like this. It is more an then a queue. 

DRY Don't Repeat Yourself. In the above method you do the same thing twice. Try to merge the conditions and give them a meaningful name rather then putting a long expression into an : 

The sounds a like a workaround or a property for everything and nothing. suggests it has at least three purposes: 

Implementation You could improve the current implementatio to be more functional by using more LINQ. The method could work like this 

If I had one instance of the parser and called in two different threads weird things would happen. You try to hide it by instantiating it via the method but the default constructor isn't private so theoretically it's possible to use it incorrectly. 

Now come a bunch of managers. I don't like the term but I don't have a better idea for their names. The managers are not complete but just rough examples. 

A lot of code to just concatenate a string. This could be a single line if you used the method. There is no need to cast or convert anything. 

The hardcoded connection string name should be a parameter. You can have default constructor using a default connection string name but it's always a good idea to have another constructor that lets you use another value. 

They are both wrong. The answer isn't digital, this is, there is no 0 or 1 answer. It depends. Sometimes you must execute a collection and return a non-. Materialize when working with databases Such a case would be querying a database. In this scenario you'd open a database connection (or create a context if it's some ORM) and dispose it at the end. If you don't execute it with or etc. you won't be able to do it later. The runtime would wrap your enumerator with an anonymous type containing the context but when the execution leaves the method, the context gets disposed and it'll throw an excepiton the moment you try to get the data. In this situation you should return a non- type. The reason the return type shouldn't be an in this case is that tells me that the return type is lazy so if I wanted to use it multiple times I'd call myslef (again) to get the result which would unnecessrily enumerate the collection again. So, the bottom line is: if you don't have to materialize the result (because you won't be able to get it later when the service/provider is disposed etc), don't do it but be consistent with the API (return types). 

This method doesn't require the variable. You don't store the result anywhere so you could simply call inside the just after you create an event: 

There are also two helper classes. One is the . Its purpose is to enumerate the inner exceptions and to get the custom properties from each one. 

Notice that there is a inside the . You set the to so I think it's not necessary to test other rocks for a hit. You can stop at the first one. 

Core The starting point is the . It initializes the process of creating a for the given type and caches the that is used in subsequent calls. 

It's safer to use the method rather then hardcoding the number. Especially if you don't want to care about leapyears. 

You are mixing various things here. For some values you use the and for others the . I think you should stick to one of them. What I also don't understand is why you are checking whether this is true and then try to parse it anyway ? Here is what you can do: Create a property for each value: 

In a class this is virtually always bad. You set the first two to some constant values... so why do you need those additional fields? You can use the constants directly. The third field will however cause you troubles... imagine you code runs on a server where two users at the same time can login and use the . In this method you do: 

OCP The original soultion violates the Open/closed principle. What if you have more categories later? You would need to not only modify the class but other methods categorizing children by age. I suggest you let the class store all children 

I find it very weird that you use & as values instead of & that can be much easier converted to int/bool/enum. 

Creating the ListBox But how do we create the now? Like this. We set the and tell it to use the for the display. 

True, this would be terrible so here is one more quick & dirty example of a being refreshed with 100 items every 0.5sec and each value is refreshed every 50ms. No flickering, no delays. It's fast as hell and it should be. If it's not then something's not right. This can be run in LINQPad: 

Your code is very short so there is not much to comment on but there is one more thing that you can improve. 

It'd be safer to serch for parameters by type I think rather then relying on the count. If for whatever reason they add another overload with two parameters in future it could break. The same goes for . Also the string could be replaced with . 

In order to reduce nesting you should use early returns. This means that you should negate the first condition: 

You do not need three methods for sorting because the only difference between them is the property that you use for sorting. You might as well have only one method that takes a as a key selector and use it with and : 

The voxel could recieve a dynamic mesh via its constructor. Enums Both enums should be moved to their own files because they are public already. It would be fine to place them inside a class if they were private. Now if you wanted to use them somewhere else you need to write which is an unnecessary repetition. You could remove the voxel prefix but then another problem arises that you cannot have a property with the same name inside the voxel class. That's why I prefer to put them in separate files. 

The -prefix ;-) It doesn't hurt but it doesn't look professional either. You know everything there is yours so there's no need to emphasize it with my. 

For the reason detailed above I find it's better to create a simple object like (I used read/write properties but an immutable object would be more appropriate) 

In this console application it might not be that important but later you should always take care of any resources and dispose them propertly. Closing it isn't enough so you should wrap the streams in s: 

You should stay consistant with the variable names. The xml element is named but the property is . Pick one and use it everywhere. Otherwise you'll need to explain and think all the time what was it for. 

I think this would be more useful if the user could specify an interval and how many times he wants to retry like: 

Shortening s You add everything to the same list so you can concatenate all conditions and use only one with a helper variable: 

You are calculating this for way too many objects and faces. Consider this algorithm (I'm not sure if it will work because I don't know how Revit stores objects but it might give you an idea). 

Consider materialized parameters The same priciples apply to parameters. In your example you execute multiple times: with and with the loop. Here, I'd requested an or an to tell the caller: Look out! I'll be using your collection more then once (so you might consider materializing it for better performance before givit it to me). 

I prefer the first option and switch do the second one only if something really seems to run slow and I notice and measured it. So how would it look like if you ware lazy and wanted to get the job done quickly? You would create a map point generator: 

Voxel class You pass a data to various methods of the voxel class but you don't store it anywhere. I think it would be a better idea to move dynamic mesh related properties and methods to the and override its methods in different dynamic meshes if necessary rather then the 's: 

While implementing the Retry & Breaker patterns I decided that the Breaker does more then it should so I extracted two responsibilities into their own classes. Here they are. I stripped out the to be only data: 

This method shouldn't check the user-id. If it doesn't exist then the method won't do anything useful. Check the user-id before calling . 

The class stays the same but I removed the class and instead I created a new one, the class. This one will hold each setting as a property decorated with the attribute. In this example I used the context as a parameter for the constructor but this may be of course a context factory lambda or anything else that works for you best. Anyway, the one and only place where the name of the setting is actually written down is the property name. To get the setting you use another attribute but this time a compiler attribute . 

Here's an example how such parts could look like. Part 1 - Oscillator This part is responsible for creating collections of numbers oscillating between the given number. 

This class imports the exchange rates into a dictionary for faster and easier lookup. The dictionary ignores the casing with by using the argument so you can enter any name. You use it by specifying two currency codes and a value that you want to convert. If the target currency is PLN then it returns the intermediate value. Each value needs to be first converted into PLN and then into the other currency. 

I like lambdas very much but putting this much code into a constructor seem like way too much. In all four cases you should encpasulate them in separate funcitons/classes and pass them to the constructor like a strategy pattern. This would make the logic easier to test (I guess) without having to be a part of an . You already pass the to the constructor so there's no need for closures here. The could take one more parameter to work with later. 

I cannot complain about your code because it looks ok to me (at first glance) so I just share an idea. You initialize all properties for an object at once. I think it many scearios you use only a few of them so making the initialization process lazy should speed it up. A good start would be the . This means you initialize the getter/setter caches only if a property is accessed and even then, I would init only one cache at a time. If you use a getter, then init only the getter and so on. The API wouldn't change, just the implemention of the constructor and and .