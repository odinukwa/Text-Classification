Your code tricked me to think Logger is a property, and turn out it is a field. Why do you choose to have a public constructor for an internal class? It won't be available across assembly boundary anyway. 

Why do you use Logger to encapsulate the Console for output and then directly do Console.ReadKey() later? 

You print out "Start" to the standard output. This basically restrict any usage of this class to have access to a console. What if it is used in a GUI application? What if this is used in a server application? Also, "Start" what? Whoever read the console will have no clue what is started? The object is constructed as a static field, and Java did not guarantee when these static constructor are run (they only guarantee it is run before the class methods is run, so it is basically you have a console print that is shown in non-deterministic time. This is not great too. 

Bearing in mind that a linter can only look at how the code is written and not at what it's actually doing, statements (or the equivalent as with Ruby) that don't do much are completely fine. A switch that tests many conditions is bound to be long-ish, there's not much you can do there. Every one of the warnings you get is a direct consequence of the fact that you're testing 8 values. I would say this is one prime example of a situation in which you just don't waste your time in an attempt to make the linter happy. Extracting methods is going to clutter things up and look dumb. The only viable option that I can think of right now is sticking those ranges along with their readable description in some kind of hash, and retrieving the value from there. But it's a compromise, really: if this method gets called often, you could be instantiating yet another object at each call. I say you just ignore what the linter says in situations like this, or adjust its default settings to make it less bitchy. Your method is fine, the intent is very clear to me, and it's not doing anything complicated. Don't get all caught up in an attempt to please a tool that doesn't understand your code to begin with. 

OK, the data-structure looks a little wierd here, because your list consists of map-entries, but this was the main work. If you print this result, you already get (format added manually): 

... the same for min. As a general advice: Java is a very mature language, and chances are good that every "simple everyday task" is already solved in the library. (Also note that most books on Java are from the pre-java-8 era and may be considered somewhat outdated today.) 

First of all, cramming that all into a single method is not a good idea. Refactor the different actions into other methods (ideally with basically the same signature) and use a over the action: 

As to your compilation error: when you are working with final fields, each class constructor must ensure, that all fields are initialized. This initialization of all fields is the main point of the answer: deserialize the complete buffer once and then take all further interaction with the answer frame back to object level. 

Code like this is bound to be a bit hairy. However You aren't using parameters This is a big security vulnerability. What's that method doing? Is it doing everything by the book? Does it handle every possible obscure corner case? Let ADO the MySQL connector manipulate your query, especially if there's a chance you're handling values supplied by the user. MySQL can perform the so-called MERGE (also called UPSERT) You can do it via INSERT ... ON DUPLICATE KEY UPDATE statement. In case you are not aware what that is, it's basically a way to either insert or update in case the fails because of a duplicate key error. It's for sure faster than making a separate query to retrieve the records that are currently present. By the way, code like this leaves your code open to race conditions in case another user inserts a record exactly between when you read the current records and the moment you execute your . This is bad, and you're not currently guarding against it. MySQL can do it for you, take advantage of it. EDIT Also 

Hmm... the generalFizzBuzz method is a mix of business logic and output, I think this should rather be separeted. Thus, I'd rather have a business logic conversion number, which converts a given number to test to the output string: 

The User class Quite straightforward. However, the use of try-with-resources blocks is inconsistent. For some objects try-with-resources is used, for others the "old" construct using external null init and a finally block. Also note, that you can create multiple closable resources in a single try clause, e.g. 

Parameter checks First of all, I'd be very strict about the check of the parameters: I do not see any use in gracefully trying to work around unset or illegal parameters instead of throwing an exception. Thus, I recommend you start out with: 

Data structure: First of all, choosing an ArrayList as the data structure for a queue is suboptimal to say the least. A remove(0) on an ArrayList always copies the remaining elements to the beginning of the list (see remove implementation in ArrayList - sources are available). Use a LinkedList instead, which has constant removal time. New Files-API: Usage of try-with-resources is good, but manually creating a FileReader and a BufferedReader is quite old-fashioned. Simply use java.nio.Files.newBufferedReader instead. Method signature: Your LimitedLengthQueue.add method has a boolean return which is always true and never queried. What for? If you don't care, simply make the method void. 

Congratulations to the completion of your substantial project. It is really smart and brave for you to ask for feedback. I am going to tell you what is not so perfect about your code, after all, that's the whole point, right? But don't be discouraged, for you have done a decent job! Let's begin with the high level algorithm: The first thing I would like to point out is the usage on memory, in various places you make deep copies of all the cells. This is pretty convenient to do, but it also take up a lot of space. For the unique/elim/subset functions, you can simply return a flag if the board is changed, and save a copy in the solve function. It might be difficult to remove the deepcopy in the guess function, and that's probably fine, as you might be making a lot of changes. Try save some space, you should notice a performance change. Then let's talk about the code: The checkpuzzle function and the backgroundcheckpuzzle is almost identical, why don't you just parameterize it just like you did in unique? A lot of the code have the structure of going through each of the row/column/squares. It looks like a lot of duplication to me. What if you abstract them into a concept called block, and just iterate through all blocks? Last, and probably least, you made a few typos, 'recieve', 'posslibles' 'indicies', and I highly doubt the word 'possibles', although Wikipedia say it is a plural of an adjective. 

Regarding the method: you could at least eliminate the repeated call to s.length() for every loop operation: 

Edit: As an afterthought: why do you waste so much code with null-checks anyway? This is a technical interface, so whoever calls this, should simply not send you invalid requests. Therefore, in real life, I'd simply add the condition "values must not be null" to the interface contract (if possible), then do a single validity check at the beginning of the method, and reject with status code "bad request" if there are nulls in the data. 

This basically boils down to a grouping problem: you have an input list and want to group it by date, which yields a per-date list of a given length (1 to number of departments). Then, these list's contents get added to a collector list chosen by the list's size, i.e. add all contents of list with size 1 to collector 1, add all contents of lists with size 2 to collector 2, and so on. Using the stream API, you already have the grouping, the rest is a little footwork: 

For one thing, the domain being global is not very good: what if two users have email addresses on different domains? Are you going to set it to different values in between user creation? Just let the user have its own email address. Globals in general are frowned upon for many reasons, so when you catch yourself thinking "yes, I'll make this a global", please count to ten and then don't do it. To answer your question in the comments, where you assume you have an internal mail server only: a good rule of thumb is to keep outside of your program everything that can conveniently kept out. In this case, the domain is configuration, and as such it should be kept in a configuration file. Your program does not and should not know what the specific domain is. It just needs to know how to read it from an external configuration file/database/what-have-you. Modifying software is not a lot of fun, so if you can make a program whose behavior you can modify without even touching the source, it's way better. What if your domain changes? As it stands, you have to change your program, and possibly even test it again. What if the domain sits in a config file? You change it in there and you're golden. If you think hard enough, you will find that a lot of configuration can be kept outside of the program, even down to the choice of different algorithms to accomplish the same task. Personally, I try to make everything I make as configurable as possible, because recompiling and testing and deploying is boring. Finally, globals are bad because they're hard to keep track of, and it's difficult to know what parts of the code read from and write to them, which makes the whole thing horribly coupled. Do try to avoid them as much as possible. 

Volatile won't do anything here, as this basically only affects the reference to the map, not the contents of the map. As for ConcurrentHashMap (as opposed to explicit synchronizing I suppose): this depends. If you want to make absolutely sure that no digest is ever computed twice, stick to your approach. If you just want general concurrency, but can accept that eventually in race-conditions, digest is called twice for the same input (sidenote: I suppose digest is deterministic, so that two calls with the same input yield the same result), you may simply repace the map with a ConcurrentHashMap and the whole method with: 

By putting it into a method and naming this method, you document your business intention. Furthermore, by breaking up the long command chain with a new variable in between, the code gains much in readability. The additional line-breaks in the second part are what I consider best practices in streaming API: each new operation on a new line.