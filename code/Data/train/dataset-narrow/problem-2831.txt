Essentially this looks like something where you'd need a custom blending function where the result will depend on the distance to the outlines of the actual shape. 

Then open the project properties, select the "Publish" tab and click on "Application Files...". In the new window you should see your text file being listed and you're able to change it's group or status (default one should be fine). 

The next logical step would be creating categories for your objects (not always feasible). For example, you don't check an object for collisions unless it is explicitly defined as being some "collideable": 

Remember that you're doing isometric projection, not perspective projection (so you don't have to fiddle with real rotation along the x axis). 

As such, you can't really avoid people doing nasty things to your game client. Due to this, don't trust the client at all, i.e. everything important should at least be verified server side (better: calculated there). If this is done properly, the player won't be able to do anything harmful with their manipulated client. As for your login thing, I'd say it's perfectly fine to keep some magic number in your client determining its version (usually a protocol version or some checksum). This is passed during the login process. If it doesn't match, access is denied. In addition to that, ensure the game client is started by the launcher. There are several ways to do this, e.g. the actual game client could be a dynamic link library - not a real executable file - which is then loaded and run by the launcher. Overall, there's no 100% perfect way to avoid manipulations and the like. There's always some way to cheat or modify something (even if it just happens in-memory). Live with it and just fight those really doing something wrong rather than trying to secure everything. Such checks should only keep the player from accidently connecting with or using some kind of manipulated or broken client. If the player forcefully circumvents such measures, it's their problem in case something goes wrong and their client acts weird, displays wrong things, etc. (i.e. other players must not be affected, but if the player manipulating their game can't play, it's their problem). 

One socket should be enough, but you could split traffic between them, e.g. handling chat on a separate port, so you could later move that to its own server more easily (although I'd use TCP for that). 

This enables you to determine the time it takes your projectile to reach the enemy based on his currenct velocity (and orientation) as well as your distance to the target. Once you've got this, you can once again use the very first formula to determine the point you'll have to aim for: 

I'd probably use a 1 bit texture (more if you want to store more states) and then draw it using a shader (or a second texture you only modify once some pixel is hit). So yes, this would essentially mean you're working with a pixel perfect collision detection, but you wouldn't necessarily use a full bitmap/texture (1 bit per pixel vs. 32 bits per pixel). Of course, for performance reasons you'd first check whether your shot is actually inside the bounding box of the obtsacle and then determine whether it actually collides. As for drawing, there are many alternative possibilities, e.g. you could use voxels, a second texture with more details, or even some kind of 3D mesh (think of the different Worms games and how they're drawing their map). 

The only games I can think of right now using images as maps are several artillery clones, such as Worms, Gunbound, Warmux and others. If you don't want to use repetitive tiles in a tile map, I'd suggest you use polygons to describe your map and separated tiles/textures to decorate your map. E.g. your map file defines the solid outlines of your map and where to place art assets for the solid areas to be visible in some way (e.g. as a rock). 

These coordinates can be used to get a first estimate, whether there's more work to be done, i.e. whether there's just sky, some ground (i.e. pixel testing needed) or only ground. If you need pixel perfect testing, the next step should involve determining the position within the tile you'd be looking at: 

Since both approaches got some nice features, I typically try to include both at once. If I need accuracy for something, e.g. player movement, shots, etc., I update it using fixed timesteps. If accuracy doesn't matter and it's all about quick processing (e.g. visual particles), I update them only once per iteration (using the delta time). I'm usually using a main loop like this: 

You don't sync the simulation at all. Only the results. Or in other words: Those waves wouldn't be synced over network (only start/intensity and such). Only things moved by the waves (players, vehicles, etc.) are synced as usual. The waves themselves are calculated by the clients on their own with details/accuracy based on local settings. You can't really sync the whole simulation (with all details/elements/nodes) as that would require you to transfer/sync lots and lots of data. If you only have to simulate the surface, consider it being a net or mesh of points. 

First of all: I'm no designer either, my games usually consist of "programmer art". ;) Probably the quickest escape, congusbongus already noted in the comments: 

Please note that this approach has its flaws, e.g. you won't be able to sign your final binary (since that would once again change the layout). There are workarounds, but it would overcomplicate things here I guess. Of course you can use platform specific loading of embedded resources if you want to, but this won't be a cross-platform solution and requires further information regarding your goals. TL;DR: Is there really some reason to do so? If you want easy deployment, use a setup programm/installer (like NSIS or InnoSetup). If you want to compress/pack ressources, do so in a separate file. 

I'd move your game logic code to the same thread as your message processing/drawing code (i.e. the main thread). This not only saves you from properly locking ressources to one thread at a time, it also allows you to use vertical synchronisation (VSync) as an alternative to waiting in a busy loop or using your own calls to . In addition to that, you can introduce a minimum frame time (which would essentially be something like sleeping for 10 ms), which would essentially limit you to 100 frames per second. Also I see one tiny problem with your logic update: If your processing isn't fast enough to catch up with the time that passed (e.g. one iteration takes 10 ms, while there is supposed to be one update every 5 ms), you'll end up in an infinite loop of updates, that's getting a backlog that's only increasing in size. That's not necessarily a problem in the multithreaded approach, but if you consider merging everything, you've got a problem. In either way, you'd have to check for in your inner update loop, though. 

This would probably be more suited for programmers.stackexchange.com I guess, but basically it's just some added knowledge, based on what you're supposed to do (like GUI programming in Windows Forms or WPF. Overall, I'd say you should be able to get the required basics in a few hours, especially if you've worked with STL classes such as in the past. There are some added concepts and language constructs (especially if you plan on using LINQ as well), but overall I'd say you should be able to understand and train most generic concepts in a few weeks or just a few days (depending on how fast you learn, what you learn, etc.). Getting some simple UI program to run should be doable within a few hours though. 

This loop is outside any function, and as such not acceptable. You can't initialize array members that way for static members (or any other members). If you're using Java, you can use the following code for inspiration, but it won't work 1:1. There might be better methods to do this in newer versions of C#/.NET, but I'd just create some initializer code called in every constructor (this will work in any version of .NET): 

Random assumption since I've never used Pygame: You can't receive/check keyboard events before initializing Pygame first. So move down your line to be after ? 

I guess you're talking about player stats like attributes, health, and such? If so, I'd keep these things outside your player in some global "save state" (which will make loading and saving easier as well). In your player entity just refer to the right "position" (e.g. player x or character x as some kind of index or offset). I assume you're talking about separate combat screens similar to the older Final Fantasy games. As such I'd create a separate game state for this (so separate entities). This allows you to just "push" the combat scene on your game state stack and it's easy to return back to map screen without issues. Once combat ends, you just pop that state and you're back at your world map. 

Doing this will already create the parallax effect you're looking for. Simplified: Move your backgrounds with your camera, where the actual movement is a function based on the camera's movement and the distance to/behind the screen. The further away something is, the more you move it (so it appears static). This can get a bit tricky drawing wise, but you'll essentially just have to draw your backgrounds twice at most (so it always fills the screen, no matter the offsets). 

Note that can act as a real black box here. It doesn't matter how the updates happen, i.e. whether there's some fixed time step or not. Now let's unwind 3 iterations of that main loop and you'll get... Version 1: 

Simple answer: cheat or don't be that accurate! If you've played some shooter online, you'll most likely have experienced the so called "rubber banding" if your connection to the server is bad. This is caused by your client correcting your position from time to time. Basically, what happens on the two sides: