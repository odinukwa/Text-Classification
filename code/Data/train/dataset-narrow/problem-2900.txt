[Don't move if a collision is encountered on the way] This could cause jittery and weird behavior when moving towards an object. As, e.g. if the object is moving at 5 pixels per frame towards a wall, it will end up somewhere between 5 and 0 pixels away from the wall, depending on it's position. I suspect jittery behavior to happen when this solution is extended to collision checking between moving objects. [Implement IsTouching() methods to check whether an object is colliding but not penetrating another object] I have no idea how to elegantly use this information in the raycasting algorithms to allow "sliding behavior" of shapes, without sacrificing performance (as the algorithms are very optimized right now). Also, I imagine objects "touching" is defined as having a penetration depth of 0.0. Checking for this could cause errors in case of float rounding errors. [Push away both the object and the colliding object upon colliding] Some of my objects (such as walls and terrain) are static and I'd rather not move them even slightly to resolve collision problems. [Push the object out of the colliding object along the collision normal] Using this solution, the object can get stuck in another object, as it gets "blindly" pushed out of a colliding object. [Push the object out of the colliding object backwards along the motion vector] This sounds good as the object won't get stuck in other objects. However, I'm not sure how to choose "how much" to push the object out of the other object. The best thing I can think of is to move it using "a very small float number" such as 0.00001f. But this sounds very ad-hoc. 

By sampling your texture using these new UVs, a rotation will have been applied. You can increase your angle uniform over time to apply an animation to the rotation. 

The camera up-vector A property of the camera you could use to solve this problem is the up-vector. This vector indicates which direction in 3D space should correspond with the (upward) vertical axis of your screen. Usually, cameras will use the positive y-axis for this, thus: (0, 1, 0). 

I believe that OpenGL's standard clipping volume is [-1, 1] x [-1, 1] x [-1, 1]. You want to clip at [-1, 1] x [-1, 1] x [0, 1]. You can achieve this by transforming the z-coordinate after all transformations have been applied to the vertex position (model, view and projection transforms). In other words, you want to operate on the screen coordinates of the vertex. 

This will make sure, vertices which originally had z-coordinate 0, get mapped to -1. Coordinates with an original z-coordinate of 1 stay at 1. Everything in between is a linear interpolation of the two. As you are just doing a small additional calculation per vertex in your vertex shader, you won't notice a hit in performance. 

If I understand your question correctly, you are trying to find the center of the hex cell to which an arbitrary point belongs. Your question made me think of Voronoi diagrams... I have a gut feeling that they might be relevant here, though other solutions might have a better performance. (This solution might be wrong too, but I feel like it could be relevant.) Voronoi Diagrams A Voronoi diagram is a pattern of cells, with each cell containing one predefined point. Each cell holds all positions ("pixels" if you will) for which the cell's point is the nearest neighbour. In other words, a all positions get assigned to the nearest predefined point. In even other words, the borders of the cells represent positions that are equidistant to at least two points. The image below is an example of an arbitrary Voronoi diagram (taken from $URL$ Depending on how your points are positioned, you'll end up with a different Voronoi diagram. If you align your points as "horizontal lines, with all odd lines being offset by 50% of the horizontal distance between points" you'll end up with a hex pattern as in your example. You can adjust the vertical spacing between lines of points to "flatten" your hexes as in your post. The image below shows the layout of the points visually (image edited from $URL$ 

You'll want to look into pixel-art upscaling filtering algorithms ($URL$ These have been specifically designed to upscale pixel art, having the properties of (1) retaining the original color palette (aka. no blurring) and (2) removing jaggies (aliasing that occurs due to nearest neightbour sampling). Some names of algorithms are: Eagle, 2XSAI, Super Eagle, Super 2XSAI, Scale2X, Scale3X, HQ2X, HQ3X, HQ4X, 2XBR, 3XBR, 4XBRZ. They are more or less ordered from simple to complex, with 4XBRZ being my favorite in appearance. They all work with integer magnification factors (2, 3 and 4). The usual approach for obtaining non-integer magnifications is to take the nearest integer larger than the desired magnification factor and downscale the resulting image (using either nearest neightbour or linear interpolation). An alternative is to take the nearest integer smaller than your desired magnification and add borders around the image. The choice between these two approaches comes down to the style of your pixel art and personal preference. Edit: I ran your image through an implementation of Eagle, Scale2X and Scale3X I made a while ago. Here are the results in order (magnified by x2 so you can better see what the algorithm does to the pixels). Scale3X is the most complex algorithm, and it also looks best in my opinion. There are way more complex algorithms in the list I mentioned above though, so you'll want to experiment with more of them. 

Generate a circle using polygons You can also use polygons to define the circle. Rather than drawing your texture on a quad, draw an actual circle. Calculating the vertices of your polygons to form a circle is very simple, as you just need to use points at regular angular intervals around the center point, at the desired radius. In the same way calculate the UVs by calculating the respective points on the texture. 

There are numerous other advantages, but overall using a back-end component in mobile game architectures has proven to be advantageous (if not essential). Not that you referred to using Facebook instead of a custom back-end. Technically, facebook would be your back-end component in this case, aka. a centralized platform for storage and processing. A custom back-end is prefered as you can incorporate all funcitonality your app requires. The facebook API is a more general purpose back-end, not tailored to fit your application. To summarize, a back-end component has so many benefits, that it is almost impossible to avoid using one in mobile games. While using the facebook API is possible for general-purpose operations, a custom back-end is recommended to tailor it to fit the needs of your application.