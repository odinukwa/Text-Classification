Under-powering a Raspberry Pi is quite bad. Usually, symptoms will start showing up with usage, due to the SD card becoming corrupt. This can happen systematically slowly over time, or very rapidly depending on where the corruption on the card occurs. The results can be lost data, corrupt files or at worst, an un-bootable Pi. 

If you can't find anything in the user's crontabs, it is very likely there's an entry in that is kicking off the procedure. 

The IP will be the IP address of the hotspot. To resolve names to IP addresses, you'll need to add at least one DNS server: 

As @joan said, wiringPi has different pin numbering schemes. uses the GPIO pin scheme, whereas uses the wPi pin scheme. You either need to change your init call to or change the pin number to ( is the GPIO representation for physical pin (PWM pin), and is the wPi representation). Your wiring is definitely correct, as the command uses the GPIO pin scheme, and will automatically use as the pin number and that's why it works on the command line. 

When run under , your environment is not passed in, so within your script, you often need to specify the full path to binaries. For example: 

The IP here will be that of your DNS server (quite possibly the same IP as the gateway above, but that's not certain as I don't know your network). 

The signifies the alternate functions of a pin. See this for a better understanding. is the pin number when using (aka BCM) numbering scheme, and is the pin number when using the wiringPi's own pin numbering scheme. So when using wiringPi, if you choose , it'll default to using the wPi pin numbers, and will result in using the GPIO/BCM numbers. 

You need a TDS (Total Dissolved Solids) meter (aka EC/PPM meter) for measuring the nutrient content in your water, and you should also have a pH meter for maintaining a proper alkaline/acid level. I did a quick search, and here's a link for each of the above meters, and how to integrate them to the RPi. They are brand-specific, so you'll have to do your own searching if you seek out alternate units: TDS meter pH meter Note that I am not making a recommendation for the above products whatsoever. I've never used them; they are just examples of what you're going to need. 

As with all Arduino sketches, each line is terminated by CRLF (). At a very rough estimate based on watching the LED on port 7, the sketch generated 1000 lines per second. This sketch was installed on four Arduino boards: Uno R3, Mega 2560, Leonardo and also a cheap Nano clone. Python Serial Reader I tested several variants of the following code, testing a pause of ten seconds, a minute, ten minutes and finally an hour between reading from the serial port: 

As has been answered in the comments, Raspberry Pis don't generally have a device. The GPIO serial port is typically , although that's not always the case on a Raspberry Pi 3. All available serial ports belong to the dialout group, so for convenient read/write access it's best to issue this command once: 

Yes, it will work, because it's not read-only. Yes, it will damage your system. You'll need to look at mounting root read-only, and having a small ram/tempfs file system for the things that Linux needs to keep track of. No, because there's a good chance you will have damaged the filesystem. 

To avoid coding errors like this, calculate the °C value, and investigate using Quantities to do the units conversion. 

Which port did you plug the cable into? The 2864 has five ports on the back: a red WAN-ETH port, and four yellow LAN[1234] ports. You want to use one of the yellow ones. Pictures of the ports here: User Manual: Sagemcom 2864 / TekSavvy Solutions Inc There are, unfortunately, many ways to configure one of these beasties. If it's set up in the standard Bell way, the wired ports should work automatically. I run mine in bridge mode through a router for TekSavvy, and everything behaves quite differently. 

The magic word you're looking for is HX711: namely, Avia Semiconductor's 24-Bit Analog-to-Digital Converter (ADC) for Weigh Scales. The HX711 converts load cell Wheatstone bridge outputs to digital pulses. There are a number of breakout boards for the HX711, including the SparkFun Load Cell Amplifier board. There are a number of Python libraries that purport to read HX711 output via GPIO. I can't recommend any one in particular, as I haven't tried any of them. 

Now in my IDE, I can simply open the repository as if it were local (). Much, much simpler and easier than setting up an entire Samba setup for my needs and purposes, and I maintain the file system security per user, as I needed. 

Just flashed with a new Raspbian image (20170111). Logs me into the terminal directly, so I with no issues, it loads Pixel. The first problem is that the terminal application will not open. It absolutely does nothing. Chrome opens fine, as do some other apps, but not terminal. So, I go to install (which is the terminal I prefer anyways). Switch back to a different pseudo-term (CTRL-ALT-F2), and do . It complains that is missing, which indeed it is. Come back to the UI and open the package manager, but doing a search for anything always returns zero results. I can't see this being a bad image as it boots just fine. It's just these two issues I can't seem to find a way to resolve. Has anyone run into this on the most recent Raspbian? If so, any advice on how I can get past these issues? 

The RPi and the PC need to be in the same logical network, which they are not. The computer is in the network, and the Pi is in the network. You need to change the IP address of the Pi to be in (example: with subnet mask ). 

I wouldn't advise cloning a live system, but if you have enough space on the SD that you're running the Pi on, you could put the OS image on it, and expand it onto the new (USB connected) SD card, using the official install instructions. It may take quite a while, but it does work. Essentially, you'd put the new image file onto your existing Pi's SD card, plug in your USB SD card reader, figure out what the new drive is called, and: 

To avoid having to install a custom kernel, you can use this driver, and then follow these instructions. Specifically, because you have the 5" model, you'll use the following command after following the first few steps of extracting the driver tarball and changing into its directory: 

A crude way of keeping the connection alive: on the Raspberry Pi, create a crontab entry () to ping a host once an hour:- 

You can add many different types of I²C Real Time Clocks to the Raspberry Pi, f'rinstance RasClock/DS1307/PCF8563/DS3231. 

Editing config.txt or using rpi-update are really only for fixing very specific problems, and most users shouldn't need to resort to those levels. 

The bare OV7670modules don't seem to be compatible, but the ArduCAM Mini incorporates a controller and SPI output. This is what the code on github appears to be for, along with this installation guide. 

I would hazard a no on this. SD cards have low transfer rates and yet reasonable seek times. Read ahead works best when finding data on a medium with a high transfer rate but a slow seek time. Reading more than you absolutely have to from an SD card will always be pretty slow. 

Both programs have slightly confusing options, so I leave the choice of bitmap size to you. seems to create a proportional font from Inconsolata; you will have to use options to fix this. The files in have a very specific naming convention (not least, they have been compressed with gzip). I don't know if it's acceptable to just dump properly-named font files in there and console-setup will find them, or if there's a control file you need to edit to say what's available. Inconsolata lacks box-drawing characters, which are typically assumed to be in console fonts, so if you run curses-based programmes, the results may be unusual. 

If you accept changes, you're going with Raspbian's recommended settings. These have evolved over time, but generally represent a community default. This means you don't have to remember obscure settings you've tweaked, and your system is far more likely to run the way it's supposed to. This is important for when you ask other questions, as it's generally assumed that you've kept your system up to date and in line with the package managers' recommendations. Supporting highly customized systems is harder. Longer explanation: What you're being shown here is what's known as a context diff. It's the output of a utility (diff, short for differences) that compares two files line by line and shows you the differences. Diffs are use a lot in Linux, so you'll get used to seeing them. They're used to distribute changes and updates or patches — as in mending something by patching over a hole — with the patch utility. So what's the diff telling you? It starts with a header:, which is of only mild interest to most people: 

When you create your SD card with RaspianOS, simply create an empty file called into the root of the boot partition. The first time the Raspberry Pi starts up, it'll configure SSH automatically. Then you find it's IP address (if you didn't set it up manually on the SD card, you can use nmap to scan your network (eg: ). Your Pi will be one of the devices that have TCP port 22 open. 

Here's an example that does the same thing, but uses my Mock::Sub Perl distribution (it's equivalent to Python's 'Mock'). If the env var isn't set, it'll mock out certain functions/methods. If it is set, we're on a Pi board, so we can run natively with the original functions: 

I rarely, if ever, use the GUI on my Pi devices. I develop for it from my laptop workstation. In the UI, there's an annoyingly terrifying icon** that pops up for this condition, but how can one tell if a Pi is under-powered if only used in headless (console-only with no immediately direct visibility of the console itself) mode? ** - ok a bit extreme 

What I often do (from Linux not Windows but the premise is the same), is set up a share (sshfs in my case, but Samba works equally well) that shares the repository/code working directory, and mount that into Windows. Then, in intelliJ, open that as your code base. In the terminal window within intelliJ, SSH (using Putty) to the Pi, and exec your code on the Pi directly. This allows you to code in your IDE, but work on and execute code on the Pi itself. I often have a whole slew of tests for my code that can run on any platform, then a bunch that can only run on the Pi. To do this, you have to instruct the test to 'skip' if it's only to be run on the Pi, and for ones that don't require specific Pi functionality directly, you can use something like mock to mock out the GPIO calls. Although I don't use Python on my RPis, I do use techniques such as these in the Perl distributions I write. Here's an example that checks if a certain environment variable is set or not. If not, it skips all tests in the current unit test file: 

10.1 has not yet been release for Raspberry Pi. If you've recently done a , you can check the most recent release version with: 

Seconding sdenton4; it's a card problem, for sure. To check this, I took the system card from oldest Raspberry Pi. This has been running for over a year. It's had numerous OS and firmware updates, and had a generally hard time living as my workshop controller. If any card's going to have a problem, it'll be this one. So, on another computer, I did: 

The current version doesn't work on ARMv6 (see: Raspberry Pi • Which Language to Learn?) and there are efforts to fix it. 

That means you'll get prompted for a password the first time you use sudo in any session, and again after a few minutes' timeout. You can't edit directly; use to do so. Looks like Krzysztof hopped in with an answer just there. Are you really sure you need to reboot every time you install new packages? Unless you're installing a new kernel or firmware, not much else needs a reboot. This is a quality OS we've got here ... 

I'd say no. Not because of lack of computing power — Gerben's comment is dead right — but because the Raspberry Pi doesn't handle external USB insertion/removal well. Some models will reboot on inserting a USB device. 

Sometimes, even if you've changed the host name via , the settings don't stick. To make it permanent: 

The Raspberry Pi Zero is produced and distributed by the Raspberry Pi Foundation directly. The other Raspberry Pi boards have commercial partners involved with their sales. These partners improve the availability of the other boards, at the cost of incorporating a profit margin for everyone in the supply chain. The Raspberry Pi Zero is still deliberately not available in multiple quantities to individual buyers. It is meant to provide the cheapest computing platform for those who need it, rather than those who would like to integrate it into a commercial product. The Compute Module is meant for larger volume integration. Requests for volume supply of Raspberry Pi Zero boards are promptly shut down on the Raspberry Pi Forum run by the Foundation. They don't appear to even want to discuss the decision. 

I am reasonably certain that wiringPi's command can't be used to interface with the expander in this way from the command line. You'll likely want to interface it by writing your own binary. Please see this document on Gordon's site for further details. Said GPIO expander is an i2c device, and must be treated as such. 

Now, the above example is useful for cases where you need to perform tests that don't explicitly require a Pi board, but need an object. The constructor, calls inherently. Obviously if you're not on a Pi board, it'll fail horribly. In this case, we mock out that functionality to trick the class that ran correctly, and we get a full blown object, even if not on a RPi. So mocking is handy for doing things where you can fake out certain calls (typically ones that are called from within other methods). In both cases above, that allows me to have a nice test suite that covers many aspects of the software on non-Pi systems. If on a Pi, then the entire suite runs. Very useful when doing Continuous Integration on many systems, such as the CPAN Testers automated testing. Doing things this way also allows you do to some of your coding on a normal workstation that doesn't require the Pi, while being able to run at least a portion of your test suite before you fetch the new code onto the Pi and run it completely there. 

I am pretty sure that uses the HTTP proxy environment variables, and the issue you're having is that you can't fetch anything during install from the Internet: 

Just be very careful you have the drives the right way around... the OS won't warn you if you try to overwrite your main SD card. 

Given the information in the comments (the red LED staying on solid) means that the SD card does not have a valid boot partition (ie. Operating System) on it. A solid red LED indicates that the Pi is ok, but it can't start up. You need to re-flash the SD card, put it back into the Pi, and power it up. Installation instructions can be found here for both NOOBS and Raspian OS builds. You'll need to read through all of the information, including the link that directs you to the Operating System you're running on your computer.