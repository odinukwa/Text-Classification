Will you be able to write something like that on a sunday afternoon in your bedroom? No. Can it be done? Well, it has been done so surely it can be done but it's going to take a team of skilled software engineers several months to years to put together from scratch. 

It's certainly doable, but in the second case you're going to need some form of scripting API for the crafters to script that interaction into the item. 

What's happened to your custom binary data format? If you are afraid of raw serialisation, write your own system that writes fields as needed, and reads them back. No need for xml, which is indeed overly bulky and complex for situations where you don't need the transparency the format provides. Just define a well-specified file format and stick to it, leaving maybe some room for expansion of your data set in each record by padding them with null values (say you have a 100 byte record now, pad that to 150 for future use. Add a version number and maybe a checksum so you can know what fields should be filled and have a sanity check for validity, and you're good to go. 

What would you want the players to do with the items they create? Will they be purely cosmetic, or actually have function to interact with (other) players, npcs, or the environment? 

Calculate how much testing will have to be done (as time, say you come up with a figure of 200 hours), then figure out how much time a single tester would spend on the task, and you have a figure for the number of testers you need. Of course that should take into account retesting bugs they report, duplication (especially with volunteers testing games), people not actually doing the work they sign up for (especially with volunteers testing games, many just want to play something new and shiny before anyone else, and get a free copy at release date as a reward). 

Whichever you do, it doesn't matter. If you rely on clientside calculation of anything you will get hacked. All the "anti-hacker" tooling has AFAIK been thoroughly penetrated, new versions often themselves being hacked in a matter of hours after release. Given that, browser games are a major PITA IMO (poor usability) though they do offer ease of installation. So push as much as you can to the server, validate and counter validate everything sent by the clients to the server, and aggressively detect and ban any violators. Of course you do have to account for lag which can cause weird results being sent (or received), which is another reason you don't want to rely on clientside anything. So the client tells the server he's moving in direction alpha, let the server decide the next position, not the client. Client tells the server he's pulling the trigger, let the server decide whether there's bullets left, where they're going, and whether anything is hit (and what damage they do). Done like that, the client becomes little more than a tool for rendering the world and allowing the user to request things (data, movement, etc.) from the server with the server deciding whether those requests should be honoured based on what it knows about the real abilities of the client (this also makes it impossible to render walls invisible for example, unless the client avatar is known to the server to have X-ray vision, a decision made based on gameplay and resources the server assigned to the avatar, not the client software). 

There's no magic number, depending on the size and complexity of your system, the number could be anywhere from two or three people (you do want some duplication of effort, to cut chances that someone misses something) working for a few hours over a weekend to dozens of of people working full time for months. And with consumer products there's the added factor of disparate hardware/software combinations it will run on. It wouldn't do to test a graphics heavy game for example on only 2 computers, both with the exact same videocard, operating system, and drivers. It will need to be tested on a broad range of hardware/software combinations to determine if it works properly on all of them (or at the very least to be able to mention in your documentation what the hardware/software requirements are to run it). 

You do realise that when you're in game development you won't be playing many games? That most likely you'll quickly come to loath playing games because you have to test little bits of them over and over again to analyse errors? You seem under the impression that working at a game development shop means you're just going to be paid to do what you like to do now, play a certain genre of game when and how you like to do it. Nothing could be further from the truth. You're going to be spending a lot of time not playing games but in exhaustive meetings about minute details about them. The rest of the time will be spent working on implementing or testing those minute details, and if that includes any playing it'll be playing the same little bit of the game over and over again to test that little detail you happen to have been assigned to working on. It's a job no different from any other, and any job can quickly destroy what enjoyment you have in the thing you're doing. Which is why I always advise people to NOT try to turn their hobbies into their jobs. 

Levels should also not be so long that people get bored and give up, thinking you're just making things impossibly hard because you can't be bothered to create a well leveled game experience. 

So you see indoor and outdoor typically don't have much in common. That's why there are dungeon portals and explicit loading screens in games like World of Warcraft when switching from on to the other. To get a better answer please explain the workings and shortcomings of your current renderer. You can also learn a lot about indoor rendering from the good old Quake toolchain. 

Your approach and implementation are valid (disregarding that line). As long as there is only one instance of . There is nothing in the code you have provided that leads to an over-O(nÂ²) runtime. Therefore it is reasonable to expect a drop in framerate by half at 100 planets. That is 100 planets at 150fps. 200 planets at 30fps. etc. As this does not match with your observations some questions arise. Most prominently: Are you sure the fps are lost in ? Have you measured it with a profiler? Which statement is the offender? Is there any notable difference in memory consumption? Is the garbage collector busy? Can you render 100-200 planets at 300fps when there is no gravity? 

You can check for talent dependencies programatically by querying the complete talent table, and building a linked tree. You can also do that with SQL but it will require either recursive subselects or lots of queries. Better do it in your code. If there are multiple dependencies, like for example depends on AND use two tables to represent the dependency graph: 

All zeroes but ones on the diagonal. Called identity matrix. Does nothing when multiplied on a vector or matrix. Use glLoadIdentity to reset matrices. 

Note the and instead of and . The difference is the preserved perpendicularity of z on the plane if is moved away from the origin. I guess you wanted to do that through but that doesn't suffice. Also note that I normalized . This will result in orthonormal XYZ on both planes and and means that scale is preserved. If the triangles and are not similar (i.e. one is stretched) then but . Don't normalize anything if you want to preserve stretching. 

True. GL_PROJECTION is for choosing between orthogonal (2D, UI) and perspective (3D) projection. Do not touch yet. 

All the games I know of that display lots of terrain make heavy use of LODing to create the illusion of huge amounts of very detailed surfaces. The CryEngine is king at this. And in World of Warcraft you can even see the LOD transitions when using low-performance settings. The second post at $URL$ describes many different techniques to visualize huge terrains efficiently. Especially the HLOD article $URL$ seems helpful. I doubt that displacement mapping will get you anywhere near the performance obtained by simply reducing the number of triangles for far-away terrain. Especially for mobile devices lacking hardware support. 

You are ignoring the players current position, which is why it only works once because the initial position is (0,0,0). Use instead. 

Model space! See the ancient but still excellent NeHe tutorials for more info on these topics: $URL$ , especially $URL$ 

I'd advice on using SQL databases whenever you can. They are robust, well known, easy to interface, scalable and all. The only downside might be performance. But as you are not asking about how to store your live game objects on every update performance of the database itself will very likely not be a problem. Make sure to learn about serializing you savegame-relavant part of your game state. Pushing those into a database should be fairly easy then. 

But be aware: Getting started on CUDA is easy, getting started on physics simulation is a good bit harder, but combining both is quite a challenge! 

@Byte56 is right. You only want a direction vector without any information about the distance to the target. You can get that by normalizing your vector to unit length. Do this: 

Modelling everything in the metric system I also observed that gravity feels much too weak with regards to the player jumping (in a platformer). Much like "on the moon", "jelly", "too much phyics", not "arcade" enough. On the other hand players in games are regularly able to jump to great unrealistic height too. TLDR: high gravity feels very fast paced and arcade, realistic gravity sometimes might not give the desired game experience. 

Look out for Nintendo DS titles. They tend to use the stylus for game mechanics similar to yours. There are rhythm games like Elite Beat Agents employing something similar to your attack/defend game mechanics but based on music. Elite Beat Agents is actually quite challenging but fun to play. I'd also recommend playing The World Ends with You! It's an action RPG with very similar combat mechanics. It's also quite innovative and unique. Regarding crippling the player (controls) I'd always advise not to. I haven't seen a single game where not-being-in-control due to darkness, staggering, impairing effects, etc. was adding fun. Realism != Fun != Immersion. 

As already suggested by @Philipp creating, storing and rendering are often handled very differently when in comes to indoor vs. outdoor. This is because the requirements and challenges are typically very differrent. Example: Outdoor: 

OpenGL mixes camera and model transformations which is highly unintuitive at first (GL_MODELVIEW). Read the tutorials at the end on my answer to better understand things. 

It depends if any of your physics can happen outside the flat player space. As ghostonline said debris and ragdoll animations are a classic example of out-of-2D physics in an 2.5D game. Another example is bullets: If there are any projectiles in your game, do they follow the curvature of your 2D space or do the travel straight ahead even if that means they will leave those bounds? Also mapping a physical 2D space to a curved 3D visualization correctly is (correct me if I'm mistaken) .. not that easy. You will need an injective projection functions probably involving lots of splines or something similar. While having curved 2D game spaces is a nice add-on, it requires quite some overhead for the code. That might be the reason why there is no such thing in Trine. But the game was fun anyway, wasn't it? I'd think twice about a feature like that.