This improves efficiency by reducing the time required to concatenate the s, as well as removing the requirement of the empty . In fact, you split the s where no split is necessary. can just simply be . 

Well, read on! Immutable classes should not have any methods. This is because an immutable class should only represent objects that don't change. If a person needs to be changed (not likely though), then the most obvious way to do so is to directly call the Constructor for a new Object, as a person with a different characteristic would not be the same person. 

The last case is not required if it does nothing. If you really want to tell a reviewer/code-reader that it will do nothing, simply use a comment. It is also understandable, as only the and options should do anything, and the button should be completely ignored, as it is in many real-life applications. I cannot think of a single situation where a button will do anything... SwingOverviewView 

where n is how many false you have. generates a number between 1 and n, and checks if it is one. It has a 1 in chance of returning true, just like what you have. This increases the efficiency and is much less of a pain to type. 

Because does not need to return , , or . It returns , , . If you want to retain your way of result, use : 

In See all advice in . In Again, see all advice in . In Not the A again... See second piece of advice in . Good Job! Hand Evaluators are very hard to implement. It's very courageous of you to tackle such a challenging task (as you can see, there are quite a few bugs). Good luck improving your code, and I hope to see a follow-up after the bugs are fixed! 

In , all I see is a mess of code. What I want to see, or what I should see, is a properly formatted code: 

I was recently given a Sudoku Puzzle to solve, and since I began solving many Sudoku puzzles after, I decided to attempt to create a Sudoku Puzzle viewer with JavaFX. I am not done yet, but have decided to split it into parts so that it is easier to fix future problems. Part 1 is the class. The class does: 

This is just a short answer about the use of . It is almost always a poor option, as it is pretty much an array with helper functions. If you have an of 10000 integers, and then add another integer, will (if its current array it's storing the values in is of size 10000) create a new array, move all the values of the old array in the new array, then add the integer to the end. Sounds inefficient? Certainly does. My opinion is to use . is faster, because it works like this: 

The program first determines the set of all possible values that can be entered into every blank square in the puzzle board. The possibility set is determined by iterating through the row, column and the block, and eliminating the set of numbers already present. The possibility-set is stored as a bit-filed value for each square. Every blank square with a single possibility gets the number entered into it. The algorithm is repeated from the first step again, until there isn't a square with just one possibility. If there aren't any blank squares left, the current board's state is returned as the result. It chooses a blank square and enters a value into it. The process of choosing the blank square, out of all the available blank squares is guided by an analysis algorithm. The value entered into this blank square is chosen from all the possible values that can be entered into the square. A recursive call to this function is initiated with a clone of the current board's state. Note that the current board state now contains the modification done to it at the 4th step (entering one of the possible values). Steps 4 and 5 are carried over until all the possible values in each of the available blank squares are tested with, or until the puzzle gets solved. 

This Sudoku puzzle solving algorithm follows a brute-force approach mixed with rule-based approach. To further improve performance, an extra analysis step is added, to determine which squares to be prioritized while choosing it to be filled. The priority value is inversely dependent on the number of possible values that can be filled into a particular square. This value is used in computing the priority weight value of each of the blank square that is to be filled. This priority weight value helps in ordering which squares must be filled first. 

The following defines bit-field values associated with each symbol accepted by the sudoku board puzzle: 

The following is the header file, containing the primary functions that are used in the evaluation process: 

This holds the priority value of each square in the puzzle board. This is used during the evaluation process, where each instance is sorted based on the . A detailed explanation will be provided in the later sections. 

Though this algorithm may seem to provide an alarmingly bad worse-time complexity, this algorithm almost never hits the worse time complexity regardless of the (legal) puzzle entered. List of types defined and used throughout the program : I. BoardGrid 

Rule-based search: This method involves identifying the set of blank squares that can be filled immediately with the available information. For each iteration, the amount of information increases, and eventually as each squares get filled, the puzzle board gets completed. guided brute-force search: The evaluation algorithm, on a high level, is a brute-force algorithm which relies on an analysis method which prioritizes the blanks that are to be filled first. During each search iteration the rule-based search is called to complete the evaluation if the amount of information on the board is sufficient (as each depth first search iteration increases the amount of information on the board). The analysis method that guides the depth first search: This assigns a weight value for each of the blank squares based on a measure which determines the influence of filling-in that square with a possible value. 

Today when I was implementing ReCaptcha (as if there is much to implement!), I thought it would be perfect to create an Aspect Annotation to automatically secure web methods with recaptcha. My solution is strongly based on the ReCaptcha implementation walkthrough that can be found here: $URL$ If it interests you, you can get the full source code and a fully working spring boot example project at the following link, you should be able to instantly import it into Eclipse or STS: $URL$ Just start the project and go to localhost:8080/ If you want to see it in action visit this page: $URL$ As this is my first Aspect Oriented Programming adventure I would like your opinion on my code. I am especially unsure about proper error handling and the proper invalid recaptcha response code. Here are the core classes: The Aspect itself, RecaptchaAspect.java: 

You are often injecting HttpServletRequest and HttpServletResponse as method arguments. This is not necessary and bloats the method signatures. You can just define two instance fields of those two classes and annotate them with @Autowired. Spring creates proxies for those classes and offers the correct instances to your request threads. Run a code formatter / cleaner on your code before comitting! You should enable "format code on save" in your IDE, if you use one. You do not need to and probably shouldn't call the way you do: You can define the HTTP methods you want to accept in the annotation via . You can define multiple methods with the same path but different methods. If you decide to put a comment above a method, do it in the proper JavaDoc style. You should not use absolute redirects like: , use relative paths instead since this would break if your application were to run on another server/port. Your entities do not use JPA constraints like nullable. Your animals name should probably not be nullable for example! You might want to implement equals and hashcode for your DTOs and entities, or let your IDE do it for you. You would benefit from using Spring Boot for applications like this. With Spring Boot you do not need to define applicationContext.xml and web.xml. It's very easy to use and does not require changes to applications on this level. You would benefit from using spring-data which brings default implementations for the DAO pattern (JPARepository interface and its relatives). Your controllers might contain too much logic. They should call @Component/@Service bean methods that contain the DB logic. This serves "separation of concerns" and gives you code that can be called from elsewhere. Your entity method should probably not be public. When would you ever want to manipulate the entities id? Let your JPA provider take care of it. 

Sets all numbers to (as in, is a prime). Starts at 2, and works its way through the primes. While doing that, marks all the multiples of a prime to . If it has 100 primes, the loop will terminate. Print the result. 

Of course I didn't include the numbers in the description... I am sure there is a better way to do this. I just did a simple solution, where I add all the numbers and take the first 10 digits. 

Similar to , but and result in , and every other combination . What is happening is that the ASCII values are 'd and 'd. Is this really what you want? In this case, you have to do it the tedious way: test each of them to : 

This is the end brace of the previous method plus the new method. Again, a couple of things: Lines 1-2: Extra newline between Line 2: Should be separated into two lines: and declaration Line 2: Space before brace Line 3: Already mentioned, space before brace Line 6: Extra newline serves no purpose, but can be left there if wanted Result: 

Select a pivot Create two pointers, one at the front and one at the back Move first pointer up until there is a value greater or equal to the pivot Move second pointer down until there is a value less than or equal to the pivot Swap and advance both pointers If the pointers have not passed each other, go to step 1. Otherwise, continue Repeat recursively for each subarray 

Now let's do some actual reviewing... OOP Java is an Object Oriented Programming (OOP) language, which means it's based on objects. You did a good job trying, but if you leave a default constructor and let the calling code do the work, it's not OOP at all. Let's do some serious redesigning: 

This way, programmers using it has a choice of being able to give less information, and add it later through the methods. Also, this allows them to prevent them from doing stuff like: 

The conventions say that each line is a maximum of 80 characters. You exceed that many times, especially because of a large amount of arguments to a method, or calling a method with a lot of arguments, or maybe some other reason. After formatting: 

Though this program tells the truth (unless you change the source code), it does tell Fibonacci numbers, depending on the user's input. Keeping in mind of all (or most) of the feedback given from previous questions, I wrote this program to see how well I have progressed. 

Again, consistency. Always put a space before the opening brace, or never. I recommend always, as that is more readable. 

The class's function solves the entire puzzle. Understanding the functioning of this function will be enough to understand the working of the algorithm. The following, 

initializes the evaluation for the current iteration. The statement called before these is the program's attempt to try and solve the problem purely based on the rule-based procedure, trying to eliminate the set of numbers that can be entered into each square. The function iterates through each bit-field trying to discover the possible elements (values) that can be entered into the blank box. The set of values are then stored as bit fields. This function runs in a loop because, an empty box getting filled by a value might help provide enough information to figure out the value in a different box. Therefore, until such a possibility is ruled-out the function iterates. The above process configures the bit-fields, which would help the function to compute the number of possible elements that can be entered into each square. The next function, which relies on the result of the function, computes the which assigns a floating-point value to each square in the sudoku board following the expression and later the function is called followed by the function, which returns the list of all the empty cells, along with its associated priority value. The function sums the number of possibilities across each row, each column and each cell (the smaller boxes, which must also contain values from 1 to 9) and stores them in an array. The function returns a priority queue, sorted based on the priority value derived from the result provided by the other three functions. The final depth-first search is computed by recursively calling the function, belonging to a locally declared instance of the class. The sets the puzzle board for the next recursive call. Recurrence is brought about by calling the same belonging to a local instance of the same class, declared within the function. In what areas does my code need improvement? And how can I improve the design of my code and algorithm? I wrote this code intending it to be Object oriented. How object oriented is it? (I.e.., is there a better way to structure the same solution) And is there a better algorithm to solve this problem more easily? For complete code, please refer this URL: $URL$ 

I had written a Sudoku puzzle solver that accepts puzzle boards, and completes them with the least possible time. Rather than purely depending on brute-force, my algorithm first attempts to fill in the squares that have an obvious solution. And for each square being filled this way, the amount of information increases (I.e.., more number of squares get filled which aids in filling in the remaining squares) which makes the further iteration process easier. Once this method fails (this happens if there isn't an obvious answer to fill-into any of the squares), the algorithm immediately switches over to brute-force search. (Note, the source contains a few spelling mistakes, like the word recursive misspelled as Recrussive. Please ignore spelling errors. Anyway, it has been a while since I touched this code, and this was my first object oriented code written in C++). The basic working (High level view)