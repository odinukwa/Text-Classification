Presuming you have a valid SIM this may work -- I haven't used a cellular modem dongle, so I don't know if there is more to it. I have used a cell modem via UART, and that was a matter of a few simple AT commands. I would presume the dongle is smart enough to deal with that automatically, since the driver presents it as a normal network interface and not a low level device. 

This is gobbledygook. You are confused. That is not what an operating system image file is. It is a binary, block-for-block duplication of either a single filesystem, or (as with the ones used for the Raspberry Pi), a block device containing multiple partitions and a boot sector. This is why all you have to do with the Raspbian image to create a usable SD card is copy it to the card with . 

To . That's a public Google owned DNS server. This is usually not an ideal solution since your ISP's nameservers (which DHCP to your router would probably provide) are (probably) preferable, but it will get you by until you sort out your configuration. 

This keeps a copy of the corrupted file(s) in for whatever reason; if you don't want to bother with that use instead. Then: 

Going about it this way, yes. The up/down state of a network interface may change as the consequence of a layer 1 event, but it obviously isn't in itself. It's a data link/network layer concern. I would look into powering off the ethernet controller, which is also the USB controller: Disable LAN9512 Glancing through on a B+ running a current kernel (4.9.30+) it looks like this stuff has changed a bit; look in ; and are writable. The problem then is how to input to the Pi with the USB and ethernet turned off. 

If the manufacturer provides open source linux drivers then they could be recompiled for the pi. There are a bunch of touchscreen drivers available for the raspbian kernel () some of which are apparently multitouch. The list is: 

The I2C connections are GPIO 28 for SDA and GPIO 29 for SCL. If you attach header pins on the top of the board, beware that you can't then easily fit connectors if there are already some in line on the existing 26-pin header. However, I managed to bend them subsequently so the vertical clearance is about the same, which is necessarily if the case is snug. Doing that if you wanted to use a bonified plug, or all 8 pins at once, might be more of a problem, so think about this before you heat up the iron. 

1. It actually makes more sense to research things that are primarily about software in terms of the OS (which is usually a form of GNU/Linux), than the brand of hardware (Raspberry Pi). Then, if there's any uncertainty, you can ask here "How do I apply this on Raspbian?". If instead you search directly how to do it on Raspbian I think you will almost always find a relative paucity of materials. 

There's source for building brcmfmac.ko in the rpi specific "3.6.y" source. I've built kernels for use with raspbian using this source with a cross-compiler; building it on the pi will be easier but take a very long time, I think. I don't have the 3.2.27+ source that represents the raspbian default, but presumably it is in that too. However, the 3.6.y default build doesn't include the brcmfmac module for some reason (it includes most of the other available wifi drivers), so it may not be installed in raspbian. Make sure about which kernel you are running with . Your best bet is to just plug in the dongle (actually, plug it in before you power up, as wifi dongles tend to cause a sudden voltage drop when inserted into the pi, cutting the power momentarily) and try: 

Where is the number. If that doesn't work, try . If/once you are sure of the name of the process you can also just use: 

You don't need to "flash it live". The firmware is on the SD card and loaded at every boot. Just update the system normally: 

There isn't really a best partition size here, at least not in a way that is relevant to the operating system or the pi and hence that would be on-topic and specific to the pi. Going off-topic a bit in that sense, I would say the most significant consideration is sparseness. Leave as much room as you can without compromising your other needs. The more room the OS has to play with, the more easily it will be to keep things organized in the most efficient manner. For example, a system with a root filesystem only 25% used will probably perform slightly better over the long term than one used 60%, and they will both perform much better than one used to 90 or 95% capacity (i.e., there is a curve in play performance wise and as you approach 100%, things will become more and more dysfunctional; try to avoid going over 75%). Another advantage to this is it may spare some wear and tear on spinning disks where partitions really are constrained to specific portions of the disk and it is better to slowly wear out the disk as a whole rather than quickly wear out a small section of it. This logic does not apply to solid state devices, which use virtual addressing to distribute partitions dynamically. As to how much space might be used by the root fs if you are using it primarily for system/distro software, this depends a lot on how much stuff you want to install. 50-100 GB is not that hard to reach, so setting aside 200-250 GB should be good. You could split that in half and use two partitions if you know how to keep yourself organized but if you have a whole TB to play with it is likely not worth the bother of ending up with 5-10 partitions on one drive for different specific purposes. Use bigger partitions and exploit the directory structure instead, it is more flexible. Minimally, I would not go smaller than 8-16 GB, although it is certainly possible to run a pi with a root fs < 2 GB (or < 1 GB, or if we really want to put in some time pairing things down, < 1/2 GB, but why bother here?). Linux and ext4, the default and recommended filesystem type for the root filesystem, are commonly used on terabyte size partitions so that is not an issue. You may or may not want to consider dividing the disk up and using some form of RAID partitioning to add automated data protection by storing it redundantly -- note would mean cutting the available space by 1/2, 3/4, etc. Personally I think it is a waste of time in this case (and may come with its own risks); if you want to redundantly protect your data using the same drive, maintain a back-up partition. 

Yes, because what's really associated with a file is the numerical ID. Text names are found via a lookup on -- you can see this if you run: 

And guess what that always is? Again, I'm not a python user so I can't tell you the correct way to read a pin1 but that's your error. 

In this case, when the switch is left, X connects to Input A. When it is right, it connects to Input B. If you get something different from this -- one pin is always high and the other always low, or both always high, or both high and low at the same time -- then two of the pins are wired together. There are still three possibilities for pin X corresponding to these three alternate possibilities. 

Powering down is not necessarily the cause of lost wifi. However, you could try to view all the logs since 12 AM yesterday (i.e., 24 hrs + the current time). This will appear in (or perhaps whatever is set to; this is the same app used for man pages) by default, which is sort of nice since it also includes a bit of color. Less has regular expression searching (use 'h' for help), but if you prefer you can redirect that, including to a file (the complete system log does not appear in a plain text file anywhere unless you configure and appropriately). I would just search for the name of the interface (e.g. ) at first. There's probably at most a thousand lines in there for , which is not that hard to eyeball scan either. But it may well be that there is no error logged despite the fact the system is offline, except for by things that expect it to be, which is not much help in diagnosing the problem. I don't use the normal high level network configuration/interface on linux, so I am not sure to what extent it can be expected that it will reconnect when there is a problem (I suspect it is either "not at all" or "depends on the issue"). However, you can still adapt my solution to work with the conventional system. I run a background script that configures and maintains a connection. I've done this for years and it is fairly bulletproof (e.g., I have a few devices, including a Pi 3, that have been on wifi for months and months without me having to reset them). The part of the script that keeps things online pings the router at intervals using a "back off" style algorithm; after making a connection it does it fairly frequently (every 30-60 seconds), then doubles it until it reaches a predetermined maximum (3-5 minutes). The actual check is just: 

The program itself should not be persistent. Anything it forks should use or that may not complete; you'll have to experiment but keep this possibility in mind (TBH I'm not positive that will help either but it should). 

And I think you would be pushing the boundaries too much if you gave all those LEDs their max current at the same time. The GPIOs proper (by which I mean the actual GPIO pins, and not all 40 pins on the breakout, some of which are non-configurable power rail and ground pins) are intended for signalling and not supplying significant amounts of energy. So, if you really want to drive that many LEDs at full current you should control them via transistors supplied by a 3.3V rail pin (integrated circuit darlington arrays like the ULN2xxx family are good for this). If not, you want to plug in some numbers to keep the total current draw below ~120 mA. I.e., aim for 10 mA or less per LED. Go as low as you can as long as you are still happy with the brightness. 

Remember, don't really use anywhere. You should be able to log in as or whoever and find your normal home directory. 

For me, #1 is the primary point. If you don't like this kind of set-up (I don't) then change it. This could be as simple as deleting user , or even more simply, just changing 's password after you install. Most people presumably will do that (unless they don't think any one else can gain access to the system) out of plain common sense. This is the online, digital information age after all. If I sold you a computer and said, "The admin user is 'admin' and the password is 'FUBAR', just as it is originally for all computers of this type," you'd probably ponder that a little ("Hmm, so if someone else who owned one of these knew this they might try to see if I'm still using the default password..."). This is the norm for household routers, I think. People who are completely computer illiterate, do not understand the significance of passwords, etc. are really unlikely to want an Rpi, and if they do, there is probably a lot more grief waiting.1 Again, I don't mean by this that I feel it is a good practice and will not guess as to why Raspbian, decided to do this (normal Debian does not); perhaps because they felt it made a potentially intimidating process less prone to stress and error. Which I'm sure it does. However, it is also a good example of how things can be dumbed down to the point of potential calamity. 

This is because all 40 pin models have the exact same pinout, just as all 26 pin models have the exact same pinout. So if you find a hat intended for the Pi that has a 40 pin plug, it is compatible with the Zero W, including the JustBoom amp which says on its product page: 

Although overclocking is not unusual, this does not make it 100% risk free. Electronics do not last infinity years under any circumstances, and overclocking them will probably wear them out faster no matter what, because the major factor in wear and tear is heat expansion. Using just a case fan, you are almost certainly heating things up and down more than you would without overclocking. Overclocking entails a risk by definition; if it did not, OEM's would stamp their product with a higher frequency. The reason it is possible at all is because the manufacturing process is on such an infinitesimal scale that it is impossible to create chips that have a uniform, exact maximum frequency.1 In fact, when you buy a 4.0 Ghz Intel Core2 i7-4790K processor, it rolled off exactly the same production line as a 3.5 Ghz i7-4790K. There is no difference at all in the manufacturing process. They are then tested and classified in a process called binning. The OEM uses this to make a bet about the upper safe limit of an individual processor. Their goal is to make this as high as possible without excessive risk of failure, which will negatively affect their reputation and lead to excessive warranty claims. So in general, again, it is impossible, by definition, to call overclocking safe. The OEM has already tested the product and determined the safe frequency limit. You are exceeding that. Note that the Raspberry Pi Foundation is not the OEM of the Broadcom processor in the Pi; their claim that "there will be no measurable reduction in the lifetime of your Raspberry Pi" is just a claim, although of course they have backed it with a warranty. Which you can now make a claim on. 1. Put another way, they inevitably vary on an infinitesimal scale in a way that would not be significant with the functioning of, e.g, toasters or flashlights, but is with microprocessors. 

If the last command is new to you it is necessary to use "update" the first time (and occasionally thereafter) because the searches are performed on a local database. It takes a few minutes, during which time on Raspbian there is output perhaps implying that some repos are not indexed -- however I don't know enough about it to confirm that, and I have not investigated. Anyway: 

For video streaming, both the pi and Android can make use of DLNA via various client/server applications (on raspbian, see or ), although I'm not sure if those can be made to suit your purposes. For just logging onto the pi, there are SSH clients for Android -- "Juice SSH" is good. 

If you really need to do that often (or even just occasionally), I think you will be better off investing in some heftier hardware than the pi. All pi's have 100BASE-TX ethernet, meaning in theory up to 100 Mbps. Looking at this chart, one full HD stream is likely to be 5-10 Mbps. If, for sake of an arbitrary "reality factor", we halve the first number and use the high-end of the second one, you at best will be able to serve less than half a dozen people. 

IMO anyone who owns a Pi running Rasbian or another GNU/Linux distro without another linux box should learn to do the latter method. If it is too challenging, I fear so is the Pi. But that's just a opinion. 

Because you are looking at the partition while the system is not running. contains device nodes created by the kernel, mostly during boot. They are not real files in the sense of being a sequence of bytes stored somewhere, which is why they usually appear to be of 0 size. When the system is not running, should be empty. When it is running, a special file system of type is mounted there. It is unmounted at shutdown or will otherwise cease to exist if the system stops since it exists only in memory.