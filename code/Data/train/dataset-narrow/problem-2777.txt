This will depend entirely on the drivers. Since immediate mode is deprecated, it's up to the hardware manufacturers if they want to support it or not (mostly not). I suggest you reverse your process and convert to VBOs first. Then upgrade and get the remainder of your OpenGL function calls updated to work with 4.x. There are libraries out there that attempt to emulate immediate mode, but I don't think integrating more libraries into your code is a step you want to take if your final goal is VBOs. 

You can't. Unity doesn't have an interface for creating GUI interfaces in the editor. Further, there may be extensions for this in the Unity marketplace, but it's highly unlikely you'll be able to get away from any coding at all. There's still going to be the requirement to connect the GUI to your game, and many of those interactions are going to require scripts to trigger events in your game, or alter the game state. Your goal of using the Editor only to make anything more than the most simple game is unrealistic. You'll have to code. 

This is a nested loop example. When looking at a grid, imagine you want to place something inside each square. An algorithm for making sure you touch each square would be similar to the above. You can think of as a column position and think of as a row position. That means for any , pair, you have the coordinates of a grid location. For example, the very bottom left square in a grid would be x:0, y:0. The one to the right of that would be x:1, y:0. Like so: 

Then I follow out the ray until it intersects with an object, you can do this with bounding boxes or something similar, since this is specific to your game, I'll let you handle that. Generally this is done by following the ray out (adding the direction of the ray to it's starting point over and over 'till you bump into something). Next you want to see which face is being picked, you can do that by iterating over the triangles in your cube to see if the ray intersects them. The following function does that and returns the distance to the picked face, then I just use the intersected face that's closest to the camera (so you're not picking the back face). 

Model a weapon/shovel through 3dsmax/maya. Make animations for the item through 3dsmax/maya. Export the item and animations using the CryEnigne 3 exporter. Make a xml file for your tool. 

You don't need to master any language before jumping right in an making something. Jump right in and learn on the way. It's likely your best option for learning the relevant parts of the language anyway. 

You can see from the documentation related to touch events that touch events are related to the hardware screen, for example related to the x-axis: 

is returning because it's unable to find the face you specify. So it could easily throw a null pointer exception when it reaches: . Since you can't access a method of a null object. 

Compare the direction your character is facing with the direction to the enemy. The dot product of vector A and vector B divided by the magnitude of vector B will tell you the projection of A onto B. If you're using normalized vectors, you can skip the division. The results can be interpreted as follows: 

In this case, the rotation of the door will take 2 seconds to reach 90 degrees. And just a tip, setting the variables to will allow you to edit them from the Unity editor. This means you can apply this same script to multiple objects, but change the values for each object without editing the script. 

I don't think this would be possible over the internet. Having mobile devices connect to each other, without an intermediate server is near impossible. Since one or the other would have to broadcast its location in someway that the other could respond to. I'm not familiar with a way to do that if the devices don't already know about each other. However, on a much smaller network, like a home wifi network. This is reasonable. Both devices would need to be connected to the same wifi network. From there they can communicate and sync save files. 

Not a lawyer, here's my personal interpretation. I'd think that using the name of a company that doesn't exist could be considered fraud. The copyright holder should be you for now. This covers the contingency where you don't form that company, or you don't form it soon. A copyright is property that you can transfer to your company later if you wish. 

One way to achieve this is to have an additional layer of noise (2D) that controls the height of your current noise. This second layer should be scaled larger to give slower transitions between terrain types. The noise you have now defines the bumpy-ness, this second layer is kind of like a scale that will flatten out or exaggerate the bumpy-ness. 

Before placing the object, perform a collision check with a physics body representation of the mesh you're placing (either a bounding sphere, bounding cube or more accurate shape). If this collision check collides with the scene, move the target position far enough away from the collision that it will no longer collide. Do the collision check again with the new target position. If the new target position also has a collision, you're probably in a location that's too small to fit the object you want to place. Notify the user and perhaps draw an outline of the object to show how it doesn't fit. 

The triangle with the shortest distance is the picked triangle. Also, shameless plug for my game, you should check it out, follow it and vote in the polls I put out occasionally. Thanks! $URL$ 

Scripting for games can range from simple operations with home grown languages to writing the entire game in high level languages like Lua or C#. If we take a car analogy, a game engine is like a real engine, and scripts are everything else. Scripts are the fuel, body, wheels, steering, paint job and so on. Scripts are what make the engine run, and tell it how to run. Even though a car may have the same engine, they can drive and look completely different. Which is how we can have the same game engine under the hood, but have completely different games on the outside. Scripting APIs are the connection points with the game engine that allow us to control it. API stands for Application Programming Interface. It's the interface between the game engine and the scripting language. These APIs go both ways, they allow us to get information from the game engine and allow us to provide information/instructions to the game engine. Some engines are flexible enough that they give you the power to create an entire game with scripts alone. Some engines are just part of the solution and are available to build upon to create a game. 

I'm not a lawyer, but this is my interpretation: Found in the Terms of Service linked in the footer of the page you linked, this is the notice given to people uploading their content: 

The easiest solution is to make the movement amount smaller, something like Additionally, you'll want to modify your code to react to the function. In the update loop you'd have something like: 

As you can see, the result is fairly smooth terrain. A change in textures could help if you wanted something more realistic looking without the dark outlines. 

The system used to access each can be very similar. It's just that one system holds chunks, while the other holds voxels. 

There may be very clever ways to do this, but there's also brute force simple ways. Create a function for each axis X,Y and Z. Each of these functions will take an input for which layer to rotate (1, 2, 3). So for example, the call will do exactly as the image above shows. It will take the first row (from the top) of the Xplus, Zminus, Xminus, Zplus faces, and shift all their values through each other. Another example, will take the second row of the (from the left) of the Yplus, Zminus, Yminus, ZPlus faces and shift all their values through each other. 

Ahh yes. I threw my math at it and I think I hit it. You're correct it does involve the Pythagorean theorem and some scaling. You start with your normalized vector that represents your ray. 

If you're unsure, you need to research. One search in Google for "nyan cat copyrighted" brings up this question and answer, and this one and this one and so on. This is the process for any resource you find online, research it before using it. You can also search the government's database for copyright in the US and find Nyancat there. To answer you specifically about this meme. Yes it has copyright on everything about it. There's some question about whether the owners of the copyright would pursue you for using it, so that's up to you. 

Essentially you are moving the ball in and on screen and simulating the movement in the direction by changing the scale. 

Maybe this is how it's typically done. You have your list of different tiles that represent a road tiles in all their possible orientations. Left to right, all four corners, top to bottom, whatever. Now you'll index all those tiles with a byte each. 8 bits, one for each direction. This could be in a hashmap or by file name... however you want to do this. So you have this: 

You could probably combine the rotation and placement steps and just place the start initially at their rotated position. I'd do it in separate steps to start with, just so you can see how things form up without being all twisted up. Bonus answer: Humans haven't really had the star viewing technology long enough to watch a galaxy rotate, so we don't know exactly how it looks. However, from viewing simulations, it looks like it's spinning at higher speed in the center than the outside. You can try applying the same rotation to each star as you do in step 5. Or you can just slowly rotate the entire galaxy and see how it looks. 

Basically, it's a collection of things you've done. This collection has the purpose of making you look good to potential employers. So you want to put everything in there that shows off your skills and talents. In many cases this is a digital portfolio. This allows you to put in code and digital art assets. Some people make a game to represent their portfolio, others will just have a collection of things they've worked on. It's not required to have one. In fields where it's hard to convey in words what your talents are, it's very nice to have something like this. 

If you search the box2d user manual for "Pre-Solve" you'll find an example for implementing one-way platforms: 

This can be done with raycasting. Cast a short ray (using the distance parameter) downwards from your walking object. Make the walked on object part of a special layer for trigger objects. When casting your ray, you can restrict it to only collide with that layer of objects. This strategy allows you to keep all the code for checking when you walk over an object inside the object doing the walking. 

Notice how the shifted path has "settled" into the darker areas of the noise. The same way a river might flow through a valley. One benefit of the Perlin noise choice is you can factor in your obstacles and avoid them as part of the algorithm. 

You can mix Javascript and C# scripts in one project with Unity. They cannot be compiled into the same file, but the same project is fine. I believe the base project that you start with in Unity3D contains both Javascript and C# if you want an example. 

Seems strange to pick apart on just the fact that you could hear sound. There's a good deal of things that many space games do that doesn't relate to reality: 

It's not clear to me exactly how you're handling this now, but in C# with Unity you can use Events to get the job done. For example, you'll create your event handler (it doesn't have to follow the format if you don't want it to): 

You're not hurting yourself because you're doing what is required by your school. Learning to program is only partially about learning the syntax of a specific language (and it's a small part!). Right now you're learning to think logically and like a programmer. Don't worry about learning things you don't need, because it's all useful in some way. 

To add to the environment. By far the most likely reason. Nearly every game has components that are not essential to gameplay. From NPCs going about their daily lives to birds flying around, all of these things add to the immersion for the player and increase the visual appeal of the game. This even goes as far as, why use an animated sprite for your game character? It's not important to the gameplay for the character to look nice is it? It's for something you don't know about yet. Maybe later in the game, these non-essential elements are used for something else. Where it wouldn't make sense to have them appear right when you need them. It was going to be a feature, but didn't get fully implemented. Perhaps the elements were part of a planned feature, but it wasn't finished. The developer has a personal reason for adding it. Maybe it's a joke, or something they really like. The game is their canvas, they can add whatever they like. 

If you're likely to only be colliding with one object at a time, this will work. If you're going to be colliding with multiple objects at the same time, you'll need to track the "currently colliding with" objects and check against that. 

In this situation, the length of the vector would be considered the speed, since the vector itself represents the velocity (speed and direction). This is also referred to as the magnitude. The vector class you're getting and from likely already has a built in implementation for getting the magnitude or length. 

This image will represent the X axis. You'd perform this test for the Z axis as well. Basically, we can simplify the check to: 

bfxr This one and number two are for generating sounds effects. I have no idea what 75% of the sliders do, but I just slide them around until I get something like what I want. sfxr Dynamically composing music and sound effects - Don't follow that one too closely ;) Creating and playing synthetic sound - Just something to get started with, then create algorithms for the sounds I want. Audacity I use this now for editing the voice overs on my videos, great program. Unfortunately it doesn't help the feeling that I sound weird to myself. 

I see. Your update tells me that you are much further from results than I first thought. You're actually looking for an algorithm to define the movement of a jellyfish. That's very complex and is likely thesis level work. In fact it is thesis level work. See Dave Rudolf's paper (PDF) on the subject. Additionally Marcin Ignac has done some work with the topic. Perhaps there's some simpler method that I'm not thinking of, but if the linked sites are not suitable for your purposes I think you may be asking for too much. Good luck. 

Then it's a simple matter of making the acceleration to maintain a constant velocity, or you can make it a positive number to increase velocity or a negative number to decrease velocity. If you want to "decelerate" just just a negative acceleration, that's all friction is. Friction is just another force like accelerating. 

Setting the width is a different operation from setting the points. You just need to use the SetWidth(a,b) method: 

If you were to compare a list of all the systems that could be affected by the addition of multiplayer with a list of all the systems that need to be in the game, the lists are likely to be the same. For example, adding multiplayer to a single player game can/will affect: 

When drawing the character, you can scale it to -1 along the x axis to perform a flip. Additionally, the object has a function that will allow you to flip the sprite along the x or y axis. It's a quick way to do left/right movement without redrawing everything. There are other ways to get this result (like creating new animations for the opposite direction), but if they're better or not is something only you can answer. 

Typically this is specific to your game. I'm sure you've learned about writing to and reading from files in your classes so far. The basic idea is: