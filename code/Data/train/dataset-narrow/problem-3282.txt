For a new system you would have to create a wpa_supplicant.conf file in /boot to configure your wifi. Follow this post for a new setup. 

Try to open the file and check if APT syntax is correct. Here is a post that may be helpful in your situation. 

Connect your RxD GPIO Pin (GPIO15) to TxD pin of your USB to serial adapter. Connect TxD GPIO Pin (GPIO14) to RxD pin of your USB to serial adapter. Connect your USB to serial adapter ground to Raspberry Pi Ground (Pin 6 of GPIO connecter) Use appropriate serial terminal program (depends on your OS and choice) 

Yes, you can use command line tools to play internet radio streams. I have used omxplayer to play internet radio streams with no NDMI/video head. I created certain shell scripts for station choices like Jazz, pop, etc. I would ssh into the "headless" box and start/stop playing. You can improve by invoking shell scripts via GPIO buttons. 

This is an excellent question as a lot of people want to drive loads using their Raspberry Pi. I'm not sure why you received a -1 your question may have need rephrasing. Yes, You can drive a load using a Bipolar transistor or a MOSFET. A MOSFET will be more efficient. 

From Raspberry Pi Documentation: "The flow of boot begins with reading the OTP to decide on the valid boot modes enabled. By default, this is SD card boot followed by USB device boot. Subsequently, the boot ROM checks to see if the GPIO boot mode OTP bits have been programmed â€” one to enable GPIO boot mode and one to select the bank of GPIOs it uses to disable boot modes (low = GPIOs 22-26, high = GPIOs 39-43). This makes it possible to use a hardware switch to choose between different boot modes if there is more than one available." As per above, it doesn't seem that you need to program the OTP (One Time Programmable) bits to boot from USB. 

Master with daisy chained slaves: More scalable (adding slaves will not use additional pins) but will get more complex in operations. 

How about using a ? It is a stripped down version of . I've used it before. Image size is about 450 MiB and it very well fits in a 2 Gigs SD card. You can always install extra utilities as you need. Here is the link. Hope it helps. 

It looks like you will have to upgrade your dependencies as well. Try As you can see, you need , , and then try installing it again by . If it doesn't install latest packages you need, you can install dependencies by finding corresponding .deb files from repository one by one or use to install this package along with its dependencies. Please note that dependencies will only get installed if it's available otherwise you will have to take a long route to compile all of them from their sources. Hope it helps. 

Theoretically, yes. It's possible to connect as many webcams as you can as long as they're powered up as per their requirements. 

It will install along with its dependancies. Now follow raspbian steps as mentioned above to expand file system. Any Linux distribution (works for Raspbian as well) Follow this wiki page : $URL$ It very well explains how to use to expand file system. Hope it helps. 

Second point, Rpi is a 3v3 device while Arduino is 5v device. So while connecting both of them, you must use a level shifter to convert 5v logic to 3v3 logic else it can damage your RPi. Here is a connection circuit for your reference. 

The most reliable way to check if RPi is working or not is to burn a fresh in an SD card (brand new SD card if possible), powering it up via laptop / desktop USB (do not use Hub) or a decent (with current rating 1A or more) charger. Don't connect any USB peripherals to RPi. Just connect TV / monitor via HDMI and give it a go. If it doesn't show up anything in display, it is most certain that something is wrong with RPi. Hope it helps. 

How about . Make sure you have an active internet connection. You can confirm it by . Hope it helps. 

My recommendation would be to add another layer of opto-isolation when driving the above relay. Here is how opto-isolators work. If possible, double the capacity of the relay (90A) to add scalability and over-current scenarios. There a lots of advantages of using SSR over mechanical relays. Here is an application note from IXYS that delineates the advantages of SSR over mechanical relays. I would not recommend you do it yourself unless you are licensed. Better get a licensed contractor as the voltages are lethal and one mistake would cause electrocution! 

When the energy in the cap is fully depleted, the power draw becomes higher than what the power supply circuit (excluding output capicator) can store and deliver. Hence the load does not get enough power (P=V.I). This is my understanding of the situation. As I mentioned, a better analysis can be done by measuring current and voltage (output power of the power supply). OP has not provided any specifications about the power supply used. I have personally seen these dropouts happen when using cheap 500 mA power supplies that are labelled as 1A. I would encourage OP to use a 2A power supply with the V, I monitor, and report back if issue still persists. 

You need to put your script in /etc/rc.local. This script runs once when the OS starts. It runs irrespective of id any user logs into the system or not. Raspberry pi manual describes it in detail here. The .bashrc file is used to setup your bash shell environment when you login into bash shell. .bashrc does not execute if you don't login into bash shell. 

Your application doesn't need denouncing as there are no mechanical contacts involved. The pulse adapter board has no mechanical contacts, relays, etc. Debouncing is only needed if you connect mechanical contacts to digital inputs. From Whatis.com - "Bouncing is the tendency of any two metal contacts in an electronic device to generate multiple signals as the contacts close or open; debouncing is any kind of hardware device or software that ensures that only a single signal will be acted upon for a single opening or closing of a contact." Here is a excellent guide on debouncing. On the other hand, your application may need signal conditioning. The pulses from the adapter bard may be of different amplitude that the PI can handle. Or the pulses may need filtering, etc. You can read more about signal conditioning here. 

I believe that video size is the problem. It seems that Phonon makes use of only to process mp4 videos and shows it on screen and CPU may not be able to cope up to deliver real time performance for higher resolution videos and hence it is stuck. You can have a look at or something similar that makes use of RPi GPU which can render 1080p videos without any glitch using RPi GPU, and if you could incorporate it in your program. Also, may I know which SD card class you're using currently ? It would be worth to try a class 10 or higher for better IO performance to check the performance. I'm not sure if it affects the performance or not. But worth a try. Hope it helps. 

Since synergy uses x-windows and hence can't be invoked using as by the time executes, x-windows is not up and running. You can try adding it to as per below steps: 

I think you want to read an input ? Syntax error was due to because you forgot to put after your statement. Here, you can use this, 

You can downgrade kernel version with as well. All you need to have is the hash of that git hash of that particular firmware upgrade. As per this link, 

I'm assuming that your script works fine when invoked manually on terminal. Well, does your program make use of GUI functions like imshow or something ? If that's the case, you can't invoke it using rc.local / crontab since items in both of them execute before running an X server. You will have to place it under /etc/xdg/lxsession/LXDE-pi/autostart. Follow these steps : 

You can not open programs that uses via ssh. Use remote desktop using a decent vnc or xrdp as per your platform. You can make use of plain shell by issuing and start executing your code. 

As per links in question, I think the method described in it is not working because newer versions of Raspbian calls autostart from instead of normal startup, not sure why this change in newer versions, may be someone experienced or someone having deeper knowledge of Raspbian can shed some light on this. Hope it helps. 

From your diagram, it doesn't seem that you have connected the LED to a GPIO! Here is a map of the GPIO connector: 

Is, it recommended to use SPI to communicate over a long distance, No! My recommendation will be to use ESP8266 modules with Arduino boards and transmit the data over WiFi and collect using Raspberry Pi Ethernet (or WiFi interface) 

Download and image latest raspbian on SD card - Guide Mount the SD card in Linux (assuming your laptop has Linux or a VM with Linux) and edit the /etc/network/interfaces file assuming 192.168.10.110 is the IP you want to assign and 192.168.10.1 is your gateway. 

The Raspberry Pi board operates at 3.3V internally. Although you power up the board using 5V but the GPIO voltage is 3.3V. Even if you replace the 5V relay module to 3.3V relay module, the GPIO can't provide enough current to energize the relay coil. You need an opto-isolated relay board that will take 3.3v trigger input (most opto-isolated setups do). Referring to below schematic, you would connect DGnd to Raspberry Pi Ground, IN1 to Raspberry Pi GPIO, Supply Relay voltage (12V in this case) at J9 and connect your load (bulb) at J5 (in series with your load supply voltage, same as your current module). 

Raspberry Pi does not have an orientation sensor built in. You can simply use of of the GPIOs along with a tilt sensor to detect the flip / Orientation. Here is are example of tilt switches. 

By looking at your question, it seems that you are trying to gather light data from multiple Arduino boards and using Raspberry Pi as collection (and may be reporting) point. SPI specification has no set length limitations but when run a few meters apart, it is susceptible to EMI/RFI, cross-talk, slew rate issues. Assuming your Arduino boards are far apart, you need a differential pair bus like RS485, RS422, etc. To answer your question in simple words yes, you can use SPI to communicate between 3 or more Ardunino boards contingent to proximity between your nodes. Master with three independent slaves: Simple in operation but limited to the GPIO pins required for each SS. Each additional slave will require one additional Slave Select pin. 

This should install all the dependencies along with OpenCV 2.4.1 with Python support. If you have an Rpi 2 and want to use TBB to gain advantage of multiple cores of Rpi 2, I would advice you to grab the source of 2.4.9 and build it with cmake flags along with other flags as per your requirement. Because libtbb-dev is not available under official Raspbian-wheezy repository. Hope it helps. 

sudo nano /etc/xdg/lxsession/LXDE-pi/autostart Add this line at the end : @sudo /usr/bin/python /path/to/script/script-name.py Ctrl + x, yes to save changes. Reboot to make it effective. 

Here is a quick solution. This is how my /etc/network/interfaces file looks when it connects to a hidden / key less wireless connection. I am using a home router and hence my sub net is : 192.168.1. and all the ips are as per this subnet. You can modify it to suit your network. 

Each usb web cam that you connect gets listed under where n = 0,1,2 .. as number of video devices increase. Ie, if I connect two webcams to my system, I would be able to see two entries and when I fire . I've not used personally but its documentation suggests that using flag you can specify a particular webcam. Default is . You can run multiple instances of fswebcam to capture images from all the cams simultaneously. However, USB bandwidth bottleneck is entirely a different issue as you keep on adding devices. Hope it helps. 

Make sure it works manually. Open rc.local by Copy paste the same command that worked fine when testing manually before line. reboot 

You can use to install PostgreSQL. Also, if you don't want to install tools on raspbian, I suggest you to get image of kali linux for Rpi. Link : $URL$ 

I have a couple of RPI which I use regularly. Recently, I have been seeing Red and Green light blinking on my RPi. Rpi works great. I just couldn't understand why both the lights are blinking as it should be red constant and green blinking on a normal scenario. Just wondering if anyone has faced the same issue.