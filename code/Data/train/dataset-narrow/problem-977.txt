You naming convention does not follow PEP 8. Try to follow it as much as you can as it helps having same consistent guidelines all over Python code. 

thousandUp: Once the code is simplified, we realise that as described in Janne Karila's comment, we could use to call , killing many birds with one stone : 

and no more small functions. A more Pythonic solution/option Using properties, you may be able to implement a solution computing values when you try to access members and they are not set yet. 

Hidden recursion Your game loop relies on a hidden recursion: calls which calls . This makes things heard to follow but also will add another level of function calls in the stack. This can be an issue if you need a backtrace because you'll get something like: 

Disclaimer : most of my comments might be irrelevant as far as performance is concerned but should make your code better on different other aspects (readability for instance). Listen to your compiler Compiling your code with gives me the following warning : . I guess you know the first thing you can do :-). Making things easier to follow Splitting your code in small chunks is usually a good idea. Unfortunately, I am not quite convinced by because what it does is quite complicated and it makes it hard to give it a simple name, to test it out of the algorithm or to reuse it later on. Thus, from my point of view, it's easier to just remove this function. A good habit : defining things in the smallest possible scope It is quite common to try to define variables as late as possible and in the smallest possible scope. It prevents whoever reads the code to try to keep in mind the value of irrelevant things and to find what is used for what and it allows one to find easily when a variable becomes unused. It makes even better if you use as you can them define indices in for-loops. Also, you can take this chance to define things that go together (such as and ) together. Consistency You should try to be consistent in how you write your code. You should define a way to put space in your code and try to stick to it as much as possible. Consistency is relevant also for braces (you did good), line breaks, incrementations (you used and ). 

Nitpick Because of Gareth Rees' excellent answer, there is no point in trying to improve your code until you've made it correct. However, here is a tiny piece of code that could be improved: 

Now for the actual review Your code looks nice and is splitted in small functions. What seemed wrong at first : 

However, it seems like something even smarter could be done here. At the end of the day, my assumption is that what you want to do is just to iterate over from the beginning to the end and call on each element. This is not what you are currently doing because you are not processing the first element of the list (index is 0 and would correspond to ). You have more than one way to do it but the most straight-forward solution involves looping over your list in reversed order with reversed : 

You are retrieving various elements to be able to loop over parameters without default values then over the parameters with default values. You could loop over parameters and defaults values and fill with None for the parameters without. Because you want to fill from the beginning, you could simply reverse both input lists. Duplicated logic Expressions such as are repeated in multiple places. This is easy to get rid of because you have stored it in already. At this stage, the code looks like: 

More advices If you are learning Python, it would be a good idea to give Python 3 a try. There is not much to change in your case but the earlier you take the good habits, the easier it will be. Regarding your length comparison, you could try to use izip_longest to handle scenarios with strings of different lengths. 

Split your logic into smaller functions. In your case, one can easily see that and are good candidates. 

You can write a function to compare two "position" strings and a function to compare "priority" strings. Then a resulting comparison function could be written easily by calling the two already defined functions. Now for the actual review, you don't need the check in the case, checking first if is enough, in the other case, you can simply return -1. Similarly, , you only need to consider , otherwise, you can simply return 1. 

Removing useless copies Currently, in the nested loop, we copy an entire vector. This could be expensive when the vector gets big. It is more efficient (but more work for the developer) to perform the copy once and then making sure you restore it to the original content after using it. You'd have something like: 

Also, if you were to do things manually, after notificing that 0 has to be in 10th position so that the number is divisible by 10, you can notice that it leaves only 5 to be in 5th position so that the number is divisible by 5. You have 2, 4, 6, 8 left for 2, 4, 6 and 8th position and 1, 3, 7, 9 for 1, 3, 7 and 9th position. You can do this programmatically for yet another performance optimisation. 

Naming Your 2 arrays are used the same way, it is a bit weird to have 2 different names for them. Maybe and would be better names. Also the fact that they contain integers may be irrelevant for the naming: and would do the trick (or and because the corresponding Python primitive data structure is ). Problem with the check for length equal to 0 Checking for identical lengths as the beginning of the function is a nice touch. However, the condition makes me uneasy. It only makes a different when the first part of the check was false and the second part is true which means: which really means: . I'd expect the empty array to be a rotation of the empty array. The alternative would be to document the function to precise that only non-trivial rotations are considered (which is not the case at the moment). The easy fix is probably to remove this test or to return True in that case (or whenver == ). Comments Commenting your code is nice but adding obvious comments doesn't help anyone. There is a fine line between too many comments and not enough comments. I'd get rid of for instance. On the other hand, could be kept somehow. This should be moved in the function docstring. Also, Python has a Docstring convention called PEP 257. You could write: 

Then, because there is not point in adding spaces because all elements of the array already end with a space, we can do : 

(Please note that I took this chance to remove a as non-zero boolean will evaluate to True). This is all pretty cool but we want speed! You want to compute/check primes up to a certain limit. Good for you there is an algorithm just for this : the Sieve of Eratosthenes. Here's an implementation : 

You have a O(n) algorithm, that should be fast enough (and it is easy to see that better complexity cannot be achieved). 

Now, there is quite a lot of code and I have a limited times so I'll just point out other things that could easily be improved. Basic logic By reorganising the code in : 

Documentation Please add documentation to tell what the function is supposed to do and what input it is expecting. Avoid repetition In , you repeat many times which smells like something wrong. It can be rewritten : 

A different algorithm I though that by the time I'd write this, I'd have found the name of the algorithm to solve your problem but I haven't yet. :( Real life problem and data example In your description, you say 

A quick detail You've written : this is not the ""right"" way to use the "ternary" operator. Don't get me wrong, it will do what you expect it to do. However, the whole point of the operator is to return a value. In your case, it is no different that : . This calls for a ternary operator but to write it in a simple way : 

Using the right tool : at the moment, you are using Lists for and . Lists are fine but in your case, you have better things : 

should provide you some hints. I'll go deeper in the code once you confirm that my understanding is correct. Edit : I have to go, no time to run benchmarks but here are the improvements. I kept different versions to that you can take ideas out of it. 

At the moment, your code is simple enough so that it's quite easy to understand what it does and to be convinced quite easily that is does correctly. One of the main principle of programming is Keep it simple. Adding special cases will give you more code to maintain and potentially introduce bugs. This is probably not something you want. If you want to be sure that your function returns the same thing as , you might want to use this in your unit test (you were about to add unit tests, weren't you?) If your reasoning to add special cases was performances, I guess you shouldn't be too worried about that as it corresponds to a situation which would have been super fast anyway. 

Similary, could be extracted out and made into a clear function with a well defined behavior. Also could call it before doing anything else and raise an exception. Improving You are iterating over the input multiple times to count the different characters one by one. A better approach would be to iterate over it once and count all the characters in one go. Fortunately, this task is really easy with the class.