And I called your extension on , you would end up with duplicated options for these two different selects. Is this desirable behavior? 

You need to think about inverting your happy path vs. error path. Take for example your main conditional. Instead of: 

If you follow suggestion above about injecting dependencies (including content) at point of instantiation, then perhaps this simply looks like: 

It is not really clear to me what this code is doing. It looks like this might be some mechanism to update the running application on your site. If this is the case, I would suggest you really rethink this whole thing, as there are any number of better ways to deploy code changes to an application. None of them involve trying to swap out files on the fly like this. It is clear that even the zip file artifact in this case has been poorly constructed based on the fact that you have to do clean up on unneeded, OS-specific directories and such. Don't operate using 10-15 year old ways of working with websites. This ground has been covered innumerable times before. 

Now you may say that "Hey, I don't like having cases mixed in there with ." To which, I would say "Exactly! Why not group your assertions together make them more readable." 

Now, the code path is much more clear, and having done your conditionals this way, you can clearly see what might be problematic conditional logic in your current approach (what happens with certain values between 0 and 1?). What I have shown above obviously still needs to be cleaned up to the point where the design intent is made clear. The general philosophical approach should be to make quick exits from functions/loops, etc. to enable you to de-nest your happy path code. Also note that there are very few times where you really need an condition. If you have written an , you may want to revisit your condition to see if there is a better way. Note that you should also de-nest your very last conditional. You have ~15 lines of code inside a conditional when it doesn't need to be. 

Should you really be using Laravel object as the basis for your collection class? In other words, do you really want to you an array for your data structure here? Note how in your methods you will have to repeatedly iterate over the collection/array to determine if certain entries are present, or to get their values. Your method performs an \$O(n^2)\$ search against your underlying just to be able to add an entry. Your requires an \$O(n)\$ iteration over the collection in order to return a file rendering. This might not be a problem if you are only ever expecting to be working with a handful of entries in the collection, but will become a problem if you expect your collection to grow to significant sizes (even 100 entries would cause 10,000 individual iterations on the collection to be performed to add a new command, 1000 entries would require 1,000,000 iterations!). If this concerns you, you might consider a key-value lookup scheme to allow for quick \$O(1)\$ lookup of results. For example a structure like the following would enable fast lookup against the collection. 

You should invert the order of your PHP processing and your HTML output. When working in PHP, always strive to adhere to this approach, as it will help you as you start working on more complex logic. You will inevitably find yourself needing to set HTTP response readers, cookie values, etc. in your responses. You need to do this work BEFORE sending any output to the browser - either that or use a hacky output buffering approach. If you need to set conditional output (i.e. success/error messages, dynamic content, variable output, etc.), consider setting these values into variables and having only basic PHP insertions in the HTML portion of the code. You should avoid any complex PHP calculations or logic once output to browser has started. Other thoughts: 

First, I am concerned about the underlying data model. I am not sure that trying to fit all different event types into the same table makes sense here since the events are so different in nature (account validation vs. taking a quiz vs. making comments vs. completing missions vs. completing a campaign). My guess is that you should have separate tables in the database for each of these types of events. One table for quiz results for all users, one table for all user comments, one table for storing mission information, etc. Second, I am concerned with how you are hard-coding the level requirements into this section of code and storing the level on the user record. This is a very tight coupling of your leveling logic with the user object (presumably in database as well). What happens if you change your leveling criteria? I would probably strive to store necessary properties or expose necessary methods with the user class to be able to pass a user object to an independent level-determination class where it is compared against levelling criteria. So to fill out a rough class skeleton, perhaps you are looking at something like this: 

Shouldn't be static, since that is the only context in which it makes sense (there is no instantiation of this config). 

Not sure that you are getting any value for storing duplicate copies of this information in this scope. You are only using app.activeDocument.layers a single time, in your function. Why not have first line of that function simply be ? 

Not sure about the overall utility of this class, in that it limits some of the functionalities of the underlying SSH2 functions. Let's look at the method for example. You have now restricted the ability to do things like pass in variables to be set on the environment. You also do nothing there to monitor STDERR stream. If your main intent is to manage the way in which connections are made (i.e. authentication and such), then perhaps this class might be sensibly refactored into a factory class that can take inputs for host, auth settings, environmental variables, callbacks, etc. and simply return an object of another class representing the SSH resource with appropriately set-up mechanisms for handling STDOUT and STDERR streams which would be suitable for passing around as a dependency to code needing SSH to that particular target server. Your concrete class could be similar to what you have now, allowing for various operations against the resource and providing proper error/response handling around the executed commands. Consider naming something like to clearly indicate you are working with underlying functions. Example usage with this approach: 

Since you know have complete class information, I have updated my answer to give more specific review comments on your code below. My comments are within multi-line comments. 

Why do you need two shuffling functions? You should consider having a shuffle function that operates against whatever deck/hand is passed to it. 

Update Per your request, here is how you might use your first query as a sub-select to simplify the overall query and data retrieval process: 

Does your class know that it is handling user input? Do you need to sanitize before passing this information to this class method? 

I think you need to consider either passing all needed dependencies (id's, voter, vote type, etc.) to the constructor, or you need to validate these values are set before performing database queries which rely on them. I do question why caller needs to provide an id for inserting a vote though - is this not autoincrement field in table? Without understanding how you are working with these objects in your application, it would be hard to determine which approach might be best. If you are treating these dependencies on the objects as immutable during the lifetime of the object, then passing dependencies to constructor probably makes the most sense. If the dependencies can change during lifetime of the object, then perhaps rather than a bunch of individual setters for these dependencies, you provide a single method to set the dependencies on the object where you can perform all validation necessary to make sure the object is set-up properly to work against the database. 

Outside of format, your query seems odd in that it doesn't seem to match the relations you have noted. You said the relationships are: 

And would go through all the logic of for validating user name, setting up directories, etc. This code should know nothing about what is required to create a "user" outside of whatever information needs to be passed (i.e. user name). 

With your DB-related classes, you seem to have fallen into a classic anti-pattern in working with DB objects in PHP. For some reason (probably because there are thousands of bad code examples out there on the web), almost every developer picking up PHP tries to write some DB abstraction or DB connection class. 99% of the time these classes add no value above and beyond working with the underlying , or similar classes. In your case, what value do and add? These classes present a number of problems: 

Thanks for your example. It kind of validates my concern on how you are thinking about routing. I like that you are thinking about the routing problem and trying to move away from legacy ways of having each URL going directly to a physical file for processing. I would however challenge you to take this a step further, as what you have now really only gets partially away from the legacy web application, a script-for-every controller/action line of thinking, in that you still have scripts that you are redirecting to rather then using your router to instantiate an appropriate controller object in order to satisfy the request. Most modern frameworks that utilize a front-controller routing pattern like you are trying to achieve have gone the route of auto-loading a controller (ideally auto-loaded in a PSR-4 compliant way) to handle the request passed to it by the router, not having the router just include some specific script file. So you might see a pattern like: