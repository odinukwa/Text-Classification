I'm using a Raspberry Pi 3 with and my issue is marginally different, but I found a solution, so I think this can help you too. I boot the RPi with set up so that I have one SSID and password set and the RPi connects automatically to the configured SSID on boot. In addition, I wanted to change using some automated text processing script and then reload the wifi settings. After searching around for a bit, I found this post on the official Raspberry Pi forums and found this set of commands inside that worked for me at least: 

From the following: $URL$ In PiMotionAnalysis, "The data-type of the array is an (x, y, sad) structure where x and y are signed 1-byte values, and sad is an unsigned 2-byte value representing the sum of absolute differences of the block." What does x and y represent? 

I think I may have cracked it! Oh what good 3 hours of sleep do to us. x and y may be the displacement vector of a given macroblock in his coordinate. I found this because when printing a['x'] and moving a sheet of paper along the camera x axis in one direction showed a matrix with mostly positive values and when moving to the other direction the signs changed. I think I can work with this. 

This might already give you a good start and might even be enough for most situations as most people won't install a boot splash screen and an icon set specifically designed and branded for a desktop environment they don't have installed. Just my two cents. There are much more clues to be found though, and with some digging on what components Pixel consists of (or uses by default, like ) you could also find out which folders/files, init scripts and configuration files are needed for those components to run. Ultimately, you could then conclude from their (non-) existence in the filesystem if Pixel is installed. Keep in mind though that in linux many different combinations of packages might achieve the same thing, meaning that you might under some circumstances face a situation where somebody runs just some parts of some common combination like, lets say, Pixel. You might then be able to tell that there is a GUI based on installed together with a display manager that is sporting the running on , but possibly no more than that. 

I'm currently trying to access a Bosch BMP280 pressure sensor from Haskell using the HPi wrapper for the bcm2835 library. I have no experience in handling SPI at all and as documentation is extremely brief / sparse, I had no success trying to troubleshoot the problem on my own. As far as I understand, to read from the chip's registers, I have to clock out the address of the register to be read (with the first bit of this being replaced by a '0' to enter read mode)and then clock in as many bits as I want to read (by clocking out the corresponding number of Bits / Word8's of zeros while returning the bits being clocked in at the same time). In code (following the spitest.hs from the HPi GitHub repo): 

and with the FE-PI 2 board it works ok, with mine I only record noise. Doesn't the kernel driver take care of everything such as I2C configuration? I double checked the power voltages between the boards and it is relatively the same, give or take 50-100mV, and also the oscillator. Basically the question is: when using a driver for an I2S CODEC, does the driver take care of the I2C configuration or does the chip need to be "flashed" one time first or whatever? EDIT: Something is wrong, when I measure the MIC_BIAS voltage on the chip of the working board it gives 2.54V, and when measuring the same pin on my board it only gives 1.49V. I tried setting the voltage manually using a python program but the chip address appears to be locked by the driver. I'm now studying how drivers work so I can get a better understanding on what is happening. EDIT2: Found the problem, the bias resistor and the cap that is between the MIC_BIAS pin and ground were switched in production, that was the problem. I have to learn how to silkscreen better on Eagle... 

I am using this board and this works: $URL$ Now, I wanted to integrate an SGTL5000 (the above board's CODEC) in a custom board. I designed it and I already have it with me, a local store made it for me and soddered the components. I suppose the next step would be to just record as I do with the above board: 

There may be some trickiness if your fb is 5:6:5 format, as I believe imagemagick does not support that. Note that because imagemagick's convert utility understands practically every image format, you can replace my_image.png with most any image. (Imagemagick has lots of other nifty features, too, for example if you wanted to add text or other overlays). 

In general, no - GPIOs don't have a variable voltage output. If they did, we'd call them a DAC. As suggested by xPino, you might be able to use a PWM pin - but I suspect that the backlight pin on the LCD is going to have higher current requirements than can be provided by a GPIO (or PWM) pin on the Broadcom. You'll have to look at the LCD datasheet to find out. 

Generally, yes. In Android, the question about whether or not an LCD will work, and what you'll have to do to set it up, is really a Linux question. Do you have drivers for the LCD? If you have drivers, and can build them into your kernel, and configure them correctly, they will in general expose an interface to /dev/fb. Android will automatically find that interface and use it as your display. 

Another datapoint, if its useful. I regularly shutdown via ssh, but I run ssh from the command line (not via Putty). The following shuts down my Pi and powers off (HDMI out becomes disabled, but always on Power LED stays on). Note: this is on Raspbian, and I ran uname to show you my version. The commands below were run remotely from my Macbook. 

One possible way would be to check if the package is installed, which should give a good clue on whether the Pi has Pixel installed. This is possible by running for example . This lists the version of the package if it is installed. If you want to do know if Pixel might be installed from without using apt, you could search for packages listed in that match such a system. You can be quite sure if you find the following entries: 

Is that correct? With this code I get nothing than back from the sensor. Starting to guess what the problem might be, as the enumeration type from the library seems not to be handled in any way in HPi, I wonder about if there is a default clock divider / clock speed used by the library and if it possibly exceeds the maximum of 10 MHz mentioned in the sensor's manual. Is that the case? 

Have you made sure that the necessary packages are installed? If not, try . Anyways, are you using exactly the specific printer the CUPS filter is designed for? Otherwise, there is a large possibility that the filter won't work for you. maybe offtopic: Generally, I would ask if you really need CUPS to print with your thermal printer. CUPS is a printing system that is able to act as a print server, handle print contingents etc., but which is possibly also hugely overcomplicated for what you might be trying to achieve. If you only want to print something of that simple shopping receipt type with just some text and maybe even barcodes printed, you might probably want to consider writing directly to the file (with being specific to your system), as it is the easiest way to line-print on linux. Basically, everything written to this file will be printed. Text formatting (bold, newline, etc.) is then handled by escape sequences similar to those in the terminal. Using this technique you could easily print any (command line) output of a program of your choice by starting it with . A how-to on this topic including some clues on escape sequences is to be found for example here (this one is using php, but will work with every command-line program). As a next step it would also possible to just 'open' the file from within a program using filesystem functions and write to it what you want to have printed. In this way you wouldn't even lose your screen output / interface within the program. Let me know if this works for you!