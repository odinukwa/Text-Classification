Use Classes Documentation. Using classes will not only make your code more readable, but also more easier to be maintainable and re-usable. It will help you separate the HTML logic and the PHP logic, instead of having a lot of messy PHP code in HTML files. My recommendation is, learn OOP Principals. Readability Variables like and can be simplified as: 

If you do not know about Dependency Injection, click here. In this above code, we have created a class called CMSData, to carry all data, and that class is accessible by every other class. So, when you want to do something with Data Storage or whatever, your class would be CMSData, where you change the stuff. The UserHandler class is to Handle user interactions. Let's take an example, suppose your is tell you that the URL has changed, and a new page has to load, so there would be a function called, lets say in the and an argument which contains what page is requested is also passed along, to the UserHandler class. The UserHandler class calls functions in the Mapper class which does validity checks, etc and if necessary, stores some information in the CMSData, where there are bunch of variables available. 

The way you have your function set up, you're appending and changing the DOM each time that loop goes around, and it goes around for every image. That's not good because DOM manipulations are quite expensive performance wise. So if you have 100 images, you're append one at a time - 100 times. The better way to do that would be do all your stuff and save to a variable, string, or object, then append once outside the loop. Here's an example of what I mean: 

This code handles a response from an RSS feed. It organizes and appends to content. If there's a video embeded then separate it from the rest of the content. I would like a review mainly on performance/efficiency but I'm open to any other suggestions as well. That star selector is really nagging me but I don't know of a better way to iterate over all the contained elements. 

Probably the most important thing you should be focusing on is the idea that ID's are unique. There can't be more than one element with the same ID. If you're trying to select several elements, jQuery will stop looking as soon as it hits the first element that mathces the ID. You should use classes instead. That said, it's up to you to make that change. I cannot determine how to do this, or the implications it will have on your site, just based off the code you posted. Second most important thing is you should cache your jQuery selections. If you use a selection more than once, you should cache it. This way jQuery doesn't have to go looking for that element(s) every time. You then simply reference the variable you saved the selection in. I've also replace your variable inside the callbacks to use instead. This is the index. It counts how many times you've gone through this callback and is more appropriate for what you're trying to do. I would also recommend starting at zero since JS is mostly zero-indexed and will make your life easier if you need to manipulate any of these ID's later. Anyways, I'm sure there's more you could improve on, but without changing the HTML and while keeping this "the jQuery way" there's not much else I could change. Here are the few changes I've made: 

A more 'advanced' approach could be the following, where I use a little Linq and an enum of Animals: 

The calls to CheckForDuplicate(...) seems to be on the same level of concern so maybe make a combined handler for that: 

I assume that does not return a possible duplicate url-friendly title or else you maybe are positively redirecting to "Index" having a duplicate url-friendly title set on the model because is not checked for duplication before returning. 

Beside that I would change the flag to an too, because you can then distinguish between more levels like: 

When determine if a number is a prime, it is only necessary to check primes up to (inclusive) the square root of the number: 

I think there is a little problem with the performance of your implementation. When the number of elements increases (> 8 - 9) the time the algorithm uses to calculate all the permutations growths significantly which causes an "unbearable" delay before the permutation can be used (the function returns). The problem is that the function returns a list of lists, and the solution is to change it to return a sequence of lists as shown below. 

As a rule of thumb, when you use a jQuery selection more than once, you should cache its value. When you do , jQuery now has to go find that element in the DOM, wrap it in the jQuery object and return it. If you save what it returns, then you only do the search once - not every time you use it. The hard part is caching . This is relative to where you are in the code, function, callback, etc. and changes to provide context. For example: 

I wouldn't rely on $.noConflict - Chaining: As pointed out in your question, you should be using something like that. jQuery is particularly good at this and you should make the most of it. Ex.: 

This works just fine and fulfills all the requirements from the assignment. What I want to know is how can I improve this code while still remaining within the requirements. Also any reading materials/videos that you think would be useful for my learning please feel free to share them. Main Race file: 

Nice and clear code - a couple of things though: The total number of occurences (the sample size) is constant per input string: 

I think your solution is quite OK, it is doing what you want it to do. You can sharpen the if-statements a little by using for all but the first, because an animal can only be one kind. Alternatively you can experiment with a -statement instead which will make the code more clear. By the way: you don't need the flag for cats () because it's the 'lowest' level of animal type. You solution with a switch statement instead of if's: 

2) When checks the input list it does not find changes to items in the list, if they are of reference types. In your test environment it find changes to the string items, because a string behaves like a value type in this case and the changes made to the string actually make a new string - not a change to the existing string object. So your method actually finds a new string not a changed string. If your list was a list of a class like: 

Here they don't return the jQuery object, since this utility is for arrays. My point here is that there's no one shoe fits all. It depends on what you're trying to get from your plugin. Also chaining is expected but not on something like $.map(). Also keep in mind, in your callbacks should refer to the element in question (ie. in a click callback refers to the clicked element). If you're not playing with an element, should refer to the global(window) object. 

From what I could understand from reading your plugin, I've cached your references for you. I didn't change anything else except for calls at the end. You can use a space and put in several attributes to be removed at once. Anyways here's your code: 

That just makes the syntax so easy to remember as well as provide you with enormous control over your events. If you're going to use jQuery on a regular basis, I recommend that you take some time and read through the source code of the methods you're using. To find them quickly just use and type . That should jump you straight to what you want to know. This way you can understand what and how they are doing things, and even find better ways to do them on your own. Also if you see something you think should be done better or differently, you understand how it works and you can contribute to jQuery.