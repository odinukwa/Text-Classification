I was installing and removing packages recently and i noticed that it said: as soon as i ran the command. But, when i ran it still said: When i ran however it also said: 

When creating a new motor object from the GPIOzero module like this: , then you need to specify the backward and forward pins. What does that mean and what if the motor only has two pins? 

SSh is disabled by default on all new raspbian installs. To enable it you will either need to physically log in and enable it with or insert your sd card into another computer and create a file called with no filename extension to enable it on the boot partition. Then make sure it's connected to WI-FI and try again. 

I've been getting into GPIO recently with the GPIOZero library but when i first tried it today it completely failed. As my first foray into GPIO i set up a circuit to light up an LED with the push of a button, so simple nothing could go wrong, right? I imported the library like so: then i set up my components: then the button: And then this happened: 

One of my friends had the very same error which he resolved by following the steps on this page. Apparently there is a/are defect(s) which prevent xrdp working with the vncserver. However it works with tightvncserver Also the order of installation of tightvncserver and xrdp seems to be important. In summary 

That said there is a good probability folks might find better quality open source software compared to yours, so might not be worth going overboard attempting protect your work against all possible attacks BTW If you find a fool proof way, a lot of folks would pay good money for that knowledge :P ; I think M$ is still looking ... 

With the right power management logic in the ardunio, it should be possible. see this page for the specs of the board/chip as well as this 

Looking at the header it appears isnt actually implemented which would explain why your code changes didnt make a difference 

Up and down speeds depend on the network and are typically asymmetrical (meaning download speeds are higher than upload speeds) This mode of usage is pretty much opposite to what you are looking for. Typically there are number of considerations that would go into configuring a system that is going to be exposed to public such as security, load balancing etc. Assuming your use case doesn't require such rigorous effort or considerations but just a simple system that allows you to remotely access some information on your Pi from another system, you will need to deal with at least the following 

I need more information. What is the range of travel? I ask because there are different cellular standards in different places. Pianywhere (BTW: it would have been nice to have a link there) would do the job in many of the places. For example, The Americas is one region, Asia another, and GB and the EU yet another. The Pianywhere does seem to have a GPS in it. I have no idea what the SparqEE is, but if you'd linked it I'd have looked. Other things to think about with travel would be power: if you have to run on batteries, how are you going to charge them? And what about weather-proofing if necessary. I assume the Pi will be outdoors because GPS doesn't usually work indoors. 

Does this driver run even without the -mfloat-abi=hard? I ask this because figuring out where the problem lies may involve looking for defaults. First, does your system have the directory: /lib/arm-linux-gnueabihf ? That directory has your library files in it compiled for hard float. If the directory is missing, then you may not have a hard-float linux. If you have the directory /lib/arm-linux-gnueabi then you have a soft float linux. I don't know what happens if you have both of them. It's probably like crossing the beams or something. I'm doing this on very little sleep, so the best I can further say is that the build system has defaults for compiler switches. There seems to be a switch set for mfloat-abi=soft somewhere in the build system. 

Briefly (incase the link(s) go dead sometime) the relay board appears to use a FTDI chip (USB => USART) and therefore should be simple to control by writing to the serial port like so (taken from a customer's comment on amazon and modified to include more examples) 

Use 2 threads, 1 for acquisition, 1 for file writing using pthreads once NUM_SAMPLES samples have been acquired, swap the 2 buffers - adc_buffer and file_buffer and let the acquisition continue with the other buffer In theory, using 2 threads will allow the file write thread to block without affecting the acquisition thread though the real underlying problem is the different subsystems (GPIO, USB, RAM, CPU) work at different speeds and some kind of tradeoff definitely required. there are probably many other tweaks worth pursuing but I will stop here :) 

Unless you have a specific reason to use the low level socket library, I'd recommend using the requests library when retrieving data (text or binary) over HTTP. This library supports proxies as shown here. 

According to your code the value of is just initialized once. since you need a different file to be selected every time motion is detected a you need to pick a new file from within the function like so 

what is the difference between these two and what do they mean? I have searched for "action 17 on raspbian" and other things like that but found no helpful results. 

If you are looking to install something nicer I would recommend Iceweasel which you can install by simply running But if you want only things already on Raspbian there are 3 web browsers that come with Raspbian netsurf: which you can use by using the command dillo: which you can run with and Epiphany: which you can run with 

Theoretically this should speed it up to whatever time you set as n. For a better option you should have it be multi-threaded so that you can have them happen at the same time with no delay if you'd like to try that i recommend you here. 

As you can see this shows the website it is from from which you should be able to tell who it's from. 

I don't own a camera but the way to enable it is to run then go down to option 6 and select yes and I believe that this should enable it. 

I am looking to get the output of thermal_zone0 (CPU temp) to display on my Sense-Hat. I now know how to print the temp thanks to @Joan but when i try the code below but i got 

and you can either wait or poll for the process to exit. The indirect approach is generally useful if you don't need total control over the playback but just a simple interface. Sometimes I use it to play a song for a certain duration and stop by having a timer callback terminate the process 

The port on the raspberry pi 3 maps to the bluetooth and to the standard serial port on the others Assuming you have used the default raspbian image, you will first need to disable the serial console as detailed here 

My guess as to why ssh (from laptop to PI) works but not pings from Pi to laptop is likely because the laptop OS is configured to block ICMP requests. I have seen that happen on some networked computers in my office. 

Probably not the solution you are looking for, but I noticed you have not launched the jar file as a background process as it should be done when editing the file. The system will not finish booting until the exits. See the documentation on this Try adding a at the end like so 

[disclaimer] i havent really tried this but i believe it should work if the drivers are correctly setup 

If you can program in Go, Node.js, or Ruby, then you might want to look at GoBot.io. GoBot is a lightweight framework that has several communication frameworks and Raspberry Pi is one of them. I have my Linux laptop speaking to a Raspberry Pi Zero W, just to see if I could do this. My next experiment will be to have wired communication. If you look on the front page, they have "sister projects" written in Ruby and Node.js. The Go code runs on a larger computer (PC, Raspberry Pi, that sort of thing) and through and "adapter" (a communications protocol) they communicate with microcontrollers if necessary. The same technology allows for communication between multiple Raspberry Pis. It is a much lighter framework than ROS, though, but it is much easier to learn. 

I've never heard of trying those strategies. I've never heard of a Raspberry Pi hat or other add-on that adds a new CPU. I suppose you could use the Raspberry Pi Compute Module with multiple modules, but that would be more expensive than choosing a more powerful single-board computer. There have been people who have made parallel computers with a network of Raspberry Pi's. These clusters are more educational than useful, but they might increase your CPU speed enough, and they should be able to share a hard drive. I don't know if this will help enough, though, because I've never tried this. Have you considered a more powerful board such as the Udoo x86 series? This is an x86-based board (or rather several of them with increasing speeds and prices). It will run Linux just fine, it can also run Windows. It includes an on-board Arduino clone, which is useful for robotics. The Raspberry Pi, while a wonderful computer for some things, has too many networking bottlenecks to be useful where networking is important. Don't get me wrong, I like the Raspberry Pi. I have many of them. I'm going through my electronics, and I have many more than I thought I did. Maybe I will try making a parallel Pi someday, purely for educational purposes.