The code uses the internal pull-down to 0V so shorting it to ground will never make a difference. Connecting it to 3V3 and then disconnecting it from 3V3 should trigger the callback, The code refers to 17. This is a gpio as you are using BCM mode. gpio17 is brought out to pin P1-11. Pin P1-17 is the 3V3 rail (NOT a gpio). 

There may be other issues but I will only mention the one which is immediately apparent. The schematic does not match the wiring. I can see no evidence that you are feeding any signal into the ADC's input channels. That means they will all be floating and will return random values. For testing tie the inputs to ground or Vcc to get a fixed reading of 0 or 1023. By the way if you choose to subsequently use 5V as Vcc make sure you use a voltage divider to drop the ADC output line (MISO) to a Pi safe 3V3. 

For current draw I doubt you'll find anything more official than $URL$ On the voltage side the only official comment made will be use the USB specs of 4.75V to 5.25V. However if you look on the official site at $URL$ you will see that as far as damage to the Pi is concerned approaching 6V is the real danger. 

Almost certainly. Are they unipolar motors? Most of the hobby steppers I've seen come with driver boards containing a variant of the ULN2XXX. Here a unipolar motor is been driven by a ULN2003A. The inputs are four Pi gpios. You'd need 8 for two such motors. The software is trivial. The steppers should have timing diagrams to show the order to pulse the coils. 

In contrast if I bit bang I2C I can use repeated starts without problem. The following is the same as above but using bit bang (see bi2cz for details). 

max_usb_current is a boolean. It is on (1) or off (0). If set it means let the maximum USB current flow. 

From memory you just create another class and instantiate with either the same GPIO (if for some reason you want to read a single encoder twice) or from the GPIO connected to the new encoder. Below I show an example (I have added a different callback2, you could probably change the code to use the same for both if you wanted to). 

There will be the normal voltage regulation, i.e. 5V will be unregulated but 3V3, 2V2, 1V8 will be regulated. As far as I'm aware all you lose is the protection of the 1 or 2 amp polyfuse fitted at the microUSB (depending on Pi model). 

The code as written is checking to see if /dev/tty001 can be opened. I'm not sure if that relates to serial activity. Do you close that serial connection later in the loop? If not the script will open thousands of files and then die through a lack of resources (no more file descriptors). I suggest the code is rewritten as a function, e.g. 

You need to be able to ping the Pi from the computer you want to ssh from. The actual connection does not need to be an ethernet cable. Wireless, bluetooth, serial, router, modem, switch, etc. will work as long as they can ping each other, i.e. they need to be networked. 

Do not use I2C. The standard Raspberry Pi Linux I2C driver can only act as a master device. It can not deal with unsolicited I2C messages. Use the serial link instead. On the Pi end that is /dev/ttyAMA0. The Pi's gpios are 3.3V so use a voltage divider on the Arduino TX/Pi RX line if you are using a 5V Arduino. 

You will to need to measure the voltage yourself. No one can guarantee the modules you receive will be as illustrated or the same as theirs. If you power the receiver from 5V or more it is safest to use a voltage divider between data out and the receive GPIO. The transmitter side is irrelevant. The data in pin on the module is an input from the Pi, not an output. You can connect the transmitter data in pin to a GPIO regardless of whether you use 3V3 or 5V power. 

You may have an old version of wiringPi. Could you edit your post and add the result of the following command. 

I suggest a cable such as this Micro USB Host Cable Male to USB Female OTG Adapter. Plug a wifi dongle in the end and you can access a wifi network. 

To prevent false alarms you need to make sure all inputs are pulled low or high (which way depends on the alarm situation, active high pull low and vice versa). If you have pulls enabled and you still get false alarms you need stronger pulls. Long wires act as aerials and can induce signals. If you do have long wires you could consider using twisted pair to provide some shielding. 

I think you will have to re-image the SD card. You seem to have serious corruption. Any idea what caused the problem? 

As long as you are not using NOOBS you should just be able to edit cmdline.txt on a Windows PC (it is on the partition visible to Windows). The single line contents of mine is 

It's always worth double checking the connections if a circuit doesn't work. Remember that you also need to connect a Pi ground to an external device you want to control from a Pi GPIO. WIthout the ground there will be no return path for the control signal. 

If you can physically fit the board over the first 26 pins on the expansion header it should be fine. Early Pis only had 26 pins. See $URL$ for a diagram. Pin 1 is nearest the end of the board with the SD card slot. 

It's probably best to give your wired Ethernet link an address on a separate subnet. On your Ubuntu machine 

NOTE: The order of the above is important as raspi-config will incorrectly set . You can then use minicom or whatever. I used minicom -D /dev/serial0 

I'm going to guess you mean one of the LEDs. The (green) activity LED can be written. On early model Pis it is connected to gpio16 and is active low (i.e. writing 0 switches it on, 1 switches it off). On the A+/B+/Pi2/compute modules it is connected to gpio47 and is active high. It is also possible to control the other LEDs but that is a bit more advanced and requires a software download. Google may find that software. 

Your code to calculate the old size looks dodgy to me. Are you sure it's not just that line failing. In C introduces a multi-line comment, what does it do in perl. In C I use the following invocation to change the pipe size. I have seen no evidence that it doesn't work. 

The base image is sized so that it will take as little as possible of the SD card space as practical. That's probably 4GB for Raspbian (full). Many people will use larger capacity cards. Unless the file system is expanded all the extra space provided by larger capacity cards will be wasted. Use the command to see the SD card utilisation before and after file system expansion. 

You are not doing anything wrong. The activity LED should flash 3 or 4 times just before power off. It is then safe to remove the power. I typically shut-down, go away for a few minutes, and then yank the power cord out. 

To drive a DC motor you need a motor driver board. The Pi's GPIO can only supply a few milliamps (say 20) at 3.3V which will not drive a motor. Look up L298N or L9110S based motor driver boards on eBay for examples. Such boards typically drive two motors. I'd suggest the L9110S if your motors are small as it is simpler to wire and understand. You also need (probably) two light/dark sensors to track the line (assuming a black line on a white background or similar contrasting scheme). If the sensors output 3V3 and are digital you could connect them direct to the Pi. If they output 5V you would need to drop the output to a Pi GPIO safe 3V3 (typically using a pair of resistors to form a voltage divider). If they output an analogue voltage you would additionally need to buy an ADC such as the MCP3008 to convert the analogue output to a digital signal. You will also need to buy jumper wires etc. to connect all the components. 

Not sure what you are doing wrong. For comparison the following works. gpioReg is a uint32_t pointer to the base of the gpio peripheral. 

It should have an option to disable serial boot messages and getty under Advanced -> Serial. You may need to reboot for that to take affect. Alternatively disable the service if running with systemd. 

As long as the analog voltage is between 0V and 3.3V you won't damage anything. The gpis will be damaged by voltages less than zero or greater than 3.3V. The severity of the damage will depend on the current flow and you may slow the damage by limiting the current with a large resistor (say >5 kohm). See $URL$ 

As the comment says it is not possible to give a complete list. However Raspbian is based on Debian. Debian has an extensive package list which you can search at Debian packages. If the package is in Debian it is likely to be in Raspbian. Use the following command to update the local copy of the list of packages available in Raspbian. 

Remember that each GPIO will need a pull-up to 3V3 for the bus to work. For reference the Pi uses 1k8 resistors. Each additional bus will be identified by the next available number. You will be able to use all the standard commands on the bus (i2cdetect, SMBus calls etc.). 

It looks like the first is the SMBus read byte data command and the second is the SMBus write byte data command. In pigpio terms i2c_read_byte_data and i2c_write_byte_data.