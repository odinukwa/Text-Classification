Gameplay Design Technically, it depends on the style of gameplay you are designing. In some game genres, it is almost explicitly expected to have certain "save types". For instance, in online casual flash adventure/RPG games, you will often save every tiny change into a cookie so if the player accidentally (or intentionally) closes the browser, the game state persists. Another common alternative is frequent auto-saves that will be triggered by certain events such as you win/lose a battle or when the player returns to town. In MMORPG (not what you're doing specifically), it is expected that all the characters' data is saved immediately with every change. In casual platformers and shooters, you don't particularly need to save but it's expected that you let the player "unlock" content such as stages / worlds and achievements. In some oldskul games, you'd let the player save when they want to. This is a feature that lends itself well to long "serious" games that require a substantial time investment like more classical RPG, Adventure, FPS and RTS games. Adding a quick save & quick load option too and possibly an auto-save in addition to that. In roguelikes, you are expected to save at least when the player quits the game if not all the time but in this case, saving all the time is not a gameplay feature as much as it's a UX one in case of crashing. The gameplay feature is surprisingly the lack of a load button which boosts adrenalin in close call situations. This is a good example since having only one chance to do something can be considered a gameplay feature or a great annoyance depending on the person you ask and the gameplay context like a challenging rare boss fight or a bonus stage (where you can't save or load the game). If your game is casual, as in you're not going to limit saves / lives for the sake of additional difficulty or to intensify suspense, then saving all the time is a virtue; that is assuming it doesn't hurt performance. Performance You don't have to heavily compensate on performance if you save data asynchronously. You request the disk (or http server) to write some data while you continue running the game. If the game has some kind of "game world" structure like cities -> stores, mazes -> levels -> rooms then you can get away with saving whenever the player enters or leaves a zone. Just remember that when you save asynchronously you still want to make sure the save went through, especially if the play decided to save the game. ;) If for some reason (disk space | online connection issue), you are unable to save, you may wanna notify the player the connection was lost or whatever is relevant in that case. Also it is important to note you don't have to store everything in one file or one DB record. You can save information about the character incrementally. For example, if the character travels across your game worlds and visits many zones, you may want to keep track of visited zones. You don't have to store all that in one file. You can "touch" (create a tiny possibly empty file) inside a designated directory or add a row in a database. You don't have to write all the progress related data at once. The same thing with items, you can add or modify it on the fly with a local sqlite DB, or a designated file folder with one file for equipment, armor, weapons, etc or even one tiny file per item. Obviously, the more complicated it is, the harder it is to maintain so keep it simple. 

Answer to actual question (Does a game loop need to be in a separate thread): The reason people often recommend using a separate thread is because they don't want heavy processing to interfere with UI interactivity. You are the only one who can tell if a separate thread is needed for your game. It entirely depends on the engine and framework if the main game loop in your present design may interfere with the UI's response time. Thought you generally assume it won't (in small projects) unless you have a reason to think otherwise. Another reason to keep code in seperate threads is to keep code modular and simple. Having two unrelated pieces of code mixed together can often cause code to become less readable and maintainable in the long run. Does a game loop need to run on it's own separate thread? Possibly. If there is a problem with response time or code and you need multiple UI items to respond regardless of heavy processing or you simply wish to break the code into specific tasks that occur simultaneously for design reasons then go with it. However, it is considered an advanced programming practice. A simple but perhaps not a great example to illustrate is a two player game. You may want to run two instances of a class that handles user input and converts to state changes in player character instance. Some frameworks encourage/require you to utilize and event/interrupt based system like ActionScript3.0 does. In those case the loop code will normally go to the event or something similar that occurs 20 - 60 or 120 times per second. 

By what grounds do you feel it would be resource intensive? There are plenty of RPG developed for AS3 and battle mechanics are not something you are limited to programming in any certain language. They are a collection of conditions and logic that could be expressed in any language. MapleStory, any MMO that is not extremely heavy on 3d graphics that would require C++ to optimize performance could probably be implemented. The only limitation would be server capacity hardware wise. If you have a lot of clients, you may need several powerful servers to handle the load well. If you are interested in html5 do not waste time making predictions about it's future and start making a game now. There is no tangible limit to the things you can achieve with nearly any of the popular languages that are available today aside from some issues with performance. The main variable is the game developer. 

You need to set the angle to be the derivative of motion or in lament terms, the angle needs to be between the previous position and the current position. Specifically, store the previous position , somewhere. The on the next frame where you already have calcualted the new position , , you calculate the angle between and and use that for the projectile. I don't understand the mechanism you are using but it appears to rely on alone which is bad. The angle should be determined by & and relying on the current & and the previous ones. 

One of the many advantages of ActionScript 3.0 and Flash is that the content your create can be viewed on any device with little to no work (on porting) needed from the developers. To see your game on mobile devices, follow the instructions and if you get stuck on a certain step, please feel welcome to ask. Learning a whole new framework just to do what Flash is designed to do in another framework is wasteful at best. If you want to learn a new framework cause you wish to expand your horizons, that is not a question covered in the Q&A site. $URL$ Taken from FlashDevelop (The instructions are general): AIR for Android instructions 

First, what are our goals? We want a lot of people to use the engine as effectively and as quickly as possible to prototype and make full blown games. 

This is based on the original BFS code from wikipedia. To get the neighbors, simply look above, beloow and to the left and right of and you'll get all neighboring tiles, represented each by in the algorithm. 

The function you chose is not likely to be suitable for your purpose. First, if you go this route a failed random condition should result in a delay before the next time you roll the dice. Also, it is unlikely that keeping the spawn timer within a constant range good for your goal. Let be a difficulty threshold you think is high. We use that later to decide when to slow down the pace at which the game gets harder. Let be the amount of monsters you want coming in every minute (or round). Let be the rate in which difficulty increases (for now it'll be ). Let's say you start with . Now the player killed monsters so you can increase rate by and the new . How to implement a condition that will generate monsters every minute: Set spawn timer to a number between to round-timerate0.25` chance that no monster is spawned when the timer reaches 0 and the time is randomized again. If ever reaches you need to slow down. Now instead of increasing by , you could increase it by . That way the player won't be destroyed instantly in the harder setting. You can reset to be around 80% of the at which the player lost the game. If you wish to randomize the strength of the monster be cautious about the timer. For instance, if you decide that (determined by monsters killed so far) will be used to determine the max strength of a monster that could spawn, you can do something like this: . Then randomize a or between to and multiply the result by itself. 

If we randomize a direction, either or and a value for time than we can place a platform in that direction in the correct position. let: 

29/09/2012 - 23:20 I created a git Repo here: $URL$ You are welcome to download the source files as a zip from there. It also includes a demo you can compile using FlashDevelop. To use the demo, open the project in Flash Develop and click 'Test Project'. While running the demo, click the LMB to randomize a new Bezier curve and a new Circle. Good luck! The zip link is hard to see - just use Ctrl + F and type zip. This source represents a couple of weeks of reasearch and programming, I hope you enjoy it. 

Create new helper list Add each 'live' object to that new list as you iterate over it. kill the old list Have the old list's pointer, point to the new list. 

If you are using DFS starting from the top, all unvisited nodes should drop. The top should be an invisible node connected to all top bubbles (in the top row). One thing worth noting, is that unlike the current DFS which is checking for color equality, the functionality you should use for deciding which bubbles to drop because they are hanging in the air should ignore color and simply be content with bubbles being accessible from the top. 

Answer: You can use Beziers here to create a smooth continuous curve ... first randomize a continuous list of points: 

Build a 3d uniform grid or an Octree (depending on data distribution) of Edge arrays around the scene. Add each edge to the appropriate slot (based on the edge's center) in the grid / Octree. If the edge's center is away from the inner border of the grid, compare that edge with neighboring edges that are on the other side of that inner border. 

Implementing threads, like any programming task is time consuming. More so when it is dealt with for the first time as everything becomes simpler with experience. Threads are not a valuable improvement for a simple 2d-game. Such a game should preform perfectly well on a single thread: 

I don't think there is any reason for an entity to be a class in the first place. It could be represented by an index number unique to that entity. Components can then have a member named entity_id with that index. There is no need for any inheritance or classes to represent entities. Components could and would possibly use classes and inheritance. Using classes an inheritance is wasteful if it's not done to prevent code duplication or substantially improve your productivity in some manner. I would recommend using only what your project needs when it is needed as it is absolutely disastrous* to use a technique when it is not useful or avoid using one that is needed. *Detrimental to productivity and if you're an indie with a very limited budget I would consider it to be a disaster. 

If there are very few states an entity can be in (dead or alive, there or gone), then it is likely that you can define a simple Enum to contain the state of the entity. Then you create a that returns the correct string description for each state. If the states are more complex then you may need to use a more sophisticated funtion. 

If you let the game continue as normal, it will probably highly increase the chances that the player will lose the game. This will cause frustration. If you pause the game automatically it will possibly disrupt the player. 

Now you need to check how soon you will reach the desired angle and begin to slow down. Generally, if you are moving as velocity and need to stop smoothly after a distance of then you are going to travel for time unit, then you need to slow down at a rate of . You can use that to callbrate your stopping motion. is . When the delta is small enough, you can have it beging to slow down instead of speeding up. 

Use Dijkstra to find the shortest path between them. If the path does not touch the trail, their relation to the trail isn't well defined or their on the same side (for now it outputs they are on the same side). Assuming the path does go through the path, we pick one of the edges it went through. Each edge belongs to two faces, each of these faces has precisely one vertex that is not on the edge trail. we now have two vertices that are supposed to be on different sides of the trail. Dijkstra from each of the trail side vertices to the vertices in question. If the shorter path to both vertices in question is from the same side then maybe they are on the same side. If it each vertex prefers a different side then maybe they are not. 

I think you need to figure out why this is happening. Can you reproduce the behavior by creating a app and letting it run in the background? Do other games respond the same way exactly? If not then why is your game slowing down so dramatically is the question and it's a debug question. 

You need a square that moves around in an empty area. Add a simple (preferably existing collision system) and some obstacles Add moving destroyable obstacles (with hp) Make the square attack whatever is in-front of it when the player hits "A". Make a moving obstacle that attacks back. Put a tiny image on top of the square. Add a sound when the player hit successfully. 

To get serious legal advice contact a lawyer. Games exist where under-aged characters perform violent acts: Bully I can't say if it's ethical (your game idea). I think it isn't because it gives the impression that kids are allowed to use firearms against other kids. We all know that only adults are allowed to play dress-up, wear uniform and commit mass murder of complete strangers and only if it's sanctioned by their government. So I think your game idea is possibly not legal for both good reasons and hypocritical reasons. On second thought, Kickass is all about kids killing others and Battle Royal is kids killing kids so maybe.. You could pull it off in game land somehow but I doubt any publisher will agree to help with it. 

tl;dr: Learning how to make an engine is often as useful to game making as learning to build your own computer and operating system from scratch. If you not an expert in the field, you probably do not want to make an engine. Make a game instead, the engine part already exists. Later on if none of the engines you have access to meet the criteria for your game design, you could focus on building that specific aspect and hell it might be useful to others as well since you are creating something new and not rehashing a less robust version of something that people already invested thousands of hours in. Long version: If you really want to learn how to write an engine, don't look at an existing engine yet. Learn instead of the parts (algorithms) that make an engine, be it rendering, physics or path finding etc. Once you gain a deep understanding of a specific aspect, you may want to check out source. You normally do not wish to learn directly from source unless there is no superior alternative. Even experienced programmers normally would not look at the source of an entire engine to learn from it (if they can help it), they would most likely inspect a specific part of it or tweak a certain part of it. Trying to look at the source for pure learning purpose would not expose the procedure and thought process behind the engine code; That would be like tearing a building apart ti pieces in an attempt to see its insides in order to learn how to build one. While I agree with Josh's answer, I will take it another step further, you do not even learn the "How" in many senses (unless you are familiar with the field); for instance, what methodology was used by the programming team? What principles did they rely on to implement working code? What tools and techniques did they use for debugging? All these questions are sometimes more important than the code itself (for learning purposes). If you do wish to learn from source, look for source that is well documented and has a strong community built around it. Reading (engine) code, even if you've written it yourself, is often confusing.