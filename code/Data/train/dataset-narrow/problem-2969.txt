The big disadvantage seems to be that you're re-enforcing their (or maybe your own) preconceptions about barriers to entry, and taking them further from the 'normal' programming environment. Yes, you can twist a spreadsheet to demonstrate some topics, but the biggest misconception you will teach by starting like this is 'everything executes in parallel'. Having moved from coding software to verilog (hardware) I can vouch for this being a major mindset change. You're also teaching a non-flat code layout, have zero scope for sensible comments, and an unusual syntax. A better approach is probably to find an online simulator (i.e. a web browser, which everyone has or can access in many countries). These will handle the code storage (in the browser or in the cloud) and avoids any assumptions about how familiar they are with specific types of software. I really think you're better identifying this as a new journey, and not expecting your cohort to have anything installed on their machines. Having supported a public drop-in class, I'd also opt for an environment which allows both 'block' coding or text based views like the micro:bit javascript blocks editor. This removes the barrier of needing to remember syntax and seems just as relevant with older introductory level students as very young ones. Once you have introduced the fundamentals (keeping the first contact easy and low stress), you can move to using text based entry. Returning to the micro:bit example, I think having a physical device is less important with an older cohort (particularly if they are in your class by choice). It gives you scope to use a demo, and show some context about how close to invisible/trivial computers are (something else that your spreadsheet doesn't expose). To summarise my objections to the proposed approach: 

Science classes would be my immediate thought, where data can be collected to support experimentation. The most obvious metrics being weather, sunlight, etc. for biology type things (not my subject, so I'm a bit weak on examples). In physics, accurate timing and acceleration are easy to sample, so that can also be linked to experiments. In design, you might collect and analyse strain data or measure force distribution. 

It may be a hassle (is this an argument for better editors), but the time spent in keeping the code tidy usually pays off by both avoiding and finding bugs faster. Its a different (but related) question to 'would you prefer your code to be really fancy and efficient, or to work properly'? I think this latter problem is maybe easier to explain because it's more tangible. 

Maybe (given the opportunity) the best way to address this question is to have your students talk to someone actually working in the field right now. You probably don't want to give the message to your students that it's been a while since you were working on what they regard as real projects (and I venture that many teachers don't have time to work on projects in their spare time). So maybe you don't think you have any particularly interesting personal examples to share. In that case ask them about what tech they find cool and exciting, then explore what that might lead to. There are two threads that I refer to when I'm talking about careers: Technology changes This is a complex thing, meaning that there are both new things to learn (smartphones now outperform the supercomputers of my youth), and that there will always be new technology along in a few years. The hook can either be 'how does it work', or 'what can we do with this', and the appeal will be different for everyone. There is a lot of detail Despite the apparent rapid changes, this isn't necessarily a field where skills become obsolete (assuming you view languages as a tool). There are also many different levels to work at in even a niche of the field. If you consider products, look at the whole supply chain. If you consider applications, look at science/industry/entertainment/health. Then don't forget development/support/training/marketing - technical skills are relevant to all of these roles. If you want a modern example to break down into it's components, look at today's high-end VR. GPU hardware, High-bandwidth data to displays, 3d-rendering, position aware audio, sub-mm resolution position tracking, nausea avoidance, let alone all of the actual applications of the technology and generating content. Something that a few years ago, not many people though would be possible. 

Java is close enough to C that transition to/from it is manageable, while being safer (no pointers) for people starting out. I also prefer a strongly typed language. I will offer the following anecdote: This year I gave an assignment to my students to write a simple program in assembly language just to have an awareness and appreciation of the differences between low and high level languages. (Print out a number being incremented by 1 in a loop starting from 1 and going to 10.) The code for this in assembly was over 130 lines of code, while the corresponding Java code was a few lines. This exercise was enough! to give them a deeper understanding of how a CPU executes code -- programming. They liked learning about how registers and memory locations are used by CPUs. They came away with an understanding that a variable is really a named location in memory. It should be noted that in some curricula students are expected to know the definition of high- and low- level languages with clear demarcation . 

There are lots of great answers here. I am adding this answer to preserve it outside of a comment. If you are new and learning the course material yourself try to apply more structure to the content to assist yourself and your students. A good tool for this is to develop scaffolding for your exercises that your students work within. This will help contain the material and limit the types of issues that you will need to prepare for. I have seen that one of the biggest challenges for new CS teachers is "debugging" student code. This can be time intensive and distracting. Scaffolding can help immensely in this area. Another technique is working backward on an exercise. Provide answers that are flawed in some manner and have them correct them. This kind of backtracking can avoid the many paths students can take if they were to move forward through some material. 

On a different note, it is much more effective to use simulated robot environments when first introducing programming to students. The addition of the H/W elements in physical robots (along with more complicated software environments) make the combination more difficult. This would only be exacerbated with a short time line. You could even replicate the physical nature of the robots in code before they work directly with them - giving them a sort of preview of the issues they will encounter. Alternatively there are more user friendly robot development kits available today that you can look into. 

I have also followed a similar path in learning. I am also often asked where to start. My response has been to start with a language like Java. This is for very practical reasons from an educator's as well as a student's perspective. 

Don't forget to mention what information is not available when they choose between certain looping constructs: foreach loops lose position data (index, relative locations (i and i-1, etc) for(int i;;) loops lose the index variable (i) upon completion of the for loop foreach loops are designed to work with collections & iterators. See Teaching the humble for loop Also from a AP CS A exam perspective, the trap is usually that you don't have an index value. The advice I give to the students taking this exam is to avoid the foreach when writing exams because in the majority of cases they will require the index. 

In the context of an undergraduate course on microprocessors and architecture, I'm looking at how to introduce a VGA display peripheral. This is with the specific goal that they implement the peripheral in verilog on an FPGA (they're given a microprocessor and the rest of the system). It's VGA because of the current hardware used for the supporting labs - and I kind of like the example peripheral because it has a useful set of physical layer constraints. An LCD interface might seem like a more relevant, but then we're looking at a SPI peripheral or similar, and that defeats the object of the module. The VGA physical layer is clearly an evolution of analogue TV and CRT technology, so it's quite tempting to start the description of how pixels need to map onto the screen by talking about the CRT and how an electron beam scans across the phosphor, line by line. My question: how relevant is this analogy going to be to current school leavers, and will it work as a starting point for describing horizontal and vertical sync? I've thought of trying to update the module by describing how an LCD panel would de-serialise the VGA signal, or switch to another output interface altogether, but it seems that the example I have at the moment might be worth keeping alive for a few years longer. 

Although the 2nd reference may be independent, it's not easy to tell. Are there any other studies I can refer to? Looking particularly at benefits in engagement or diversity. Although the first reference does indicate that teachers also found that using (or being trained to use) the micro:bit felt more confident, I intended to ask specifically about student engagement. 

You can also have copies of the same book - with different notes in the margins, or different pages missing. Today, files are maybe in an anonymous data centre, or on a device, or on removable storage. I think it's useful to go to this level first before introducing the idea that we have a virtual structure within any one drive, because this helps to explain why it starts to be useful to have a structure. When you only own 5 or 10 books, you can easily find them all. Once it's all your photos, and all the music you ever streamed - then it's not so easy. At this point, you can introduce the idea of arbitrary named containers (which are nested). Explain what they're for and how they are important, then show the real-life example on the actual hardware you're using (and explain why this is abstracted from normal non-expert users). Note: It also occurs to me that spending too much time re-enforcing legacy storage concepts is not helpful, so resorting to the command line as a primary teaching tool for this might not be good. Teach enough that if they are in an environment where the command line is important, the concepts come naturally, but don't pass on your own legacy baggage. 

The purpose of indentation (to express the intended control flow) and the value are subtly different things. For a 5 line script, there is really not much value in indentation or comments - the code is a throw-away. The real value in cleanly presented code (of which indentation is only a part) comes when a person is reading the code some time after it was written. Maybe it's something you've posted on SO as part of a question, maybe you're asking for help in improving the code from someone else (or explaining how good your code is). Maybe even worse your code is broken and you need to fix it in a hurry. Well-presented code: 

The ones who finish early, are also the trouble makers. I suppose that is somehow related. Once they are out, I can actually focus on guiding the ones who need my help. These early finishes become a constant source of interruption and that energy can be used on the slow folks. it acts an incentive. Knowing they have an opportunity to leave early, some students tend to put in a little extra effort learning the programs they need. That allure of leaving early can be great motivator. The slow kids also seem to be encouraged by this because they don't have to bear the gloating of the fast finishers for the next 2 and half hours. 

I haven't taught about analog television but thanks to my gaming related experience (both as a gamer and game development trainer) I know that the topic of horizontal and vertical sync is very important for understanding one of the more core things of computer science, the display. Further, I am all about the cutting edge stuff. Yet, when it comes to getting the concepts of display, I am all for going to the roots, and CRT is by far the easiest way to explain these things. So, to answer your question, yes, the analogy is still relevant. And going further, It will and continue to be the starting point for studying this display stuff. Eventually, you will have to upgrade to modern screen but CRT is definitely the go point on the table. 

We don't have Scheme in our entire country (here in India) but that honour goes to C programming language. For the purpose of my answer, substituting C for Scheme, I keep asking myself, why bother with C. After that 1 semester of C, I have never used C professionally anywhere. In fact, once I step out of educational purposes, C becomes useless. That begs the question, after almost 25 years, why are they still teaching C? Why not something else? I think, why they are still teaching C (in my country) and Scheme (in yours) is probably because it is ubiquitous. there are any number of books written on C. More importantly, the faculties who teach them ( I think most faculties change their jobs once in 60 years) can teach the same thing for the rest of their lives, use the same lab manual, and use the same code, and ask the same questions, use the same evaluations. From a strictly logistical point of view, it makes sense to teach C 30 years ago, and 30 years hence. Can you image the mess, if every five years, the universities change their syllabus? Thats a logistical nightmare (not to forget other challenges) no one wants to deal with. For instance, one university could decide to go with C sharp, and another with Java. That creates all kind of problems. However, if all universities agree (which is how things are now) to simply keep using Scheme (in your case) and C (in my case), life becomes simple. Further, the foundation that you get by learning an ancient language is that, everything that came after it, be default, would be easier. I learnt to ride a bike (as in motorcycle, not bicycle) in my dads old bike which was, well not that good. However, because I drove the tough one, all of today's bikes seem like child's play. Although I don't use C itself, anytime I learn a new language, I unconsciously compare it to C, and learn from that. Update 1 : To add some context, I have been part of the IT industry for 11 years, and 5 of them as a developer/trainer/educator who travels widely. I am sure C is used somewhere, I haven't seen one single enterprise usage of C and I have worked for startups, small companies (less than 100 employees) and for MNCs (more than 2000 employees) and never ever has any division, anywhere talked about C, used C or implemented C. Again, no disrespect to C (or its legion of fans) but I request that my opinion be taken in this context.