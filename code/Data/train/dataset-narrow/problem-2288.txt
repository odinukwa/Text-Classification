No, simple polygons are not any easier than disjoint segments. Given any n disjoint segments, there is a simple polygon with O(n) edges that includes all of the input segments as sides of the polygon. Then, any BSP tree for the polygon forms a BSP tree for the segments. One way to do construct a polygon for a set of segments would be to triangulate the planar straight line graph formed by the input segments, and then pick a spanning tree of the triangulation, which is necessarily non-crossing. Then form a simple polygon by walking around an Euler tour of the spanning tree, using each of the input segments the first time the Euler tour traverses that edge and a parallel segment near it the second time the tour traverses it. 

Although it is not really the reason they were originally studied, finite automata and the regular languages they recognize are tractable enough that they have been used as building blocks for more complicated mathematical theories. In this context see particularly automatic groups (groups in which the elements can be represented by strings in a regular language and in which the products of elements by group generators can be computed by finite state transducers) and sofic subshifts (subshifts of a shift space whose forbidden words form a regular language). So there are reasons to study them even if you are interested in pure mathematics rather than computer science. Finite automata have also been used in the design of algorithms for other kinds of objects. For instance, an algorithm of Culik for testing whether a one-dimensional cellular automaton is reversible involves constructing, modifying, and testing the properties of certain NFAs. And a 1986 FOCS paper by Natarajan showed how to solve a certain problem in the design of mechanical assembly lines by reducing it to a computation about finite automata. 

The disjoint union of $n$ copies of $K_5$ (or $K_{3,3}$) is a minimal forbidden minor for the graphs of genus $n-1$; the same is true for a graph in which some of these copies share a single vertex, so that the blocks of the graph are $K_5$ or $K_{3,3}$. This follows from results in J. Battle, F. Harary, Y. Kodama and J.W.T. Youngs, "Additivity of the genus of a graph", Bull. Amer. Math. Soc. 68 (1962) 565–568, and is already enough to show that there are at least exponentially many forbidden minors. Bojan Mohar, "An obstruction to embedding graphs in surfaces", Discrete Math. 78 (1989) 135–142, lists the graph formed from $K_8$ by removing a 4-cycle as having genus 2. Since $K_7$ is toroidal, this means that either $K_8\setminus C_4$ or one of its spanning subgraphs is an obstruction to torus embedding, and that graphs that have $n$ copies of this graph as their blocks have genus $2n$. Mohar also shows that the graph formed from a $(2k+2)$-cycle by connecting vertex 0 to all the even vertices and vertex 1 to all the odd vertices has "relative genus" at least $\lceil k/2\rceil$. The graph is planar, but I think relative genus means that the cycle has to be a face; or you could add another vertex to the graph, connected to all of the cycle vertices, to effectively force it to be a face. Maybe this is closer to the sort of thing you want. But I don't think he shows that these graphs are minimal forbidden minors. 

Filter first — find sequences of $4\times 52$ symbols from the alphabet $abcd$ with 52 copies of each letter and no four consecutive copies of the same letter — then randomly shuffle each deck and use your preselected filter to select the order to interleave the decks. It's not hard to set up a recurrence in four variables for the number of valid sequences with $x_a$ $a$'s, $x_b$ $b$'s, etc. Once you've done that you can build your sequence of $abcd$ letters one letter at a time — once you've picked some letters, the next letter should be chosen with probability proportional to the number of valid sequences of the remaining letters that start with that letter. In this way, you'll get exactly a uniform distribution on all permutations. But this approach takes something like $52^4$ time to compute the recurrence values; probably it's possible to do some combinatorics and find a way to simplify this part of the computation. 

This should allow you to define your rectangular drawing top down. Find a canonical ordering of the dual graph, and make side-by-side rectangles for the first two dual vertices in the canonical ordering (corresponding to two adjacent faces in your graph). Then, add rectangles one by one in the given ordering, below these first two rectangles. For each successive rectangle r, corresponding to a dual vertex v, choose the top vertices on the left and right sides of r to be points on the rectangles corresponding to the endpoints of the contiguous path of neighbors of v from the canonical ordering. The invariant that makes this work, at each step, is that the boundary cycle of the canonical ordering is exactly the same as the sequence of rectangles that you would see if you stood underneath your drawing and looked upwards. The circular map should be exactly the same, just starting at the outside and working inwards. As for the other questions at the end of your post: is this interesting? I don't know. There's some related work in the graph drawing community on representing maps by regions with rectilinear boundaries; the phrase to search for is "rectilinear cartogram". You'd have to show some concrete advantage of your method over previous rectilinear cartogram construction methods such as the one in $URL$ — but suggesting ways to achieve this is probably beyond the scope of this exchange. 

Solution 1: Find the $\Theta(n^2)$ perpendicular bisectors between pairs of points, and construct the arrangement of these lines. The arrangement has $\Theta(n^4)$ cells, within which the sorted order is constant. So build a point location data structure for the arrangement, and decorate each cell with the sorted order that is to be returned for points within that cell. The sorted orders between adjacent cells differ only in a single transposition, so you can use a persistent data structure to allow the representations of these sorted orders to share space. Total space is $O(n^4)$ and query time is $O(\log n)$. Solution 2: Choose a random sample of $\Theta(n)$ of these same perpendicular bisectors, construct their arrangement, and partition each arrangement cell by vertical line segments through each crossing of two sampled lines. The resulting partition has $\Theta(n^2)$ cells, each of which with high probability is crossed by $O(n)$ unsampled bisectors. Decorate each cell of the partition by a valid sorted ordering of the points as viewed from some x within the cell. Total space is $O(n^3)$. Now, to do a query, locate the query point in the partition, look up the ordering stored with the partition cell, and use the Cartesian tree comparison sorting algorithm of Levcopoulos & Petersson (1989) starting with this stored ordering. The time for this step is proportional to $\sum_i O(1+\log k_i)$ where $k_i$ is the number of points that are out-of-order with point $y_i$. But $\sum k_i$ is $O(n)$ (each unsampled bisector causes at most one out-of-order pair of points), so the query time $\sum_i O(1+\log k_i)$ is also $O(n)$. 

I don't know about whether this specific problem has been studied before but I can point you to a general class of problems that include it and that have been studied: This looks like an LP-type problem (or perhaps even a low-dimensional linear program although I am not quite seeing how to coordinatize it so that works). If so it can be solved by a linear-time combinatorial algorithm. To set this up as an LP-type problem, we need an objective function mapping sets of line segments to some totally ordered set of solution values. The obvious objective function to use here is the numerical value $l$ that you're trying to optimize (the length of the longest split segment), but I think that's not quite good enough. Instead you should use a lexicographic combination of $l$ with the coordinate vector of a line achieving value $l$. With this lexicographic combination, the problem automatically satisfies the monotonicity and locality properties of LP-type problems: adding another segment to an instance only makes its solution worse, and if a given line is the solution to two sets $A\subset B$ of segments, and adding a new segment $x$ to $A$ doesn't change the solution (because the line cuts $x$ in pieces shorter than $l$) then adding $x$ to $B$ also doesn't change the solution (because the same line cuts $x$ in the same way). So the main remaining question is whether this problem has bounded dimension, where the dimension of an LP-type problem is defined as the largest size of a minimal instance with a given solution value. So, in any problem of this type, is there a subset of a constant number of the line segments that has the same solution as the whole problem? I think the answer must be yes, because the optimal line must cross some three segments at points that are at distance $l$ from the ends of their segments (else it could be moved continuously to a better solution) and those three segments should determine the solution value. 

Such a cut exists if and only if the graph has an even number of spanning trees, which can be checked in polynomial time by using the matrix-tree theorem. See $URL$ 

It's not quadratic, but Alon Yuster and Zwick ("Finding and counting given length cycles", Algorithmica 1997) give an algorithm for finding triangles in time $O(m^{2\omega/(\omega+1)})$, where $\omega$ is the exponent for fast matrix multiplication. For 4-cycle-free graphs, plugging in $\omega<2.373$ and $m=O(n^{3/2})$ (else there is a $4$-cycle regardless of existence of $3$-cycles) gives time $O(n^{3\omega/(\omega+1)})=O(n^{2.111})$. 

The process of journal reviewing shakes out bugs. Conference reviewers tend not to look at papers with a fine-tooth comb; the program committee process gives them too many papers to review in too short a time to do that. The main things that one should get out of a conference review are whether there are obvious flaws (these are rare) and whether the results are interesting. A journal review should evaluate those things too, of course, but it also needs to check the details of the proofs to make sure that they all work and are clearly and correctly stated. If you are treating your journal reviewing tasks as if they were conference reviews, and only giving them a high-level interestingness check, you are doing it wrong, and depriving journal authors of a valuable service. If you are treating your conference reviews like journal reviews, spending the time to go over them carefully, and making sure that papers don't get accepted until all the details are correct, congratulations and thank you for doing such a good job, but I don't think that's the case for most STOC/FOCS/SODA program committee members. Secondarily, many conferences still have artificially small page limits, and the journal provides space to fill in the details. The preprint version does that, too, but doesn't provide any assurance that someone has checked it carefully. If I see a paper published five or more years ago in a conference, making claims that are not backed up by full and clearly-written detail in the proceedings, and with no journal version, I am likely to consider it untrustworthy. Is that the future you want for your research? 

It's not quite the same, but you may be interested in the 0-1 law for first order properties of graphs. A first order property is something you can describe by a logical formula with existential and universal quantifiers, in which the variables refer to vertices of a graph and there are two two-argument predicates: equality, and another predicate $\sim$ that tests whether two vertices are adjacent. For example, whether there is a universal vertex adjacent to all other vertices can be tested by the first-order formula $\exists v\forall w\,v\ne w\rightarrow v\sim w$. Then, for every first-order property, the fraction of all $n$-vertex graphs that satisfy the property, as $n\to\infty$, approaches either 0 or 1. More strongly, there exists an infinite graph, the Rado graph, such that this fraction approaches 0 or 1 exactly when the Rado graph does not or does have the same property, respectively. But when the fraction approaches 1, it still might not be the case that the property holds for all graphs, so this differs somewhat from what you're asking.