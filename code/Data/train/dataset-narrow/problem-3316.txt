As an expansion to Butters answer. The raspberry has build in pull-up and pull-down resistors. To activate this, in your case, use 

Yes you can do that. I use it to deploy a setup to multiple Pis, without have to reinstall an setup every Pi individually. When using I think I just swapped the and paths. So something like 

You'll have to check the voltage on the TXD and RDX lines. The Pi only allows upto 3.3V. Other than that you can just connect the TX on the Pi to the RX on the dictionary, and vise versa, and the connect the 2 grounds (GND). I don't think you can reprogram it though. But you might be able to see the boot process. Maybe even add words or something. Sound like a fun exercise. 

You don't need any additional hardware. The board uses active low optocoupler to switch on the relay. But since the Pi is 3.3V, when the Pi put a pin high (3.3V). But if the relay board is powered by 5v, this 3.3V is still 1.7V lower, and the optocoupler will (apparently) trigger. To fix this you can just remove the jumper that connects JD-VCC to VCC. Next connect 5V to the JD-VCC pin, and connect 3.3V to the VCC pin. If you look at the schematic on sainsmart you'll see that VCC is only used to power the led inside the optocoupler. While JD-VCC is used to activate the relay. Originally the jumper connected JD-VCC to VCC so both would be 5V. Another option would be to set the GPIO pins to INPUT when the relay needs to be turned off. This will prevent any current from flowing (where it did when you'd set it to 3.3V). To activate the relay, set the GPIO pin to OUTPUT and LOW Third option would be to add a resistor between the GPIO pin and the IN of the board. You'd have to find a suitable value that will disable the optocoupler when 1.7V is applied, but not too high that it won't work on 5V. 

Don't buy those crap receivers and transmitter. At least pick one that has a crystal. The ones you linked to just provide the modulation of the signal. You'll have to implement a protocol yourself. Better go with the NRF24L01. These chips do all the heavy lifting. The can both send and receive. Just push some data to the chip using SPI, and the chip will create a package and send it. The receiving chip listens for packages and converts the signal back into a your data. It also does error correction. You can even have it setup, so that if a packet is resend if the sender doesn't get an ACK from the receiver. There are some nice libraries for these chips for arduino. At least one of them is ported to Raspberry; $URL$ If you need more range, you can get these modules with an external antenna. Since they are on a higher frequency 2.4Ghz the range is in theory less than with 433Mhz. I am using these modules to transmit power-meter data. Currently my arduino is reading the data. But the plan is to connect it to my Pi, and create some nice graphs on it. Since my power-meter sensor runs on batteries I had to mess around a bit to turn off the auto-retransmit feature. PS. the internal temperature sensor on the atmega328 is not very accurate, and gets heated by the cpu itself. Just buy these cheap temperature and humidity sensors, while you are on eBay. 

Yes, you definitely can. A lot of people are doing this. Just note that some hubs don't work properly. E.g. because the power adapter doesn't provide steady enough voltage for the Pi to work properly. Also because some hub have power-feedback. To prevent this, first check the list of hubs, known to work with the pi. 

Yes. It's even cheaper that shared hosting. It will cost you more time to setup, and maintain though. But you might consider that a learning experience. HD-video might be pushing it a bit, but normal images and other static files won't be a problem. But your uplink speed at home might also be to low to do HD video. Just a wild guess; 100 requests per second will be fine. But it might even be 1000 of 10000 before things start to break down. 

The second type of led strips are a lot more expensive, but with those you can give all the leds a different color. The led strip you have now, you can only set the color of the entire strip. Also not that your strips probably require 12 volts, not 5. I would use some mosfets to switch the red, green, and blue leds on the trip. Also add some resistors between the pi and the base of the FETs. Maybe some pull-down resistors to make sure the leds are off when the Pi is off/booting-up. 

More info at $URL$ Or just ask me later, as I'm currently not near the pi of mine that uses gpio interrupts for triggering. 

The labeling is the same as on the left of the next chip in the strip. The red and black cable is for power. Where red is 5V, and black is ground. You can't us the 5v on the GPIO for power, as 5 meter would draw way to much current. Connect these two to a separate power supply. The other cable (blue green yellow and the other red) are for communication. This red one is connected to the same point as the black so that one goes to ground on the pi. yellow and green are connected together, you just pick one and connect it to MOSI. The blue one is for SCLK. Who wired this one up is totally bonkers. I would probably resolder those wires to prevent any wrong connections in the future. Using red for ground is just bad. PS I hope your spi-gpio pins are still working as you had them shorted together, in the way you described above. 

The RF-module doesn't require the UART pin. You can use any GPIO pin you like. So the library you are using (found at $URL$ can easily be modified. Just change line 14 in kaku.ccp to and recompile. 

In case you don't want to wait for shipping (without a pot, contrast will be off, and the display will not be readable at all) If you have some different value resistors, you can try some different combinations of 2 resistors, to form a voltage divider (a pot is basically a variable voltage divider). Try to find a combination where the contrast of the display is good enough to read. To make the process of guessing a bit easier you can create a pot by drawing a thick line with some pencil ($URL$ Connect ground to one end, and 3.3v to the other. Add a lead to the contrast pin and move it around the line, till the contrast is good. Next take you multimeter and measure the voltage at that point. Then calculate a resistor combination that will produce that voltage. 

So you should be able to connect it to the GPIO pins and send data to it. But you can't connect like a normal display. So you can't get the video card's output onto it. 

Web servers don't need a lot of horsepower. Mostly it's disk-access that limits a webserver. And more memory will be needed if it's supposed to handle a lot of requests simultaneously. 

remote.sh is very limited it what you can do with it, but I wouldn't be surprised if you could just add other option. for volume-up you could use 

So you want to read out the LED, and be able to simulate a button press? Safest way would be to use a light sensor to read the LED, and a relay to trigger the button press. (These units seem to be operated on 15V AC power $URL$ 

You'd need some transistors to control the battery power going to the motors. You need some diodes to protect the transistors. If you shut down an induction motor, the collapsing magnetic field will create a current spike into the other direction. These will do fine $URL$ Also, you say the motors are 3V, but the battery holder will provide 6V. To control the speed you could PWM the pins controlling the motor. Since those kinds of motors can use up-to 2A amps of current, I don't think your powerbank is powerful enough to run both the Pi and 2 motors. Unless you can find some way to limit the max current of the motors. Otherwise, too the power bank would not be able to provide enough power, and the voltage will probably drop, which will most likely crash the Pi. And maybe even damage the powerbank. PS cool rover you have there my fellow Dutchman.