Enumerator The first thing I notice here are the stacks. And the first thing that makes me think: recursion! You're not only worrying about keeping two stacks aligned, but you also have to keep track of how deep you are inside them. Taking advantage of the call stack to take care of that for you makes life a lot easier. So start with the signature: 

Now you get all the advantages of the rich functionality of , along with the guarantees provided by your original class. 

One alternative would be instead of providing a helper method to use inside , you provide an alternative version of that method. You'd probably need to tweak it, but a rough version might look like: 

(Logging would be left to interceptors as described previously.) Is it impossible that this class, or code consuming it, would have to change? No. But by calling it a rather than a and adhering to the SRP, I've made it more likely that a new requirement would be an extension of the class rather than a modification. By implementing an interface, I've made it more likely that if this class needs to be extended or swapped out, the consuming code won't need to be modified. By completely decoupling the validation implementation from this class, I've ensured that any change in validation rules will almost certainly not impact this class. And I believe that that's about as close as you should reasonably strive to get to ideally OCP-compliant code. 

I'm working on a page that shows groups of users. The following JavaScript function is used to show more details about a user (such as email and login) when you click on their name. But there's a twist: clicking on one of those pieces of information will highlight it to make it easier to copy. This is accomplished by adding an in-line onclick function to each span element containing the user info. 

The performance benefits vary depending on the browser's implementation of ECMAScript, but you can usually get a modest performance improvement by selecting the parent element first, then selecting only child elements of that parent element. This jsPerf test somewhat demonstrates the difference. In native JavaScript, this is done by selecting the parent element with , , or . You can then call a similar selector method on that element instead of on to limit your search to only child elements. Native 

Since these are constants, a common standard is to name the variables with all capital letters; you can do that if you find it helpful, but the important thing is to be internally consistent. I would take this concept (of capturing reusable strings in variables) a step farther for the element IDs of your daily deals, and throw them into an array of objects. 

Can the speed and/or accuracy of this algorithm be improved? Is it proper to use centered differences at interior points and one-sided differences at the boundaries? 

as you are creating as a copy of ; any change to changes as well. Also, you can iterate through your unique values in instead of checking if each element is in . Sorry I could not be of more help. Let me know if anything is unclear. 

This can be rewritten using a helper function (or alternatively a for-loop), which may look something like this: 

Since the sum changes with each iteration through your dictionary values of , I don't know of a way to pre-compute the right-side sums before-hand. This would be a little easier if you could use external modules. That said, you might see a slight speed-up if you use more comprehensions. For example, you can get via . Also, use (not ) to check zero equality and use (not ) to check . Also, you are iterating through all possible combinations. In the case of using and , you know that and . So you know that your lower bound is cut-off at 76. Those are 76 permutations that you do not need to use. You can include a statement at the lower bound since you are incrementing downward (), but I would instead use this lower bound as the starting point and iterate by incrementing upward as you may find some other way to restrict the sums in the upper limit. Lastly, the use of globals and non-descriptive variable names makes it hard to edit the code. For example, instead of , instead of , etc. Also, you can pass into . I personally prefer iterating over lists instead of dictionaries since you can use zip. I don't have a full solution for your problem, but it may help as a start. 

createForm() I don't think you need the array or its named elements at all; you're not using it for anything. To build the form controls, you can loop through the array instead of the array. 

avoiding global namespace pollution Since your logic (wisely) does not depend on global variable declarations, you can avoid polluting the global namespace by wrapping all your code in an immediately executing function expression (IEFE). 

It's also worth noting that using bitwise OR assignment you end up with a number rather than a Boolean; it'll be 0 or 1 in this case, which JavaScript nicely interprets as false or true, respectively. With that said, you could accomplish something visually similar by just breaking up your comparison into its components with line breaks. In your example code, I see no reason to have two different IF statements leading to ; the conditions could be combined like so: 

For some browsers, the performance impact is significant. For reference, here's a relevant JS perf test: $URL$ Avoiding Unnecessary DOM Queries You did a good job by caching (that is, saving to variables) most your query selections up front. This is much better than querying the DOM on the fly every time you want to access those elements. There's only one spot where it looks like you're querying the DOM unnecessarily, inside your function: 

Like your code, this is technically correct, but is less successful in capturing the structure of what's similar and different between the messages. So trying a more literal interpretation of the first statement, we can write: 

A note on OO One last thing, since I noticed a few other answers mentioning taking a more OO approach, I'm going to disagree. In my opinion one of the best ways to make sure you misunderstand OO is to apply it where it's not appropriate. Here your entire application is concerned with input/output to the console, the only real behaviour it has other than UI concerns is a single very simple calculation and a greater than check. Trying to "object-orient" that is much more likely to baffle than teach. Understanding OO is a very important part in becoming a proficient Java programmer, but I'd say that you definitely took the right approach keeping this particular program procedural. 

A couple of general points: You shouldn't be using properties to set an error message like that. The error message is associated with the action you attempted on the object- in this case the delete- not the object itself. After the error has been handled, it doesn't make any sense for the property to continue holding that error message. It also potentially adds unnecessary concurrency woes. You could fix that by wrapping up the bool you're returning and the message into a class, like . Or you could make the message an parameter. But this still isn't a great solution because you have a leaking of concerns between your layers. Why should the data layer directly dictate what's being displayed in the UI like that? Better options would be either: 

These aren't complete examples (I didn't want to rewrite your code), and I'm sure they could benefit from additional code reviews, but I hope it gives you an idea of how you might approach the problem from a different angle. 

This code is telling SharePoint to retrieve every item in the list, forcing all of the returned items into an in-memory DataTable. Then it's manually filtering that table down to just one specific item. This is inefficient for two reasons: 

Right now is a string that seems to be put together solely for searching through it. That has the potential to be a big performance bottleneck. If you change it to an array, you can squeeze a bit more efficiency into your code by sorting the array and then using a binary search method to detect whether it contains the desired value. Here's an example of a binary search method. 

This saves you all the processing that would take place within the loop. You would also need to update your function to accommodate the new format for the parameter. 

Since I could not get to compute a derivative successfully, I wrote a script to compute it manually. Running the script below will output a plot of two functions and over the interval . 

I am trying to write an algorithm that can find user-specified nearest neighbors. By user-specified, I mean that the user can specify whether it's a general nearest neighbor, a forward-nearest neighbor, or a backward-nearest neighbor. The idea for this code was inspired from this SO post. While it isn't ideal to search the entire array (perhaps use searchsorted as an alternative), I want to find all occurrences of the user-specified nearest value in the given data array. While there are other techniques that can be used to achieve the same goal (such as using the cumulative sum of differences of argsorted values), I feel the code below is easier to read/understand and is likely quicker since it performs less operations that require traversing the entire data array. That said, I would like to know if there are better approaches (in terms of speed) to achieve the same output, as this code will be applied to a dataset of at least ~70,000 data points. More than the value itself, I am concerned with the indices at which the values occur. 

(Since this code needs to work on IE8, it's clobbering the mouseup event instead of adding an event listener to it for the sake of brevity and performance. Add that to the list of things I feel guilty about.) 

I have a fiddle demonstrating how the technique works, but it's polluted with logging and metrics, and doesn't have all the logic encapsulated into functions; I'd rather any critiques be directed to the above code rather than the code in the fiddle: $URL$ 

Sure, you can use event delegation for this. For the uninitiated, event delegation in JavaScript means attaching the event listener to a container element and using the property of the event to identify which sub-element was acted upon. You'll still need to crawl your way up the DOM tree to get to the root element, which can be done without knowing the DOM structure as long as you have a sentinel you can check, such as the root element's class name, to determine whether you've reached the root. Once you've made it to the top, so to speak, you can use query selectors to find your way back down to specific child nodes within the root element, again allowing you to grab or modify specific elements without knowing the HTML structure--all you'll need to know is a reliably query-selectable combination of attributes (such as an element class). Here's a working example with comments: 

When performing a chi-squared test, one takes the square of the differences of the expected counts per bin and observed counts per bin, and divides these per-bin differences by the expected counts per bin, as seen in the formula below. 

However, I've heard that it is good practice to modify the bins such that the observed counts are above a threshold (typically 5, sometimes less) as a large number of bin counts below such a threshold can result in a bad fit (assuming minimized chi-squared). If the observed bin count is less than this threshold, then the bin is merged with the next bin. Assuming a distribution (such as a Gaussian) with a central peak, the next bin would be the next-right bin (i to i+1 bin) when the bins are left of the central peak while the next bin would be the next-left bin (i to i-1 bin) when the bins are to the right of the central peak. I've created an algorithm that I believe works and covers all-edge cases (assuming a single central peak). I was wondering how it could be improved in terms of speed/efficiency. I also feel like I am duplicating code using similar approaches in two while-loops; can this be averted? 

This doesn't really address your efficiency concern, but I want to bring it up as a potential behavioral problem with your code. Unless the "update" is going to be performed independently in each timezone at 10:00am, 12:00pm, and 5:00pm, you may want the countdown to be based on UTC time, rather than based on the local time. For example, if the update is going to occur for everyone at 10:00am United States Eastern time (UTC -5), you'll want the counter to measure the time until 5:00am UTC time (or 4:00am UTC time if the US east coast is observing daylight savings time). All of the Date functions that get or set time values have an equivalent UTC function (e.g. , ). 

Here are a few suggestions to start off: Understanding the Base Number conversions The base number system should be irrelevant by the time you have a number as a primitive type. It only matters when you're converting strings to numbers and vice versa. JavaScript can't tell the difference between and ; in both cases the underlying number is the binary ... the other formats are just to make it human-readable. So is functionally equivalent to ... in both cases, you're saying here's the number 30 (or if you like), please give it to me in decimal format; thus the output is always the number . The same is true when you reverse it with : both and will evaluate to . The question to ask yourself is: "Under what circumstances would an octal primitive be passed to my function?" Since JavaScript itself doesn't distinguish between octal, decimal, and binary numbers when it handles them in code, the question doesn't make sense except insofar as someone's JavaScript code could explicitly pass as a parameter. In such a case, the error would not be in your function but in the logic of the author who types and expects it to be parsed as a decimal instead of the octal number that it is. Determining the Class of an Object It's tempting to use to determine the type underlying a variable (that's what you'd expect the operator to do, after all), but its output is not always consistent. For example, will return when the underlying class is actually . On top of this, the return values of the operation are not defined in the ECMAScript specification, and could thus be different in different JavaScript implementations. Yikes! The only thing for which you should use is checking for an undefined variable, using the syntax Instead of using to determine the class of an object use . Here's the syntax for that: where is your variable. The reason we call at the end is because the function call would otherwise return when all we care about is . Semicolon Best Practices While JavaScript requires semicolons, the JavaScript parser is pretty forgiving about them: if semicolons are missing, it'll try to extrapolate the correct semicolon placement and insert them as needed. However, it's a best practice to explicitly identify the ends of lines. This not only saves the parser some work, but prevents it from making mistakes that can change the behavior of your code. Since you already have your code in jsfiddle, go ahead and click the "JSHint" button in the nav bar. It will identify lines where you excluded semicolons (such as at the end of a variable assignment) or added unnecessary ones (such as at the end of a function declaration).