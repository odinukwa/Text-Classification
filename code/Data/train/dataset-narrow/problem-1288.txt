This will only allow conversion to bool when an object is used explicitly in a boolean context or explicitly cast to a bool. 

In the function entab: You don't detect and thus compensate for '\t' characters in the middle of a string of spaces Thus "A \tB" is encoded as "A \tB" it should be encoded as "A\tB" In C (unless you are explicitly using C99) you should not use // style comments. A lot of C compilers are not C99 compliant but a lot are not C99 compliant and support //. You need to be careful on this usage if you want to be portable. Then is easier written as: 

In Fib() you should probably not use recursion. Prefer a while loop. Loop from 0 upto the point you want to reach. This makes using a vector easy. You can also start from where you left off last time rather than 0. 

Member variables should not be public. Modification of the object state should only be through a controlled environment (method call). Note: It is OK for the to have all public member variables (ie a struct) 

That's why we use smart pointers and containers. So the user does not need to read the documentation. 

You have these two the wrong way around. Make the version do the work. As noted above you are not mutating the object so it provides some slight protection from simple mistakes. Also you will find the version becomes unnecessary. As the compiler will automatically add const (ness) to parameters for you so you don't actually need the this version. Other comments are same as @Konrad Rudolph Note on the use of const. If you put const on the right or left is a style thing. Peronally I always put it on the right. As there are a couple of corner cases (with typedef) were it does make a difference and I want to be consistent. Note: cost always binds to the type on its . unless it is the left-most part of a type declaration then it binds right. Read type right to left. 

This is a terrible idea as doing initialize. The standard language features will do all this for you with zero effort. If you have a global like this. There are many issues. In fact the standard advice is not to have globals. 

Singelton is an anti-pattern The singelton is a bit of an anti-pattern. They make testing hard. It is often best to combine a singelton with a creation pattern (to allow yourself the luxury of creating different types of singelton for different things (ie testing)). But even better is not to use a singelton. Pass the Texture manager around by reference. Prefer not to pass pointers. Pointers do not convey ownership information. So the user of your class does not know if they are passing ownership of the object to your methods (or even if the object should be dynamically allocated). 

The reason to use a free standing function over a member is to allow either sides of the expression to be auto converted into the class (rather than just the right hand side being potentially auto converted into the class). Make sure this the expected behavior. Stealing things from std::string 

True and slightly outdated. Every call to new requires a call to delete. BUT usually the delete is automated by using a smart pointer, or alternatively you don't use new/delete directly but store objects in a container (and the container handles the memory management aspects for you. Modern C++ has very few direct calls (as this is not exception safe). 

by definition is char. tolower() may return an int unless you pass in an EOF you will get a character back. I would have just done: 

My two problems: You have a magic object you use to test for validity. I know a zero'ed array of longs is unlikely to be equivalent to a valid object. But it just sticks in my throat a bit to use a magic object. Also if it ever goes wrong then finding that error is going to be really hard. You are using the equivalent to a on an type object in certain situations. To be type safe you must always use the constructor on creation and the assignment must correctly call the assignment of the the underlying object. That will also make destruction simpler as you don't need to test validity (and thus don't need a magic object). 

As this is reserved for the implementation in C++. Also the term BITMAP is very generic and you are very likely to clash with other libraries try and make it more unique to your project. You are assuming that a char is 8 bits. 

Note: If I was doing the interview I would ask this to make sure you could do a breadth first traversal of the tree. Which involves using a loop rather than recursion. 

Small Inefficiencies There is no need to create the cell object each time through the loop create it once outside the loop. (Personally I would leave it in the loop, but if you are going for speed then this is an obvious simple save). When scanning the date you are making a copy of the value: 

PS The above code is also broken. The command assumes there is enough space in the destination. This is not true. Additionally the result of is not modifiable (even if does return (C is not know for its const correctness)). So copy data onto the end of the string is not allowed Looks like this is your main object. Global mutable state is a bad idea. Looks like this should be a class and all the following methods members of that class. It also makes the re-using the object easier (Note: The above is is not mutable so it is OK to make it global). 

But you never decrement the variable . Thus after the first thread is created it will always be true. Thus I would do this: 

Methods that return information about the state of the object without actually changing the state should be marked const. 

The idea of making it and not was so that it would not be too obnoxious when going in the code. This is very obnoxious to read. A bit of work formatting these lines to make it easy to read would have gone a long way: 

By moving this code out of the you are opening yourself up to a whole bunch of potential maintenance problems. If you keep this in the class then if you modify the way is used then you will automatically update the way it is copied. With your current implementation you have to search for all the places that is used and update them as well. Don't do extra work 

You can call the global function with any thread to start the initialization processes. There is no requirement that the object is used. 

Its the same thing. See my description of usage above. Comments on Code: Always prefer to use the initializer list. The compiler is going to plant the appropriate code anyway. May as well take advantage of this fact and use the compiler to put the corret initial values in place. (Note with POD data there is no initialization but for user defined types there will be. So it will construct the object members before the function is entered. 

Why O Why do you use this. Its a obfuscated way of swapping two values. Just swap the two values using a temporary. The compiler will use any tricks it has internally to do this as fast as possible (probably using a register and two memory accesses rather than 3 memory accesses (which will be slower)). Seems to me like you are trying to manually do peephole optimizations that the compiler is already doing for you. The compiler is better than you at these optimizations so the only thing you are doing is screwing with the compilers ability to perform these optimizations probably resulting in slower code. Humans are bad at this, compilers are very very very good. Humans are good at algorithmic optimizations compilers are bad at this. Do what humans do best and let the compiler to what it is good at. 

Sure. You implemented the basic factory pattern. But factories don't get useful to you start using . SO you can swap out out factory for another factory. Side Note: When presenting code it's easier to review of the header comes before the source. And best if the base class comes first. Prevents a lot of scrolling backwards and forwards. Virtual Functions 

I see no testing of or for so they can't be so there is no need to pass them as pointers. So you should be passing them as references. Since neither value is modified by the function you should also probably be passing them as const to prevent accidental modification of the original value. 

My main complaint is the use of the in such a low level interface. I think that is totally a waste of resources. Would be interested to know how this performs in comparison to you vector based version. I basically swapped the for a and built a chain. It makes the assumption that is at least the size of a pointer (but I am sure we can add a static assert to achieve this).