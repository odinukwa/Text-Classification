The other part is a little trickier but in my experience is extremely fast when doing it inside Excel. Perhaps this concept could be applied to your code. 

As was already mentioned, I also am not crazy about -1 return, I would rather see it raise the exception rather than an odd exception later about integer subscript so I removed the try/except negative 1 return. Here is the code I came up with after applying the changes mentioned above: 

That limits the change in the field called "sort" as it alternates each time as the "group" changes. I have looked around and did not see a standard way to accomplish this without rolling my own. I think the code is fairly straight forward but curious if I might be missing something or an easier/faster way. Any comments would be appreciated. 

I can't really comment on the performance since I found it difficult to read, especially the spaces around the operators throughout the code. As you mention though, I would focus first on cleanup and applying PEP 8. There are many issues with spacing around operations, spacing between/after definitions, line length, etc. That would help with the readability. The other part that seems difficult is the "main" logic near the bottom. It is good convention to place that in a "main" function and then use the "if main" at the bottom. So you would have somethning like this: 

It says that a boolean function of one boolean is valid if and only if and are both valid. Of course, the validity of boolean is just that boolean. So in this case, can be thought of as being a bit simpler: 

Inductive Instance Definition - First Step This is the fun part. We're using induction. Here's the full code snippet, and then I'll break down each line. 

Boolean Instance Definition All we've told the compiler so far are our promises: there will be methods for checking whether an instance of is valid or a contradiction, and a method for comparing two propositions of the same type for equality. To start, we implement these procedures for the most basic type of proposition: one that is just or . 

to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

Pre-calculate 1-9 powers and store the results in a dictionary so they don't get recalculated (Memoization). It lets me look them up very quickly without calculating each time. Separate the digits using math.log10 as to avoid the int->str->int conversion. 

Use a context manager to do the file opening rather than the try except up top and then closing the file manually at the bottom. Don't bother with just do . Stripped both sides of the line rather than the right side first and then the left side later. Pulled out regular expressions and the parse flag, just use the mode as the flag, set it to if the mode is not of interest. Changed the , just use .... but it may be even easier to just lookup the "mode" in a list of "modes" you are tracking so I changed that. I changed the mode naming to match the file. That was just to make things easier. If you really want them renamed perhaps the modes could be a dict rather than a list. Replaced with style check. Before setting the values into the record, I checked to make sure there was something on the right side of the equal . This may be something that the regular expressions avoid but it didn't run right for me. At the bottom of your code you should put in the . There were a couple pep8 issues with line length. I just broke them down a bit. Removed all imports since I didn't need them anymore. 

The first thing you should realize is that in Haskell, typeclasses are basically the same thing as Java's interfaces. They define a contract of behaviour which instances of the class must obey. In this case, the typeclass I'm calling promises the user three methods: 

It won't be very often that a number is , so let's tuck that check away so that it only fires if the number passes the check first: 

I'm late to the party here, but I thought it'd be interesting to consider some more optimisation you could do. First let's consider the number of 'modulo operations' your code does per 15 integers: 

Here, says that in the expression above, the type whose behaviour/implementation we're defining is the type. How do we check if a is valid? Well, it takes no arguments, so a proposition that is just or is valid if it's true, and otherwise a contradiction. 

Alright, so is valid if and only if it evaluates to for both arguments! That's what we want. Now for : 

Here are a few tips that I have used often to speed up macros and code that runs against excel sheets: 

Applying those changes to the code make it about twice as fast. Here is what I end up with for the function: 

When sorting by multiple keys, I need the second key to alternate between standard and reverse sorting. This is to minimize the change in the second key. For example, if I have a list of dictionaries, I want the first sort (group key) to be sorted and then the second sort (sort key) to alternate. This should produce a sort like this: 

There is quite a bit of code there. I would start with PEP8 formatting as it makes it much easier to read. The other thing that came to mind is using namedtuple() rather than using the indexing all the time, this may help with readability. As far as performance goes, the best way to confirm may be to do some profiling.... Since I went through much of the PEP8 formatting just to try and see what was going on, I have inlined it here along with the profiling setup at the bottom: 

says that the function mapping our proposition type of to whether or not it's a valid formula is the function . (This function just returns whatever it's given). says that the function mapping the proposition type to whether or not it's a contradiction is the function . Just as well, because takes just one as an argument, and returns a . This is compatible with the contract we laid out earlier in the typeclass definition of . says that the way of comparing two of these propositions (once again, of type here) for logical equivalence is to simply invoke the already existing method . 

What we're doing here is creating a new typeclass called Prop. We need the syntax because we need to define the behaviour of an instance of the class. If we don't introduce a symbol for it, then how will the compiler know what we're talking about the in the typeclass definition? For example, the line says that for every instance of typeclass , there must be a method called which maps to a boolean value. Likewise, there must be a similar method for . Now the line may cause some confusion because appears twice. It's important to understand that , being an instance of a typeclass, is a type. There are no "objects" as in object-oriented languages. Remember: is a type which satisfies the typeclass contract given by . The Java equivalent would be a class implementing an interface . What we're saying here is that for type which implements/is a part of this typeclass , there is a method called of comparing them. And its type is meaning that it takes in two expressions of type and returns a boolean indicating whether or not they're equivalent. 

Unfortunately I was not able to get the code to run and produce any results even though I adjusted it to load the data file. It just returned an empty dict. Rather than try to figure out why, I took a look at the things I would change based on reading through the code and just made those changes, it seems to work after I did that, not really sure what the cause was but I did do the testing on Windows which may have had something to do with it. Here are the things I focused on: 

When doing the , you are calculating the power of each digit many times. If this was a much more expensive calculation then only calculating 1 time is even more important. In this problem there is a conversion from int->str->int. If you can breakdown the digits without converting them it saves some time. It seems like a good thing to know how to do just in case your ever trying a different language where skipping those transitions may be even faster. 

Not that you need these grade messages, but that's an example of the power of holding on to the type rather than converting the grade directly into a . Sorry if I've made syntax errors as I've not used Java in a while. Edit: Just realised that you might like to put , and into the itself as static methods. 

These correspond to three questions which we could ask of any proposition which is a function of any number of propositional atoms. In case you're unfamiliar with this terminology, an 'atom' is one of the inputs to a proposition which is a function taking some number of atoms and itself evaluating to either or . Typeclass Declaration The name for the type class bears no meaning for me, so I changed it to short for "Proposition". 

Alright, this is the first time I've used Typeclasses so someone feel free to slap me with a tuna if I mess something up. First of all, I don't understand why the use of "FlexibleInstances" is necessary, and it scares me because these kinds of warnings are usually put in place for a reason. With that out of the way, I'll go through the code. 

For speed comparison, I did an example sheet with ~ 16000 rows, I read two cells, added them together and wrote them into another... it took about 4 seconds (Excel VBA). When I convert using the mentioned array method it completed in far less than a second... To show it using com, here is an example using python, the set each 'cell' method takes about 27 seconds on my machine, the set a 'range' method takes about 5.3 seconds, ignoring the 5 second wait so you can see the sheet, the 'range' method is many times faster: 

The second part is a little trickier, what it does is uses math.log10 which gives a count of the digits, then it does a mod 10 to get the right most digit, looks up that power to add to the total and then finally does integer division to divide by 10 effectively moving the decimal place 1 position to the left (dropping the right most digit we just dealt with). This is probably a little different between Python 2/3 due to changes in int/float division. It is basically doing what you are using to do but without converting to string and adding the power of 5 dict lookup as it goes along: