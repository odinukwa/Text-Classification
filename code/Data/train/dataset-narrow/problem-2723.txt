For example, let's say you have two lights A and B, with colors CA = (1.0, 1.0, 1.0) and CB = (1.2, 1.0, 0.8) and brightnesses LA = 1000 and LB = 5, which are at distances dA = 50 and dB = 4 from a point P with color CP = (0.3, 0.8, 0.2). Assuming the standard falloff of light intensity as the inverse of the squared distance, the total light intensity at the point P (assuming that both lights actually hit the point) is:       Ctotal = CA LA / dA2 + CB LB / dB2                = (1.0, 1.0, 1.0) · 1000 / 502 + (1.2, 1.0, 0.8) · 5 / 42                = (1.0, 1.0, 1.0) · 0.4 + (1.2, 1.0, 0.8) · 0.3125                = (0.4, 0.4, 0.4) + (0.375, 0.3125, 0.25)                = (0.775, 0.7125, 0.65) Now multiply this componentwise with the surface reflectance CP to get the apparent color of the point:       Crefl = Ctotal ◦ CP = (0.775 · 0.3, 0.7125 · 0.8, 0.65 · 0.2) = (0.2325, 0.57, 0.13) (If you're doing indirect illumination, this is also the color of the light reflected from the point P.) Note that, in the example above, I normalized the light colors CA and CB so that the average of their components is 1.0 and used the separate scaling factors LA and LB to represent their intensities. This is just a matter of personal preference, and you could just as well bake the intensities into the light colors if you wanted, but this way seems clearer to me. Also, for lights that are very distant and very bright, such as the sun, you'll probably want to leave out the 1/d2 term and just let the L represent the brightness of the light at the scene. Also note that, while the light intensities can (and typically will) exceed 1.0, the reflectance values should not. If they did, that would mean that the object would reflect more light than falls on it, which is obviously absurd. The reflected light intensity can also exceed 1.0; that just means that the light exceeds the maximum brightness that can be displayed on the screen. You can just clip those color values to 1.0, although you'll probably get nicer results if you render them unchanged into a HDR buffer and apply a bloom shader to the result. If the average illumination level can change a lot (e.g. if the player can move between outdoors and indoors), you'll probably also want to include a variable scaling factor to account for adaptation of the eye to the varying light levels. Also, if you're not doing true indirect illumination, you'll probably want to include an "ambient" light term (preferably with some approximate ambient occlusion factor) in your calculations to avoid your shadows being completely dark. One way is to simply let the ambient light have a fixed color (usually neutral gray) and brightness everywhere, but you could also e.g. try making the ambient light proportional to the total light level in the area, ignoring (most) shadows, or use more advanced techniques for estimating the ambient illumination. Another term you may want to include is light emission from glowing surfaces; that can simply be handled by adding it to the final result. Finally, everything I've written above only deals with diffuse reflection; specular reflection and highlights are a whole 'nother kettle of fish entirely (although the same basic physical principles still apply). 

There's no guarantee that a firewall (whether NATing or not) will let UDP packets through at all, so your client and server should be prepared to communicate over TCP if necessary. Typically, the client will create a TCP connection to the server, and thereafter both will talk back and forth over that connection. For setups where no direct connections are permitted through the firewall, you may want to also support tunneling the TCP connection through a SOCKS proxy. In particular, it may be a good idea to query the system default proxy settings and use them if a direct connection fails. It's perfectly feasible to use the same message format for both UDP and TCP. There are some features that you'll only need for one protocol or the other; you can either have two variants of your message format, one for each protocol, or just include all the necessary features in both: 

You noted that you want berserking to be a state that can sometimes be entered by normal enemies (with a propensity to it). Thus, you'll need to decide what will trigger it. IRL, traditionally described triggers include combat, heavy exertion and stress. Some potential triggers for a game might include: 

Humans have trichromatic color vision, so the space of colors we can see is fundamentally three-dimensional. (Well, for most of us, it is. Colorblind people may only have dichromatic or monochromatic vision, and there may be a small number of people who can (barely) distinguish an extra dimension. Also, technically, even normal humans do have a fourth type of photorector — the rods — but those are only active in low light conditions where normal color vision starts to fail, and are not believed to contribute to it in any significant way.) You can encode the position of a color in this three-dimensional space in different ways, which gives us various color representations like RGB, YUV, HSL, Lab, XYZ, and so on. But the one thing all these color spaces have in common is that, in order to be able represent all colors humans can see, they need at least three coordinates. (The reason CMYK uses four coordinates comes down to the limitations of printing technology, and specifically the fact that it's hard to get a good black just by mixing colored inks. The extra channel is, strictly speaking, redundant to the other three, but exposing it to the graphics software allows more detailed control of the printing process.) Certainly, if you only wanted encode a subset of the colors, you could pick some two-dimensional surface within the three-dimensional color space and encode your colors as their position on that surface. A simple way to do that would be to take one of the existing three-dimensional color encodings and fix one of the coordinates at a constant value (or at some value that changes as a function of the other coordinates). For example, if you wanted all your colors to be maximally saturated, you could take the HSV or HSL color spaces and fix the S channel at 100%, leaving you the two other channels.