No. In the code you posted, the only way and the like would be overwritten was if it was a static member variable. If you copied the class wholesale to create (for example) a class, that would be a new static variable. This is still a bad idea. 

It won't attempt to cull enqueued sprites against the view at all, either. They'll be clipped out entirely during the transformation stage like any other geometry, but it's vastly less expensive to simply never enqueue a sprite you know will not be drawn because it is out of view. is really just a wrapper around a dynamic vertex buffer that may or may not do some sorting for you to minimize texture stage changes and such. If your curious you can use Reflector to poke around at the internals and see that it does very little besides manage the buffer for you. 

A ball should have methods to query the size and bounds and a higher level interface (for example, a class) should be the one that determines if the ball is in within the boundaries of the playing field. This allows you to, with no loss of generality: 

Here is a tutorial on using vertex and index buffers in XNA; vertex buffers are probably the ideal way to approach this, but if that seems a bit daunting to you right now you could use the simpler function. A related tutorial outlines that process. Essentially, you'll want extract the vertex data from the file (the format is described here). The most straightforward way to do this is probably to call File.ReadAllLines and parse the data line-by-line, assuming you are using the ASCII version of (otherwise try File.ReadAllBytes). The methods may not be available to you if you want to deploy to the 360, though. You turn each vertex in the file into an appropriate vertex structure in your C# code, write that vertex into a vertex buffer or an array of vertex objects you're going to use with, and then draw the buffer or call . The format doesn't appear to support indexed data, so you don't need to worry about index buffers, although you could in theory look for duplicate vertex data as you load and build an index buffer that way (I wouldn't recommend trying this first though, keep it simple). 

The rules for whether or not you should call on a D3D object are simple: It is your responsibility to balance your calls to functions that increase reference counts with those that decrease reference counts. Explicitly calling , for example, should be balanced by a call to when you are finished with that reference. Most functions that create or get resources from somewhere implicitly increment the reference count, which means you should call when you are done with that reference to the object. The documentation for a given function will note if it does not increase the reference count. These rules apply regardless of the function the object was created in or with, used in, and so on. They are more about the higher-level semantics of your program: generally if you allocate a bunch of resources in a startup function, you should clean those up (call ) in a matching shutdown function. But if you allocate or acquire a resource temporarily within one specific function, you should release it within that function, unless you know another matching function in your codebase will be able to safely release the resource instead. If you are getting "errors" when you move the release calls around, you've probably unbalanced the add/release reference count pairs. Or you have another sort of bug. Either way, however, "debug my code" questions are off-topic here so you'll need to resort to the old-fashioned means of problem solving: your debugger. 

The resolution should not affect computation of simulation logic such as "where your bullet hit." Any reasonable game will divorce such simulation data from the final render resolution of the screen. That means the main thing you're talking about with respect to resolution is what the player sees. 

I'd suggest you structure each of your milestone deliverables as a simple bulleted list of clearly-demonstrable features your game will have by the end of the milestone. For example, perhaps your first deliverable will involve a game where: 

You're talking about the guide button, it sounds like. The guide button is reserved, and you can't detect its state directly. You can, however, detect if the guide is active so you can pause your game (or whatever). To do this, you'll want to have a look at the IsVisible property of the Guide class. 

Having some kind of central "meta server" or "locator server" is pretty standard practice, and they are pretty generic and straightforward (even though entire middleware solutions, such as GameSpy, used to be popular in the early days of internet gaming). A locator server just maintains a list of known active game servers that can accept connections, probably in a very simple database table (or entirely in-memory if you really want to be simple). Consequently: 

To handle the case where a bullet has left the screen during the update loop, you don't remove it from the list. Instead you swap that bullet's data with the last enabled bullet's data (which is at and decrement . Obviously this technique implies two things: you have a fixed upper limit of live bullets and that the order of bullets in the list doesn't matter. The latter should not be a problem, however the former might be. Fortunately you can deal with this if you have to by adding a new bullet at the end of the list (not in the middle) and swapping that bullet's properties with the bullet at index . Then you increment -- much like how you handle "removing" a disabled bullet, really. The end result is that you have a system that allows bullets to be activated and deactivated in linear time (your original method was more intensive) and has a fixed memory budget which can't leak or induce garbage collection during gameplay and is easily cleaned up post-gameplay by simply clearing the entire list (if need be). 

The graphics pipeline (typically) involves transformation from model space to world space, from world space to view space, and from view space to clip space. There is a transformation matrix associated with each of these (the world, view and projection transformations, respectively). There are of course stages of the pipeline after geometry reaches clip space, but they are not relevant to your question. Because each transformation is a matrix, you can combine them: you can create a "model-view" matrix or a "view-projection" matrix or even a single combined "model-view-projection" matrix. They're all perfectly reasonable and are in fact used fairly commonly, when appropriate. The reason that the term "modelview matrix" is so prevalent is because of classical graphics pipeline theory and OpenGL, where it was considered standard practice to combine the model-to-world and world-to-view transformations. This was done because there was a very common reason to have geometry in view space: it simplified the computation of lighting effects. There wasn't a particularly common reason to have geometry in world space, particularly since the pipeline was not programmable the way it is today. Consequently, there was not really a common need to go from world space directly to clip space, and thus a "viewprojection matrix" was not a common thing and did not gain a foothold in the vernacular of the industry. If you have a good reason to have your geometry in world space for some intermediate computations during the pipeline, but have no reason to have your geometry in view space, then it is perfectly acceptable to use a combined view-projection matrix. 

It's rather impractical for images of any kind of complexity, since it both requires you to write or find some tool that will save or convert bitmaps into source code, and it requires a re-compile to change any part of the image (which is not very good for iteration), but it's a common technique for really simple demos that don't want to confuse the issue being demonstrated with lots of file IO and image read code and whatnot. However, I wouldn't recommend using this technique in production code (or really, at all, just load the image from a file, there are plenty of libraries to help you with that). 

This is a problem that most people have when first hearing about or approaching "design patterns." Design patterns exist to create a common vocabulary for talking about problems and solutions. They should not be viewed as solutions in and of themselves. That means when you encounter a problem, you shouldn't necessarily go hunting for a "design pattern" to try and fit over the problem, and you shouldn't worry about implementing the solution to a problem "correctly" in terms of the canonical definition of the pattern. Focus instead on solving the actual problem. In this case, the problem you have encountered is that you need some way for other code to react to world events when they happen. And it's true that this the basic premise of the observer pattern -- but that doesn't mean there is a single "correct" way to implement the observer (and there shouldn't be!), nor does it mean you should think about the solution in terms of the pattern. It is a subtle distinction, but it will help you avoid "square peg, round hole" problems in the future if you focus more on the needs of the solution rather than the definition of the pattern. 

I'm unclear as to when exactly you think "immediately" is in this context, or what you're actually trying to do by "watching the keyboard during rendering." But given that you must have known what function is actually being assigned to the keyboard callback (since you had to pass to the function), couldn't you just directly invoke the function you passed yourself when you want to? No flavor of GLUT that I'm aware of has the ability to manually invoke the callback indirectly. 

This should not be the concern of the entity/component system. This should be the concern of the reflection/content representation system you use. It's trivial to implement without dynamic "property bag" dictionaries in languages like C# with good reflection support, and it's only slightly more work to do it in something like C++ with really poor reflection support. Consequently you shouldn't use this as a strong rationale for storing component attributes in a runtime associative array. 

I'm assuming you're using GUI.TextField? It doesn't appear that there's a built-in way to restrict the text field's legal input set, however, you can achieve the validation behavior you want by writing a script: 

Yes, you will need a library and headers to use OpenGL. Fortunately, every major operating system ships with the libraries and headers already in place for you, so you do not need to download and install anything from the OpenGL website itself in most cases. However, especially on Windows, you may want to download and install the latest drivers for your video card as they will generally improve the OpenGL functionality made available to you through the OS-supplied libraries. 

The process, in pseudocode, is as follows: When you get a mouse-down event, record the drag origin position as the point the user clicked, figure out which shape the mouse hit, and store that shape.