It would be nice to have a code review to show me where I can improve on readability (along with other things you may find!). I've been trying to clean it up and refactor a bit, but a fresh set of eyes would be nice. I went a bit crazy on comments because I wanted to make sure I would be able to look at this in a few months and not forget why I did something the way I did. But perhaps putting some of that info in a github wiki would have been better. 

I've implemented the coin change algorithm using Dynamic Programming and Greedy Algorithm w/ backtracking. The description is as follows: 

I'm integrating with a 3rd party vendor that has and in it. My tool is a user administration tool that allows us to store information in our local database about the and that we manage in the 3rd party vendor. So the and are stored in the 3rd party vendor as well as our database (we act as the middle man sort of). I'm at a crossroads with some ideas and would like to hear what others thought of the following problem and my solution. Before I dive in, we're using Grails 2.4.4 One use case for the tool is creating a . We create the user in the 3rd party vendor via an API call, and then we store information about that user in our database. There are many uses cases like this and there are 3 fields that are always in common between them, an a and an . These 3 fields are required for just about every API call we make to our 3rd party vendor and most of the result in an API call being made. For this reason, I had the idea to make a "Common" with these 3 fields on it that can be extended by another Command Object. 

Below you can find a generic implementation and some unit tests of a minimum priority queue in Kotlin. What could be improved in this implementation, so that it complies to best coding practices in Kotlin? 

This is an implementation of the Damerau-Levenshtein distance in Kotlin which I created as an exercise, but might be also useful, if it proves to be correct. The implementation is based on this Wikipedia article, even though it does not 100% follow the suggested pseudo-code. 

This regular expression either matches the variable pattern or the loop pattern. Here is the actual method which performs the variable replacement + looping: 

I know that there are enough Red Black Tree implementations in the Java libraries, like e.g. . Yet I wanted to create my own for learning purposes and also to learn Kotlin. It should work as expected, even though it could do with more testing. What I want to get to know about this implementation is how I could improve the code, how I can use Kotlin in a more elegant way and if there are potential pitfalls. I thank Robert Sedgewick and Kevin Wayne for their Java implementation and course materials on Coursera which taught me how to implement this code. 

With an insert, the entire string will be inserted. Sometime in the future (when you try to fetch the font from the database), and before you output it into CSS, you'll want to escape the string for this new context. CSS escaping is something that hasn't a native PHP API, but there are probably libraries around. 

Depends, are the pictures extremely heavy or otherwise take a burden on the server? If you're uploading 100 2MB pictures at a time, that may be the case. If you're only upload 2-3, it wouldn't. Don't generate the thumbnail in advance. Generate it on-demand and based on the requester's needs (i.e. an avatar in a forum is 64x64, but in the profile page it's 128x128). Save the results normally to a file and create a database entry for it, so that next time, you won't have to generate the thumbnail again. It is. It depends on the rest of the application. Personally, I'd go with a more OO solution, but that's because I understand how OO works and how to incorporate it into my needs. Split the code into smaller pieces of work. Either objects or functions, that do small tasks each (get input, do something, return output). This will help code readability tremendously. 

Below you can find a Kotlin based implementation of the Knuth Morris Pratt substring search algorithm. Here is the corresponding Wikipedia article. 

The template processor should be able to receive its data in form a java.util.Map. Each key of the map should correspond to the name of a variable declared in the template OR to the name of a loop. Each map loop element should contain a list of maps. This implementation contains only one recursive method which executes string replacements and a regular expression which matches either of the patterns described above. Here is the regular expression: 

This code performs replacements of variables or in the case of loops starts a recursive call and processes a partial template with a partial map. 

The template processor should be recursive, so that loops can be nested inside loops and variables too. Here is an example of a template: 

This implementation is a port of Robert Sedgewick's and Kevin Wayne's MinPQ implementation. See $URL$ 

I want to check for its correctness as well if I am using Kotlin in the best possible idiomatic manner. 

The basic idea is to use a flatMap method followed by a collect using a set for collection. I get on my machine for the following test: 

Also, what's the need for here? How does it do things better than just making a new object and working with that? A few WTFs when going over your code: 

You should first ask yourself this: Why am I sanitizing input in this way? Let's say I have a login form, and the user enters his credentials, an email and a password. The email will be queried against the database, to figure out the user's hashed password (You are hashing your passwords, right?!), and the password would be hashed, to be compared against that hash. Both of those fields will never be outputted to HTML, the password is never kept in plain-text form for very long, and the username is queried against the database and then discarded. So why should you escape them for HTML? 

Yes, it is safe. No, it is not a good idea. Don't mix application logic and configuration with the database, the database is used for permanent storage of data. Use a file (json, ini, xml, whatever) which is named the same but has different contents in production/dev environments. Then, it's as simple as: 

You can have more methods like "fetch the N top user with most comments", or "Fetch all the friends of this $user" The point is, the is responsible for getting/saving all necessary data from the database or whatever other permanent storage you might need, and fill the actual Domain Object, which is then used by the application to do processing.