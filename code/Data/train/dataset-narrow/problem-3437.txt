I have created a script that will set this up for you automatically. It is apart of another project but can used without the main project. Simply use the following commands 

the PID signal is terminated and shairport is able to begin playing the music from the device connected to it. Even when I run the script from the terminal it terminates properly, but it does not do so otherwise. Is there something I am missing or not doing properly? Any help is appreciated. I have tried searching multiple topics related to killing the PID and none of them work. I have tried kill -9, kill all, but none seem to work. I have raised an issue on shairport-sync github page, but I was told it was a possible difference between runtime environments, I have tried searching on that subject as well but came up with nothing. 

It is a commonly known issue that if the pi is not powered properly , wifi and Bluetooth communication can be very finicky and have a lot of weird symptoms. While it is suggested to have at least a 1amp power supply, I would suggest a 2amp power supply in case you ever decide to add even more peripherals. 

I will keep it without markdown so its more easily read. For me this works and only displays a grey box with the three dot loading screen then goes straight to the login prompt. 

PiCAST 3 is out, but from what I can tell only streams YouTube videos? I may be wrong, but I haven't have much experience with it. You can find it here: $URL$ shairport-sync is an iDevice version which will allow you to setup AirPlay to stream audio to your device. However, if you are lucky enough to still be on iOS 8.xx you will also have the ability to mirror your display. Unfortunately, with the newest updates from Apple, the mirror functionality doesn't work from any devices running 9.xx + You can find it here: $URL$ UV4L is another option. However, it looks as though it requires a bit more work to setup each time and isn't as simple as shairport-sync, but it does allow for video 'casting'. You can find it here: $URL$ OSMC has built casting that may work for an android device, being an apple user I am unable to test whether or not it works, but others have reported it working: $URL$ 

We have also seen that pip was not included with Python 3.4, in which you will have to install the dependencies: (I would suggest updating before doing so) 

Aside from what joan has mentioned in regards to your servos, based on the code you have the code is running properly. Lets take a second and breakdown the code so you can understand what is going on. 

I have found that there are current issues with pulseaudio5 especially when it comes to audio playback over bluetooth. As such I propose that instead of having to debug those when they come along simply use PulseAudio6 for what you want. I have created a repo that will automate everything below so you don't need to do all the leg work, but if you're still set on doing it yourself continue on below. Repo: $URL$ Install Process: 

I have a project setup that allows for a car installation of an Audio Receiver Audio Receiver Code I currently have Kodi setup the autorun on boot. Around 10+ minutes the Kodi screen becomes transparent with a transparent CLI (also transparent) overlayed on top. Audio still plays fine and you can navigate Kodi with the remote, but it pretty much ruins the reason for having Kodi active. I have tried using to no avail. After plenty of research I am still at a loss as to why this is happening. I am using the Raspbian Jessie update of 1/11/17 

You are almost there, you have all the proper setup (from what I can see) that is needed for hostapd to be working. The issue is with the dhcp, by default the latest raspbian has dhcpcd installed on the OS. You will need to edit the file and add the following line to the end. Afterwards, reboot and it should work properly. Another way to do this is : 

Between line 6 and 7 there is no delay or pause so what will happen is that as soon as you make the servo begin to move, the script will then begin to make it stop. A simple way to test this is simply add the following to the beginning of your script 

Alright guys, I have a question in how to solder an additional USB port to the board. I have an old security camera system dvr that I've taken apart and gutted to install my raspberry pi and tb hard drive that hosts my webpage and shared drive for the house. With this enclosure it doesn't allow easy access to any of the ports. However, the front of the case has a female USB plug with 4 wires that no longer connect anywhere since I removed the board from the dvr. Is it possible to solder those wires somewhere on the board to gain access to the USB functionality? If so, are there any instructions of how to do so? I've searched and have come up with anything, it all relates to pi zero or upgrading A to B. Thanks! 

If you want to use a python script and a button press you can include the following in your python script: 

I am currently running shairport-sync on a raspberry pi zero running raspbian lite. Everything works well, but I am choosing to use a soundcard for auxillary input as well. I currently have these scripts to run at the beginning before a device connects to shairport and after shairport ends playback. the script run when a device connects is as follows: 

I have tried changing the shebang from #!/bin/sh to #!/bin/bash but neither of them work to kill the PID, but they still change the amixer level. from the terminal when I run 

from there you just need to pair, trust, and connect to your device. From then on every time you turn on your device it should pair to the Pi. If audio is playing when the device is turned on and connected the playing music a udev rule will then move the sink input to your connected device. If you would like a deeper walkthrough of what is going on, I'd urge you to take a look at the answer I left here: $URL$ 

I have had great success with the following (as far as quiet boot goes, I haven't tried any splash screens yet) 

Ok I have solved the issue. When is enabled with and enabled as suggested in the readme.md, a script is unable to kill the process due to the need for . Since is run early in the boot process, it loads before is loaded. Then since runs in a consistent environment it runs the process without any rules. That being said, each time is needed it will require a password, which is the error that is occuring and not allowing for the command to execute. There are a few work arounds to solve this issue. The first solution is running . Then add to the end of your file. The next solution is to change sudo permissions via . From there you can add anywhere in the file, I chose to add it to the end of the file. The last solution and possibly the simplest, is change your kill line from to 

copy waveshare35a.dtb (found on-line via swkim01's waveshare git hub [use a web search]) to the /boot/overlays directory as: 

Save and reboot. Try removing the device then repairing and trusting the device with bluetoothctl. Then connect to the device with terminal via: 

There are a couple way you might want to approach this. If you are using an android device you can download an app called Script Kitty, and run the following code: 

I am creating an embedded display to be used as a heads up display. I want the system to be up and running as soon as possible. The basics I need to be running is the GUI of X to run a Python script and I need Bluetooth enabled as well so I can communicate with an obd2 device over Bluetooth. What are some good ways of cutting down boot times whilst keeping X, Python, and Bluetooth. I would also prefer to keep networking to ssh in to work on if need be. Thanks, Brett 

A simple fix of adding to the file fixes the transparent CLI from overlaying on top of kodi. I believe you can disable the faded kodi screen somewhere inside kodi, most likely power saving or power management. 

Please make sure that all these are seperated with a space and all placed on a single line. Additional work can be used to quicken things up: We need to tell dmesg to be quiet 

If you are not well versed in writing kernel drivers, I would suggest forgoing tft and simply buying at 7in hdmi screen, they can sit on top of the header pins of the pi for power and usually come with a "U" shaped hdmi plug that connects the screen to the hdmi input of the pi. In addition this still gives you the option of mirroring/rotating the image which can be useful if you plan to use the screen with a collimator for a HUD type feel for old school racing games. Usually this isn't needed but, the simplicity of using such a screen is nice and saves you the headache that many of us, myself included, have gone through in trying to find or make a kernel driver for a screen. There are already screens out there that can do what you want but they aren't cheap, and the ones that are need either special drivers or special images. Try searching this site or google for a 7in tft screen you should find plenty. 

There is also a file Change the line to as far as starting playback of a song you will need to learn how to use The kodi api with Python to playback songs on startup. 

You may begin to find that the while using a fan the entire time takes away from the normally quiet nature of the pi. As such it may begin to become annoying. I propose a different solution one that you can customize to come on at a certain time or when the temperature reaches a given point. You can setup the fan + lead to the 5v and connect the fan - lead to drain lead of an n channel MOSFET. Then connect the gate lead of the MOSFET to a GPIO pin of your choosing. Then connect the source lead of the MOSFET to your ground pin on the pi. In addition I would suggest either soldering on a 10K Î© resistor between the gate and source leads or using a GPIO with a built in pull down resistor and setting it in the code. From there you can write your own fan script to control it. I have made one that you can use if you're so inclined. You can change the values and the logic to better fit your needs. The script can be found here: $URL$ In this example I have used GPIO 25, as per the BCM diagram and not the actual PIN number. With the setup purposes above you are able to use software PWM to run the fan at submaximal speeds to keep it quieter or set it to fully on to maximize cooling. I have used a similar setup in my media center and included 2 fans one for pushing in cooler air and one to extract the warmer air from the box. With the stress testing with the command stress I was able to keep the pi under 60 degrees C in an enclosed box with heatsinks and running a hifiberry amp+. This may be overkill for your needs, but if cooling is a real issue I find this solution to work best for cooling and silence when cooling isn't an issue. If you need help with using such a file or setting up the FET feel free to ask. 

temp will hold the output of the file, which you don't necessarily need for this, but it can allow you to add some logic depending on what the output is. However, based on how bluetoothctl and rfcomm work you may not get any usable information back from running the command. If that is the case you can use the following: 

-------------------- Complete walkthrough: -------------------- Compiling PulseAudio 6 Add the following Files /etc/init.d/pulseaudio 

EDIT: Recently I have created a Repo on GitHub that sets the Pi up as an Audio Receiver that allows for auto pairing of bluetooth devices, sets up airplay for iDevice users, and allows auxillary line input. The installation works great on the latest raspbian, it is best to use a fresh install. There are two versions, one that is a Home version that uses an existing wireless network for the AirPlay, the other is a Car version that creates its own Wireless Access Point without internet so that the iDevice can use AirPlay. It would be easy enough to add a hotspot for internet access as well. In terms of this specific topic, the bluetooth works flawlessly and allows for users to control the bluetooth volume with their device. REPO: $URL$