It is rare to see RAW pointers in C++ code. Pointers are usually wrapped inside smart pointers. But in this case you don't even need a pointer just use a normal std::vector as an object in place. 

There is a slight problem with this. If an exception is thrown you will leak memory. That is why in C++ we use smart pointers to make sure delete is called automatically and correctly. But if you do as I have shown above you do not even need to call delete. Same comment as above. 

This implies you have not set your object up correctly. Some exceptions should help you cover this in a much more readable and maintainable fashion. All over the code you are repeating the same error handling: 

I presume these keys perform actions? I would rather name them with their action. So if you change the key bindings you don't get inconsistent code. If Itook your code but I prefer 'o' and 'p' for left right your code still has and scattered through the source. 

Make a copy into temp. -> Dangerious as exceptions can fly. Swap the temp and current. -> Safe as swap should not throw exceptions. Destroy then temp. -> Safe as the state of current is now good. 

Sure you can test if it is open. But usually that is a waste of time. If it failed to open nothing else is going to work. So exit the function now and reduce them number of levels of indention of the code. 

It's very simple; what you're saying here is "give me a , I can give you n random values from it". Option 2: 

Naming conventions aside (short names in camelCase are typically used in Go), this is the right way of doing what you want. The authors of Go have a different view of what is more readable & maintainable than the authors of Python :-) 

If you can't guess, try it; it's a good way to learn =) Anyway, you don't want that to happen. So you can do this several ways. Before I'm going into two idiomatic options, let's talk about your interface definitions: 

It doesn't seem that the library has a query builder or a specific type. So building a query in an idiomatic and readable way should be done as you would do for a normal string, and that is using the package. This will allow you to get rid of many code smells: 

You're saying something similar here: "give me a and I give you a ". It's better if you want to have a concept of a variable that you'll later pass around or reuse. 

And, no, there's no easy way to have something more dynamic that , unless you have a specific use case in mind (and then, you would use an interface, but this is out of scope for this question). See this for a detailed discussion on why Go doesn't have generics for now. 

What are you returning me here? What is the interface to the object I am getting back. Is it an iterator a reference to the object inside the container. Its not obvious to me what the behavior of the return value should be. 

The pthreads library is a C-Library and thus only understands the C ABI. It has no concept of the C++ ABI and thus can not call C++ functions and definitely can not call class methods. This just happens to work on some systems as you are getting lucky that that the ABI for static member methods is the same as the C-ABI. Best to just make a C-function so that you are guaranteed for it to work. This C function can call your static member in a valid fashion. 

Select You are using incorrectly. It's not going to break anything as it is used here. But this is not what it is designed for. 

Using a for loop is easy. But sometimes it can be simpler to use the standard algorithms to accomplish simple tasks over short containers: 

Implementation I would say your list leaks; but it does not actually own the nodes (it should) otherwise how do you gurantee that all the members of the list are valid. Secondly the addNode() 

Const Correctness If a method is retrieving data but not altering the object. Then you should mark the function is . Thus if you pass the object as a const object you can still call methods that are marked const. 

you could also write but it's not that important. Now, the rune/string/byte question is the interesting one. deals with only; and converting strings to bytes and back is expensive (new memory allocations each time). So I'd change your code to use instead of , and instead of . The function becomes faster: 

In , you're needlessly allocating strings by modifying the variable. It would be a fairer benchmark to write it in the following way: 

→ , same for . is more readable. You can also convert everything that represents a time into a or a , rather than deal with Unix timestamps. There are functions in the package that do what you want to do (, , etc.). About that, why does need to do complicated things with times, checking when was the last time it was called, etc.? Shouldn't the caller take care of this with a simple instead? It feels like this complexity shouldn't be there. is a weird name for an implementation. maybe? Your package isn't very idiomatic, which makes the callers do weird things to use it. For example, why do you have a struct that doesn't contain anything? Why not simply have as a package-level function? Same for the other empty structs of this package (…). It's more idiomatic to test for rather than . I'm not exactly sure what you're doing with (this is pretty complex). Maybe add a comment for the line or refactor this part? Talking about refactor, is way too long. Split it in sub-functions. No need for an after . Rather than: 

We can also see that the calculation of wrap is overkill. All variables are unsigned and bits that fall of the top are lost. 

I don't see the advantage. Maybe if you can show the code being used in a larger context where it provides an advantage over std::stringstream. 

In int bt_depth(struct BTnode * tree) Too many different checks for NULL. You only need to check once. The call to bt_depth() on the left and right nodes will perform there own explicit checks don't try and pre optimize. 

The streams library already discards spaces when used correctly. Also the ';' at the end of the for. This is considered bad practice. It is really hard to spot and any maintainer is going to ask did he really mean that. When you have an empty body it is always best to use the {} and put a comment in their Here you are basically lower casing the string. 

You should avoid . Though it has its uses these are mostly advanced reasons to use protected. Stick to and . 

This is declared way at the top. You should declare variables just before you need them. This helps in the readability of the code (as I don't have to scroll back to the top of the function to find out what the code type is). Also it prevents you wasting an instruction initializing a value that you will never use (here you init to zero but is that just a waste). If you declare at the point of usage you avoid that waste. 

and then, check directly whether the result is within your interval (without your auxiliary function, which just hinders readability). Now, the bad news: computing the number of days between two times, even assuming that they are in the same timezone, is hard. Your function only works if you are in UTC. To truncate to day for any timezone, use the solution in the accepted answer of this StackOverflow question instead. Once you have you correctly-truncated times, getting the difference in days between them is not as easy as you think: if you simply divide by (like you currently do, in a somewhat weird way), this will fail if the times are not on the same timezones. You say "that's not a problem", but you're probably wrong: most places in the world change timezones twice a year, for daylight saving time. So you have to take this into account… You have two options: 

You client code is incompatible with the argument type of (I guess you meant to write instead of ?). But this is strange to have for an expiration time, most probably should just be renamed to and be an . The code could be more idiomatic. Your variables/functions have long names that aren't really useful. You could replace by , by , by , by , etc. Your function does many things (type conversions everywhere!) so that's confusing. You should probably refactor away a function like: 

Register objects Now you should register objects derived from this class with the factory. This will prevent you accidentally passing NULL as a callback. 

It will not be slower than your code but could be quicker. It also expresses intent much more clearly. Same comments as above: 

You don't need to choose the value at the pivot point as the value to pivot on. Since the value is random just choose the value at (*l) as the pivot point (this also makes sure it will not be moved as less or equal to the pivot point goes on the left. Thus you can reduce the above too: 

Seems a little obtuse. Since this is a private member and this is a private method. You are not buying yourself anything with the extra layer of indirection. Delete works on nullptr You are allowed to on nullptr. You do not need to check for empty/nullptr before calling delete. Just do it always. That makes sure your always deallocate allocated resources. 

To use this you need to know to get that you need to extract (or get) state from the enemy. Which exposes your code to being abused. Better to pass a reference to the enemy and let you and the enemy talk directly. 

Don't have time for a full review. But you doing the operator overloading the wrong way around. You are defineing in terms of . This causes a extra copies, you should do it the other way around and define in terms of . Original Code: 

Yes, this is the way to do error handling in Go. By design, you can't let exceptions propagate to the callers "silently", you have to consider what makes sense at each step. I found that on large-scale projects, it makes it significantly easier to predict and test the error handling behavior of your code. It also forces you to put the error handling first, which (imho) results in more readable, less nested code. Truly global variables don't exist in Go — if a package exports a variable , other packages will have to call to access it. That being said, it pretty much never makes sense to do that. In the example you gave, cmd.go and project.go are in the same package, and all package-level variables are shared, so identifiers conflict. If you want this variable to be shared, it's more readable to put all functions that use it in the same file. When you want to mock some of your functions, it's the sign that there should probably be an associated interface. You can then "mock" an interface easily, by re-implementing your interface in your tests and making it do whatever you want. I find this more readable and idiomatic than using complex frameworks. 

In short: your method should be two lines long, your method should be three lines long, you shouldn't have more than 2 global variables, and all errors should be caught on . 

Singeltons and copying You don't want your singelton copied so disable the copy and assignment operators. 

When writing recursive routines it is usual to check if you have reached the end as the first thing in the recursive function. Then do the body of the action. You don't need to check the next one as soon as you recurse the next call will then check. 

@William Morris mentioned the spinning on a lock issue (busy wait). This is a real problem that you should address. Empty block at the end of while is non obvious to read. You should comment on it so that people don't think it is a mistake: 

Even if you know the rules very few people do. So best avoided. Since you use the modern timing routines you are aware of the modern library. So look up the modern random number generator. 

As you can see my implementation is a lot simpler than yours. I am not sure what you are trying to achieve with the relax method (it actually made my less relaxed trying to read it). 

Stable Sort A very nice property of a sort is when it is stable (its a maths term go look it up). Change this line: 

Getters/Setters Getters and Setters break encapsulation. They expose the internal implementation details of the class. If you see the pattern 

Get rid of them. The side affects make it harder to remember things when modifying the code and also probably prevent the compiler optimizing the code as much as it could if you passed around things by parameter. Spurious code: In 

Minor: don't panic. This is encapsulated in a function (that, indeed, does too many things) so the function should return an error if something bad is likely to happen; and you should let the caller deal with the error. Furthermore, is almost always what you want rather than . Major: don't use a regexp to parse HTML. Seriously, don't. Consider using the html Go library instead. 

→ . When a function returns and you want to return an error, you usually return the default value of along with the error. So in , you would return rather than . This helps you make sure that you're not going to use the return value when you return an error. Instead of printing the error with , you probably want to use and add an error message. Or not print anything at all and let the callers deal with the error (after all, it's why you return it), possibly returning instead of just . Close the file after usage. Add . Use a with option instead of trimming whitespace by hand. Your CSV file shouldn't have space after values (arguably, it shouldn't have spaces anywhere). On "does this look like Go", I'd say you have too much whitespace (empty lines in functions are seldom used), line returns (you never see them right after declarations () or assigments ()), and your variable names are Java-level verbose. In Go, you would use instead of , instead of , instead of , etc.