I think throwing a seems like a good idea. Alternatively, you could also store default values somewhere and return those (eg "missing", "n/a", "", "invalid column", etc). Misc 

Reflected XSS via POST Echoing user input unsanitized is a really bad idea. XSS is also possible via POST, and thus an attacker could steal your cookies, display phishing forms on your website, log all keystrokes, and so on. So when echoing user data, always protect against XSS. Misc 

Comments I think that your code is generally well commented. You might also want to comment the class. Here, you could also state that your canvas starts at (1,1) and that the y axis goes downwards. You might also want to comment on what values arguments can have. For example no negative values, etc. Whitelist I really like that you have a whitelist of supported commands. I think that this is a very good way to make sure only allowed commands make it. But here is the first problem: It does not work all that well. For example, this can happen: 

@HristoYank is correct, you shouldn't catch exceptions that you can't handle. What you are doing is basically just ignoring the error, which will make it difficult to trace bugs. If I call a method called , I will expect to get a number back. If the function can't return a number, I need to know that, so that I can react appropriately. Depending on the situation, I may want to use a default value, ask the user for new input, or abort with an appropriate error message. If the function just swallows the error and logs it somewhere, I will continue processing with invalid data ( in this case), which will result in all sorts of bugs down the line. As only a generic error message and no stracktrace is logged, debugging will also be rather difficult. Misc 

Structure I think your interface is slightly confusing. Classes should be reusable without actually looking at the code; the method signatures and comments should be self-explanatory. Without actually looking at the code, here is what a user of your class would see: 

Readability I found your code a bit hard to read, resulting from a combination of these issues: Naming 

With this, we already got rid of two levels of nesting. You can also combine the camera movement ifs: 

MVC is a bit of a confusing concept, as different people use the term differently. Just looking at the different images at different wikipedia pages shows that MVC can be implemented in different ways. I don't think that you need to worry about implementing it 100% correct for now, but you should try to follow the basic idea. So basically, you have three components: 

would work just as well. Here, you can also see the similarity to . So you can create a more abstract method: 

Or you could just save the variable by putting the expression inside the if directly. Return early Generally, your code will get a lot more readable if you handle simple checking at the top of your function, and return early. This will also reduce the level of nesting. eg: 

As you don't declare types in PHP, Netbeans has no way of knowing that is a object. But you can tell Netbeans this: 

I don't have answers to your questions right now, but I do have some general suggestions to make your code cleaner and more readable: Coding Style 

I would move the invalid input loop into the getInput method itself though. Documentation You should definitely add JavaDoc comments to your public methods. It's not really clear to me what are, what and are refering to, what a is, and so on. Better variable names and structure may help here, but in my opinion documentation is a must. Misc 

Performance You didn't post the code, but I would assume that it interacts with the database. Is this call really necessary? You don't seem to use the result. But if you do need it somewhere else: couldn't you just retrieve the id in the initial query? Have you tried storing the path to an image in the database instead of storing the whole image? As to your main query: is quite slow. Check out this question for faster solutions to select random rows from a big table. If you google for you should find a lot more results as well (for example here). Also, do and really need to be different tables? I don't know your whole db schema, but it seems that it could all go into the same table, thus saving you a . Misc 

You can extract the y check the same way. Note also that I rephrased the condition from to which is faster[*] and a lot clearer. You could also negate the expression and use continue if you think that this will lead to too deply nested code. 

It is practically unreadable and contains a lot of duplicate code. It could look something like this instead (but try to find better variable names than and , I'm just honestly not sure what they represent): 

Restructure It seems that your method currently does two things: It finds a category by name, and it calculate/finds some kind of price for a category. I would write two completely separate methods for each tasks, and then try to reduce duplication. 

You should move the code for inserting the first root node to . It just complicates . I would also rename to . And I would write a method for the tree to test it. Right now, your code doesn't seem quite right (you are doing in both cases). 

It is of course a matter of taste, but I find this a lot easier to read. I also extracted some duplication to a function and removed the tags which did not seem to have any purpose. You could generalize the function even more, resulting in less code, but also possibly reduced readability: 

Why are you doing this instead of using the fields directly? This seems unnecessary and confusing. Functions of Board Why are some functions not part of board? is, but and are not, for example. This seems odd. Comments Comments on functions are especially important when the variable names are not too good. But even if you change them, I would still like some comments. For example: What is the acceptable range for tile width? If I use for example 50, the board does not look good anymore. Another example: What happens if I set row and column to 4 instead of 3? And one last example: What does draw? Everything? Or only the game field, but not the players choices? Reset I extracted your init code in a function: 

Security You are escaping user input, which prevents SQL injection. It's good enough, but really not the recommended way to do this as it's too error-prone (whenever a project does this, it's basically guaranteed that you can find injections). Use prepared statements instead. It's not only more secure, but also leads to nicer code. Guard Clauses You have a lot of nested s, which makes it difficult to see what happens when (for example, I have to scroll all the way down to see what happens if it's a request). If you use guard clauses / return early instead, your code will be much more readable. It might look like this: 

Regarding your questions, yes, that looks fine to me. XSS When echoing user input - or really any variable data - you need to protect against XSS attacks. Otherwise, attackers can inject JavaScript code, which will then be executed in the context of the browser of the victim, leading to bypass of CSRF protection, cookie stealing, phishing, or injection of JavaScript keyloggers. Specifically, these statements are vulnerable: 

Naming You use in multiple places as variable name where it doesn't really make sense. The variable doesn't contain multiple forms, but actually multiple document names. This naming also leads to the odd to read loop. Instead, you should name name these variables (in , , and in the view). 

The first piece of code is just a straight up implementation of the well-known leibniz formula. Anyone familiar with it will recognize it right away (and even find the mistake of instead of which I'm assuming is a typo). Apart from wrong indentation, there's nothing wrong with it. With your code, there are a couple of issues: 

Generally, when creating an entry for a collection, it should be posted to the collection, not to a specific entry (the id is then determined by your application, not by the user). So it should be: 

Neither is all that good. It seems that you just apply functions at random to your data in the hope that some of them will protect you, which is not the correct approach to security. How to properly defend against XSS First of all, the correct approach to XSS is to HTML encode data when outputting it. That is where the vulnerability is create, and that is where it should be prevented. There are three important reasons for this: 

I think it looks pretty good. There are a couple of things I would do differently (eg separate view and controller, remove the small parts of game logic - switching players - that are in the view/controller, and some of the stuff in misc), but all in all it has a clear structure. Misc 

The and functions now do the actual db interaction. This way, you can easily reuse those functions in other parts of your application, and your code is a lot more readable. Other 

Structure The above comment problem seems to stem from a lack of structure. Currently, you present Bar, Bell, etc as string as well as integers, which causes some confusion. You should restructure your code so that these values are encapsulated in the same structure, as they belong together. You could create an object for this, or you could simply use an enum containing , , etc. There isn't really a need to associate an integer with it, you can simply retrieve a random value from the enum. 

is generally used. Here is code to reverse a string that's also quite nice and that might even be faster in some situations. As to your code: 

is deprecated, and has been for quite some time. however is not, and it does offer mysqli_real_escape_string. Still, prepared statements are the way to go. The good news is that you use prepared statements, and use them correctly, so you are defending against SQL injection exactly as you should be. Your additional Filters That being said, your additional filters are not helping, and are in fact adding a false sense of additional security: 

Security First of, your code looks pretty good, especially from a security point of view. You use prepared statements, and you use them correctly, and you use bcrypt instead of some weaker hashing algorithm such as md5 or sha. There are a couple of things which might cause problems under certain conditions, and as defense in depth it might be a good idea to include them: 

Maintenance Code In addition to the good points of @Madara Uchiha: You use in addition to , which seems odd. The will redirect the user after 6 seconds to , making the useless. The W3C recommends against using meta refresh, and I think in your situation the is a better solution, as first redirecting the user to , and then to , from where it will probably go to again is confusing. Of course, then you need to include instead of redirect as @Madara Uchiha recommended, otherwise the user will stay on forever. But as an include is a lot more user friendly than a redirect (user stays on page and can reload manually), this is not a problem. SEO & Google Returning is how google recommends to handle planned downtime, so this is definitely the way to go. Google is not 100% transparent on how it determents placement in search results, but downtime is one variable that will negatively affect your standing, so try do reduce it as much as possible. 

Your code looks mostly good to me. One thing: Functions can help increase readability of your code, and reduce the amount of duplicate code. Additionally, they make testing and (re-)using your code easier. Your main method should only be an entry point, it shouldn't really contain any logic itself. Your main method might look like this: 

I don't see how you could do this in a single queries, because both queries have nothing to do with each other. Your code does contain a bit of duplication, but otherwise it looks good to me. You can simplify your code by introducing a function: 

Even better, you could pass on a list and iterate over that, meaning that your function now wouldn't care how many content types there may be. You could also convert your if into a switch, which makes sense here: 

It might seem overkill, but anyone actually using your function will be glad that it's there. You can remove the warnings about incorrect input if you don't care about it, or you can add error checking and throw well named exceptions and add extra comments for them, to clear up the comment a bit. Different Solutions As @Martijn said, letting the database perform the sort might be a good alternative. It would also be interesting to know why you even need to do this in the first place. Where does the id array come from? Is it permanent - ie hardcoded in PHP? In that case, I would probably just add a column to the table. Error Checking and difference between Functions Your functions are not exactly the same, as they handle invalid input differently (none of them handle it well). If my input is for example: 

Structure So your structure is definitely a bit off. First of all, you made your generic, which is good, as it could theoretically work with any content - which is what you want from a queue. But then, you have fields which just don't belong there, such as (and , which is just not needed). So first of all, lets move outside of the node and into the animal classes, where it belongs. As cats and dogs are both animals, lets also create an class which both extend: 

Note that I rearranged the if statements for more readability, and used the method for all messages, instead of using echo. Naming 

You'll notice that this doesn't actually work! The reason for this is that strings as well as true evaluate to true with weak comparison. So instead, I'll need . And I will need to remember to use strict comparison each time, as I will otherwise have a - possibly quite serious - bug in my code. The main problem is that you are sending error messages via the same mean as your return value, which just complicates things. There are three different solutions that come to mind: 

As for the structure: Sometimes, it helps to think about the real-life situation: Is it the responsibility of the hand or of the player to get cards from the deck? Generally, it's not, and the class shouldn't be responsible for it either. Your class is also quite static. It is hardcoded how many cards a hand can have, so you cannot for example play Omaha. The way cards are added to a hand right now, you also cannot play a game where cards are added at different points in time (for example Stud). A more reusable and practical class might look like this: