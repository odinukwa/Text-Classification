Yes, absolutely. Like Michael said, this is a very common problem that students will face, so they should definitely know how to handle this case. 

I don't think either one is very obviously better or worse than the other. They're very similar in a lot of ways, especially if you haven't used either one at all yet. Honestly the best thing you can do is try out a few hello world programs in both and see which one you like better. I will also say that neither one of these is used extensively in the real world. Everything is either a web app or a mobile app. I can only think of a couple of Java-based desktop applications. I'll also add a shout-out to Processing, which is a Java-based language (which can be used as a Java library) that makes it easy to create visual, animated programs without all of the boilerplate that Swing or JavaFX require. Might not be right for your class, but definitely worth checking out. 

Make sure you teach these in an engaging way. Have them write programs that play simple math games like higher-lower or the subtraction game. 

The function fails to change the value of the parameter, because it's pass-by-value. But then the function also fails to change the value of the parameter- because it's also pass-by-value. I also really like Cup Size -- a story about variables and its follow-up Pass-by-Value Please to explain the difference between pass-by-value and pass-by-reference from a Java perspective. Now, as for whether you actually bring this up to your teacher, I'm not sure. If I were you I'd probably just bite my tongue and move on with my life. 

I'm not saying you should spend half your course on this catch-up, but spending part of your first class on this, and assigning a few token homework assignments to make sure everybody is on the same page, will go a long way. Taking a step back, you say that it took you a few weeks to realize that students weren't at the level you thought they were. Why did it take you so long? You should be finding this stuff out as early as possible, and correcting it before you start throwing tests at them. That makes it sound like you were lecturing without really engaging the students or making sure they understood what you were talking about, which is not great. Instead, you need to make sure you're engaging students by meeting them at their level. Understand that they don't have years of experience, and that they might need to be reminded of things that you think are obvious. A little bit of understanding your students will go a long way here. 

I say they need to understand this, because too often I see students who don't understand what the difference between path and classpath is, or who don't know what the red squiggly lines in their IDE are telling them, or who rely on auto-complete and copy-paste for everything. All of that being said, I think you should start with a very basic text editor and the command line. Spend some time there and make sure they understand the basics. Then as their projects get more complicated, they'll naturally see the benefits of using an IDE. Present the IDE as a solution to the problems that they're already experiencing. 

It's pretty easy to compare the CPU power, RAM, and hard drive space of a phone to an early computer. Maybe pick a few computers from each decade and plot them out. But something that was really effective for me was hearing stories from my (older) coworkers. About how they had to store their code on punch cards and run their programs at midnight every night because it was the only time the mainframe (read: only computer in the computer science deparatment) was not being used. About needing to wait another 24 hours to run their code again (which they fixed using tape and hole punches?). Compare that to modern development, where my IDE updates several times a second whenever I'm typing code. I don't know if you should organize any of this info into a lecture though, as like you said it all comes off as a bit "back in my day we had to walk uphill to the mainframe- both ways!" Instead, maybe try to start a discussion about how much technology has changed in the students' lives, and then work backwards from there. 

Shameless self-promotion: I've put together a series of tutorials that cover all of these topics, available at HappyCoding.io. I'd be happy to help adapt these tutorials into an introductory curriculum. 

This program shows a window that draws a circle wherever the mouse is, 60 times per second. Hopefully this gives you an idea of Processing and the general approach. From here I'd cover these topics: 

Create a GUI that resembles a console. Note that this should be further broken down into individual pieces, like create a text area box that shows the output of anything you run, and create a text field box that allows users to input commands. Allow users to run commands using the input field. This will involve taking commands as string values and converting them into system instructions. Take the output from any commands that are run and display it back in the text area we build in step one. 

Show them why having separate CSS files makes their lives easier. Step 1: Give students an assignment where they create an HTML page with a bunch of elements that use the attribute for inline styling. Have something like 10 buttons with the same background color, 10 paragraphs with the same alignment, etc. Step 2: Now have them change those styles. Have them change the background color on the buttons and the alignment on the paragraphs. The point is to show them how painful this manual process is. Step 3: Now introduce the concept of css classes and separating CSS into its own section or its own file. Have them modify their HTML to use this approach instead of inline styles. Step 4: Now have them change the styles again. This is a 2-line change instead of a 20-line change. This assignment will be much less tedious than the previous one. This approach will motivate students where they live and show them the real-life benefits of separating your CSS styles from your HTML content. Then you can introduce some of the other benefits that the other answers discuss. 

And the answers to those questions should be as obvious as possible. I should see at a glance specific examples of what you're capable of and interested in. A portfolio should highlight specific examples of stuff you're good at, and stuff you want to continue doing. In other words, do not include the minutia of every assignment from every class. Don't even include every class. Maybe list the more advanced CS classes you took, and then showcase your final projects for those classes. If a recruiter / interviewer / whoever sees a student page that lists every course they've taken, they're going to just close the window without reading anything. You should make it as easy as possible for the reader to get an idea of what you're all about. With that in mind, you should also provide embedded demos if possible. Don't bother linking to executables that require a download, because nobody is going to download anything. If you can't provide an embedded demo, then screenshots or animated gifs are good enough. Also, simple website creators like Weebly are good for some things, but not for creating a computer science portfolio. Having a site like that is a bit like having an email address: it's fine for some people, but it's probably not something you want to put on a computer science resume. Instead, I'd recommend putting together your own basic HTML page. It doesn't have to be fancy, but it should be yours. I really like GitHub Pages for this sort of thing. 

I highly recommend checking out a language called Processing. Processing is designed for novices, and makes it easy to create visual and interactive programs without a ton of boilerplate. Here's an example Processing sketch: 

Forget Google search. Your phone is more powerful than the computers that got us to the moon. Some random articles I found: 

With the way Java works, the really big object goes out of scope at the end of the or block it's declared in. That means it can be garbage collected, and that's awesome because we don't have to worry about it anymore! It's possible to have function-level scope (like JavaScript), so the students' intuition isn't wrong. It's just that Java chose a set of rules to allow garbage collection to happen sooner rather than later. But as a result, this also means that you can't use a variable outside of its scope. 

Michael's answer is already pretty spot-on, but I wanted to offer another angle: you need to break your problem down into smaller pieces and then take those pieces on one at a time. Those steps should be in English, not in code. If you aren't sure what code you need, then you haven't broken down your problem into small enough (English) pieces yet. That process of breaking things down into smaller pieces is one of the most important skills in programming, and it's very hard to teach (and learn!). The only way to learn it is by going through it, over and over again. Think about it this way: every time you had a homework assignment that you didn't know how to start, the real lesson wasn't about syntax or regurgitating code. The real lesson was the process of taking a larger goal and breaking it down into smaller pieces! 

I'm not so sure what you're talking about is a great idea. Students should be writing a lot of throwaway code, especially at the beginning of their education. They should be learning, writing code to test what they learned, and then moving on to the next thing. Part of being a student is writing code that, 6 months from now, will look like garabge to them. "Why would I have done it this way?" This is a completely normal thing that everybody feels, and it's a sign that they're learning and improving as developers. But it also means that students shouldn't spend a lot of time polishing their code. Instead, move on to the next thing. The rest of it comes with experience. Don't worry about "design" so much, and just focus on writing code that works. Forcing students to work with code they wrote weeks or months ago is just punishing them for learning and improving. 

You might also explain the concept of minimum viable products. It might also be useful to mention feature creep and bike shedding. A lot of this just comes down to communicating your expectations. 

I think it's detrimental, to both computer science and education in general, to think of "computing" as a separate topic from the more "traditional" subjects of reading, writing, arithmetic, art, etc. Computer science permeates our lives. It's used in pretty much every subject and every job. And it's not just the surface-level "here's how to use Microsoft Word" stuff, so I urge you to get as far away from that type of lesson as possible. Instead, think about the intersection of a particular subject and computer science. Some examples: English / Language Arts 

There are a ton of online courses, and which one you'd take depends on exactly what you want to be doing. Programming is a huge topic: there's web development, server-side development, database management, robotics, machine learning, system programming, etc. First figure out what you want to do. Then start searching for tutorials and online classes. 

Shameless self-promotion: I've written a bunch of tutorials that start in Processing and then "graduate" to more advanced topics available at HappyCoding.io, and I think they're pretty amenable to a classroom environment.