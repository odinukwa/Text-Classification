I want to use hardware filtering to smooth out colors in texels of a texture when I'm accessing texels at coordinates that are not directly at the center of the texel, the catch being that the texels store 2 bands of spherical harmonics coefficients (=4 coefficients), not RGBA intensity values. Can I just use hardware filtering like that (GL_LINEAR with and without mip mapping) without any considerations? In other terms: If I were to first convert the coefficients back to intensity representations, than manually interpolate between two intensities, would the resulting intensity be the same as if I interpolated between the coefficient vectors directly and then converted the interpolated result to intensities? 

It's hard to read code of other people, but I think this is one possible (purely brainstormed) workaround, although of course I'm not able to test it: 

I think your error is in the parser. The code after the lines if('v') and if('f') always enter those branches (you're basically saying if(true) two times). So your code basically pushes something back into the vector every time the loop executes (I think this is basically once for every line in your file? I'm bad with C functions). I think you mean to say something like 

Can you recommend a scripting language which allows me to easily parse "one-liner" types of scripts (they're just commands, really)? For example, a C/C++ function which simply sets the value of a 2-dimensional vector (position, for example): 

Of course I can't say for sure since I haven't played all the games that there are in the world, but I seriously doubt that such a thing exists. I even doubt that it is viable. Here's why: A large part of the fun in these adventure games comes from figuring things out from beginning to end. If another player partially does that for you (because you just joined the game, or because the game requires you to only solve a part of the puzzle) it kind of takes away the fun. Adventure games are usually lengthy affairs, where you spend a lot of time in single chapters of the game. Having multiple players play this kind of game together would require them to play together for a very long time, which rarely works out even if you have buddies who want to play with you. And last but not least: Adventure games are story-driven by design. I find it hard to imagine that these kinds of games would have a lot of replay value. But of course, if you have some awesome idea to actually put this into practice, everyone's welcoming you. The gaming market is certainly not oversaturated with original ideas. 

You do need a fragment shader (it's required by the standard), but you can just provide an empty fragment shader. shadowmap.frag: 

Let's say all the AI knows about it's surroundings is a pixel-map that it has which clearly shows walkable terrain and obstacles. I want the AI to be able to traverse this terrain until it finds an exit point. There are some restrictions: 

Just to make sure that I don't just draw them on the screen reversed, this is how I actually display the textures: 

(On my system, didn't test it anywhere else) In GL, instancing a single mesh (drawing with count = 1) has some nasty overhead, but I don't know where it comes from. I strongly suggest not doing it. I tested this in a practical application a couple of months ago. I coded some global illumination algorithms in the Crytek Sponza scene, which consists of roughly 350 or so meshes (don't remember exactly), of which a couple share a handful of instances. At the beginning I did it like you suggest, just instance everything and draw the rest with instance count of 1, since it simplified the rendering code a bit. Later when optimizing the renderer, just switching back from instancing the count=1 objects to submitting them the usual way saved me about 3.5 milliseconds per frame worth of time on an i7 3770k (and GTX 770). Switching the meshes with multiple instances to just doing them the traditional way saved me another 0.5ms. Overall the application went from ~120 FPS to about ~230 FPS. These figures of course always depend on where the bottlenecks are in your application, and the latter 0.5ms might actually become a slow-down in an application where you're very draw-call bound. But otherwise, in my experience instancing has some nasty overhead if you're not drawing a lot of things at once. 

If you already know D3D, then it's only a matter of getting used to the API. For that, specifically these three tutorial series should cover everything you need to know. For other stuff, the official OpenGL reference pages are pretty excellent and rarely leave questions open. 

How does one usually go about this? Is this something that generally an artist has to do manually, or are there decent procedural methods (such as with normal mapping where one can look for gradients in the texture) to generate specular maps for textures? 

I now need all the largest possible (straight) lines around the two bodies inside that map. There are no additional required attributes to the lines. In this image, I've marked the lines that I'm trying to find, each one with a different color to make sure there are no confusions: 

When I use "normal" spot lights as presented in tutorials such as this (with the exception that I use inverse square fall-off and then gamma correction), the spot light doesn't behave like a real spot light would, because in real life I would expect a narrow spot light to cast a brighter light than a broad one. In my primitive understanding this is because the light that would be cast outside of the spot lights casting angle is reflected on the inside of the spotlight device (e.g. flashlight) and effectively cast inside spotlights cone. The spotlights usually presented in tutorials do not account for this, because the light calculation is still based on a spot light that distributes all of its energy evenly in a 360 degree radius, and the light that isn't visible is simply "clipped away", thus removing energy from the system. My question is this: I plan on accounting for this by just multiplying the outgoing color by a factor that depends on the casting angle of the spot light. The function of this factor is just