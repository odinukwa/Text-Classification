Realistically you could have every certification known to man, and you will probably get a job. But in the same respect you could have never stepped foot in a school, and have some amazing demos with your name on it, and get the same job, if not a better one. Ideally, both is best. I'm studying at a college in Canada for a diploma in Game Development. So they do exist. 

Is SQL fast enough to handle this kind of data traffic? Or would it be better to store it all in memory? Or is there some alternative (such as paging) I haven't considered? 

However flash is a prissy little nitwit when it comes to communicating client side to client side. The only realistic options I can see would be to create a second client interface in another language (say .Net) that would be used to interface the AI agent, the player would then login to the flash client and enter games/observe in the above mentioned manner. OR the flash client would create a second socket pointed at the local host. A suitable API would be created to manage the communication protocol (as a DLL or similair) that would handle all data values of the game, and sending commands. This API would be extended by the users AI agent, and the player would login to the flash client and join/observe games. 

The above represents one piece, moving one space down from the top corner of the board (assuming 0, 0 is the top left corner). You may also notice I chose to use a multidimensional array for the move. This is because pieces may theoretically move a great number of times in one turn (for 'jumping' other pieces). So let's pretend at 0, 1 there was an opponents piece, meaning we would land at 0, 2: 

The above assumes you can cycle through each piece to find all it's legal moves, then given a collection of all the legal moves somehow choose the best one (strategy here). The move is then applied to the board, or throws an error. Then the next player takes their turn. So we have an AI that knows how to play! Joy! Moving on. 

This gives us a way to describe any move on the board. Yay! Now since I don't fully understand the rules of the exact game in question (although I've played a bit of Canadian checkers in my day) the exact move legality will need to be defined by you. A good flow up to this point would look like: 

In a perfect world the flash client (Using an MVC type model) would be able to interface in some way with the users AI agent, handing data to the agent, and receiving commands from the agent. In this way the user could observe the game in the flash client while in play, as well as choose games for the agent to participate in. This model would be ideal for debugging purposes, as to not interrupt play on crash, and since commands can only be sent (with malformed commands being ignored, with an error callback) users could pick out major bugs quickly. 

The game I'm working on currently has a Client in Flash AS3, and a Server in C# (multithreaded). Currently I use mySQL to handle logins (Raw access: no middleman for accessing the database) which seems to be extremely quick. My question is would using a mySQL database be quick enough for a fairly simple real time game? My game functions in a similar way to Diablo2, League of Legends, or even Starcraft: 

That should give you a good jumping off point, it is only one method of literally unlimited possibilities. You could theoretically build a giant robot to draw with crayons then conduct spectral analysis on the drawing to choose moves... but it wouldn't work very good, or fast. This way has worked in the past, and worked well (: Hope that helps! 

Now if we had no server, one of the player's must be the source of truth (or worse still a shared truth). This is where being laggy AND the server causes everyone else to be laggy regardless of how awesome their connection is. Being a laggy server is like being a bottleneck. 

Overview The game is a multiplayer simple real time strategy housed in a Flash application. Players run the Flash client, and are connected to a server written in another language (the language is irrelevant). Players compete against one another in games of 2~8 players. My aim is create some way for people to create an AI agent to play in the same realm against human players, or other AI agents. Akin to the Broodwar AI competitions, but in a much simpler game. 

Pretty simple eh. The program should understand that if we skip a space we are jumping another piece (or else it's an illegal move, and should throw an error). Now let's jump two pieces: 

Winning Simple games are wonderful, because winning is defined by a very simple state. Ain't no white pieces on the board? Well I guess you've won! This is implemented in step 2 when we choose the best move to take us closer to the winning condition. To make some very intelligent AI you could keep a database that stored every possible board as a state, with every possible move from every possible state, to find chains towards winning. You could also create strategies, like: if there is a piece that WILL be jumped, save that piece or if a piece is able to jump more than one other piece do that jump. 

Now, the game has been designed in such a way to minimize server calculations, while still providing zero trust to clients. Is it possible to use SQL in a way to store and manipulate all game data, for each game? ie: 

So we keep track of which pixel we are putting on screen (blitting) and the location we are at in the texture. We start the for loops at the top left pixel of the texture to be drawn, and we iterate through to the last (bottomright) pixel of the texture to be drawn. But once the user zooms out to a ratio of say 10 pixels on the tile = 1 pixel on the screen, we need to handle what should and shouldn't be drawn. The easiest method is to simply skip pixels: (assuming you can find the topLeft and bottomRight * scale pixels) 

So when the computer needs to make a move it simply looks up the board state (stored as the primary key) in the database, and can either choose the best move (should be unbeatable) or one of the other moves to make a more friendly AI. Great now let's build this database. First we need to calculate every board state. Which can be done with a great big nasty loop, if someone wants to spend some time and work it out that would be awesome. Look at the array as one big number, then count upwards, except in base 5 (0, 1, 2, 3, 4), and condition that each player may only have 16 pieces. At this point we should have every board state stored and can go through calculating all possible moves. Once all possible moves are calculated comes the fun part of pathfinding the best possible moves. This is where my knowledge begins to fall short, and things like Minimax or A* start to come into play. Sorry I can't be of more help on that :/