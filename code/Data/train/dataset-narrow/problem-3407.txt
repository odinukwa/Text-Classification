I'm not sure whether I've seen mention of this here before or not. Anyway, I have a B+ with enabled so I can run an external USB drive off it. There's never been a problem with this, but usually the pi is plugged into a dedicated 2+ amp adapter. Just now I had it instead running off a 3.8 A powered hub, which I think is unregulated. Anyway, I plugged in the HD and suddenly the red PWR led started blinking steadily, about 1 Hz. The pi itself remained operating and responsive and the blinking stopped when I unplugged the HD. I shut the pi down, plugged it in with a dedicated adapter, and put the HD back in, everything is fine. Is this a documented/recognized feature of the (some of the) newer (+ and beyond) models? 

The last is needed if some other module depends on it, since blacklisting is not enough to prevent loading of dependencies. You can create a new file in that directory if you want, make sure to use the suffix. A possible issue with this method is you may have to run afterward to make it effective, meaning you'll have to use the cmdline.txt method first, to get the system running. I'd try this one first (without being able to call , obviously) just to see. 

1. Horrible, misguided, absurd. One of the first things I do with a Raspbian install (sometimes, before I even boot it the first time) is remove the user completely and snip out most of the nightmare in . 

There are two partitions on the card. The first one is small, ~60 MB, and formatted with a FAT32 filesystem. Pretty much any operating system can read this. It contains the bootloader/bootstrap firmware, OS kernel, some configuration files, and a variety of device tree overlays. That's what you are looking at. The second partition is much larger, (I think ~2GB with jessie lite but it may be more) and formatted ext4; this is the root filesystem which contains the directory. When running, normally the first partition is mounted on in the root fs hierarchy. To read/write ext4 on OSX I believe you need third party tools or to use a VM running some GNU/Linux based system. 

You would not have the same potential with that -- the pi GPIO pins are processor pins. They are the kind of thing that is used to implement a bus (such as USB) from the processor to a peripheral. You could simulate the concept with a peripheral on the other side of a bus, but it is hard to see who would want to use such a thing and for what. Keep in mind the pi is not a piece of consumer electronics. Although it is used as a media player, I think if that kind of thing is your primary interest, then other than being really really cheap it does not have much going for it. Put another way, if you are looking at it in terms of the kind of things you would do with a smartphone, it is not for you -- you will only end up disappointed and frustrated. 

You can simply create this file, make sure it is owned root, group root and set mode 0644 (owner read/write, group and other read). You can then add whatever lines you want. E.g.: 

There's a couple of ways you could prevent from using period; the first one is via a mechanism provided by PAM; it may differ slightly from distro to distro but the description on current versions of Raspbian from is: 

The connector on the pi is in the wrong position. It's starting at the second pin down on the outer row, which is a 5V power pin, so the other two pins connected to the TTL jack on the printer are GND and TXD. Presuming the black wire is for ground and that cable was built to cross the lines properly (it is impossible to tell which pin is which on the printer, but the jack seems to fit in only one way, so if it came supplied from Adafruit it should be correct), then you want to move it one pin down, so there are two pins above it (considering the short end of the board with the USB & ethernet jacks as "below"). If you look at the full size image from the Adafruit guide this is easier to see (also there are lots of diagrams of the breakout online explaining what each pin is; going by that one you wanted pins 6, 8, and 10, not 4, 6, and 8). Since the pi is still running I don't think accidentally attaching 5V to the ground of the printer will have damaged anything (although see ppumkin's comment below for a more refined opinion about that); I think it would have effectively disabled the serial connection. The major risk here would be shorting the 5V to ground, but if that happened the pi would be junk now. However, since this means they were connected TX to TX, if the printer did output a wacky signal voltage then the UART may be damaged. If you connect it properly and it works, then no harm was done. Again presuming the cable crosses over properly, the middle wire yellow wire would have been from the Pi's GND to the printer's RX, and that is harmless (it also means the printer's RX line would never have gone high, so chances are it did not even consider there to be any connection on the TTL port). 

This seems odd considering it looks more or less like file sharing software -- unless of course it is interacting with hundreds or thousands of other nodes at once. I guess it is up to you to decide whether that is appropriate. 

A "full desktop environment" may be ambiguous since the technical definition of desktop environment in the context of the X stack is not something that is required to run a GUI app. All you need is the Xorg server running and the GTK libraries installed. This is probably less than 100 MB of physical RAM. Note that like everything else desktops don't consume much (or any) extra CPU except to the extent you are actively using them (moving around, opening and closing windows, etc). 

You don't need the system running to configure sshd, and I think the stock raspbian (and probably other distros) will start the server by default. They certainly will have it pre-installed. So you can, for certain, set this up without the pi, meaning you don't have to worry about the monitor. Mount the SD card on your computer and configure /etc/ssh/sshd_config to allow root login, add your public key to $HOME, etc. That's the easy part, presuming you know how to configure sshd. Next, check that sshd is actually set to start in /etc/rc2.d (runlevel 2 seems to be the default on raspbian, although it seems like 3 to me, but those directories are more or less the same). If you see or something in there, you are good to go. If not, you can just add such a symlink (the target is ), which will work although you may want to do a more proper debian services thing once the system is running. 

Crontabs are managed by cron, a system daemon started by init, which on Raspbian jessie is systemd. Exactly when a service is started in terms of time depends on what it depends on, and a degree of indeterminacy, since things that do not depend on one another may be started in parallel. You can get a fancy graph of everything from the last boot with --- unfortunately, the plain jane text output of won't include because it isn't part of the "critical chain". However, .svg files are viewable in a web browser (and you should be able to text search them there as well). Here's an example from a headless Pi running Jessie, with enabled -- you'll have to "open image in a new tab" to make this legible, and S.E. does not allow .svg uploads, so I converted it to a .png, which are not text searchable. 

The Broadcom datasheet linked from raspberrypi.org in Bo≈°tjan Jerko answer is a great reference; for example, section 6.2 describes the various functions that can be assigned to each pin as per joan's answer. To summarize the meaning of the ones indicated on your card: 

Those files are part of the kernel sysfs. They are not files on disk, they are nodes in memory and function as a language agnostic API for using the GPIOs; when you read such a file, you are requesting information from the kernel, when you write to one, you are asking it to do something. So in C you would do something like: 

Odd this is still there since it is supposed to disable itself after it is run -- but that might not happen if you ignored it. That might relate to the keyboard thing. If possible you should plug in a monitor and see if it pops up post boot. In any case this is something else you might as well disable. 

I'm guessing you are logging in via the default GUI display manager, . Different display managers have different attitudes toward using start up files such as and . Technically, they're not obliged to do either thing, since they aren't login shells, and you aren't calling or . This is approach taken by . However, it (or rather, X itself) will execute and . The easiest thing to do is move your stuff into that. There are other solutions to this problem online if you search "lightdm xinitrc". 

The ampersands here are critical. Also, if you are not used to using shell scripts, they need to be executable when invoked via a shebang (the first line) -- . There's obviously all kinds of other information you can include here if you want. The line at the top means all output will be redirected to . An example of the output from this: 

I'm not a Cmake user but what you have done probably doesn't set , since this is a runtime environment variable, and even if it is used in compilation, it may have been set in a subshell, which will not affect the parent shell when compilation is finished. Try: 

The user in is a matter of intentional configuration, which can easily be changed in minutes. In contrast, an unintentional bug of the sort involved with cannot be changed by the user, period. If you own an OSX system with this problem, there is absolutely nothing you can do to protect yourself from it whether you know about it or not. The system requires a linker. Going back to what "intentional" means: It is explicit. If you understand how the system works, then you will recognize it is possible for a user with the pi password to execute total FUBAR commands. This is not a mistake or a secret. It's right out in the open from the beginning. 

The GPIOs on the Pi are on a regulated 3.3V circuit. This is true whether they are set as outputs or inputs. If you attach them directly to a 5V source, including the pi itself, you may damage them permanently. This doesn't explain why the pin fluctuates with the button up unless it's because you already damaged it. Try using a different pin and 3.3V but you need to use a resistor in a button circuit. There are many examples and explanations of this online if you search for "raspberry pi gpio button". 

I have a nano size wifi adapter and an el cheapo wireless keyboard/mouse combo, they are useable together, but I would not recommend it. The keyboard often repeats, which I believe is related to the "underpowered" issue. However, you mention a hard drive. The pi only has two USB ports, so it's physically impossible to plug in a drive, a keyboard, and a wifi dongle. If you are considering an adapter/unpowered hub to increase the number of ports: don't bother. As is, the pi does not come close to meeting the USB 2.0 power standard (500 mA per port); I don't see anyone claiming you can expect more than 150 mA TOTAL. If you have a good reason to believe you can plug in a drive and have 200 mA left over, please share it. Otherwise, if you want to do this you will need to use a powered hub. If you are intending to use this rig as part of your education campaign, I recommend against the pi. While it was designed for educational purposes, the educational purposes it was designed for involve educating people about computers and electronics, and not serving as a general purpose computer. By the time you include a display, SD card, keyboard, wifi, a drive, and the powered hub (and/or power supply), you are up into three figures -- for that money you would be better served with a cheap Android tablet or netbook, which are intended for general purpose use. 

There's no library that needs linking. I've used this to write C++ based interfaces to various I2C sensors, I'm sure it can be made to work with an RTC. The API isn't the complicated part, it's figuring out how to use it in relation to a datasheet. I did notice that sometimes that using a or on the file descriptor in a manner that should have duplicated an function did not produce the same result. I mention this because if one method does not seem to work, try the other. 

Because it is being thrown from the block, which happens no matter what, including if fails. If you then call on a lock you do not hold, you get an . $URL$ You could use to check if this thread actually holds the lock before trying to release it, or you could ditch and unlock in the block. 

As per comments, it is simple enough to create a boot service that runs only once, or runs until some criteria have been satisfied, then it simply disables itself (). However, from the sound of things, you don't want to have to run the image in order to install and enable a new service. Technically this is not necessary; all you have to do to enable a systemd service is create symlink to the service file in an appropriate subdirectory (e.g., if the system will be running a GUI or otherwise). If that seems like too much work, rather than adding a file you can replace one: , and start whatever from there. 

I presume you mean video and the answer is yes. However, it may be difficult to get low enough latency to make it viable for controlling a remote vehicle -- there may be a lag of several seconds. 

They aren't necessarily different, although there may be different methods available for you to choose between. You can choose to use exactly the same method on both boards. If you stick to using the interface, your code should run without modification on both devices, so if that is a priority then that is what you should do. If you are unclear on this, see the kernel docs. If you have specific questions about that, feel free to ask. The sysfs interface uses file nodes and hence is language agnostic. The use of file nodes does NOT mean there is some significant I/O overhead involved. There may still be some extra cost in the use of and because these are system calls, meaning, they require the execution of kernel space code, but that does not mean that they require waiting on I/O with some peripheral device other than main memory, which pretty much everything including mmap'd methods must do also. Things like wiringPi instead use to access a region of memory exposed via the the kernel's interface. So the major difference between the two would be that using the sysfs method uses the kernel gpio driver, whereas the mmap method bypasses that. It does not, however, really bypass the kernel -- the kernel implements just as it implements the gpio driver. However, manipulating the map can be done completely in userspace code without invoking the kernel (hence no overhead for system calls). So, the advantage to using the hardware specific mem-mapped method is that you may get lower latency with very fast transitions. However, this may or may not be significant depending on context: you still have to do this from userspace on a multi-tasking system. Again, if you want your code to work on something other than the pi, don't use a pi specific method unless you are sure you have no other choice -- use the kernel sysfs based interface. 

Yes, but those are unlikely to fit a VESA mount. A quick look with a search engine at "raspberry pi vesa cases" reveals that the VESA spacing of the four screw holes looks broader than the base of the pi in most cases, hence the case has a bottom plate that extends beyond that. There are actually a set of possible dimensions, and a set of possible places on the monitor. Which one(s) your monitor uses is probably dependent on its weight. Some cases refer to "75mm spacing". This is across; the long dimension on the board is 85 mm. The smallest VESA diagonal is 100mm. The diagonal of the board itself is about that, but of course it is not square. A common configuration for the VESA cases seems to be using two holes with 75mm spacing. Having the mount holes on an exterior part of the case may be better since it would make getting it on and off the back of the monitor easy. Anyway, you should investigate your monitor and go from there. You might as well then just use a search engine, since if a case is VESA compatible but not described as such it is a bit useless since you need to know compatible with what spacing.