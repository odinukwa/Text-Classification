Expanding Shiro's comment: You could increase the speed the game updates to a higher fixed rate (as long as you know beforehand it can handle that FPS). While this isn't really SOLVING your problem it will at least reduce it's effect. You could either set the FPS to a specific amount: 

By multiplying the Speed variable by how many seconds have passed since the last update you end up moving the XPos at a consistent rate across varying frame rates. TL;DR - Change your movement variables to take into account the ElapsedGameTime so they run at a steady rate. NOTE: When using a FixedTimeStep you often do not have to take into account the elapsed time as it is usually steady, but it's still a good idea. 

I'm working on a small Unity 2D project in which I need to modify the collider of the player at runtime. I'm using Physics2D.Raycast to find the collider and then what I'd like to be able to do is then copy that exact collider over to the current gameObject and remove the current collider in the process. Basically when my Ray hits an object, I want my player to turn into that object. I'm fairly new to Unity and have been digging through the API for some hints but haven't found anything yet. Any help would be appreciated. So far all I have is as follows: 

CmapTools was used to create this image, which is a visualization of a Choose Your Own Adventure book. This might fit your needs, even though it's not specialized for story-writing. 

To reduce the amount of statements you have you need to make your solution data-driven instead of manually adding logic for each UI component that needs to interact. You could do this by storing your buttons data (such as each buttons bounding box and state) in an array of structs or a NSArray (or NSMutableArray) of classes. Then when you receive a touch you just need to iterate over the list to see if any touches are inside the bounding box, if it is then update that objects texture. To keep track of touches across their lifetime I use a single NSMutableDictionary with the touches pointer as its key and a custom class as its value. This allows me to store information per touch (such as if I've already handled it) and react to touches that are held and not moving. 

I agree with Daniels answer, in that iterating through large amounts of boxes is the most likely cause, and that by using spacial partitioning you could speed the game up a lot - but the problem could also be elsewhere, and you could be wasting your time. In order to increase the speed of your game significantly you need to profile your code. Identify where the bottleneck is, this will allow you to make the biggest improvements. There are lots of ways to profile your code, you could roll your own performance analysis class (which could make use of the Stopwatch class (MSDN)), or you could use PIX to get a general idea of how busy the CPU/GPU is. You can also put PIX event markers in your code, which will show up as colored regions in PIX's readouts. There isn't an official C# interface to these functions, but this thread shows how you can make a C# interface yourself. 

AFTER READING EDIT: You cannot change how fast the game will do it's draw calls. What happens is that on a fixed timestep your game will attempt to do one update and one draw call at a steady rate (usually 60fps). If it cannot keep that up for whatever reason then it will lag. On a non-fixed timestep your game will run as fast as it possibly can and you would NEED to take into account the GameTime in order to have a stable game. If you are experiencing frame stutter then you probably need to take some time and figure out where the bottleneck is. Make sure you aren't looping unnecessarily and that you aren't drawing things that are off the screen and don't need to be drawn. It sounds like you weren't considering the fps when doing movement calculations. What you are doing is indeed slowing down the frame rate. The consequence of doing so is that now your game will have half as many updates, and most likely you are not taking the frame rate into account when considering movement, so this means everything moves at half speed. For example if you were moving a sprite around like the following: 

And then press left and follow your code through to see if it does what you think it does. My best bet is that there is a problem indexing the map array; you should verify that the coordinates that are accessed are the correct coordinates. I did notice some things that could potentially be the cause: You said the map is an array with three components: [LAYER][Y][X] but then your calls to GetValue index in another order: LAYER, X, Y (although I guess your GetValue function probably does switch those around). Also I'm not sure why you are doing (x/size) in UpTile/DownTile/RightTile/LeftTile - if x is smaller than 64 (and is an int) you'll get 0. Also, I presume: 

Supporting functions I had to write a function that would find a key in a dictionary given a value, since when backtracking we know the id of the room we are trying to get to, but not which door to use to get to it. 

If you need certain sprites to move between tiles smoothly such as bomberman himself or sliding bombs you could store an additional offset as a float. 

You can find out what the SpriteSortModes do here, but Deferred is usually what you'll want. It's really worth it to familiarize yourself with the other parameters though and you can find them on the MSDN docs as well. 

If you are looking to use a Matrix as a camera and to scale and rotate the scene then spriteBatch.Begin() is indeed what you are looking for. Now I know it looks like a lot of parameters but you can actually assign most of them null values. For example: 

Then every time your game updates it will add a value of 2 to the variable. Now since you used to be at 60 frames-per-second this meant that your variable was being increased by 120 every second (2 * 60fps). But now, Since you changed the frames-per-second to 30, instead of XPos adding 120 to it's value every second it is now adding 60 (2 * 30fps). The result is that everything is moving at half the speed it was moving when you were at 60fps. The solution to this can be very simple if you keep good coding practices. XNA provides your game with a variable. Inside this variable are two very useful values, and . ElapsedGameTime gives you the amount of time that has passed since your game last updated (your frame time). TotalGameTime gives you the amount of time that has passed since your game started. Using ElapsedGameTime you can make your game run independent of the framerate. Borrowing from the earlier example: 

Each state needs to check if any relevant events have occurred. Typically this is done with if statements. 

Y is usually upwards in 3D, but the designations of the axes are rather arbitrary. To keep it simple I'd either have: 

I would suggest doing this manually in software like Photoshop. In Photoshop there's a filter called offset which scrolls the image by the given amount of pixels. If you offset by half the images width and half the images height you'll see the seams in the middle of the image. You can then alter the image until the seams are no longer visible. When you've done that, use offset again to make sure you haven't created any new seams. This tutorial may be of help. 

and then you would only use Vector in your code. This would only work if you weren't planning on switching Vector classes at runtime. If you did need to switch between them at runtime you could use a factory, which would create the required class and return a pointer/reference to the base abstract class. In practice for performance reasons I'd rather rely on refactoring tools (e.g. Visual Assist) to rename functions and classes unless I'm working on a massive project or there's a legitimate reason why the classes would need to frequently change. 

So I was sitting here staring at my computer wondering why it absolutely refused to run my program, and then it hit me. I wen to my anti-virus, turned it off, and voila, it works. I don't know why Avast didn't come up with some sort of message about the program being unsafe or anything, but at least now I know what the problem was. I'm a little worried about what these means for anyone else running the same AV but at least I can start developing again. 

There are two important modifications I made to the example. The first is that the Speed value is no longer 2. When using the frame rate as a part of your calculations you need to think of movement values as how far the object should move per second. Since in the previous example we were moving 120 units every second (2 * 60fps), to get the same movement the Speed value had to be changed to 120 to match it. The reason the Speed value was changed to 120 is because of the second modification. 

If the problem isn't the one described by Byte56 and you only have the script attached to a single object, then check to make sure you have at least one camera that has Clear Flags set to 'Solid Color' or 'Skybox' (as opposed to 'Don't clear' or 'Depth Only'). 

At any point in the game the amount of possible moves for a player is quite low* (around 5) this means that thinking a few moves ahead, evaluating every possible move and selecting the best move is doable. This approach is called minimax (wikipedia). To implement minimax you'll need a evaluation function that returns a score for a given board layout and player. For draughts a naive implementation would be a function that returns one point for every piece the player has alive. 

I'd store the positions of items as integers as you are doing now in a array. Testing for a collision with a wall could be as simple as testing the map array for the wall piece, for example: 

You need a minimal test case that reproduces the problem - input a board that will be solved with one step of the algorithm, and follow it with a debugger, or print statements if that isn't possible. You can find out which return is actually returning the nil value - you could insert a breakpoint on the line previous to each return statement, or add a unique print statement before each return. Then track backwards to discover where the nil was introduced. Another way would just be to step through the whole get_best_move function using a debugger and check it's doing what you expect (the code is short enough for this approach to be realistic). Other observations: 

Again: this depends on hardware and the performance of your application, but in simple cases it will be more than fast enough for your precision. Just get the amount of time elapsed from the start of your application (or a separate TimeSpan) whenever a button is pressed and compare it. 

I've been working on a monogame project for a little over a week and had no problems. Today I went to test out the project outside of Visual Studio, by running directly from the .exe in the release folder. When I click on the .exe I get the cursor icon indicating something is loading, but nothing ever does. No window shows up, even though I see processes related to my game in the task manager. Also when I try to end mygame.exe in the taskmanager it doesn't work and the process still sits there. I've tried both a Windows and Windows OpenGL monogame project and both hang once I click the exe. Does anyone have any idea why this may be or any steps I might take to track down the issue? I'm using Windows 7, Visual Studio Community 2015 and the latest Monogame Build. My project references Farseer Physics, Lidgren, Json .Net, and my own Utility class library. Edit: I tried creating a brand new Monogame project and run it without debugging in VS and it hangs the same way running from the .exe does. Also the project runs when placed on my laptop which also has monogame installed so it's nothing wrong with the project. 

Expanded: You can use the rand() function to generate random numbers. You could use these random numbers to set the position/health points or any other attribute or your enemies. As for saving the enemies data (I'm assuming you just mean store the variables, correct me if I'm wrong) you need to store the data in an array or list. This can be done in many different ways. If your enemy is a C-Struct then you can store your enemies in a plain C-Array. If your enemy is implemented as an Objective-C class, then you can store your enemies in a NSArray class (such as NSMutableArray). 

All files in the Resources folder exist in your built application (regardless of if they are used). This allows you to load them as needed with . I believe Unity made the decision to prevent files in Resources being built into sprite-sheets because there would be two copies of the same sprite in the built app (which is wasteful). This answer on the Unity forums uses the same explanation: $URL$ 

There's a few solutions for this: Solution one (low effort) Use GameObject.Find in Scene two to find the relevant objects in scene one, and assign them to your scripts. Solution two Create a singleton manager, which will avoid the sometimes expensive GameObject.Find call. A script in scene two can reference variables mediated by the singleton.