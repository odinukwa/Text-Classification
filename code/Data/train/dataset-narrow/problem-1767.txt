These are not error messages but debug messages and are clearly marked as these. Unless you need verbose_ssl to debug a problem you should just switch it off. More background: it is showing every state it is going through when doing an SSL handshake. To display the description of the state it is using the function SSL_state_string_long from OpenSSL. This function does not have a string description for every possible state and returns 'unknown state' if it does not have a more specific description. Again, nothing to worry about. 

You can only get a certificate for domains you own. This means, that you cannot get a certificate for www.*.com, because you don't own all the matching domains (like google.com). Apart from that browsers support wildcards only in the leftmost part of the host name. What you can do is to either have a certificate for each domain you own, or a certificate containing all domains you own using subject alternative names, or something in between (multiple certificates, each for multiple domains). You also need to consider that older browser like IE6 support only a single certificate per IP address. Newer browsers can work with multiple certificates per IP address by using SNI (Server Name Indication). 

To use protocol specific features you have to use the appropriate mode. Mode tcp gives you only access to tcp specific features, but to get http specific features like choosing the backend based on the URI you need to have mode http. Unfortunately HTTP/2 looks very different from HTTP/1.x and is not support by mode http currently so you have to use mode tcp. This also means that you cannot make any decisions based on URI as long as you want to support HTTP/2. Better support for HTTP/2 is expected with haproxy version 1.7. From $URL$ 

SNI is essentially the same as the header in HTTP. The main difference is that the header is only inside the HTTP request and thus can only be seen by the web server after the TLS handshake is already successfully finished. The SNI extension instead is send within the ClientHello, i.e. the initial message sent by the client inside the TLS handshake. The server then extracts the SNI extension from the TLS handshake to find the matching configuration (which includes the certificate) the same way as it extracts the value of the header to find the matching configuration. Based on this there should be no qualitative difference and no additional limit with SNI vs header. But there will be some quantitative difference in that more memory will be needed with SNI compared to only header: additionally to the HTTP part of the configuration also the SSL part needs to be kept in memory, i.e. specifically the certificate, certificate chain and private key. 

SNI support is in HttpsURLConnection for a while. But if you do anything more advanced you are probably using the Apache HTTPClient library and Android SDK contains only an old version which does not support SNI. To make use of SNI you have to be aware of it and then you can work around this limitation, see $URL$ 

HIGH, LOW, EXPORT etc are kind of macros which include a range of ciphers. To get the actual ciphers use command, i.e. 

There is no technical reason against installing the same certificate on multiple systems if the domains on the system are covered by the certificate. There might be usage restrictions by the CA which you need to check. And since all systems with the same certificate need to use the same private key the change of compromising the key gets larger. 

Maybe or maybe not, depending if the path len is restricted to disallow a trust path of this length or not. 

This file actually contains both the public and private key and the public key could be extracted by running 

Lots of the ciphers (like GCM, SHA384 and EC) you give in your cipher string are not available with the old OpenSSL version you are using. This leaves only a few ciphers. Clients in companies are often behind some (maybe transparent) proxy doing SSL interception (i.e. man-in-the-middle attack) to analyze encrypted content for malware. In this case the available ciphers are not determined by the browser, but by the intercepting proxy. It might be that the few ciphers you offer are simply not sufficient because they are not supported by the intercepting device, resulting in . 

More proof: The TLS 1.2 standard (RFC 5246) lists in appendix A.5 lots of ciphers usable with TLS 1.2, which includes several 3DES ciphers. 

Your server sends only the leaf certificate, the necessary intermediate certificate is missing. Browsers might have cached this if they've seen it before with other sites, but if not they will fail to validate the certificate (or they might download the issuer certificate if this info is available inside the certificate). See also the analysis by ssllabs: $URL$ wich shows: "Chain issues Incomplete". 

If instead you connect to the server with SNI you get the full chain, including the root-CA (which you don't need to include, clients will ignore it): 

With this cipher string you allow only ciphers which were introduced with TLS 1.2. Since no new 3DES ciphers were added with TLS 1.2 no 3DES ciphers will be used with this string. But, no TLS 1.0 or TLS 1.1 client will be able to connect to the server since none of the ciphers you offer is supported by these older clients. While modern browser all support TLS 1.2 some applications still don't. This is true especially for older Java applications or for OpenSSL based applications on Mac OS X, since this is shipping with a very old version of OpenSSL. 

Unlikely because the client is sending a HTTPS request. If no SSL was there (i.e. plain HTTP) the SSL handshake from the client would fail and it would not be able to do the inner HTTP request. While you don't give full details of the setup it might still be that SSL is globally enabled on this server or that there is some reverse proxy in front doing SSL termination and forwarding the request as simple HTTP.