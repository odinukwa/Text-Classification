In general your code looks good, here are a few smaller remarks. Method name: Capitalize the name of your method and make it more meaningful. Use or something similar. Comments in code: You can omit the comments in your code. It speaks for itself what the code is doing, certainly because you use clear names for your variables. IsNumeric() - Char.IsDigit(): In the .NET framework, there's the method, use this one instead: 

Why not name them both the same? The difference is the type of parameter you're passing. This leaves you free to do some method overloading: 

You could filter out the type of controls you do not want to iterate. Let's say for example that you only want to get the validationMessages from only a , you can filter them out of the property by using a bit of LinQ: 

Why continue the program when the input is invalid (not numeric)? Check for a numeric value and only continue if the input is a number: 

This way of working swallows the exception. In case one occurs the default of will be returned, otherwise the converted value. Results: 

When you're using this method to store all the error messages, you can use the Enumerable.Aggregate<TSource> method: 

Can you simplify names like . No offense intended but reading this almost gives me a headache. And this isn't the only one, for example. Try giving methods a descriptive name, as short as possible. 

In the point Type constraint a bit further you'll see why. Scoping variables: You should define variables as close to their usage as possible. In your case you can instantiate the class inside the statement since you don't need it outside the statement. Example: 

I think better would be to change the signature of the method and add a boolean (optional) parameter to indicate if you want to refresh the result: 

The answer of mjolka is already showing several good points. Here are some additional remarks: Fields => Properties You're not using the fields outside the class, so why make them public? You have two options, make the fields private or create a property with a private setter. I'd prefer the second choice: 

It looks like overkill using the methods but your code still looks clean, readable and maintainable. It's up to you, use this method or the suggestion from Dan Lyons. 

There are several remarks I could tell on your singleton implementation but since there's a far more better expert than me on these things, I'll reference his work. His name is Jon Skeet and he has an article on the singleton pattern which can be found here. Here are several points from the article that can help: 

Update: If you insist on using jQuery, cache the selector in a variable and re-use the variable. Overusing selectors can result in poor performance and since you're using the selector inside a loop this can easily occur. 

As you see, you can also add other variables like the although in .NET I suggest you use instead. StringBuilder: Perhaps, using the class is even better since you're creating a long string. And then even the String.Format can look messy. Here's another short example: 

How to: Read Connection Strings from the Web.config File Stored Procedures Introduction to Exception Handling in Visual Basic .NET 

Your thinking is good: it's a small difference but... there is a difference. And you have to find a way to extract the difference out of the methods and try create a parameter from this. Small example: 

Your constructors don't handle all possible situations. What if I call with mode set to ? When you're overloading constructors, you have to reduce it to one constructor where you handle everything, if this is possible of course. Small example with a regular method: 

Naming conventions: Please follow the Capitalization Conventions for class names. The name of the class would become for example. String manipulation: This is about this line: 

Of course you can't group by in this case as it is a string property and the expects an integer. You might change the to , but please don't as that is hacky code. Since the purpose of your method is to group by a , you can implement this easily: 

Avoiding : I personally don't like writing code using references. You could rewrite your code for collecting input like this: 

Update: As stated in the comments below, you can also take the code and throw it in an extension method. Also nice for reusability and your could will also look a bit cleaner. Here goes: 

Converter method: Here you can apply previous tips like the naming, using of , the use of the method... You pass the hours to the method but you never use it, plus you parse the values of the textboxes again. Just pass them from the button click event and use the values, there's no use in parsing them again. In following: 

Storing operations/calculations on variables in new variables can be handy and even necessary in certain situations. But in this situation where you take a string, parse it to an int and make it a string again, I suggest you do this in one line. You can even add the extension in the same line: 

Your code looks pretty neat to me. I have a few remarks listed below. Variable names: Don't mix up names, this makes things confusing: 

Note that this last line will enable the item when it is checked, not only disable the item when it is unchecked. This logic can also be applied to all the if statements in the code. 

I would suggest working the other way around. Expect that a user does not exist and only return true if a user is found. 

This does not mean you have to write all your code in one line, this an example of doing too much in one line: 

This way you'll only fetch the lower numbers in the batch only if there is no higher one. In your case you're always getting both lists which is not always necessary. 

Your code looks solid, however here are a few minor points. Catching/throwing exceptions You should only catch exceptions when you are going to handle them. There's no point in catching an exception when you're only going to (re)throw it. However if you were to use logging and still 'bubble up' the exception, you could go with this: 

The Evil of Eval I suggest your read following article: The Evil of Eval() in ASP.NET. Here's one of the many reasons: 

Taking things a bit further I'd make the method an using yield return ... and when needed you can convert it to a when needed. Here, I left out putting the number in a variable as it used only once. 

Edit: I found that in your original code in the method, when making the recursive call, you don't make use of the extension-call: 

Here are a few remarks. I'm not perfect or write perfect code but I hope these tips will help write better code: Naming consistency: It would be easier to understand if the names of your two methods had opposing names. For example: and . It's obvious that deserialization will return an object, omit that in the name. Also, if you're using the same type/kind of parameter or variable in one method, give it the same name in the other method. Truly generic: You should make your serialize method generic too: 

Variable names: Names like , , , don't have a useful meaning, not for you, nor for others who are reading/reviewing your code. Use meaningful names for your variables, this is better for readability and maintainability. 

Edit: Since the code is not exactly the same, use the first way of solving the problem: by extracting the code into a separate method. Following code implements this: 

Your implementation is not bad for a no-LinQ solution. But there's always room for improvement. First I'll provide a LinQ solution that provides a clean way to return a chunked list: 

Now give 5 as input for and and voila... infinite power for the fella! Rethink a better way to calculate this, you could for example use a Pythagorean function: 

With you correctly used , but you should also have done it for in both methods since you know what the type is from the right side of that assignment. 

Reason: placing selectors in variables is recommended, since overusing selectors can result in poor performance. Everytime you would call a function on , the whole DOM has to be parsed by the browser. This is not the case when you store it in a variable. 

Also, you prepend the type to every name you use. for a class, for a string, etc... Don't do this. Property-names like and should be and . The name of the class becomes , and the method should be . The names of the parameters in the constructor of the class should start lower case: will become . Variables should make clear what they stand for. A name like doesn't say much, make it instead. The keyword: From MSDN: 

And as "Bobson" mentioned, mixing the ternary operator and nested if/else structures is messy. Keep it with an if/else structure or you could try this: 

Edit2: I re-read your updated code and noticed you set the text of a different textbox too, this is now implemented in my code example above. 

Methods: is something I don't understand. It is a void method but doesn't do anything important enough to be a separate method. Let it return a instead. Rewritten: 

In a situation where you store an integer as a key and the message as a string in a , you can also the String.Join method: 

keyword: Although others might not prefer to, use instead of declaring your variables explicitly. Let the compiler do this for you and your code will look cleaner. Naming conventions: Local variables and fields in methods and classes use . So, in button1_Click, will become and so on. Naming of controls: What does or mean? Right, nothing! Change the name to what the control represents. For example this would become and for the button . Parsing: If I type text in the textbox (non-numeric input), your code will throw a with following message: 

Why have a loop if you will return on the first item? If you only want to return the first entry, use the SPQuery.RowLimit property and set it to 1: 

As Dan Lyons stated in his comment you could use the instead of custom goto labels. Check the example on the link he provided. If you want to avoid using completely. I suggest you take the adding of the items out of the switch/case and place that in methods. And then, in every case you call the appropriate method to add the necessary items. Example: 

More reading on Object and Collection Initializers. Get SharePoint list: Don't blindly use , it depends on the number of lists you have in your environment what call you should use. Using , SharePoint will look for all lists in the current web-object and fetch all metadata from them. Then it compares the name you provided and return the correct list. And will make a call to the DB for each list for which info is needed. If you have a lot of lists (thousands), use the second method, otherwise the first will normally score better. Also, this depends on the performance of your hardware. But in general, I tend to avoid the indexer (using the second method or even ). The foreach loop: You have this piece of code: 

ASP.NET and code-behind One of the main advantages of ASP.NET is the code-behind model. This ensures that the logic and the markup are separated in different files. The markup's goal is to display data, not to determine whether controls should be visible or not. So, your code is in violation with that principle. 

Update: As RobH stated in the comments, you can use LinQ to avoid nested if statements. Here's how your code would look like: 

You can also implement a catch statement here to handle Exceptions such as IO - exceptions. 2. statement (better) If you're using objects that implement the interface, you can always use this statement. It ensures that the method is always called, even when an exception occurs. 

Checking for the file: In both methods an exception can be thrown in certain situations. In the serialize method, if the path doesn't exist you'll get a and in the deserialize method you'll get a if the file doesn't exist. This can easily be solved: 

I only don't understand why you set the properties through the constructor and then don't validate them. Your code now only enforces that all properties will be set, although unvalidated. Also, if you want the properties to be set through the constructor only, make the private. Example: 

Otherwise, what's the use of making an extension-method? ;) Anyway... As you stated in your comment, one can indeed not assume that a person would always want to traverse only a . Thank God for generics! :D You keep your method but you make it a generic one. When calling the method you specify the type of control you want to traverse. Here's some code I came up with. Please mind that I haven't been able to test this as this is just written out of my head: 

If you do want to throw an exception, use a try/catch block and a regular Uri constructor. This should be placed in a method and not in the get statement then: 

is coming back everywhere. So you can place it before the switch statement and place it in a variable: 

Since you don't want to manipulate the objects in the list, but simply want to output them to the screen, use the __toString() method. For this would be: 

Your and variables should be scoped inside the methods. There's no reason they should be global in the class. This way you can rewrite your to following: 

Solution Make the server-side by adding to to the tag and give it an ID. Now you can access the tr-tag from the code-behind and set it's visibility property. Example: Markup