In general is is unethical to teach people skills that they intend to employ to harm others. That said, it is hard to know the intent of your students. Do you have Beavis and Butthead in your class? Pretty problematic then. But many people the age of secondary school students make a lot of judgment mistakes. (The human race probably wouldn't exist if most people that age didn't take risks.) So you need to be cautious. Some of my undergraduate classmates were pretty off-the-wall. (We had a mad-bomber who mostly blew up harmless things.) Teaching how to make high explosives in his Chem class would be irresponsible. So, if you want to teach dangerous tools, you need to provide a safe environment (likely not the wild) and give legal and ethical guidance with strong warnings about consequences. I'll second @thesecretmaster's answer. But even if you aren't responsible for the actions of others, your life could be ruined if someone goes off the rails with things you teach. There is controversy in the industry about the place of white-hat hackers, for example. They may mean good and may do good, but bad things happen and some are in jail. Tread carefully. Teachers in martial arts are cautioned not to take on a student who displays traits of a bully. It is clearer to see there, of course. That tradition is at least a thousand years old. 

What is your current practice of teaching ethics to students, both institutionally and individually? Note that the teaching of ethical standards (not just lists of rules) has at least two elements: What to do, as well as what not to do to be ethical. Are your students required to take any ethics courses? Are those courses tailored in any way to the concerns of the technorati? Do you bring up ethical consequences of the things you teach? Are you required to? What topics do you think are most important? What can you recommend to others for giving students some ethical training? Are students required to buy in to an ethical standard beyond the classroom? Or do we simply depend on, and hope that, it happens somewhere. It would be helpful to know which courses you teach that clearly require ethical behavior and how you go about teaching it. For example IoT (Internet of Things) development has clear implications about security and privacy. How do students learn this? 

The correct statement, of course is that Java passes a reference by value. That is not the same as passing by reference. You can easily show the difference, by assigning a new object to the parameter variable within the method and then noticing that the code that invoked the method doesn't see the new object. It would be pass-by-reference only if the caller sees the new object. The confusion comes from the fact that the objects themselves are usually mutable and so within the called method, the receiver gets to make modifications. But both the caller and the called method have references to the same object. So the caller can see changes within the object made by the method. But it can't see a new object that replaces the parameter. However, if you assign to the parameter variable within the method, then the caller and the called method will see different objects. Yes, you should correct the teacher, but it is a bit risky, depending on the personality of the teacher. The best way, perhaps, is to prepare some demonstration code and show it to the teacher in the office. You can then, perhaps, offer to clarify the real meaning in Java, using your code. Personalities can be messy, of course, and not every teacher likes to be contradicted. But the students have a right to know the "real deal" if they are going to program in Java. Notice that Java and C++ are superficially similar, but deeply different. Learning both together is, itself, a cause of confusion. But in this case, the contrast can be informative. If nothing else, you can show the teacher this post from a 40 year veteran of programming, much of that in OO languages, including both C++ and Java (and author of books in both). 

You may need to add a level of peer evaluation/review to this as well. Something like the following has worked for me over several years. In any group assignment, each member of the group also submits a peer review sheet. For a group of two (e.g. pair programming) I ask each participant to detail the most important contribution of their partner AND their own most important contribution. I don't ask who worked harder or ask them to make an evaluation. I ask them for the contributions. In a group of about five, I will ask each member to name the (say) three most important members of their group and to mention the key contribution of each. I tell them that they can include themself in the list of three. I also ask, separately for their own most important contribution. I let them know at the beginning of the course that this will happen and its parameters, so it isn't a surprise. Students see that they are supposed to contribute to a group and are not asked to speak ill of anyone. Keep the questions entirely positive. But you also learn a lot from what is not said and who is not included in the contributor list. If the project happens outside your view, you also learn things about individuals that you can not otherwise know. I've had students I thought were slacking who were praised by teammates for making the team work properly. These peer evaluations are not optional. This same idea was also discussed here: $URL$ 

Actually, I think a better choice would be a true functional language (Scheme, ML, Haskell) rather than a multi-paradigm language. Of course it depends on your goals. If you really want them to learn the functional programming mindset then don't use a language that lets them escape to other paradigms so easily. F# permits programming in many ways, including imperative and OOP. So, if they have a multi-paradigm language, you can either just let them program using what is available or you can try to enforce a style that may not be natural in the language. I think this would be frustrating - more frustrating than just pushing through the needed transition of thought. However, in a true functional language you don't have the option of just "making it work" using thought patterns you have already developed when learning a different paradigm. The transition to functional can be difficult, but it isn't made easier by letting students not do it. If you want them to run, don't let them crawl. I'll note that I with a bit of a library I can program functionally in Java. But I wouldn't use that as a way to teach functional programming. 

Different names can refer to the same "object" at the same time. Different variables can reference the same thing at the same time. A given name can refer to different objects, but not simultaneously. A variable can refer to one thing one moment but another at a different moment. A given name can refer to a given object in one "place" but a different object in a different place. Here "object" just means a value of some kind, not necessarily an object in an OO language. It could even refer to an operation, depending on the language. 

First, Critical Thinking is a deep concept and in a first course only simple aspects of it can be taught. To explore the depth of it you need to have context and a novice, by definition, has little of that. See Wikipedia for a start on understanding how broad and deep Critical Thinking really is. To me, the most important question to be answered by Critical Thinking is "What should be built?" (and what not built). But a novice has no basis on which to answer such a question. They have enough to do to try to understand what can be built at the start, so you can only give a glimpse of the deeper questions then. I would suggest that any true education explore Critical Thinking in many ways and in many courses - philosophy, history, .... And that later in the CS curriculum the topic be taken up, again in several courses/classes to explore its complete depth. However, the detail in your question seems to indicate that you are more interested in Deep Thinking rather than Critical Thinking as such. I'm a big believer in teaching problem decomposition and abstraction from the first days. My courses delay and constructs for as long as I can manage while the students think about abstraction and polymorphism. I don't always do it, but prefer to teach recursive thinking before loops and polymorphism before selection. That is true even in a course in Java. It doesn't require Scheme. But some aspects of critical thinking are useful to novices. For example, the idea that if what you are doing isn't working, then do something different. Also "Ask for help" when you are stuck. "Don't make assumptions" is another good idea that can be taught fairly early. "Test your assumptions." Ultimately you want them to use evidence based decision making, of course rather than wishful or magical thinking, but that, as I said above, requires context and some "seasoning." Novices are naturally focused on the "how" rather than the "what" - especially the "what is appropriate" and "what is important." 

I don't actually know enough about Quantum Computing to say that it is different, but it is the only possible exception that I know anything about. It is possible that it will change the game fundamentally. 

Mistakes are fine. We are human, we make mistakes. In fact, one of the worst things you can do in teaching is to never make a mistake and to always say exactly the right thing. This is pretty much guaranteed to reduce the fraction of students who actually learn. A lot of things in CS need to be approached from various, more or less accurate, directions, zeroing in on the truth. Since your students learn differently, and likely differently than you, more of them are likely to pick up the thread somewhere. In fact, the most valuable thing you can do, at least occasionally is to work live in front of your students, stumbling through the forest to find the spring of knowledge. If you always do the right thing, your students will get the impression that everything is supposed to be easy. But then they ask why am I finding it so hard?. Working live lets them know that they need to go through this search for truth, not just having it served up to them. If you make mistakes, it will seem more natural and expected when they make mistakes, rather than seeing it as some personal failing. I think the approach you describe is very good, actually. Ack the problem, put in a placeholder, promise to get back and then do. If you want to be a famous teacher, find a way to reward stumper questions from your students. You will probably increase attention and participation in your class. Maybe for a real "head-slapper" everyone gets ten bonus points. That said, it is also bad if you are never correct, but you knew that, of course. 

Pure FP relies on implicit state and deemphasizes (or eliminates) explicit state. In Scheme, for example, a let gives a value to an identifier that is valid throughout a scope. It is called a variable in the documentation, but it is really a name given to a constant. Once given a value the name doesn't refer to any other value in that scope, but might have a different value in a different (or larger, or smaller) scope. One envisions a computation in a pure FP as an expression that has a value. In order to calculate that expression other expressions are evaluated (recursively, so to speak) until some expressions evaluate to themselves (5, and "foo"). The state of the computation is purely implicit, the location of the PC within the chain of recursion. When the chain ends the original expression can yield a value. There are no "variables" in the C or Pascal sense. Named values (i.e. constants) may be assigned to memory locations or stored on the stack, or in the cloud, or ... It isn't necessarily specified. In a sense, the state is a Stack.