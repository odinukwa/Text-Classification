If you want the student to access any methods on the book directly it needs to be public. But you can pass some identification to the object. It can then invoke methods on the book via the LMS and the book identification. 

This will work 99% of the time but if somebody starts logging (using one of the std:: streams (in/out/err/log) in the constructor of a global scope static storage duration object then all bets are off). Since this is a rare case I am not too worried but you should document this somewhere like at the top of the header file (assuming it is still a problem). I don't see a definition for or or or 

It is definitely more clear than any of the proposed solutions. Is type safe (a key point) and avoids the copy you want (as they are created in place). 

This is a follow on to a previous question: Part 2: Upload/Download All the code I am submitting here is available in github 

Please note I changed the to . This shows you are not passing ownership but you will always pass an observer. The additional upside is that you can no longer pass as an observer (you forgot to check to see if the pointer was and thus had a potential for calling a method on a (not a good idea). Passing by value: Here you pass the by value. 

If the answer is NO then you pass a reference (as a reference can not be NULL) and also indicates that you don't have onership. 

Also I prefer all sub statements to be wrapped in '{}'. This prevents problems with macros that are desguised as functions. An attempt 

Notice the this moves an object to the function (saves a copy). So at the needs to be changed slightly. 

Also I would not bother passing the fourth parameter that should be a type to the template. Then you can have a template specialization that implements it for random iterators only. 

The only reason here you actually need the test is because you need to decide weather to increment . I would just always insert (sets don't have multiple values the same so an insert of a value that already exists does nothing). 

Does not obey the rule of 3/5 The compiler generates several methods for you. These methods work well as long as the class does not have "Owned RAW pointers". Your class does (the head and tail). As a result when you make copies of the object you will get unexpected results. Also if you add a destructor it will probably crash on a double delete. 

This needs a comment. It took me a while to figure out that you are only doing this on recursive calls because you swap data from one set of container to the other. Using. 

Not really. You are missing a whole bunch of functionality if you wish to call this a container. See: Concept: Container. BUT I don't think you need to call your structure a container it is a just like a 

Note sure I understand what the parameter is for (do I need to read the documents). Also why require the user to create a node object to insert. You could just express this as part of the interface. 

You are in a constructor.The member has just been default constructed (because you did not do anything in the initializer list). So this call to is redundant. 

This is a multi-threaded environment you can not assume run_task is being called from only one thread. You must assume that it can be called from any number of threads. 

Also notice that I am declaring my loop variable as close to the point of usage as possible. Do not use the C style of putting all the variables at the top of the function. Put your variables where you can see there declaration and type easily. 

Your code is all code. So you are writting specific code for each situation. A better style is called "Data Driven" coding. This is where you use generic code that can be used for all situations. But what exactly happens depends on the data. This allows you to change the game simply changing the data. Example: 

So the first update to the above pattern is to check that the read worked and only perform your other actions if the read worked. This is a perfectly acceptable way to do it. But it is still not the best way. The standard way of reading from a stream is to put the read test in the while condition. 

Recursion. You can make your recursion much simpler. The first thing you do is check if you have fallen off then end. If so return (and you can print null). Then you can do all your printing work knowing that you are in a valid node. Also prefer over . The difference between the two is simply that will force the buffer to flush (which makes the stream very inefficient). Manual flushing is nearly always the wrong thing to do and the cause of most slowdowns in streaming code. So I would rewrite your print like this: 

Most algorithms use iterators as the interface between themselves and the container. It abstracts away the actual container type and in cases likes this removes the need for a copy. Prefer over when you already know that your index into the container is valid (the validates the index before doing the operation (useful when using unvalidated input but otherwise expensive). 

Before you can start freeing the resources you have to make sure that no other thread is using these resources. This means you have to force a flush and make sure there are no threads in your object. 

Comments on algorithm Your current algorithm is O(N^3) This can definitely be turned into O(N^2) From reading the code you want to build a list of all sub-graphs that exist in your graph. I think you are doing t wrong and building several of the subsets repeatedly. There is a simple technique for this. Think of each node in the graph as represented by a bit in a very large integer where the integer has one bit for every node in the graph. Node 0 is bit 0 and Node 5 is bit 5 etc. Thus the full graph is represented by the integer with all the bits set to one. Any sub set of the graph is then represented by an integer with some bits off and some bits on. Thus you can generate all the different sub-sets of the graph by looping through all bit patterns in the integer and this can be done simply by starting at 1 and incrementing the integer until all the bits have been set (Each increment represents a new set). Assuming you have more nodes than will fit into a normal integer you should probably use the boost::dynamic_bitset(If you have 64 or fewer nodes you can use a normal integer (assuming you have 64 bit integer type)). 

Thus moving during the lifetime of the object is not a good idea (because you must call delete on the pointer returned by new). So if you are going to move you need to keep track of the original pointer in another member. But I would not move it all. You are adjusting so why adjust ? These can't return by reference: 

Hard to see the class part. Align the types if you think it is two long. But put the class back under the template. 

The addition of std::string will make this code ten times more efficient for the simple reason you will not have to re-compute the length every few iterations. Getters are a sign of bad design: 

Should be done automatically by the compiler. Just prefer to use normal automatic objects and the compiler will do all this for you. 

Also it is traditional to reserve names that are all uppercase as MACROS. So you will confuse people that understand normal C++ into thinking these are macros names. So try and use camel case for you variable names (its also a lot nicer to read when code is not shooting at you). Your loop for reading is correct. Which is a bit of a surprise as just testing the stream like that is usually an anti-pattern. But we can make that loop simpler: 

Personally I would implement this as an object (all the data internal to the object). Then call a method on the object to activate the new thread. This way nobody else can mess around with my data structures. 

Don't think regular expressions are the best way to capture number operator number. The stream operators support this already so prefer to use those. 

You usually find that if you are getting values from an object doing stuff with it there is usally a member function (or member of the public API) that can do that. In this case you are only using the value to print. So why not just create a function that knows how to print the value. 

Sure but I see little point in this. It means every C++ programmer has to go and look up the type definition. If you just use the normal type they should immediately recognize it and understand what it does. Static Member thread. There is no need to make the thread function a static member. It can very simply call a member method. Thus saving you the trouble of passing all the variables it needs. 

In this situation you know that both and are guaranteed to be in the correct range. So why is there an un-needed test to see if they are in the correct range. But even has a checked version of member accesses. See . Though the standard member accesses is not checked.