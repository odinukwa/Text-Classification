Corners: When you come to a corner (two ray casts hit a wall) you must switch the wall on which you create the joint, depending on the direction you are walking to. Walking direction: When you walk around a corner, you must track the direction you are walking to, so you can press forward all the time and follow the shape of the wall. 

You can make a raycast from your character into all all four directions. If you only hit the ground then you don't have to do anything. If you hit a wall or the ceiling you add a weld joint to your character and the wall. You destroy and recreate the joint inside your update loop, so the character can move, but is tied to the wall/ceiling and doesn't fall down. There are still two tricky parts left. 

This should give you a "fluid" where each particle swings around its origin when the player stirs the fluid. The springConstant changes how much a particle swings away from its origin and the dampingFactor how fast the particle comes to rest. You may have to tweak the code since its the modified version of a 1d simulation I use in my game. Now with a demo: Demo Just tweak the 3 constants at the top until the fluid behaves like you want it to. 

I'm working on a platforming game with tile based levels. I store the collision model for my tileset in an array. This is how the collision model for a 4x4 tilesheet would look like (I can't post pictures yet so this link will have to suffice: Tileset example). The red dots are the vertices of the b2ChainShape. When I load a level, I look up the collision model for each tile and create a b2Body at the corresponding place. The problem is that between the tiles, my character can experience a "bump" because it gets stuck on the edge of the shape of the next tile's body. Is there an existing algorithm to connect the bodies of neighbouring tiles to a single b2ChainShape? Or should I ditch the idea of tile-based collision models all together and simply create the collision model for the whole map with the Tiled map editor? I don't create the the collision map with the Tiled map editor at the moment, because it is very time consuming for slopes and hills. 

1.If you want something that's close to your mockup I'd use particles (It doesn't have to be a fully blown particle system). Render your particles in the form of the polygon on a RenderTexture. Make sure to use additive blending on the particles. The particles inside of the polygon will smoothly blend into each other while the particles on the outside will give the soft edge that you want. (An example of the effect can be watched in this youtube video: Additive Particles Video Now render the RenderTexture onto your main screen and you're done. The RenderTexture is necessary so that the particles don't blend with your background. You can try to put the triangles directly onto the particle texture and see how this works out. Otherwise render them on top of your "particle soup" as a separate layer. Created a quick mockup in an updated jsfiddle that looks like this You can find the updated demo here 2.Each particle has a velocity and an origin. When your player touches the polygon, you change each particles velocity proportional to the players velocity. The farther a particle is away from your player, the less it is affected by the players velocity. The formula to calculate a particles velocity would be something like this: 

$URL$ This is still how networking is done in RTS games. P2P is also the normal way of handling connections. Using a lock timestep model however results in the irritating case of desync and cheating handling. There is good way of recovering when a desync happens and all RTS games simply says "Quit the match". Bug tracing desync errors is also a nightmare. 

Not a lawyer and you should check with one for assurance. There should not a problem as long as you don't copy any specific names, things or text since you cannot trademark or copyright gameplay & rules. 

Unity3D UDK using nFringe XNA (framework, not engine) Silverlight (2D framework, not engine) Torque 3D And pretty much every open source C/C++ engine ever Support for debugging does vary among the engines. 

Neither. The only thing you should send are the commands. Example: These 20 units should move to (X,Y) and then let each player figure out how they get there. The tricky part is making sure they all do the exact same thing. To achieve this a lockstep model is used, the links below should explain it in detail. Also, you should only sync the important pieces. Anything that doesn't change the gameplay shouldn't get synced. Animations in RTS games is usually only for the visual side. Another thing, RTS games are usually not client-server, but P2P. That way one of the players can't cheat because when any inconsistency is detected, you simply disconnect. Here is something to help you get going: $URL$ $URL$ $URL$ 

When creating your own model for a weapon, say the M4 carbine, and using the model in your game. Do you need a license to use it commercially? I know that racing games like GT5 has a license for each and every car, but the same apply for weapons? 

James reponse only relates to PC and not for the implementation on the specific platforms. While all engines abstract the platform for the far majority of the game code, some parts have to be written per platform. This includes all I/O including network, rendering, audio, device input & I think video output. Compare the rendering code for say Unreal on the Xbox and PS3. The Xbox uses the Xbox DirectX version, while the PS3 uses libgcm (the OpenGl library is too slow). To simplify it a bit, on all platforms the gameplay programmers only see a "AudioSystem.PlaySound(SoundName here), while for each platform they function internally would call the platforms API for sound output. See also Tatrad's comment for more programming. 

It really depends on what you want to do. Is it a game? Then use an engine like Unity. If you want to learn 3D programming and math from the ground, writing your own tech demos could work. Remember that engines are tools, nothing more, nothing less. The DirectX vs OpenGL doesn't matter, pick one, learn it and you will easily change to the other. If you want to learn one of these start your own demo project from scratch, but don't expect being able to finish a game with it. If you just want to learn the graphics programming part of it, using any tool that supports writing shader code directly will work. Like Unity support Cg. Note also that Cryengine is only just released. It doesn't have a large community or documentation yet. Unreal, while maybe more limited, does give you that.