That's what you should do now then. Recovering data is about the filesystem occupying the partition where the files were stored, not the operating system or device used to do the deleting. Since the filesystem is NTFS, your best chance of recovery is via whatever tools are available on MS Windows for this purpose. If the external drive is a spinning disk and you have not done much with it since your mistake, then your chances are pretty decent of recovering at least some of the stuff. 

This should leave a file behind. You can leave it there or store it somewhere else. If you need to restore things later you can use from inside the same directory. Simon says to erase the current firmware and modules directory. NO. NO. NO. DO NOT. Just use the two commands to copy stuff in. This will overwrite as necessary and leave whatever isn't being replaced. You can now try to boot. If it doesn't work, you can edit again and comment out your new line and uncomment the old one to return to the original kernel. In this case, if you want to try again, I would recommend starting with the config used for the original kernel, then add to that in menuconfig. You need to get that from a running pi; it will be .1 It is not actually on the SD card so don't bother looking for it. You can put that file in the top level of the kernel source and: 

The last one is to double check. It should show no processes. If that works, you can permanently disable : 

Make a script of that and time it. To do the read, first ; you have to do this as root and you can't use sudo. I get ~17 seconds to write 100 MiB and ~6 to read it back with a nothing special card. If I leave out the sync and the flush, I get much, much higher speeds, 80+ MB/s. This is a meaningful number depending on what you are doing, but it is not the actual speed of I/O to the device. You won't get faster than 20-25 MB/s read from the SD card (this is a limitation of the reader) and a pretty good write speed would be half that, some cards may go higher. You could get a bit more from USB, maybe as high as 30 MB/s. Anybody who claims to be doing more than that with a Pi is delusional. 

Maybe, since in fact the way this works is called by an init service. On current versions of Raspbian, init is systemd, and looking at (which pertains to services with a suffix) implies that it might indeed be hardcoded. However, if you really wanted to, you probably could find a way to disable that and create your own service that plays an appropriate role. Since there are much simpler ways to accomplish the same thing (e.g., symlink ) I doubt anyone has done so. Earlier versions of Raspbian using SysV init presumably used a script which you could edit. The problem with this is your changes would not likely be protected from system updates. A better approach would be, as with systemd, to tweak init's service set and supplant your own. In both cases, doing so would require a bit of diligence and study since getting the root filesystem mounted is usually a critical element of the boot process and must be properly completed before most other things can happen. 

So the latest pidora package is 3.3.2. If you really want 3.4, you can download the source (might as well use the latest 3.5 in that case) and there should be build instructions in the chive; first you have to unpack it: 

Not by "integrating it through the OS". What you want is a userland application. While all such applications of course depend on the OS in order to function, they are not integrated with it in the same sense as a hardware driver. If you are accessing a device via SPI or I2C, there's already a kernel driver for that; you would be making use of the userspace interface to it (or alternately, one of the pure userspace libraries specific to the pi, that work by mmap'ing kernelspace -- but you do not have to understand that part). More specifically, you probably want a daemon service which monitors the state of the battery and responds to it accordingly. 

Will download and install those packages. If it completes successfully, there's nothing more to do. This command: 

Note this potentially isn't true for the Pi 2, where instead the green LED will come on and stay on rather than being off. 

Logic levels are detected by input pins. The difference between an input pin and an output pin is that an output pin has a specific voltage applied to it. An input pin does not, and when not connected to anything, it is in a high impedance, aka. a "floating", state which essentially means the voltage fluctuates randomly. This is the third state in 3-state logic, the other two being the binary 1/on and 0/off.1 When an input pin is connected to something, it's the voltage of what it is connected to that determines its state. If that thing is the ground of the circuit, its voltage will be relatively low and thus a logic level of 0. That answers part of your question about the short circuit -- connecting an input pin to ground does not do so (but keep reading, because there is a potential short involved). However, it raises the question: How can the input end up "on" if the other wire is ground? Let's look at that pull-up resistor diagram HeatfanJohn referred to. 

Then check to make sure the directory in is gone. That should free up enough space until you get a 4+ GB card. on raspbian sans the package wants "588 MB of additional disk space", part of which is oracle java 7. Meaning you likely also have oracle 7 installed and probably don't need that either (if you want an oracle java, use the 8 version which is compiled for the hard float pi). 

If that's generally the case, then the bottleneck is the processing, and nothing to do with the network. If the network were an issue, the processor usage would be less, reflecting the fact that the process must wait for input and spend more time idle. Put another way: on the pi's little processor can process 1.8 MB/s of data. So, eg, if the raw data from a bittorrent stream were saved on disk, and all the pi had to do was translate it into whatever form on the same disk, it would still not exceed 1.8 MB/s. Not really anything you can do about that, unfortunately. 

1. This might be construed as sort of reasonable since their most widely applied use is in charging mobile devices, which take 5V inputs but also use 3.4 - 3.7 V batteries. So if you have a 12000 mAh battery that is "good for recharging your phone 3-4 times", this is probably true if the phone use a 3-4000 mAh 3.7 V battery. Which is very common. Of course, this also explains why they don't always operate at 5V -- they don't have to. They have to operate at say 3.5 - 5V, which is fine for recharging but not for powering active electronics.