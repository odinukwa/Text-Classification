where there is only one method and the new C# 7 takes care of the dispatch and derived classes need to implement only the concrete overloads: 

Its implementation evaluates the above condition but there is no information about it in the method name so nobody could tell what it checks. On top of it it even uses the hardcoded magic-number . This should be a constant. You also put it inside an which isn't necessary. You can just the result. 

Create a new panel control with a picture box inside (you can create a property for it so that you can set the image later). In this control you can implement all the logic that should handle the resize. Give it a few properties that you can set and calculate the size and location values dynamiclly and internally. Use a flag (like ) to track whether a panel is in its normal or enlarged size rather than hard coded sizes. Here you can handle the event and take proper actions to modify the panel and the picture box. 

It's just an example. You can of course use other exception type that suit your needs but remember to not use the , it's not helpful. 

If you want to have maintainable code then you need to write more code and correctly use dependency injection and possibly use a few interfaces as abstractions. Nested public classes are a bad style anyway so you should avoid them. This is how such an implementation could look like. The gets an interface that allows accesing its . Its constructor also requries a lambda that lets you specify the navigator for this instance. 

Exmaples I implement resource APIs by creating a marker interface that stands for a resource I want to access - they have the same name as the controller (without the I). This creates a strong context that I can now use to write extensions for invoking actions on the web-service. (I was also thinking of generating them with a T4 script later.) 

This is very inconsistent. Once you use a full type name and another time just the and this interchangeably. Not sure which one is better? I suggest using everywhere. 

Further below I don't understand why you are recreating the with the loop. Maybe it's a requirement. 

You didn't add the performance tag so I assumed enumerating the children collection wont't noticable. Should you work with a database and have many thousands items then creating categories an groupping the results by various ages might have a better performance. For a few hundred items it doesn't matter and premature optimization should be avoided. 

The right way to prevent a type from being created and allowing only derived types to do it is... to use an class. By making the you won't need to hide the default constructor. An example implementation could look like this where you have a that implements the : 

The constructor shouln't do any work but initilize only properties/fields. If you want to read the file immediately then it's better to create a factory method like that creates an instance and calls the method. 

This kind of case-insensitive trimmed string is such a common use case that I have special class for that. It saves a lots of headaches when working this kind of data. 

AugmentationTable I see you have another one nearly identical class so most comments will apply to it too. But I find you should try to find a common denominator for them and implement the repeated code it an abstract base class. 

One more thing about it. I think the loop is a good candidate for a general purpose extension, I named it 

This is my third attempt to create a easy to use html builder because I wasn't really satisfied with the first one that wasn't extendable at all and even the one using dynamics wasn't much better. It was difficult to use due to everything being dynamic and had to be casted everywhere but what's worse it was hard to find the bug if something went wrong. This time I tried to do it the functional way. You validate how well I did or not. 

Nope. You don't need it. Use that automatically can distribute the load on multiple threads if necessary or use the to calculate the ranges e.g.: 

In situations like this with factory methods we usually use the name because suggests it's a builder but it isn't. 

I don't think there is any other way to solve it. By using the event and initializing a you do it just the way it should/can be done. You may however consider renaming the interface to and the method to which more clearly describes what you are doing. You don't create any tabs, you initialize them so name the interface and the method accordingly. Internally you can use a boolean field so that the method checks it and doesn't initialize your tab-page multiple times. Then you just do: 

Currently your method does two things. It searches the directory structure and anylizes the files at the same time. This should be separated so that you can maintain each feature separately without affecting the other. For example should you want to search the directories recursively you now only need to change the method without thinking about reading the files. 

I had given it a second thought and I came up with another solution. For the sake of simplicity I replaced the with . Particularly I did the following: 

Suggesting alternatives is always a risky review (and usually one gets DV for this) but I'll try it anyway... 

In your case creating this dummy and not actually used objects may hurt performance because you add a lot of garbage to collect. You could replace it with a simple instead and avoid the entirely. 

You should try to avoid nesting and actually use the as an . This means you should put the condition for the loop where it belongs (and adjusting it of course): 

This line screams for dependency injection. Creating the like this is not a good design because you code depends on the and you cannot change its behaviour during testing. You cannot exchange it and provide some fake-email. 

For someone who knows how to use LINQ this extension will be difficult to use and rather unintuitive because you have more options without it. It uses the extension but what if I wanted to use in certain situations? You've written an extension for something that's already there and limited the options. Now you need another one, which would be . 

This way you could save a few loops over the buffer. Even better you could turn the buffer into a at the top and use it later to clean-up the code a little bit: 

To test it I used this expression to cover each case. (I guess the 52W is wrong but this doesn't matter yet - validation comes later). 

There are two more methods that can be simplified. The first one is the method where you can use the ternary operator and don't need the . 

Error codes are an ancient era. Each of these values should be a separate exception that is easier to catch and analyze and setup and log then enum values. 

The above method will of course delete only the last directory. If you want to delete directories that are empty after deleting the last empty directory you need to repeat the process: 

Consequently the event handler doesn't need to search for the actor or scenario anymore. I think this should work: 

I'm not sure what your code exaclty does but try to define steps for the deployment and refactor them as let's say methods. If you then find that some of them perform similar things it might be good to put them into a new class. This way you will be able to better focus on a particular task rather then on everything at once.