You could and should read the user inputs into variables of types that represent what you are doing with them best. E.g. whether the user wants to invert or should be a boolean. For the operation I would recommend declaring an enum. I would also print messages about input errors directly where they happen. If a user already enters a wrong operation (e.g. "XOR") in the first question, why should you let him enter two additional values before you tell him. Additionally your messages can be more specific. Checking/Comparing user input that is not required to be case sensitive is easiest done by making the user input upper case (or lower case) and compare against the wanted/required values in the same case. This method is also less frustrating if you don't need to retype as you accidentially typed . If the user enters something invalid you can also force him to enter a valid value by using a loop that doesn't quit until something valid was entered. And last but not least you output. You can completely stream line the way you do it by "calculating" the values depending on the user input beforehand and output everything later. E.g. this line: 

The same way you can "prepare" the values of and . If the user wants to be inverted you use otherwise you use for both calculation and output. 

Data structure: First of all, choosing an ArrayList as the data structure for a queue is suboptimal to say the least. A remove(0) on an ArrayList always copies the remaining elements to the beginning of the list (see remove implementation in ArrayList - sources are available). Use a LinkedList instead, which has constant removal time. New Files-API: Usage of try-with-resources is good, but manually creating a FileReader and a BufferedReader is quite old-fashioned. Simply use java.nio.Files.newBufferedReader instead. Method signature: Your LimitedLengthQueue.add method has a boolean return which is always true and never queried. What for? If you don't care, simply make the method void. 

And my personal thanks to you for posting something that is not "programming-challenge" on codereview :-) 

Then, the actual call of the logic is simple and clean, no matter whether you use a loop or a stream: 

Your queue does not have any overflow protection. As queues tend to be used in multi-threaded environments with different producer and consumer threads, you'll have an immediate overflow when the consumer stalls for a while. In fact, this will simply throw an ArrayIndexOutOfBoundsException right now, so you'll have a program crash (which is somewhat OK.) If you expand this by creating a ring-buffer on a fixed array, you'll overwrite unread data without even noticing it and find yourself in the hell of untracable program behaviour. Thus: add bounds checks. 

I was just playing around with some code and had the idea about writing some kind of manipulator to delay the output of characters in a typewriter like style. The focus was mostly on how to use it and was inspired by or . Overall it works pretty well. I just want to make sure that I didn't miss anything that may backfire any time. The code is just for playing around and doesn't have a real use case (yet). 

So I came up with a solution that should be as fast a "normal" loop. As already discussed your main problem is the function that is called on every iteration. I removed the check (see comments) and instead added a function to calculate a range that is compatible with the size of (see comments). This function is now used instead of just using (see comments). Also: To prevent someone from messing around with the iterator I made the constructor private and added as friend class (see comments). 

The new function might seem a little bit difficult in the beginning. All it does is to calculate the next step equal or greater than the current in the direction of : 

Comparing the new code to a normal for loop with the same range actually shows us no difference in compiler instructions: 

is used to get the unsigned equivalent of as the function makes use of the modulo operator. Modulo operations on signed types is UB. Next is to get the difference between an and store it in the unsigned type. This is perfectly fine since will only return positive values. Also we are getting the absolute value of step. It doesn't matter if we are going from to in steps of or from to in steps of ... all we need is if we exactly hit when iterating. will give us this value. e.g. when using the last value we hit is which is short of . will give us this . What we need now is the value being signed again in the direction of step. will return if is negative and if step is positve. If there is no underflow we can just return the last we were provided with. Otherwise we need to calculate the next last that can be "hit" with . So we use to find the difference we need and add it to . Example: 

You are letting components be built up by other components. This is completely SOLID and is a good approach. What I would like to warn about is returning . This is fine as long as the query handler is used by other query handlers (since this enables composible queries with good performance), don't return an to the presentation layer. This makes the system unreliable and hard to test. This means that you will have to implement sorting and paging inside your business layer, but this is actually quite easy. Note that your components should not dispose any dependencies that are injected into him. The reason is that such component doesn't own the dependency and has no idea what the lifetime of the dependency is. Disposing that dependency can make the application break, and this is something you already noted in the comments. As a matter of fact, you are violating SOLID by injecting a dependency that implements ; you are violating the Dependency Inversion Principle. This principle states that "abstractions should not depend on details", but is an implementation detail. If you prevent having on the abstraction, but instead place it on the implementation, you'll see that it becomes impossible for the consumer to call (which is good, because it has no idea whether or not it should call it), and now only the one who created that dependency can dispose that dependency (which is your composition root). This makes your application code much simpler, because you will hardly ever need to implement at all. In your case however, you can't remove from the , because you inherit from . But injecting a is itself a DIP violation. Although not all DIP violations are bad (and you will always have DIP violations somewhere in your application), I rather hide the from my code, for instance by using an abstraction with a single method. Advantage of this is that the can be resolved at runtime, instead of injected into consumers, and it allows to easily wrap the with some sort of security decorator that filters the results based on the user's rights. Do note that the part of the system that created a disposable component typically holds the ownership, and is therefore responsible of disposing that. Although this ownership can be transferred, you should typically not do this, because this complicates your application (I think you already noticed this). So you composition root creates this dependency and should dispose it. In case you use a DI library, the library will create that insance for you. In that case, the library is also responsible of disposing it for you. Although you can view this as 'something magical', IMO it's simply a basic feature of the library you are using. You should understand the libraries you are use. In the case of Autofac, you can be pretty sure that Autofac handles this correctly for you. In case you would switch back to Pure DI (formally known as poor man's DI), your code will obviously again be in control over that dependency, and you will have to implement this disposal again manually. There's no design smell here. But that said, although disposing is not the problem, scoping might actually be. Please read this answer of mine. Although the query handler pattern might seem over-engineered at first, if you read the article closely, you'll see that it is simply an implementation of the SOLID principles. IMO, you should always strive to adhere to the SOLID principles in the core parts of your application. Querying is obviously a core part of every application. My experience is that query handlers even work well on small projects. They allow adding cross-cutting concerns with such easy, that it can really boost the productivity and flexibility in smaller applications. Using instead of injecting s directly has some downsides, such as the fact that handlers get resolved lazily at runtime. This makes it harder to verify the complete object graph and it makes it hard to see what queries a component executes. On the other hand, it makes your code cleaner, because the generic types and often long names for query classes can give some noise in your code (that's more a limitation in C# than a limitation of the pattern). In that case the can help. Since your implementation will be part of your composition root, it is completely fine to have a dependency on the container, since the rest of your composition will have a dependency on the container as well (although it would be good to call it ). It is incorrect to assume that this is a implementation the Service Locator anti-pattern. This is clearly explained by Mark Seemann here. In case you are swapping your DI library, you will have to change your complete composition root, including the implementation (because it is part of the composition root). There's nothing wrong with that. It is no problem that your container is stored inside your graph. Although you could try making the process generic by injecting a Func, that would still mean that the injected Func would depend on the container, making the container still part of the object graph. This is actually what dependency inversion is all about. Components can use other components and code at runtime that they don't have a compile time dependency on. 

OK, the data-structure looks a little wierd here, because your list consists of map-entries, but this was the main work. If you print this result, you already get (format added manually): 

Fetch the concrete enum constant via lookup by name, extract the value from the object via reflection, and create the comparison value by some form of String-to-whatever conversion. Then, simply apply the test. 

AFAIR, styles are "heavy cost" objects in the workbook. Thus, create each XSSFCellStyle only once and reuse the XSSFCellStyle object for the same color. 

You currently couple your SocketHolder class with the environment it exists in, as you have the comparable interface implemented in SocketHolder which in turn uses . I don't think that this is a good idea, as this dependency seems unnecessary and makes isolated testing difficult. (Or in other words: bad gut-feeling ;-)) Suggestion: as you set up your priority queue in a specific environment, and at that place it is probably OK to know the environment. So, use the constructor for priority queue where you pass a Comparator explicitly, and write a comparator which basically does the same as the compareTo-method you have in your SocketHolder right now. 

This way, you divide the problem into manageble pieces, give you thoughts a place to stop every once in a while, and should get rid of this nervousness. BTW: from an interviewer's point of view (at least I you want into my team in my country ;-)) a well thought pseudocode algorithm is worth more than working code. If you apply for a programmer's job, I just assume that you have the basic skills to use an IDE and kick against some piece of code until it compiles and produces the correct result. What I am looking for is organized thoughts and problem solving skills. One last thing: there is one and only one correct exception to throw for a null parameter that must not be null: NullPointerException. Ideally by simply using Objects.requireNonNull.