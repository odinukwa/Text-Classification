I have 3 tiers of labs. First are the required labs. They're worth 100 points each and every one must do these. If they don't do one, it goes in the gradebook as a zero. These are also the labs that I think are the best of each topic for practicing what they need to work on. My calendar is based on how much time I expect 90 plus percent of the students need to finish this set. Second and third tiers are bonus and challenge labs. They're worth 110 and 125 points respectively. If a student does these they go in the gradebook. If not, the grade is omitted so there's no penalty for not getting them done. These tend to be extensions of the required labs, but might be a little more difficult. Generally the students that are the fast finishers are also the ones that like doing the labs, so throwing a few more their direction will keep them working. Plus, it's an AP class so the 10 or 25 extra points on a lab grade will be a motivator. I also have a page with a list of websites they can go to if they're finished with all 3 sets of labs. It links out to sites like code.org, codecademy, Code Combat, and CodingBat. Sites that are related, but a little more fun than just cranking out labs. And I'll also let students come up with independent projects to work on. 

I will have to start with a list of the methods on the objects that are exposed (e.g. , , , ) and how to use them, and cover basic if statements and loops. From there, I'd like to expand their knowledge of computer science concepts while still relating it back to this device. I thought about beginning to explain the framework it's built in, but I started looking at it and it was far to complex to introduce at this point. So, how can I take students from this simple understanding of syntax and methods and give them a base of solid, cross-language, CS knowledge? 

Sometimes. And sometimes they explicitly say that you must use the previous method for credit. #3 on the test this year did that. I also have a negative rubric point for any of the penalties. Destruction of data, unexpected side effects, returning from a void, that sort of thing. 

You said he refuses to work, but has mastered the material. How do you know he's mastered the material? I've had students like this in the past. They'll finish 2 weeks worth of assignments in a day and a half. Talk to them. See what interests them about programming. The few times that this has come up, the student had something specific they wanted to build. It was well above what was expected in class, but it was still programming, so still related. We came up with a plan for them to work on their pet project, which always required that they finish the assignments I gave first. Then, they're free to build their project. 

In that case, public methods can change levels of the tree in either direction, and private methods cannot exit their level (or move to a different class in their level. This part is clearer with boxes). 

A good analogy for this is passing a document of some sort to a friend. Here is how the analogy goes: I have a document. I want to give you (my friend) the document so you can make some changes and I can get those changes from you. How would I do this? There are two possible ways: In a pass by reference language, there would only be one document that I have. I would share that document with you so that we both can access it and change it. You could make your changes, and I would already have the same document, so I'd already have all your changes because we've been working on the exact same document. In psudo-code: 

Wish I had a good answer, but I can sympathize with your Scratch example. What I started doing was just giving up on the first day we did Scratch. I would show them the drawing tools before we did any coding. Spent about 5 minutes showing how to make sprites and backgrounds and then gave them the rest of the period to play, with the understanding that was the only day that they had to just play around and doodle. Day two, we start coding. Worked fairly well. It was at least better after I started doing this than before. I think the novelty of it wore off when they were allowed to goof off for a day. Haven't taught Scratch in a few years, but I noticed the same thing happening with Jeroo. Kids love painting the island with flowers and water. The last lab in the set is one where they get to build their own lab, and make their own island. I think having that to look forward to helps. 

Because debugging can be learned very easily through experiance, I'd try and help the students self-correct when they make mistakes. When correcting mistakes, ask the students to type the corrections themselves, so that the corrections will be better ingrained in their minds. Also try to correct them by leading them through the debugging process. You can lead them through by asking questions, like "What line does the error message refer to?" "What is that line supposed to do?" etc. Eventually, they will start following the steps themselves, and will learn to do it without your help. 

Fingers crossed that this one doesn't get closed. I've tried to do something similar, but it hasn't come out well. Hoping that some others have suggestions. It looks like they're using some sort of overlay or whiteboarding software, and I assume a tablet or stylus. I can see a cursor where their pen is drawing. I've tried this, and it didn't go well. But, I think that's more a factor of my handwriting than of the idea. Enough years of typing being my main method of written communication has made my handwriting terrible. And it's even worse on a Wacom tablet. Same thing with some student created videos. They're just hard to read. I'd like to find whiteboard software that also allows typing. Haven't found one yet, although I haven't looked all that much either. A couple things that have worked... If I'm in a hurry, Powerpoint has enough animations built in that it's possible to do a fairly decent job. And, they can be exported to videos if you want to upload to YouTube. When I've had more time I've used Flash. It's deprecated now, but I still have an old copy on my computer. Takes longer, but gives me a little more freedom in what I build. Also can be exported to a video, which is especially important since browsers are starting to frown on Flash. Edit: Just played around with the pro version of Acrobat and it looks like it has a pen and text tool that might work for what I'm trying to do. Most of the time I'm just trying to annotate what's already typed out. Edit 2 - After "screen casting" was added This year I started capturing my screen as we work through problems and then uploading to YouTube for kids that missed the day or just want to go back for a refresher. I'm using a program called OBS. Works really well. A little Googling brought me to a Windows program called ZoomIt that will let me write and type over the screen as I'm demoing. Think I might bring my Wacom tablet to class tomorrow and give it a try. 

Then I'll explain that the browser need to how much space to give the element on the outside and how much space it needs to give the content, which introduces padding and margin, and finally I'll add a border, finishing my explanation. 

To give another perspective, when teaching an intro to web development course it's very useful to teach things in a way similar to how they were discovered and contextualize the different concepts in history. It's easy to understand why HTML is a markup language rather than a full fledged language when you consider the time: The Web was used for serving plain text pages, and they wanted a little markup to make it nicer. HTML was born. When styling become larger than HTML could encompass, CSS was born. When interactions wanted to be built in, JS was born, etc. Otherwise you can get into extended discussions about why the front-end environment is the way it is. In cryptography it's the same way. By following the history you can see the mistakes of those before you, and thus avoid those mistakes. Crypto is all about the cycle of making a new algorithm then having it broken, and the arms race that it causes. History illustrates common pieces of advise, like to avoid security by obscurity, and history also shows why perfect forward secrecy is needed. It shows the need for key exchange, and shows the relationship between unsolved math problems and crypto. All of these are great reasons to teach crypto in chronological order, from the oldest discoveries to the newest. I would guess that this sense of parallels between the order in which things are invented and the order in which things are taught exists in other fields as well, and so teaching history along with the normal coursework could be very useful. 

Students get to see at least one working solution, although I try to come up with several. Posting the solution serves as a good block to students asking to turn in assignments late. They'll understand pretty well that they can't turn it in late after I've already posted solutions. 

I use school colors and principal's name. If someone comes in tomorrow and says your principal is no longer Mr. Smith, it's now Ms. Jones then that change is made for every object (student) in the school. You don't have to go to each individual student and tell them that their principal has changed. It worked really well this year because we did get a new principal. 

One example is the front end web development concept of the box model. For those who do not know what the box model is, here is a graphic: 

I believe that the reason why students tend to come out opposed to using TDD/BDD (testing) is because they've been assigned to use it when it isn't necessary. Testing a "Hello World" program is 100% a waste of time. Tests only become useful when you have a reasonably complex program. The way that you can avoid students disliking testing is by not assigning it on projects when it isn't needed. A specific way in which you could do this would be by combining all the project you would assign over the year into one larger cumulative project. Eventually, as they're writing code, you can be fairly certain that they'll induce bugs or begin to find manual testing to be a pain. Once that starts happening, you can introduce automated testing to relieve that pain. That way, they'll see testing as a way to save work rather than create more of it. In addition, I think the issue may be with this part: 

Grades. Works especially well around final exam time. You can find the average. Find the highest and lowest. Find the average with the lowest dropped. Find the most common grade. Count how many are in the range 90-100%. Given an array of grades assigned for each class, calculate GPA. Given 3 arrays that represent labs, quizzes, and tests calculate the final average. Each array can be weighted differently to match whatever your grading scale is. Ex: I would have labs weighted at 10%, quizzes at 20% and tests at 70%. 

I semi jokingly tell my students at the beginning of the year they can play any game they want on the computers, as long as they write it first. It at least gets a laugh. For me it takes two things. One, I need to be able to see their screens. Given, this is probably much easier with school provided devices. When I moved into the classroom I'm in all of the student seats were facing forward with the monitors facing away from the teacher. First thing I did was push all the desks to the wall so that the monitors are facing the center of the room. I can see almost every monitor from almost any spot in the room. This also helps getting to students to help them since I don't have to squeeze through rows. It does help that I have a pretty big classroom though. And two, I need to keep them busy. What I've found is that once there's a student playing games it spreads. And the first one usually isn't playing because they're screwing around. They're probably done with their assignments. I throw more assignments at a class than most students will be able to finish - some are extra credit. I also have a list of enrichment activities that they work on when done with labs - Coding Bat, Code Combat, Project Euler, making their own game, that sort of thing. That way there's always something CompSci related to work on. We are partially BYOD in that kids are free to bring their devices, but aren't required to. There's always a handful of students that prefer to work from their own notebooks. My rule on that is that they're free to do so, until I catch them screwing around on something else. Then, they have to use the school computers. For most, that's enough incentive to keep on task.