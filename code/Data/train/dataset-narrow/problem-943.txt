Having this helper class, , eases the task of the main class quite drastically, so I provided some extra methods to allow for retrieving the name/value combo by index, or by name, so that one could verify that the is in the right place. Some other comments related to the main class: 

To properly answer your question I would focus firstly on why you want differentiated test sets, and not carry all the eggs in one basket. After that I'll focus on using factories or not, before a little summary at the end. (Sorry in advance, for the somewhat lengthy response.) Some Test Levels Different test sets could and should have various focus and coverage area, which again will reveal various kind of errors in your code. Here is a list of various test areas (with my personal and simplified description): 

I don't actually know much about how base32 (or base64) works, but I noticed that there was no official base32 implementation in PHP, so I figured I'd make one. I Googled around a bit to figure out how it works, and found this page. Using the examples at the bottom, I hacked up this base32 class. GitHub project: $URL$ 

This is just an extension to @palacsint's answer. You shouldn't pass strings to , it uses , which is inefficient and insecure. You should pass a function. Problem is, in the loop changes, so you'll have to use a closure. Don't do this: 

I am working on a program to decode MMS PDU files. They are binary files and I am reading them byte by byte and decoding each header value as I come to it. One header value is the Date, and it's represented as follows (in hex): 

Code restructure I've restructured your code to accomodate the already commented issues, and some more style related issues: 

Here is another view on your class structure, in an attempt to make it both more readable and more pythonic so to speak. Let us start of with a yUml diagram of your class structure (somewhat simplified): 

Here is declaration of a three dimensional list of list of list (of ... :) ), where the first dimension is based upon your variables, the second dimension is the level (I only added 3, not 5 as you have), and the last dimension is for the two different randint-parameters. Have also added a print statement to list which combination is used for debug purposes, and some actual calls to the method. 

For fun, I made a function queue in JavaScript. I named it tinyq. You can add functions to it, and each function is passed the next function in the queue. You can also pass parameters to the functions, and they can return values. 

That is, I am converting every byte to a string (like ), joining them together, removing the , then reading that string as a base 16 value. This works, but it seems a little too convoluted. I then realized that I could replace the / with , so now my code is: 

For my application, I was using , when I noticed it was returning the wrong value. I was using multidimensional arrays, therefore I needed a method. I Googled around and found a few, but they all only took 2 parameters. The official can take an infinite number of params. I wanted mine to, so I wrote my own function. 

Possible major speedup I just realized that you could get a major speedup related to the dictionary lookup. It is very expensive to get the complete word list, , for every sentence. This should be done once, and created into a set, which then is used to check for existence within dictionary. It's late in the night locally for me, so the following code is untested: 

So the main claim I would say is to decouple the pressing of buttons from the moving of the elevator. With current code this would most likely break stuff. Besides that, the code seems decent and clean. Alternative approach A proper Elevator would most likely handle it's own moving. To have the move coordinated by the Manager seems kind of strange. I would rather have the button press action done by the Manager, and sending events to the Elevator which would have its own Event handler. In the event loop within the Elevator, I would then look at which way it was moving, and see if there are other requests for floors in that direction. If not, flip direction and see if other requests exists. Stop when no more requests exists, and if a new event is fired, repeat process. This would also allow for the Manager to send events from the buttons on each given floor, or from inside of the elevator, or possibly from a control room. In all cases a single event of wanted floor would be sent. Such a scheme would also incorporate a proper separation of concerns, as the Elevator would only focus on handling events, and moving according to them. And the Manager would actually manage the user input triggering events, which finally would move the Elevator. I'm not quite sure what structure I would use for the requests, but I would not use one for up and one for down, as that would change as the Elevator moves. I think I would either have an ordered list of sorts, or possibly a static list of all floors with booleans for which floor have been requested already. 

is the "Date" header, is the data length (4 bytes) and the 4 following bytes represent the date (timestamp). I have code to read those 4 bytes and return it to me as a : 

This code works, I've tested it using this page, and it gives the same result, but I don't think this is the best way of doing base32. Is there a better way to do base32 that's maybe more efficient than what I have? 

So, what do you think of my function queue? Any improvements, or anything I'm doing wrong? P.S. I was also trying to make this small, any suggestions on making it smaller? 

Like I said, this code works, but I just feel there's a better way to do this than to convert the bytearray into a string and then parse that string back as a base-16 int. 

Your code does loop 700 000 multiplied by 65 000 multiplied by the number of elements in each cluster. That is a lot of iterations, and not very useful. The better approach would be to read the smaller file into memory, and then read the larger file line by line. In addition as you iterate over each row in the smaller file, matching each of the keys, it makes sense to switch from a dict with as key, and the different keys as values, to actually using the keys as keys, and list all the clusters it belongs to. This approach would leave the lower memory footprint, but should be rather efficient to work with. Here is some code to start you off with. You might need to adjust a little related to splitting on space or tabs, but I get your wanted output using this. 

I was wondering what you thought of my attempt. It seems to work ok for my application, and in the few tests I tried with it. DEMO: $URL$ 

I thought of a neat solution to this. Not sure how efficient it is, but I thought it was neat. If you look at your result array, you'll see results from "0000" to "2222". These are the numbers from 0 to 80. In base 3! So, using that, I whipped up a function to create all numbers in that range as an array. 

Apparently is a and is an . In order to parse this as a date, I need to convert it to an int. These bytes represent the timestamp (or ). I have code to convert this byte array into an int, but there has got be a better way to do it than the way I came up with. 

Edit: Original code had a little flaw regarding the parent_id. The now corrected code gives the same output when using the provided CSV file as the output from original code. 

This last one simplifies the structure by realising that all of the 's depend either one or both being null. Then if both are null return , or if only one return or depending which one is null. The second return statement, does the ordinary comparison as both are not null. Edit: Changed into as it turns out that can return not only . Further reduced the shortest solution, as suggested in comments, but kept an (unnecessary) level of parenthesis to keep some readability. :-)