When a player navigates a space for the first time, it is very interesting: the content is new, the dangers are unknown, paths need to be found. However, various situations force the player to backtrack, or navigate the same space multiple times. Perhaps the level designers are being economical, or trying to build familiarity with a space. Perhaps the game itself is open-ended, or like a sandbox, where navigating the same spaces is part of the game itself. These can make the same spaces seem tedious and sparse. Given that backtracking (or navigating the same space multiple times) is unavoidable, what are some effective, economical ways of making it interesting? Please keep in mind: 

This is to address your overlapped strings described in your edit contains arguments where you specify the position to start writing your string. Normally that means the first character will be at the specified position and the rest of the characters continue to the right (although this - the text alignment - can be changed via the argument). However if you reuse this function to draw a second string without changing the position, it will not draw the second string to the right, or below the first string. It will draw the second string at the same starting position as the first string, resulting in overlapping text. You have two options: 

Broadly speaking there are three approaches to rewinding game state (with various flavours in between): reversing/undoing actions, replaying actions from an earlier, fixed state, or storing all states and just picking the right one on demand. The first is more flexible but in the worst case you need to double your work, creating reverse versions of all your commands, plus you need to keep around "dead" state so you can undo into them (reviving dead entities, keeping all their properties around so you can resurrect them, v.s never really removing them, just toggling an "alive" flag). The latter two are much easier, but if you have complex, real-time, long-running states it can be very expensive to replay or store everything. Judging from your genre though (TBS), I'm inclined to guess that the replaying or even full storage approach will be fine. After all, chess is a turn-based game but entire games can be stored in a few dozen characters, describing the moves. Given that the replay and store approaches don't require reverse commands, your first two questions are irrelevant for them, which may save you a ton of trouble. Note that you should consider hybrid approaches too, which offer excellent compromises. Braid, IIRC, used a hybrid of stored states every short while plus replaying commands forward, and could store almost an hour of real-time gameplay. 

One quick-fix I had in mind was to give the player some sort of powerup or vehicle so that they could backtrack faster. I'm sure there are better methods, and examples of games where they were used. 

Then the choice is clear; A should pick A1 because it leads to the best payoff (because A expects B to play B1, which leads to A playing ... and B playing ... and so on and so on until it leads to a payoff of +3). With simultaneous moves, you need to consider both players' moves together, in a payoff matrix: 

One solution is to start the terrain with one type only (e.g. all 0s or all 1s), and "paint" the other type on progressively, noting the ones that you need to change into "cliffs" or "transitions". If you ever need to make an impossible cliff, resolve it by either "promoting" the cliff or discarding the thing you're trying to paint and move on. For example, you can start with 0s: 

It sounds like you are looking at an unusual problem for games: given a bunch of rectangles with connecting edges, lay them out so that no rectangles or edges (I'm guessing) overlap. Usually the layout happens during map generation, which means it's trivial. The general problem, of laying out a planar graph with a set of goals (minimise overlaps, edge lengths as even as possible) is a major field of study within Graph Drawing. People write papers on this stuff, and that may be cool, but might be a bit heavy for someone new to game development. Therefore I suggest you take an existing graph layout algorithm, and modify it to include the rectangle overlap criterion. Depending on how well you want to do it, it might be trivial, or you might need to dive into the bowels of the algorithm. Keep in mind that you are by no means guaranteed no overlaps; recall the three utilities puzzle that has no solution (but never fails to confound the internet). Here's one way you could do it; one of the simplest graph layout algorithms to understand are force-directed ones - they simulate the graph as nodes that repel each other and edges that are spring-like and try to become as short as possible. There's even an open source javascript version called springy.js here (GitHub, demo): 

People who make suggestions are often fans or critics, who are invaluable as they help you know how well you are doing. Therefore you should treat these people with respect. Be gentle, firm, and most importantly, honest. This means you tell them exactly why you think their idea is bad, whilst being as understanding as possible. 

You may find this cheatsheet useful: $URL$ When you get an error in Python, you also get the exact line of code that caused that error. That should help tremendously in troubleshooting. 

If you're looking for some magic pattern or data structure that deals with prerequisites, I don't think there is one, or rather, it's very simple: all you need is a simple way to query the number of Xs in Y, and a clear hierarchy of ownership. That is, be able to query things like: 

You can't. At least, not as a game developer. As a gamer, you can purchase more expensive keyboards with "anti-ghosting" features, but otherwise the limitation is part of the hardware itself, so there's nothing you can do in software to solve it. Check out this demo page to see how keyboard ghosting works, plus a demo: $URL$ So your best bets are: 

In fact the sunglint area will just keep enlarging until you are far enough from the Earth for it to be more round than flat, from your perspective. In terms of the Phong reflection model, the specular depends on three directions: the eye, the light, and the surface. Since your camera is looking at the same surface, just moving away, the eye stays the same; the surface stays the same by virtue of being flat, and the light stays the same by definition (it's a directional light), therefore the specular reflection will be the same - from the camera/screen's perspective, of course. 

It is now quite some time after the original question was asked; Chipmunk shapes have a property called "elasticity" which is a number from 0 to 1. Setting it to 1 for both bodies you want to collide will ensure perfectly elastic collisions. However, you mentioned that you want to "keep moving bodies moving at a constant speed". This is physically incorrect behaviour. Imagine billiard balls which are a close real-life approximation of elastic collision; depending on the collision angle, the resulting speeds can be very different. Or imagine Newton's cradle, where the collisions cause one ball to have some speed whilst the other to remain stationary. Instead, you will have to override the physics engine after collisions occur. You could do this by using : 

This way you can freely choose between a form you are comfortable with using, as a developer interface, vs whatever's best as an implementation for whatever reason, including efficiency/cache reasons. Another advantage to the facade is that it leads very naturally to the Flyweight pattern, where you use an interface to represent much more persons than are actually in memory. For example, perhaps you have robotic patrons which are never thirsty; then you can put that special case into your , and users of that interface never have to know about robots: 

Again, we have 2 foo-or-nachos, but this time also 2 bars and 4 cakes. You may be wondering why we're guessing the values at the end - isn't there an algorithmic way to solve this? Sure, there is, it's called integer programming which is unfortunately NP-hard. So guessing, or going through all the possibilities, should be good enough. 

At first you see that your commands are in the form of a list, so your first instinct might be to recreate that structure, and each dwarf will run through that list in sequence. What I suggest though is to break the list into steps, with each step having prerequisite(s), and then you run the entire command in reverse. Let me demonstrate with an example: Wood cutting 

What you'll be after is an image scaling algorithm. You can do this using plain (as in CPU) code, which is very slow, or I believe many scalers are available as GPU shader programs. This is especially suitable for you, as it sounds like you are working with low-resolution pixel art and you want to upscale them without introducing blurriness. The simplest algorithm is nearest-neighbour but it tends to introduce blockiness, which may or may not be what you want. Typical pixel scalers will try to look for line patterns and preserve them. See this example (original is in the middle, nearest neighbour on the left, 2xSaI on the right): 

What should the AI do, in the presence of a small obstruction that splits the exit? Stop? Or continue? Remember, technically the target could be hiding just behind that obstruction and avoid being seen, and double back on your AI. Virtually all problems of this kind (LOS, navigation) will be greatly simplified by performing some preprocessing, so that the geometry is simpler. It is then possible to do as you suggest - creating LOS zones - since we can make lots of assumptions with the simplified geometry. It is up to you to decide what kind of processing you can accept. 

- this needs to happen before any other use of - this needs to be done before any other use of Load and scale your images. Note that doesn't need , but you're also using to scale your images, hence the order. 

Valkea has the right idea, but I recommend you modify the of your Sprite to what you intend - in this case, the center of the sprite. If you were using P2 or Ninja physics, this is done automatically for you, but with Arcade physics, this defaults to the top-left corner. Simply call to set both the x and y anchors to the middle. Doing this will save you from having to account for the top left corner everywhere. The anchor point is used when transforming (flips, rotations, scales), measuring distances, when specifying a different collision box size than your sprite, and many more. Have a look at the Phaser anchor example for a visual representation of the anchor and how it affects sprite positioning. Update: the property now belongs to . 

You can construct non-perfect mazes as DMGregory mentioned, starting with a perfect maze then deleting walls at random. However, it sounds like you may be after a maze that's not quite the same as a non-perfect one. The definition of a perfect maze is: 

Giving players the ability to cause massive harm to each other leads to polarising opinions, and creates a large psychological factor to the gameplay. Permadeath alone makes the game take on a whole new tone, since even trivial choices (such as whether to quaff a potion) can have drastic consequences, so the game becomes more cerebral. Adding player killing to that mix makes things even more severe: not only do you have to weigh the benefits and costs of killing another player, you must also consider whether she considers killing you worthwhile, or even worse: whether she just wants to kill you for fun. Another question to consider is: why is it that DayZ feels like the wild west, whereas Eve Online is like warring nations? In these games where there is so much player freedom (including the freedom to kill each other), tiny changes in gameplay have huge consequences. Things like whether players can kill each other in a split second, whether the combat favours small or big groups, whether there are safe areas, these all have a big impact on how players treat each other - suspicion, paranoia, the size and stability of groups. More learned folks than I have studied such phenomena, so I won't dwell here: find more reading online if you are interested. Bottom line is, PVP permadeath has huge implications for the game, and your level of control as a game designer; more often than not you'll feel like running a social experiment than crafting a world. So to finally answer your questions: 

And generate outputs for biome assignment (most typically moisture and temperature as inputs into the Whittaker diagram)? I've studied Amit Patel's great article on this subject, but it does not do much to model climate or precipitation. Note: by "available for game dev" I don't need a turnkey tool, just interested in approaches that people have tried and how well they work in practice. This means it could be some hacked-together monstrosity in an obscure roguelike, but not something that only exists in a PhD dissertation or requires a supercomputing cluster to run. 

Sometimes there is no upper limit to the length of your game; you can keep making it longer so long as the cash is flowing in and the players are there. Just as they keep making episodes of The Simpsons by adding characters or even rehashing plots, you can add levels, new mechanics, rehash old mechanics... and sometimes the players love it! 

Which you can use to generate a file. Using this file, translators generate a language-specific file, which they can fill like this (everything except the is generated): 

You may be dealing with keyboard ghosting, the phenomenon where certain keys cannot be pressed down simultaneously. This differs between different keyboards, but you can test it out in the link I've provided, which has an interactive program for testing key presses. You may be able to fix this problem by finding different keys that can be pressed together, or using different devices or even multiple keyboards. You could also try more expensive keyboards; a lot of gaming keyboards advertise "anti-ghosting" features. 

This is the real problem we want to solve; GID is just a means to this and is quite poor in that regard too. We have very little control over it; we can't tell Tiled that "instead of GID 123, I want to use wall or w as the value so I can look for this in code", or "always use GID 1 as tile #1 in the Walls tileset". So I suggest keeping away from exact values of GID and using one of the following techniques: Differentiate special tiles by tileset That is, instead of remembering that GIDs 56-68 are walls (and breaking once you update the tilesets/layers), you keep all your walls in the one tileset/spritesheet, give the tileset a name (e.g. Walls), and treating all tiles that came from that tilesets as walls. You still need to compare the GID with all the s of all the tilesets to figure out which tileset that GID belongs to, but you can now add/remove wall tiles with impunity. Differentiate special tiles by layer You can also keep all walls in the same layer, and give it a special name to look for. The downside is that your map editors will need to take care and draw only walls in the wall layer and everything else on other layers, lest you end up with intangible wall-tiles and impassable non-wall-tiles because they were on the wrong layer. The upside is that you have full freedom in composing your tilesets, to suit your artist / texture packer. Unfortunately both approaches requires some human diligence, whether that's the people that make the tilesets or the people making the maps. For a more fool-proof solution, you may need to make your own modified version of Tiled Map Editor that enforces said restrictions. 

So you can see, the only path from A to D in this case is by to slow, to speeding up to fast, and to fast. Path cost is also easy: it depends on the speed. So if we arbitrarily decide that the cost of fast-fast is 1, fast-slow or slow-fast as 2, and slow-slow as 3, the cost of is 3 + 2 + 1 = 6. The problem as you may have guessed, is that A* operates on graphs, and not on continuous ranges. That is, you need to come up with discrete speeds like I did with slow/fast, and each additional speed level will multiply the size of your search graph. The more physically demanding your game, the more speed levels you'll need, and the more costly pathfinding will be, and at worst it will be too expensive for games. If it is, then you have some other options: 

According to color theory, shadows work better if they don't use pure blacks or grays, but instead use a color that's complementary to the color of the object casting that shadow. That is, if you have a red apple, you should use a dark green shadow; for a yellow banana, a dark violet shadow.