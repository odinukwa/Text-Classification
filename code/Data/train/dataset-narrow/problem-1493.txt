Note that is a pure function which makes it very easy to test. You can create unit tests for your code which may be run automatically by your build process. Pure functions are also a lot easier to test directly in a ghci session. Your game loop can now look like this: 

Then you have a list of primes and their exponents: (p1, e1), (p2, e2), etc. and the number of divisors is: 

Each of these steps can be put into their own helper function which are also called "subroutines". The will make the body of the while loop a lot more readable. Here is an example of a subroutine to get a valid number from the player (again, pseudo-code): 

First of all, the class describes a player in the game, so maybe reflect that in the name of the class, e.g. . In that respect the name name is good because it gives clues to the reader as to how the object is used. Secondly, if I read and correctly, you are just returning a copy of an object. Surely there must be a more idiomatic way to create a shallow copy of a JS object that doesn't require explicit looping? Or, how about just returning and hope that the caller doesn't modify it? Or, why do you do even need to expose ? I don't see where you call it. And for you don't need to expose the entire object - you just need to know if a player has a weakness for a specific user name. In the class , just expose this function: 

So in the vein of an old dog trying to learn new tricks, I've decided to try to polish up my JavaScript skills. I've used it a lot but I don't claim expertise. I'm looking for any critique on the approaches I've taken, particularly in style - I can accomplish what I want, but I don't have the intuitive sense of the best approach to take to various problems in this language. The Goal My first goal was to come up with a good way to handle routing to an MVC controller in Express. I had looked at some other frameworks (Sails.js, etc.) but wanted to try my own. Basically, I wanted a way I could ask Express to create a route like and have it route a request such as to an action called login on a controller called user. The Design Some of my design choices: 

My Main Questions / Thoughts I debated a lot around what the export of this should be. I was considering exporting either a new ControllerRouter object or the ControllerRouter constructor but instead created a new object and closed over it. My main reason was to give a simple and clean interface. I opted to use a ES5-style constructor function rather than an ES6-style class just to get more familiar with thinking about prototype-based inheritance, not because an ES6 class is a bad approach in my mind. 

naked calls Note that simply allocates memory - you have no guarantees about what the newly allocated memory contains. For that reason it is better to write a function which both allocates and initializes an new object, i.e.: 

array reshaping array row, column and diagonal slices to compute the product of all elements in an array flipping the array to get anti-diagonals 

Note that row and column indices start from 0. In the case of diagonals, 0 is the main diagonal, with positive diagonals to the right and negative diagonals to the left of the main. Products And here is how to use : 

I think you really should look at this guy's solution which employs numpy: $URL$ The advantages are: 

The prediction algorithm then boils down to a nearest neighbor search in a high number of dimensions (e.g. the length of the pattern array.) 

Nothing really wrong here, but I have a suggestion... it is customary to repeat the key if it isn't long enough for the entire message. I.e., if the key was and the message was , you would repeat the key as many times as was needed to cover every letter of the message. The key used to encode the message in this case would be . You can use the function to repeat a list forever: 

Not that recursion is bad, but using streams results in a more declarative definition. append I would avoid in a Lisp or a Scheme. I'm sure it's not efficient for use on lists. , however, is always efficient, so in you should use: 

The idea is to search the array from left to right, looking for rises in elevation. When we find one, we backtrack looking for how high up we can fill the valley, and then redo the backtrack, this time actually filling it (this prevents "double filling" in future elevation rises). The worst case arises when we get a large elevation on element 1 and elements 2 through are rising from 1 to the value of element 1. IE . In this case we do the maximum number of backtracks. If I have my math right, our time complexity would be $$n + \sum_{i=0}^{n} {i}\ = n+\frac{1}{2}n(n+1) \implies O(n^2)$$ So quadratic time obviously a red flag, but I'm not sure I can avoid it since I'm dealing with 2D arrays. Other than that, the big ugly part is the variable in . The point of it is to check that the left edge we end the loop on is properly checked. The last notable issue is that much of this code would be very risky if run on its own because the assumption is that all inputs are valid. This was due to time constraints though, so I don't consider it an issue. 

I like this solution because it is very simple, however it does have one inefficiency. It finds the square root only to perform a squaring operation again. It would be nice if I could find the largest square number in squared form immediately, but I cant think of an efficient way to do this. 

The above defines an action 'login' with separate handlers for HTTP get and post, and an action 'logout' that handles all HTTP verbs. An Example of Using It The module exports one function which takes a directory as input and returns a router suitable to be added to an Express middleware stack. This router defines a method called addRoute. Note that the route must either specify :controller and :action as route segments or these must be defined on an options object. It's perfectly fine to use with both and - each router will only map those URLs which correspond to actual controllers/actions found and loaded, it doesn't match all two-segment URLs. 

I wanted it to load all controller files within a given directory. That seemed the right trade-off in terms of granularity. It's important, though, that I could create multiple instances in order to load more than one controller directory. I defined a 'controller' as any file ending in within the given directory. I strip any suffix if provided (e.g. either or defines a controller named .) A controller will export 'actions'. An example of two exported actions: 

Really you only have two approaches - iteration, or precomputation. There have been some other examples of precomputation here, but I'll throw one more into the mix - computing the sums at the time each element is added/removed from the collection. You'd need a custom collection type - here basically everything except .Add, .Remove, and .Clear just call into the list's implementation. Add is quite straightforward, we added a new item and it becomes part of a new triplet. Remove is slightly trickier as we have to remove three precomputed values and recalculate two of them. A Dictionary is used to count the number of triplets summing to a particular value, so that we can remove the key only when every possible triplet summing to that value is gone. I chose to do the bounds checking within the sum method itself but that could be done elsewhere.