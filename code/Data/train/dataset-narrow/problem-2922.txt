As with a lot of hiring questions, "it depends". The human element in hiring can't be ignored. That being said, there are a couple of things to keep in mind. Are you going to be talking to a big company or a small one? Bigger companies might have HR personnel who aren't necessarily game developers who do the initial filtering. They might be more inclined to look at appearances for their opinions on candidates than, say, the art director at a small company simply because they don't have the expertise to really look analytically at someone's portfolio. Also, remember just like any other job you're going to be working side by side with people for (hopefully) a long period of time. First impressions matter. As an interviewer I'm looking for both game development skills and people skills. Namely, am I going to want to work side-by-side with whoever I'm talking to? Do they show poor judgement (like wearing an offensive t-shirt to a professional setting where they don't know the audience)? How's their hygiene? Dressing sharper might help with those sides of things. But don't dress sharp if you don't know how. Don't wear a button down shirt that isn't ironed. Don't put on too much cologne. And if you're not comfortable in a tie, don't wear one. An interview is stressful enough as it is, and you don't want your clothes working against you. I've interviewed junior candidates that wore suits and ties. If we thought they were smart (and likely to get the job), we'd poke fun at them a bit. Mainly just to get the point across that our culture didn't really care about that kind of thing (and, as far as I know, most game companies really don't care). But generally it didn't count against them. 

There are a lot of articles out there that a simple search will yield answers to, but here are some highlights from what I've found: 1) You absolutely want to give out small rewards. Most slot machines actually have a pretty high payout ratio (on the order of 70-95%) of what's put in. A good percentage of the time you'll make your money back. Of course, over time slot machines are guaranteed money makers for the house, but you want to string people along. 2) The idea of risk vs. reward is important. Almost all slot machines let you place higher than the advertised minimum, and scale up the rewards accordingly. So a $1 slot machine is really a $3-5 slot machine since players will naturally want to put more money in after they see that their winnings could've been higher. 3) The "almost" win is an important psychological factor. Consider showing the images above and below the one you are scored on so you get the occasional "so close" thought. 4) It needs to be flashy. Spins need to be quick so that they can play again quickly. Sounds are important. 

I'd throw away the first two of your bullet points. It might be a good idea to get some units designed, but isn't going to really help you for balancing. Really what you're going to have to do is just play the game a lot and keep a analytical mind (or set of minds) looking at the problem at all times. Design is a very soft art, there is no iterative way of saying whether or not a game is balanced. On the other hand, these are the kinds of things genetic algorithms are pretty good at weeding out. It won't replace having a large beta test and human feedback, but it might catch some edge cases you won't normally think of. 

You can always just do a naive approach. Just iterate through all pieces and see if there's a match in any direction, and if you get to the end before any matches are detected, then you have no matches. 

Usually you just say "my character is X meters tall" and put the camera there. For the player's hands you have a custom model that looks good from first person that's separate from what other people see in the world (assuming you can see other avatars). 

I'd just set up a dictionary of id (type of unit) to int (number of that unit) and keep track of the number of units that way. 

Fundamentally frictionless movement is just playing with inertia. In whatever your movement code is, don't stop the player immediately when they release their button/analog stick. Instead you want to very slowly reduce their velocity to zero. Or if you wanted to be truly frictionless you never reduce their velocity. 

If anything, the first option might be better for cache misses since generally you'll be iterating through, say, all the components at once. Just copy the data you need into that component to avoid cache misses due to looking up data. But it seems like you're suffering from design paralysis. Do you actually have a working game yet? Are the problems you're trying to solve actual problems given the scope of game (or games) you're planning on using with this tech as well as the target platforms you're hitting? Just pick something and move forward. Benchmark if you really need to care about performance (chances are you don't). Use good design practices to keep things separated enough that you can refactor into one or the other pattern if the need arises. 

Well they don't use something like a UIScrollView, that's for sure. You would just move the camera over a stationary world or move the world under a stationary camera. I'm a little rusty on my GL, but I would guess you just push a new translation matrix before all your drawing. For the actual dragging part, you would also implement that yourself. It would probably be something where you check to see if there was a certain amount of cursor/finger movement delta in a given amount of time to see if it's a "drag" or a "click". Or maybe you always drag unless the user clicks on a UI element or something like that. It really depends on the design of how you want that system to work. 

The quickest/cheapest way to get up and running would be to use the Unity engine for the client, and something like Photon as your socket server backend. If you're looking for something with more off-the-shelf support, there's things like Hero Engine. If you're asking which language to use, I'm assuming you're not experienced enough to pull off starting from scratch. 

Honestly I don't think using a physics engine is the right approach for something of that size domain with super strict requirements. Just write it all yourself. You'll get much better results by saying "move character up by x units in this parabola shape when holding down jump button for length y" than by having a bunch of knobs to tweak. 

It should be fine. You'll have to do some command line stuff to get it to sign appropriately regardless of pro or free, and that's all documented here: $URL$ 

As I said in the comments. The "right time" is when you want to make a game that needs that feature. 

Monetization heavily depends on the platform, but for the iPhone specifically, freemium (specifically, buying into something that lets you play more effectively) has proven itself to be probably the most viable strategy for games in which it fits. A few sample points: 

If you didn't have vectors and wanted to use this approach you could construct unit length vectors given your angles by doing . 

Unless there's other ocde you're not showing us, is never initialized to (bools are by default), so your never gets called. When you're running into issues like this, the best thing to do is attach the debugger to it. Barring that, put debug prints on lines you think should be getting hit with the values of variables as they currently are so you can see the program flow. 

There are two things Unity does to handle this. 1) All game objects innately have a Transform component. 2) When authoring game objects, you can specify that certain components require the game object they're attached to to have other components. They do this through their RequireComponent attribute. You can do things like say "when this component starts up, and the game object it's attached to doesn't have my required components, throw an error". 

There are two ways of doing it: root motion or "in code". With root motion you have basically exactly what you're suggesting with the "moveTrans" node. You use the motion of that object to determine how quickly to play back the walk cycles. You might be able to do a reverse lookup of sorts to figure out that if you want to be at position X what frame you need to be at. But the real advantage of root motion is that to get truly realistic animations you need to account for the fact that movement isn't a true linear path. Real people move at a variable speed over time, or maybe they're shuffling left and right a bit, or whatever. Mixamo did a good example with root motion control using Unity. There's a video of it here: $URL$ Now root motion does have its drawbacks. It can get tricky with things like trying to get the "walk" animation to work on stairs (ideally you'd have a separate stair/ladder climbing anim and do all the movement for that in the animation as well). I'm also not really sure how IK really plays into it, if at all. Now doing it "in code" is a lot easier from the programming side of things. What I suggest doing is first making sure all your units are consistent. For example, 1 unit in Maya and your game is 1 meter. Then you get your artists to animate a character walking (complete with forward movement). Use that to figure out the speed of the animation, and export the animation without the forward velocity. Use that to figure out how fast to play back the animation. So if the walk animation at 1x speed is 5 m/s, and you want to have the player run at 7 m/s, you simply play back at 7/5 = 1.4x speed. If your model is scaled up or down multiply the animation playback rate by the inverse of the scale. A half height dude will have to walk twice as fast to move the same rate as a 1x scale guy. 

Fundamentally creating a game with a one man team isn't really any different than creating a game with a huge team other than the fact that you don't have as many (or any, really) specialized people or parallelization of tasks. The decisions you would make here are the same decisions you would make if you were running a team who's goal was to get to ship as quickly as possible. So you have to play to your strengths and design away from your faults. If you aren't very good at high poly art, you either need to pick a style that works with your skill set, or use existing art in the form of mods or buying art off stock websites. If you don't know anything about multiplayer networking, use middleware that solves most of the problems for you. In particular, getting bogged down by non-critical-to-gameplay technology and features is going to suck away your time and not get you closer to your end goal. I'm personally a big fan of Unity due to it's super quick iteration time, easy art pipeline (just drop in pretty much any format and it'll work), and the ability play the game from within the editor. All of these will help you get up and running quicker than using something more "professional".