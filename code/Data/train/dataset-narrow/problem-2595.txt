The C64 only supports 8 sprites per horizontal scan line, so I don't think that everything in the middle of the screen can be a sprite? I would assume that anything requiring a collision would be a sprite (since I can get hardware collision detection with sprites), but even then I quickly hit the limit of 8 sprites. Also, my weapons can fire much more than one projectile - my ship, the satellite and 6 bullets would already be 8 sprites on a row (look at about 50 seconds into the video). Also, which graphics mode would a game like this use? The Programming Handbook lists Bit Map Mode which essentially modifies screen memory directly. Is this the mode I should usually be working in? How would I compose all the non-sprite elements together to get them on screen? A lot of the stuff in the score and status bar is static ("Area: 01" or the "frame"), so I guess I'll just populate them once when the level starts. Things that need updating - the score, the charge bars at the bottom - would be updated by filling the screen memory with black and then drawing the new score every frame? Or do I have to draw the entire screen on every frame? 

The Score bar, with different fonts The ship itself A satellite attached to the ship, detachable Secondary Weapon Projectiles Primary Weapon Projectiles Moving objects (can be enemy ships) The Status bar, featuring an image of the ship, the number of lives and three sections that can fill The primary weapon charge bar, can fill to the end A scrolling starfield in the background (not numbered on the screen) Solid objects like rocks or metal walls that are part of the background 

Local Host: All the network testing I've done on localhost has been completely misleading. Since it's a perfect environment it's useless... Packet Loss: The packet loss and latency you experience will differ based on your current lan set up. I've set up on several separate routers, and gotten completely different results. Recommendation: It would be horrifically slow to compile, throw the executable elsewhere, recompile (in the beginning, before menus and such) run it on your compie, and connect, then test. What I've done lately is have a persistant server (on another computer) that simply forwards whatever is sent over any port to a partner, and set my program up as a client, so there's no further config necessary. It's a path that's treated me well so far. 

Hahah, this is a pretty common problem, here's what I do-> Step 1: collision detection: Be sure you're separating your map into sections or using quadtrees to speed up grouping, Step 2: basic collision resolution, my preferred method works great for moving platforms, I always preform this check 

Well When I play games I absolutely hate the opportunity to cheat until I've played the whole way through. Because I'll get frustrated with one part and want to skip it, so I'll revert to cheats, but it will make the whole game horribly boring! What I'd do is have the player run through at least once before enabling cheats. Then once you do, enable them all, because it really should open up the game, make it a sand box of sorts. 

You would probably be well served to know quite a bit First: Game programming is easier than it's made out to be, it's not extremely simplistic, however it is easy to wrap your head around. Second: C++ doesn't offer graphical abilities right off the bat. There is nothing in the standard library that does straight graphical stuff. Therefore you must learn another library/API in order to work with graphics. Third: Be prepared to spend time learning. Be prepared to spend time troubleshooting. Be prepared for crappy programs/games, simply because you don't know better. You will get good with time, dedication, and will power. Fourth: Game programming, and graphical programming in general is AMAZING! It's like creating worlds with your fingertips. Nothing is beyond reach. 

I've been looking up the definition of radians and found out that mathematicians prefer them because they are derived from pi instead of being completely arbitrary like degrees. However, I have not found a compelling reason to use them in game development, possibly due to my complete lack of related mathematical understanding. I know that most sin/cos/tan functions in languages what radians, but someone could just as well create library functions in degrees (and avoid the inherent rounding errors when using pi). I don't want this to be an opinionated poll, I would just like to hear from people that have done game development (and the associated math research) where radians offer a superior experience over degrees, as opposed to "We're using radians because we always used them", just for the sake of helping me (and possibly others) to understand what they are good for. 

When writing a C64 game in 6502 Assembler and loading the game using , I can choose the address where the game is loaded to. The most popular address I saw is , closely followed by , but I also saw and used a lot. Why would I choose one over the other? I understand because it's close to which you have to write the instruction to, but the other addresses all seem arbitrary. Can someone shed some light into this? 

id Tech 3 isn't really free - it's GPL, so your entire Game has to be GPL. You used to be able to license a non-GPL Version for $10,000 but that options seems to have disappeared after the Bethesda-acquisition. Apart from it's age, id Tech 3 doesn't have much in the realm of Single-Player AI. So if you want to make a "traditional" shooter, you have a lot of AI work to do yourself. Another problem is the tooling. There are a lot of Map Tools, but that's about it. There is very little assistance in the Asset Pipeline or Shader creation. On the upside, the Team Arena source contains an early version of MegaTexture and supports relatively large outdoor environments. 

With my AI, I simply check if there's a platform below and int the direction of its travel (not using a tilesystem, just a groovy collision system). If there is not- or if it hits a solid block, it gets a confused look and turns around. This way you can have dynamic maps and still have a working(term used loosely) AI. 

You need some way to store previous positions of your objects You need a way to detect and store all current objects you're colliding with 

Collision resolution, instead of collision prevention. Simply move the objects, then check if there have been any collisions. If there has been a collision with another block move back to previous square, or depending on the game type, a different square. 

One thing that I've done lately, is getting up painfully early every morning to program- my mind is fresh, and I stay clearer throughout the day for my job and the rest of my activities. The problem with this route is the necessity of going to bed early- and if you've ever been on a programming rampage, you know it's tough to stop for simple things like (pshh) sleep- who needs it? But seriously, 5am-8am = programming time. While I've been doing this I've completed more games while also working full time and having a social life than I ever did programming full time. 

First Simplicity is key. Second Expandability is necessary. What I would do, if I were making a "hack n' slash" is create a simple bounding box technique. Define the height and width of the attack, then check collisions with the box. Keep in mind, that if your character can go inside of other characters you want to include your own collision dimensions in the attack box. Simple, and expandable.