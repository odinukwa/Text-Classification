Nitpicks/Style Python has an official style guide, PEP8. I'd highly recommend that you read it, as it has some very valuable information. You do have a few style violations though, so here's a small list of them: 

You need whitespace between certain things. For example, the expression would become , or would become . You need whitespace around any operators, comparison, mathematical, etc. It is the Python standard to indent any blocks of code by four spaces, or one tab, not one space. There should be two blank lines between functions, classes, and code blocks at the top level. Not one. Functions names, and variable names should be in . Class names should be in . You shouldn't group imports together on multiple lines. For example, the line would become and , both of these being on separate lines. The docstring below your imports/includes should be at the very top of your file. Finally, you should add some docstrings to your functions describing what they do. 

If you're using Python 3.x, as I assumed from looking at your statements, then you don't need to convert user input to a string. User input is already in a string format when it's obtained. The above code can simply become this: 

Using for string formatting is deprecated. You should be using instead. Here's how one would use : . also supports using keyword arguments. Here's an example of that: . Near the end of the function , underneath the block with the condition , you have comments above every line. These are unnecessary and can be removed. Finally, I'm not sure why you have square brackets, , around the value of the variable . If these aren't needed, they can be removed. 

First off, after doing a little reading, the style for ruby seems say that you should indent your code by two spaces, not four, like Python. Secondly the line can be shortened to this: . Rather than using a loop, and a variable, , as an iterator variable as shown in the below code: 

After making all these changes, plus a few more, I ended up with the following, improved (hopefully) code: 

This will also mean that the variables and will have the default values of and in the Unity Editor as well. In addition, in your class, you also don't need to initialize in as well. 

Try using and it's method instead of repeated string concatenations. As an additional point, you could set the capacity of the on instantiation to the maximum expected size of the output, to prevent array reallocations. That is, replace where is a , with where is a . s are mutable and avoid the object allocation overhead of concatenations. 

Simple, succinct, and to the point. I'm absolutely sure your code is overcomplicated for its intended purpose, and functional programming is not just about pattern matching and recursion, it's about being able to create greater functionality from pre-existing functions. 

The initial direction is always ; although you accept the initial direction as an input, you never use it. That line should be 

I know that you're supposed to create the slowest-growing function possible, but that doesn't mean you necessarily need to make your function the slowest possible (LoL!). As far as I can determine, your code for the Ackermann is mathematically correct - according to both Wikipedia and my (admittedly poor) sense of mathematical intuition. 

You'd retrieve the result with a dictionary lookup similar to . You'd simply do preceded by , where is the name of your dictionary variable. 

Now, you feel like you've probably lost all your beautiful formatting! Not to worry - to the rescue! It'll get you a containing the representations of all the elements in the , separated by commas and spaces with the whole thing enclosed in square brackets. So now we get to . Why hard-code ? I'll show how you can get the maximum number up to which to check for perfect numbers as a command line argument, and improve usability while at it! 

The way you do it - you are reimplementing division and remainder from scratch with a loop. This is, well, useless. The way you're doing it right now is OK if you can't use the above (course restrictions?), which would have helped a lot in this case - you could have used it to get rid of the loop altogether, just looping over the allowed prices. What can be done for your code is moving out the part which reimplements division and remainder into functions and using them, but then there remains no difference between the way I do it and the way I suggest for you to do it here. (Note that the extraction into functions is necessary for reducing code duplication and extending your code to support more prices). Here is my take: 

Why do all of your function arguments have default values of ? What purpose would these functions serve if they were run with all argument values as ? Secondly, you should have two blank lines between your functions, as per PEP8. Finally, I'd recommend adding docstrings to your functions, and your file as well. A typical function docstring looks something like this: 

Is there anything that can be improved here? This post is part one of a series based off of the contents of this GitHub repository 

Input checking The way you're currently checking input is clunky, hard to write, and hard to read. For example, you have the following chunk of code: 

Error classes Is there any good reason why you need the two classes , and ? They both explicitly inherit from and , so why can't you just use those error classes? I strongly encourage that you check out Stop Writing Classes. It gives a very good reason as to why you probably don't need to define your own custom error: 

There's not much for me to review, but if you want me to cover anything else, just mention it in the comments, and I'll see if I can cover it. 

Obtain user input by removing all punctuation from the input string, splitting it on whitespace, and converting it into a . Loop through a list of possible input sets, and check the following condition: \$\text{Possible Input Set}\subseteq\text{User Input Set}\$ Return a random reply based on the above condition, and output that reply. 

In my question to learn F#, I've decided to get one step closer to creating a programming language, and implement this simple Reverse Polish Notation "interpreter" of sorts. It does not allow for parentheses in input , and only accepts expressions containing the following valid tokens: 

But that's not all, we can shorten this two one line, by combining all of these s into one, and formatting one long string. 

This eliminates the need to call , and improves code readability as well. In the future as well, if you ever plan to add more buildings, it'll be a pain to edit this script to include the new building names. Instead, you could declare a public variable which allows you to drag and drop the model prefabs instead: 

The relevant JavaDocs are here: a. Files b. FileSystems c. FileSystem d. StandardCharsets e. Paths in If you aren't using Java 7 and above, the recommendation is to put all calls inside the statement after all the es (the "Ye Olde" way). For this, your IO streams should be declared outside the try-catch-finally block. It could look like this: 

This version of rotates the passed array in-place, so you can just print out the elements in a loop later. For printing, hoping you are on JDK 5 or greater, use the for-each loop: 

Make your function parameter . Although C++ is call-by-value, making it explicitly and mutating a local copy of the variable is never a bad idea, and it does make your function contract that much clearer. On the performance side, since on any reasonable computer will have maximally 16 bytes (64 bits of 8 bytes is the case for all common architectures, except for probably some microcontrollers which will have less, even as less as 1 byte) (note that the upcoming RISCV architecture does have a native 16-byte (128-bit) integral data type, but the 64-bit one is the default), you can easily make this function a template, such that the computation of the byte vector can be done at compile time without much overhead and incur no runtime overhead. You can probably even pre-set the capacity of your utilising . Although I'm not sure if this suggestion will work in the constraints of your application. 

For , an algorithm is to do it the normal, C (pointer-based way). Traverse the list maintaining references to 2 elements, the current element and it's previous element. At the element to be removed, set the field of the previous reference to refer to the element following the current element. This would work far better with loops than and . Again, imperative and functional don't really mix well in the same part of the program. Take a look here for a reasonable functional singly linked list in Scala. 

The keyword before the method parameter - which I named , because that makes more sense than : it signifies to the method which called that it will not change . Note that this modifier will also prevent any reassignments to , which is OK as you don't reassign it anyway. The spacing, bracing and indentation illustrates my above points. 

The general standard for Python is to indent by four spaces, or by one tab with a width of four spaces. You shouldn't be doing wildcard imports, (). Your naming can be greatly improved. For example, the variable could be renamed to . Use to format strings instead of using commas between string literals. Here's an example: 

Should be docstrings, not regular inline comments. Rather than ing your program in a not so clean way, from the function, you should just replace any s, like this: 

Naming Most of your naming is pretty good, there are a few variables that I'd consider renaming though. 

But that's still not all. There's a better way of initializing and in the constructor as well. Here's how the constructor would look after that: 

Finally, I'd recommend having something that allows for multiple keywords, rather than one. In addition to this, you may not want to be checking the length of intersections based on a constant, in this case, three. Anyways, if there's anything else that you want me to cover, just mention it in the comments, and I'll see what I can do. 

@janos already covered this a little bit, but if you want to use the built-in used in Processing.JS, I'd do something like this: 

Don't import multiple modules on one line. If an error occurs with one module, it can be hard to distinguish where the error came from. Some variable names could be better. For example, the names , or provide no useful information. Try to find any other names with not so great names, and see how you can improve them. I'm not an expert on asynchronous programming, or any of the modules provided in Python made for this, but if you want to do a task like this, Python 3.5 will include the and keywords built for asynchronous programming. 

There are quite a few things that can be improved here, so let's start with the obvious. Rather than having multiple individual conditional expressions to check the value of a variable, simply create a list of all possible values and use the operator to check the variable's value, like this, for example: 

When the user presses CTRL+c the program will exit. There is no need to catch the error and then manually exit with . 

Note that 's methods don't throw any exceptions - you need to call on to find out if any errors occurred. Internal calls may produce exceptions which may propagate up to , but that's not the general case. (Check the JavaDoc here.) The same for reading the file. Here my stylistic suggestion (2) should come in useful. Alternative Constructors and Encoding has a constructor , which does exactly what you do manually. You could just provide it the file path and it'll work. No need to manually create and objects. What is that in the second parameter? There's an overload of this constructor without the parameter - ideally, as @Peter Taylor said, you shouldn't use it. Why? "CSN" stands for "CharSet Name", or the output encoding. You'll generally want to pass in , which should be (case insensitive) for . You can find by importing . Encoding can be a problem when you go multiplatform. Note that or do not have such a parameter in any of their constructors. What you would want to do here if have Java 7+ is to use the class ' method to create the with the specified charset. You might call it like this: 

Type-alias to and import it to reduce some visual clutter. Also do the same with by aliasing it to to reduce visual clutter even more. 

and then your method becomes unnecessary and can be replaced with a , a method for retrieving enum constants by name defined in . You will also need to update your method signatures involving to , and add an before every piece of code in a given scope which uses a , i.e., one import before declaring the rotation s, one in (this makes the call on the value unnecessary in the rotation methods), and one in . However, this might complicate the code a bit and reduce the type safety offered by exhaustive pattern matching, however. TL;DR Your approach with a and s is the preferred one in Scala, this is just an alternative. Note, you could also as well used a Java enum for this purpose too. The one in clouds the functional-ness of the code a bit. You could replace the loop with a recursive inner method in , but there's always a better solution. Read to the end for a cohesive correction of your code. in Scala can be treated to inherit , as has an implicit conversion to , which is a subclass of , so you don't need to convert the to an before looping over it, you can use it directly as a . is semantically the same as , so use the former as it allows the syntactic sugar of making the entire call look like the following: