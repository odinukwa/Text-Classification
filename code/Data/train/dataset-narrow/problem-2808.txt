The best way to fix this is to round your X and Y values before drawing them. The "usual" way I handle this in XNA is to keep X and Y internally as a , and to expose them externally (eg. to ) as an . You should, of course, use to get you the correct tile. The code would look something like this: 

There's a great post on Zen Habits about this. If you can force yourself to sit down and work on whatever it is, even if just for 5-10 minutes, that will break your barriers and get you moving on your project. 

Another (non-GPU) solution you can use is path-finding. Before drawing the map, path-find from each potential spawn-point at each edge of the map and see if there's a path to the center. A* path-finding is pretty OK on cost/performance, but you can do this before the game starts if that's an issue. Any spawn point that doesn't have a path can be put on an exclusion list; or vice-versa (any point with a path can be put on an inclusion list). 

If you use version control, which you should even if working alone, you can always commit frequently and roll back your changes when you break something -- if you used the LibGDX app maker JAR to make your project, you should have a good, working starting point. 

I'm working on a Flash game after many, many years. I'm trying to figure out size to make my application run (eg. 600x800). Because it's a tall (not wide) game, I'm confused. I know about (and love) the Steam hardware stats. However, for Flash gaming, I have two nit-picks with their survey sample: 1) Caters to more hardcore gamers with better hardware (overall) 2) Captures only a subset of Flash gamers. Doesn't capture people who play at school, work, etc. or not netbooks and lighter machines. Are there any sort of statistics I can use to determine which size to use? Ideally, I would like to know something like: 

My question is really, which ones are out there and are worth uploading too? (And 1Mobile seems good, but just can't figure out how to upload.) Each site requires their own size screenshots and logo, so it's a bunch of extra work. I'd rather stick to the 80/20 rule and apply 20% effort to hit 80% of the markets. 

Once you do this, you'll have working code which you can run. You're misunderstanding the compiler error. It expects and you're passing in which is . That's not right. 

I'm making a bunch of 2D games (now and in the near future) that use a 2D, RPG-like interface. I would like to be able to quickly paint tiles down and drop character sprites to create concept art. Sure, I could do it in GIMP or Photoshop. But that would require manually adding each tile, layering on more tiles, cutting and pasting particular character sprites, etc. and I really don't need that level of granularity; I need a quick and fast way to churn out concept art. Is there a tool that I can use for this? Perhaps some sort of 2D tile editor which lets me draw sprites and tiles given that I can provide the graphics files. 

All in all, if you're sticking to just Android, it's great. But if you want to do iOS too, I would move to something else, like Unity or Corona SDK. 

Just keep it as a variable, i.e. . In your algorithm, refer to this variable exclusively when you're trying to determine if there's a match or not. If you want to vary this, say from level to level, I would suggest some algorithm like breadth-first or depth-first search, where you note the amount of touching, matched tiles. If it reaches the number you want, boom, victory. 

This sounds strange, and high-level, but I would consider modelling electricity through cellular automata. Practically, this means modelling electricity as a state (on/off) for each cell, and codifying a set of rules that tell you which states are on or off. The rules might go something like: 

I also have "domain objects" like and , which subclass Entity. Their constructors usually add a bunch of components. Since I'm a fan of the DDD idea of objects represent business/game entities, I model my classes around that. For a roguelike, my class has methods like: 

Although this is already answered, allow me to offer another equation: , where y is the coordinate calculated, m is the slope (-1 for down at 45 degrees, 1 for up at 45 degrees), and b is the y-intercept -- the y-coordinate where x=0. This allows you slightly more flexibility; you can change m to calculate a different slope other than 45-degrees. For example, an m of pi/3 gives you a slope of 30 degrees. 

I'm taking my first dive into creating a very simple entity framework. The key concepts (classes) are: 

Stream your video instead. This will then only require "hiding" the video URL, although it won't work if your players are offline. I've seen this pulled off in Flash games. When you reach certain progress points, they pull a (YouTube) video off the web and stream it in-game, and life is good. Again, players were pretty much guaranteed to have internet connectivity at that time. I'm not 100% sure if you can pull this off in XNA and MonoGame though. I'm pretty sure XNA supports streamed video. 

The problem with using a camera is that it will scale the image. What you essentially want is to always draw the same image at the same size (100%). I assume it's big enough to always cover the entire screen. If this is the case, one solution would be to apply the inverse transformation of the camera on the image so that it draws at a "pixel perfect" size. The easier option would be to scale it yourself. Eg. if your camera is zoomed to 75%, your image would be scaled to 133% (). 

Disclaimer: My entity/component system is a bit unique. Components are very low-level (eg. track input state by keyboard, or draw a sprite); entities combine entities and contain game logic (analogous to systems in other EC systems). For me, it turned out that the simplest solution that worked well was to treat components and entities as view-specific. For example, I would have a "world map" view (entity) for my player, and an "in battle" view (entity) for my player. The "traditional" model of the player (eg. inventory, health) became a shared object across each player* entity. When switching screens, I simply take the player "model" out of the current screen and hand it off to the new screen. 

In this case, it's a simpler problem of "pick the next best move." That would mean, the next move that takes you towards getting into a zero-visibility area.