Your loop has a potential complexity of R * M (R number of words in ransom, M number of words in magazine). Additionally you use in the inner loop which which does linear search in magazine. The solution is to count occurences of words in both, magazine and ransom. this is done in a single sweep and of linear complexity R + M (dict get/set is average linear). the moste dense and readable solution is 

No I/O from core functions We already did remove a print from . We now do that for others as well. When you do print from core functions you either 

here i used list [comprehension $URL$ Use the right data structures If you want to look up code for a letter you want to write which is clean and readable. so we use a dict for storing our codes 

it is clear and readable and tells all and shall not be done any other way. Now about sorting a . You rely on a 3.6 implementation detail that will be guaranteed in 3.7 when released. whenever you do such a version-stunt you shall check the version and either raise an error or implement a fallback (e.g. ). However when 3.7 will be released there might be a sort for implemented as well. Your solution is most likely becoming obsolete when becoming legal. About coding You define an inner function for no reason introducing a lot of complexity. In your inner function you check the existence of an outer to decide on returning a , that's awful. You mix and exception handling in for control flow. your clause is a completely regular case. You shall not implement a silent fallback to sort by string (or whatever the type is) when the user requested sorting via . this is a complete fail, hiding a user error and presenting false data as regular result. 

When writing library classes you should follow the python guidelines to enable generic duck typed interfacing. have a look at the python datamodel and try to make e. g. the following tests work by implementing and . 

comments and docstrings in you use a parameter choice which is one-based. this is not common and not mentioned in the docstring. so while there is a 6 line docstring one of the most important facts for correct usage is not mentioned. While your parameters and return values are listed by name there is no hint about the correct type nor the value range. 

Proper error handling so now the big bug. if we cannot place the player in we switch user. if something is an error report it to the caller. that does not mean to print something to the screen but to return an error condition or raise an error. Output to console shall be done from main only. so we refactor to return success and remove the print 

You already got some advice on coding style. however there is a big flaw in your algorithm which is not addressed by the accepted answer. you try to iterate downward to get an effective implementation but you got the inner loop wrong. while you expect the outer loop to do few iterations your inner loop does check relatively low numbers early. you tried to limit that by stopping the iteration at 900, a magic value without reasoning. so your implementation may give wrong results as a pair of 901*901 is much smaller than a lot of untested pairs. you need at least a check if your product is bigger than the biggest untested one 999*900. on the other hand if we do the inner loop right all problems are gone. we use the outer loop for the lower value and the inner loop for the greater one. we do not need an arbitrary limit any more and we are quite efficient. 

If you want to design a class you have to remove the from it. then you notice there is a little problem with the which forces you to expose internal implementation details to the main loop by requiring a call to as well. by the way does the job correctly, one input resulting in one call to the board. ensure functions/methods do what the name promises does not rotate the board, but a matrix only. it would make a perfect name for a method of a matrix class. a board method should do the complete job and apply the gravity as well. reuse what you have you could insert tokens on the top only and use to let it fall down. not only this resembles physics, but also there is less code to test. shows high complexity and repeated code. handle errors your does detect an error if a column is full. however it does not forward this to the loop, so the player is turned over. separate I/O from core do not do I/O from core functions, but from main loop only. this requires providing state and error information to the loop by return values or raising exceptions. or by providing getters for state. this will immediately lead to better design and testable functions. there shall be no magic numbers in the code, define constants when you decide to go for a 9x9 instead of a 7x7 board, there shall be only two edits. you make it worse by having those numbers as attributes, but you do use them only for drawing. when checking for wins, applying gravity or handling input you have raw numbers in the code. this is the worst possible combination, pretend to handle your constants properly in the but ignoring these later on. seriously, this is an absolute fail. also have a definition for and write correct expressions for all the dependent values subtracting it from or . some python sugar 

DONT! String format your sql queries, but let the cursor do it for you. As @Gareth Rees said, this is not secure! 

Your double while loop looks silly to me, I think it be more concise to use 1 loop and use a structure within 

Yes there is list slicing. Just with list slicing only the reversed could be Where the last is the step, and means we step over it in reverse This returns a list and not a generator, thus your reverse could be return a[:k + 1] + a[k + 1::-1] @user2357112, I feel like a rookie now. I made a mistake, intuitively while fast typing I thought list reversing would be like this but instead it works differently, with exclusion. , and becomes: 

Code suggestions I would use a instead of a dictionary, since it is much cleaner looking and easier to use. When to use a namedtuple! Using the above suggestions and adhering PEP8 I get the following. 

First of all, your entire is way over-engineered.. and with the correct standard modules this practically becomes a one-liner Review 

Especially if you're new learning Python, I suggest to learn . Support for will be dropped soons since EOL (End Of Life) is just a few years away. It seems silly to learn a language that will be dropped soon. 

Tests The description is a rather simple one, when pipes are leaking then things become interesting. So here are a few Testcases if you want to have a go with this. 

Now if we want palindromes that are at least 2 letters, we can add a check beforehand to check for the length. 

3. When dividing code into seperate functions it makes for a more readable code, and that way it can be imported by other programs. 

loops per se are not a bad idea, it is just using a loop for this example is overcomplicating stuff. That makes it a bad idea. is awkward because you keep appending that item to the list and refering last element, you could also have stored the range as a variable and keep overwritting it. 

BUT I think if you put this conditional before your block, this would be one loop, because after this conditional you kinda repeat yourself alot. 

Why all these temp variables? They are never used, and since the original list is not altered. It makes no sense to use a temp variable. Just call 

Ok first make a function to check if a list is in a sequence and if not return the first element where it is not strictly increasing 

Try it out for yourself to see the difference, and if unclear what is going on you can always ask me 

First of all, welcome to CodeReview! I'd like to know what the common best practices are when working on a project 

Using a structure like this will improve the code alot, and adding an AI (or other improvements will be easier after this) Avoid working in the global namespace This point is interwoven with dividing the code into functions/classes, see this link as to WHY working in the global namespace is considered bad. Wrap up your code into a guard. This will make your code be runnable from the command line, while also be able to be imported into other scripts 

Use indentation of 4 spaces, it looks cleaner Functions should be named with lowerscore letters. Example: You use a lot of which could be rewritten to Same goes for which is just You have some calculations like which can be rewritten to When using comments don't indent them! should be 

Another natas challange, they are getting progressively harder. I barely completed this. Mostly thnx to @aires to help me with the crypto stuff. This time, a Padding Oracle attack was needed to get the password for the next level. Another reason to be scared of crypt:o In short the Padding Oracle Attack works like this: 

Perl localhost test enviroment I have tried to create the important features of the webpage, namely that you can post the and , compare it to a database entry and give back the result. I have used the as I think it would be the way of keeping things simple. My recreated perl webpage 

This would change the logic a bit, now the list will be empty if all men_proposed to all woman, but since empty lists are considered falsey in python you could check like this: 

I wonder if I use the correct syntax in bash? Further I think my scanning function is not all that good, I bet there are more pretty ways to check. Lastly maybe checking wifi's near me with instead of iwlist scanning would be a better way of handling this? 

explicit loops python has list slicing and list comprehension. in you use comprehension but could use the more dense slicing 

EDIT One important point I did miss on the first glance. You do sort optionally on conversion or by default on representation. the second one is a bad idea, as you cannot sort comparable objects by their built in comparison functions. instead you force str representation which in terms of sorting is useless. So you shall not force but have the identity function . might be a third option to sort for. To your changed code - let's assume we have to write a function like this. if we have a look at 

(and so does ) does not handle the 'not found' case. this went unnoticed as you did not write a test. So the main point is - if you write a library class/function it is mandatory to do good tests. full code coverage and all regular and edge cases you can think of. python provides a unit test framework, use it. 

EDIT: I simply had to try the bag of words approach I simply slide a window of the probe words length ofer the text words in single word steps. for this text window i calculate the bag of words and compare it to the probe and sum the absolute difference values for every entry. e. g.: 'so the the moon' vs. 'the moon moon is' resulting (so:1 the:2 moon:1) vs. (the:1 moon:2 is:1) wich results in a diff (so:1 the:1 moon:-1 is:-1) in absolute values (so:1 the:1 moon:1 is:1) summing up to the value 4. This measure for my test set 

while the big clauses were identical from the start the smaller cases did differ only because of the bad data representation. Avoid error prone repetition of constants now let's have a closer look at . there is one diagonal checked twice, we delete that one. the cause for this error is editing by copy paste and altering values. with a little python list slicing and comprehension we can make this code shorter and thus less error prone 

the first definitely do not belong there, this shall be done in main or in a UI. for the latter if no user interaction is required this could be logging. if requred it should be done on the dedicated UI. getting the message there could be via return values or more pythonic via raised exceptions. so we remove the print from 

still there is an if clause which we could make shorter. there are numerous techniques to toggle/select/cycle values from a limited set. here i am tempted to use a very lazy one (as the number of iterations is small) 

if you hold your rows and columns as list of lists (which has some other advantages we will see later) you can even omit parameter n whe testing a line 

we also fix all the column indices in (where we find 9 winning cases which is one to many). Do not repeat yourself now we have a close look at as it looks now. 

so any other variable referencing a node or even the root node will possibly reference something old. 

EDIT: also, from a design point it is strange that and are returning nodes instead of values. you should get returned what you insert. 

Before adapting we have a look at the names which are not reflecting reality. the loop shall be because it is a single row. likewise should be as there are several data/spacing/separation parts in there. That said we change to (still not perfect) 

I think you got the optional part wrong. the task is to reduce the given square, not to construct one from scratch. This requires you to hold the square in a representation allowing you to shuffle columns and rows. a set does not keep the order, i suggest a simple list of lists. the challenge requires sorting the first row and the first column, very similar tasks that can be done by the same sorting function if we transpose the matrix. so i suggest to start with a list of rows 

There is nothing wrong in general with for loops. If you have to iterate over some elements there is no magic that can avoid this. So why is your function "not very efficient"? And why is this because of the for-loop? However you asked for a pythonic solution. In Python explicit for loops are avoided by using list comprehension. Internally Python again loops over all elements, however slightly more efficient. Better readability is the other big gain. So let's measure (I did some renaming for readability). I compare