Here's a different approach, taken by electrolyte, from the TIGSource forums. He was making this platformer project (some footage here). Here's some of his explanation: 

Alright, after more digging I finally came across a more definitive solution. I posted the solution in my forum post on the issue on cocos2d-x's forum, but I'll post it here too just in case. So the real issue is that on iOS devices, device orientation isn't reported correctly, and on Landscape mode, the screen coordinates will have the width and height values swapped. To fix that, I basically used the solution described by Tim Closs in this forum post for rotating the projection matrix, with minor tweaks: New method in AppDelegate: 

And regarding movement, I was thinking maybe interpolating the player's position between one tile to another, but he had this to say: 

To get the coordinates for the center of the screen I'm using the VisibleRect class from the TestCpp sample. It just uses sharedOpenGLView to get the visible size and visible origin, and calculate the center from that. 

Check if entity collides with another entity Check if the colliding entity is a "grounded" one If not grounded determine one as parent and set the rest as children If grounded free all children and do collision again for all If grounded and not children, set as children of grounded. If colliding with ground - free all children and set grounded 

In the first case, what is happening, is exactly what people hate, when a lagging person enters any shooter game, that uses this prediction behavior. They start teleporting short distances. In the other case, what is happening, is exactly what people see, when they cry for lagging server, because their characters start to flicker or teleport back. You need to find the best prediction timings for your game design. 

It seems like you are missing to move the transformation of the player high enough. like on the picture I think the problem is, that you set a jump height according to the animation and not to the player without animation. So jump height looks fine when in crouch position, but when u turn of the animation, you will see, that the player model jumps way to less high. I think this is your problem. So just fix the jump height and all will be fine. As a side node, an animation should allways be applied only, when the actual movement is ok. So in your example, only when the player model jumps correctly to its complete transformation, then apply an animation for the whole duration of the jump. 

You might just try hiding whatever it is until the frame where it's in position. Otherwise, it sounds like you want a Broken animation curve. 

The simple answer is yes, unless the terms of service specify differently, you can just use any name you decide or simply use your own name. However, if your games ever turn enough of a profit that it can no longer be considered a "hobby" then you must register as a business. 

If you need to store entities in chunks it's probably better to actually store them in the chunks rather than a separate array. 

The default Unity project settings include some joystick axes already. So looking further down, we find the same axis defined again! Removing the extra axis definitions fixes the problem. 

For a projectile starting at origin O, an initial velocity V, and several stationary planets P[n], how would I pre-calculate and store the path it would take without actually stepping through each frame along the curve? 

To move it to a specific point, attach this and set the target and speed fields to where you want it to go and how fast, respectively (from Vector3.MoveTowards reference): 

We go through all of your example pictures with my parent/child system. Picture 1 - 1 Entity Keeps falling till Picture 2 - 3 Entities Green Entity and yellow Entity fall red entity is . Let's assume green entity has a higher velocity then the yellow one and hits yellow before any of both get's grounded. Green Entity detects a collision with yellow. We decide (because mass doesn't care for you) that green as first entity get's the new parent. So we set for yellow the parent as green and for green the child to yellow. Next they keep falling. Yellow is no longer moved or done collision detection because it has a parent. We move green and ask if has children and use both data for collision detection and movement. We detect a collision of 1 child, yellow collided with the floor. So we set it to be grounded, remove it from the parent and set it has no parent. Next we do this for green, it collides with yellow, has no children anylonger so just set it as grounded. Done. Picture 3 - 2 Entities We detect a collision between green and red. We take green as the first entity of our list and set the children as red and on red the parent as green. Next we do collsion and movement only for green, because red has a parent and so will not be used in collision detection and movement. Green hits the ground and will be marked grounded. Green has children so we remove the children and set their parents to be null. Next we check red and detect a collision with green. we set green as parent of red and it is no longer part of the collision detection. But it is not grounded. As soon as green get's removed from the board, we free red and red will eventually start falling again till also grounded. Picture 4 - 3 Entities Red/Green is the same as on Picture 3. Green detects a collision with it's children against yellow. Yellow is grounded and has there for the "master" right. So we set Green with it's children as a child of yellow. They are no longer used for collision detection, as long as yellow exists. If yellow get's removed of the board, remove the children of yellow and set their parents to null, and they start falling again. Picture 5 - 3 Entites If we assume yellow falls faster or red or both have same velocity doesn't care. The algorithm is allways the same. We assume red falls faster. We detect a collison between yellow and red. yellow will the get the parent because first in the entity list. Next we detect a collision of yellow's child with green. We set green as the parent of yellow because green is grounded and so the master. We free all children of yellow because yellow is connected of a master/grounded entity. We also free yellow of green because it is no longer colliding with green. So yellow starts falling again and detects a collision between yellow and red. But red is connected to a master/grounded entity so we set yellow as a child of red and red as a child of green and set on all Picture 6 - 3 Entites Same as picture 5. 

Eventhough the idea seems very clear to me, the actual implementation of it raises a lot of questions in my mind. For some of them I feel I have very complicated solutions, while I have no idea how to solve others. For starters, the basic mechanism for moving: if the player presses right, the character will enter a "walking right". While on that state, the character will move from the starting tile until the next one, even if the player releases the right key; if the player is still pressing the key when the character reaches the next tile, the same thing will happen. However how exactly should that movement inbetween tiles work? Should it be just a regular speed being applied to the character's x position? What should that speed be in order to assure that the character will stop in the precise location in the next tile? And should that speed work with the update's delta time? Another thing that has me at a loss is how much of the sprite's positioning has to be done by the actual x,y positioning and how much should be done inside the sprite. For example, in the case of a running jump, which is, as noted, a special case of linear movement, should there just be empty space below the character (and position the sprite by its bottom) or should the y position be adjusted accordingly? I'd really appreciate some help with implementing this kind of platformer. That article above is the only thing I've found that sheds any light on how to do it, and I'm struggling to figured out the rest on my own. 

I've used forward/backward momentum here since it's easier to describe, but the same principle applies to lateral movement and turning. In order to turn, they need to shift their weight counter to the direction of the turn while moving forward or backward. 

The main purpose of the ECS pattern is to be programmer friendly, not speed. So this is essentially an architecture problem, although I will also address your cache-friendliness concerns. It seems like you're setting your components up like data records, whereas they should contain all the relevant behavior for their subject. Think 

Toggle returns the current state of the button - either the same state passed in value or the new value as changed by the user. So a better pattern would be... 

I think you want Dijkstra's algorithm, which is also used for internet routing. In short, you must create a graph where each edge is a path from one node to another. These could be pre-calculated if some of your geometry is fixed. For each starting point, you will order the nodes according to their distance from the destination. Then apply Dijkstra's algorithm through the graph to build routing tables for each one. The first route in the table will be the shortest path. Each route after that will be a variation depending on which nodes are blocked. These extra routes could be calculated as necessary, provided their order is maintained in the table (they should be ordered by the sum of their edge lengths). You'll refer to these routes again when a node is changed (blocked/unblocked). You can then add and remove nodes by splitting edges and moving the new midpoint, then recalculating from the origin node. 

Most games are designed, that they predict something for a short period of time. So in our case, the server hasn't received the NKP package, so he predicts, the user is still jumping. This will happen for let's say 100ms. After that the server predicts that the user falls back to a default which in our case would be NKP. After some time, the server receives again packages of the client. Corresponding to the correct order, he now knows the correct state of the last package of the Client send. In our case still JKP. Now the server looks in his list and has 2 options: 

For this to be handled correctly you need to design your network protocol to do something called "continuous transitions". Client send's all time packages to the server with a order. This way the server has always the last state of the client, regardless of lag or lost packages. Next step is you need to analyze the packages arrived. Back to your jump example. The user presses the jump button, and the client sends the following packages: NKP = No Key Pressed JKP = Jump Key Pressed [NKP] -> [JKP] -> [JKP] -> [JKP] -> [JKP] -> [JKP] -> [NKP] ... Each package has a order. So the server receives JKP and start's to update physics. Now the server doesn't receive packages of the client for any time. Now u have 2 possibilities 

I'll refer to map nodes as tiles for the purpose of explanation, but the principles are the same. If you have more than one node in an area, then your "tile" would contain an array or list of nodes. For all of these, graph theoretic applications can be applied, though the method of application becomes more or less complex depending on what specific algorithm you're using. Now, if by matrix you mean a two dimensional array, that is probably the least algorithmically complex method, besides a one dimensional array where tile[x+y*width] = tile[x, y]. Structured this way you always know the distance of one tile to another, and can always access its neighbors without traversing memory in steps. Next is a sparse matrix, where the information is structured like so (as a pseudo-structure): 

The common thread here is that each object is constructed with a reference to a service that provides some core functionality where the specific behavior is abstracted according to how the object will always behave. Need to create a monster? Summon the monster-making-factory from the entity service. Need to find another entity? It's in the entity service. Need to send messages to all entities of a certain type (such as physical entities)? Just filter them out of the entity service. This way you can avoid hanging on to references to "dead" entities. This is just one example, of course. In practice, your game's needs will dictate how this has to come together. 

Actually that is not that hard. As I don't know your complete design, I will just talk a bit more general. I assume, each block construct as an independent enitity. So in picture 2 as an example, you would have 3 entities. I also assume, that your design includes mass for each entity. If all this is correct then next will help you. As soon as 2 entities collide, determine the one with the bigger mass. This entitiy transforms into the parent entity of all other entities colliding. So now they all move no more independent, they are driven by the parent. The velocity break if 2 objects collide is a physics based calculation. After the collision just move the parent with it's break down velocity. When another collision is detected to the calculation again, but update the mass of the parent object to have the mass of all children too. 

To be honest, I can't even imagine a single scenario, where with well implemented client interpolation an input lag would be perceivable. Just to counter check - Client Interpolation summarized 2 Concepts meet up 1) The Interpolation itself - let the client live in the past (ae 100ms) 2) The client sends every data with a timestamp, and the server has to keep the data of all entities for some time (ae 500ms). Now for actions, that depend on other entities, like shooting, the server now can verify the position of the other entities via the timeline and the send timestamp of the client. With these 2 concepts merged together, you have a working, well implemented client interpolation. So first of, if your current implementation doesn't meet the mentioned requirements then change it. If you have both methods working fine, I will need more information to assist you in locating the problem.