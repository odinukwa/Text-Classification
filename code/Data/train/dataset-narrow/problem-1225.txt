has a static final field , , which represents the value one. I suggest you replace all your with as s are immutable anyways and it saves you from creating another . 

Your variable names are very hard to understand. What's ? Distance? Then why is it an array? What's ? Visuals? Why is it a 3D array? Make your variable names clearer, and add comments what it does. Also, there is inconsistent spacing. You do stuff like: 

Remember that s are immutable. Since is concatenated multiple times, you should use , and add s with . All the code in the loop can be at least broken down into two methods. But before we do that, the variables should be instantiated outside of main, with . 

I really don't see the point of the class here. What is its point? From what I understand, I would completely redesign it: 

Just my opinion, but I feel uncomfortable with that many spaces in code. The only place I would use spaces would be: 

The first thing I should say is that your code looks very messy and requires "cleaning up". I don't know for sure if this is because of formatting problems when transferring from IDE to Code Review, but if it is not, then formatting needs work. After formatting, it looks like this: 

I suggest you use instead, because uses arrays to store variables, and since arrays have a limited space, when you run out, it will create a new array and move everything from the old one to the new one. This takes a lot of time, and doesn't do that. You should also add a serial version ID, because that will then save the time the compiler requires to generate one for you, like this: 

Line 1: Space before brace Line 2: Space after Line 2: Space before and after , or any other operator, for that matter Line 2: Usually, though optional, there is a space after in end-of-line comments Line 3: It is recommended to use two tabs, or 8 spaces, for a continued line. Line 3: Again, space before and after all operators. Line 4-5: Here, it should be 4 spaced. Line 7: Space after Line 7: Space before and after operators, twice Line 7: Space after semicolons Line 7: Space before brace Line 8: Space after Line 8: Space before brace Line 8: Space after commas Line 9: Space after Line 9: Space before and after operators Line 9: ALWAYS put braced for statements. I explain it here. Line 11: Again, ALWAYS put braced for statements, including . Line 11: Space after comma Line 11: Space before and after operators Line 12: Space before and after operators Line 12: Space after comma Line 13: Space before and after operators Line 13: Space after comma Line 14: Space before and after operators Now that was quite a bit. Notice that most of my suggestions appear over and over and over again. Next... 

variables No, no, no. Rarely should you use static variables, such as a class constant, or something that needs to be when there is no other option available. You can easily redesign your code to not need variables: 

In the case of roots, to find \$\sqrt[z]y\$, \$f(x) = {x_n}^z - y\$, and \$f'(x) = zx^{z-1}\$, resulting in: $$x_{n+1}=x_n-\frac{{x_n}^z - y}{z{x_n}^{z-1}}$$ 

So you have to put somewhere in your constructor. Also, when it shows, is so small you could see nothing. You should also set the size you want it to be and if you want it to be resizable or not in the constructor, like this: 

There are tons of areas where there is more spacing required. Try to fix all of them (without over-spacing). Braces 

Standard conventions for class names are PascalCase, not camelCase or alllowercase. Also, I think all your variables need some breathing space: 

Choose one and stick with it. I suggest the second option, as it is easier to read. Your method looks nice, but statements without braces makes me nervous. Try: 

A couple of problems: Line 1: Space between and Line 1: No extra spaces before and after Line 1: Space before brace Lines 4-5: Should be combined Line 5: Space before brace Result: 

If you don't understand why this works, all the AI does is counts up to the next multiple of 4. Why does this work? Well, this is what happens: 

Probably a big problem is that your code does not handle ties. I will leave that to you, as it is pretty easy. 

This way, you have individual method for each value you have to check for, and it is easier to add another method if you need to. 

One word to describe this: inconsistency. Be consistent. Either have a newline, or don't. I suggest not have a new line, as it wastes newlines, and doesn't it make it a bit more readable. It also follows Java conventions. This crazy code: 

Royal Flush Checking - , , , , as flop and , in the hand will return if passed through . What??? You seem to only be checking for Straights and Flushes with the flop. Flush checking - If there is 6 Spades, or 6 Hearts or 6/7 whatever, then the method returns . Change: 

I don't see the initialization of ,, or . If they are class variables, that's fine, as long as it is meant to be a class variable. If they are outside the method just so that another method can set the values and have the current method run, then it is not okay. If they are class variable just for the method, have them as method arguments. Here: 

You use the value multiple times in the method, or to be more specific, times. You can easily avoid retrieving the value that many times by creating a variable to hold the value: 

Conventions Java conventions state that code is indented with 4 spaces, not 2. Java also states that the brace should be on the same line, though this is more of your choice; the important part is consistency. After formatting, your code will then look like: 

The biggest problem I found with your code is that IT DOES NOT DISPLAY ANYTHING. The constructor, according to Java SE 8 Documentation: 

I was recently learning about and how they work in lists, and to test myself, I decided to write my own implementation in Java. Then I decided, that since there is already a LinkedList out there, why not make it sorted? So now it is a . 

And maybe even change the naming for . Also, checking for Straight beforehand is not necessary, as your code checks if it is a flush and later checks if it contains , , , , and anyways. will take about the same time to run as , making the possible performance gain from a evaluation not worth it. Others In 

Declare variables where you need them, not before. Multiple declarations on one line isn't very readable. 

Challenge 2: I would do a complete rewrite of that. You don't need an array, and you don't need that complex of code. Here is how I would do it: 

I kind of expected and , because they are antonyms... but I don't know exactly what you want to do with the , so I can't say much. 

Code that form the same command but are on a different line should be 8-spaced, or 2-tabbed. Java Naming Conventions specify that variable should be . 

General Review I will just give a general review. Naming Some of your naming is horrible. Take a look at: 

Note that this is adding to @EricStein's excellent answer on normal concatenation instead of s. (I'm just starting to look into , so if this is bad, please comment on why) Otherwise... Just a small comment: 

I am not most experienced with C++ (java's my best language) but as far as I know, method names are supposed to be . should be . Also, why are you returning a or a ? Shouldn't you be returning a ? (Again, correct me if I'm wrong) The chain of ternary operators is very unreadable and messy, which causes easy bugs. You are also using ternary in places you can just use and . Use and statements to simplify: 

In this case, links to , which links to , and so on. So what if you want to remove , for example? Well, change the links so that links to ! How? Well... 

The can be thrown at . You now can just use your original approach, but catch the specific exception: 

Notice the movement of the braces. You should have a constructor for your that takes no parameters and one that takes only the data: 

Here, you have some shortened names, like , and extended names, like . Names should he concise, but understandable. Try: 

Challenge 5: I'll come back to this. This challenge is a bit more tricky. Your solution is again too complex: 

In , my code will still iterate over the remaining elements even if the array is already sorted. To break out at a solved array, I should do: 

Straight Flush Checking - Two things gone wrong here. a) You're only checking for a Straight Flush in the flop. What if the Hand contributes to a Straight Flush? b) Don't feel bad about this one too much; this is a common mistake that even I made when writing a Hand Evaluator (I figured it out and decided it was way too hard; so I gave up). , , , , as flop and , in the hand will return (after you edit it so that it checks both the hand and the flop), even though you see that there is no Straight Flush. 

Make it generic so it can be used for later. Make is public so it can be used for later. Your method will throw a if the Stack is empty. If you intended this, well, okay, but I would just return . Since you are only getting the top of the stack (as that's what stacks are supposed to be), you should implement a stack that can change its size, while still having similar efficiency. How would you do this? Well: 

Also, always put braces for statements. If you don't, horrible bugs may occur. Here is an example: Say you have this statement: 

Explanation: The method is the basic method. It provide default values for all the possible editable values. The editable values are as follows: 

As @janos notes, more spaces. Why is it a class? Since the class is not used outside of your program, make it either or default level. 

But it didn't work, so I did it on my own, ending up with: $$x_{n+1}=x_n-\frac{{x_n}^z - y}{z{x_n}^{z-1}}$$ My guess is that either I got it wrong, or the person writing the formula made a mistake in simplifying. Is my JavaDoc good? I feel like it has some redundant or missing information there... 

is a bit repetitive and could be easily simplified. First, let's remove the duplicate by using a different loop: 

This is one of the cleanest code I have come across in a while. Congrats to your lovely, well-written code! Just some points: 

Note there is two methods; one is for a class that implements the interface, and one to allow a to be passed as the for the class, where there is no comparator, or if you want to compare it in a different way. Then the only problem is that you don't know the bounds for the buckets; the simple way would be to use bounds provided by the calling method: 

Anything in the square brackets, if not said by the player, will be said by AI. No matter how you play, the AI will win (as long as it starts). Concerns: 

First of all, extra newline between methods. This allows easier readability. Now, to the first section: 

Naming What's ? How about ? What is ? Why are they one-letter names? One-letter variable names are not good, as they are confusing to understand. The only place you should use them is, for example, a loop counter. Change: