so, I ma not sure how many LOC are now present, but im my eyes, the code is clearer and more maintainable and extensible. 

here are my comments: 1) instead of having a method for objects, why not have classes that you can instantiate? seems more clear to me 

Declare variables in the smallest scope In addition, you have all your variables declared in the beginning of the one method you have. Some of these are used in particular places only. For example, is only used when is used. another OO paradigm rule says that variables should be declared inside the smallest scope that they are used. why? 1) it makes for easier reading of the code when one knows where a variable is used and where it is not. 2) it makes for safer modifications in the variable 3) sometimes you can use the same name on different local variables instead of having / and so on: 

Here are my comments: 1) In the first version of the consumer, you compared the enum values correctly. However, in the edited version you suddenly decided to use the names for comparison. This is simply wrong. First, you have the popular bug of using instead of in several places. Second, using enum values allows the compiler to check you didn't mistype "EQUALS" in one of the (many) places you typed it. 2) Your expression picking logic in is overly complex and confusing in my eyes. You pick an expression based on condition and action. this results in the confusing situation of returning when the condition is . A better approach would be to ignore the action during expression picking. this way, the connection between the filter's and the type of is simpler and straightforward. The consumer gets the result of the s evaluation, then queries the action and simply reverse the answer accordingly. now, while we are talking about expression picking: your current logic goes though great length to enforce the assumption that "lesser then" is the opposite of "greater then" - so why did you write both expressions? you can write just one of them (for example "lesser then") and then in "greater then"'s method call of "lesser then" and return opposite value. 3) regarding responsibilities: if holds the condition (and action) why not let it pick the expression? moreover, if we do decide that a is all that is needed, why not let the enum itself pick the expression? 4) regarding the s: the can be simplified: 

In fact, let's take this one step further: let's store all the buttons in an array. This is very easy to do with . This will return an array of all the elements that are of the specified tag: 

This same idea can be used for the rest of your code, even in spots where, instead of the parameter changing, the object that is being acted upon is changing. And, if you come to a spot where the changing parameter/object name is not only changing by a single number, you can consider using an array to hold the different parameters/object names. Then, you can just easily iterate over the array and call the method with each element of the array. 

Joseph the Dreamer's answer pretty much covers everything. I just have a few things to say about React practices. 

You should pass an error code to so that external programs will know if there were any errors during the execution of the program. 

instead of In your subroutine, you move the value into two registers. A more efficient way to do that is to the register with itself, like so: 

See something similar in the value that these classes are being assigned? If not, they are start with this: 

A simpler, maybe faster way of getting the string before the would be to just the String by the . Then, you'd be left with an array containing the String before the . Now, getting the name would be this: 

all switch-case statements are the same, just invoked on different variables -> put the statement in a method and pass it the variable to query. Moreover, the whole switch-case statement can be replaced by getting the index of the int-location from the String "ABCDEFG": and you can catch the to detect out of range int value you already use a collection to put locations. instead of keeping three separate set of variables for V/H and the rest-> use a colection for these as well. 

Regarding reducing duplicated lines, I can offer that you make a method to create the map. so if the contents of the map need to be modified due to modifications in the requirements or API, there will be only one place to modify them. creating constant variables instead of embedded literals is also considered best practice. This can apply to other literals used in the code 

This representation is both clear, concise and is portable (can be passed to another program, web service, stored in DB etc) So welcome to the wonderful world of Object serialization/deserialization. There are many libraries and documentation/tutorials on the subject. I will point you to Jackson Json parser that is considered one of the most popular. 

3) Design This last comment falls into "best practice" category: the method does too many unrelated tasks: receive input from user, file handling and main loop. if, for example, you have a separate method that is responsible for communicating with the user, receiving user input and validating it, then perhaps you would be able to check for existence of input file as part of validation... then again, one method for receiving user input and validating it? hmm maybe we can design further break down ... 

Unnecessary branching In your subroutine, you branch over to the subroutine. Since the subroutine is right beneath the subroutine, you do not need a branch there since execution will just "fall through" to the subroutine. Labels I'm not sure how this works in ARM, but you seem to be using only global labels in your program, when there should be some local labels. Local labels exist inside global labels, and they act kind of like a subroutine for a subroutine. A change I might make is make the label a local label. For more information on local labels, see here For information on the syntax of a local label, see here Disclaimer: I am not too familiar with ARM assembly, although I am familiar in other assemblies; some things I tell you might not work 

All that method declaring at the top of your code is very nice-ly formatted. However, I believe that it is in the wrong space. You should move all these declarations to their own header file. 

I have created a virtual piano that turns the home row (excluding 'g' and 'h') and the top row (excluding 'y' and 'u') of the user's keyboard in a piano's keyboard. The home row is used for white keys and the top row is used for black keys. The keyboard's keys bind to piano's as shown below: 

now, since we eliminated , we can return the value direct from the call to the client, eliminating the creation of the reference: 

This signature allows the method to decide if it wants to return or and same for implementation. 3.2) Extensibility You get a plus for using enum instead of String. and the splitting of counting into separate methods is another plus. However, we can go further with the extensibility concern. Currently if you want to add more counting capabilities, you will need to add a counting method, an enum value, and a clause to the statement. What you can do is put each counting method in its own class that implement the (new) interface 

The majority of the code deals with creating (many) instances of with the correct data. As you observed, this creates code that is is both long, obscure and error prone. Data is best represented as text in a in text file and then all that is needed is to load the file into memory and parse the text into the list of instances. You do not need to invent the wheel: There are several established text formats that can represent the data, and there are libraries that will do the reading, parsing and even create the instances for you. In software engineering, this is called Object deserialization . The two most popular text formats today are XML and JSON. JSON is more compact and supports data types other than text. So we can design the JSON representation of a object like this: 

When you are using string formatting to put the number into the image name string, you should be using or because those are for signed decimal (base 10) integers; is used for strings, which is not. 

Then, your method could take an array of these and loop through them, adding them to the string each time. 

I would choose neither of those options. Depending on how many elements you need to insert into that , you could end up with a big chunk of code that is just a group of calls. I recommend creating two arrays: one of the s, and one of the s. Then, all you have to do is create a loop that inserts all the values into the map. Here is what I came up with: 

Power (look-up) Table! Looking over your algorithm, I see that you are using a lot. While this is a nice method and it is helpful, it can be very inefficient (especially if used too many times). Focusing only on , your algorithm does this: 

(if you follow the above tip, these variables will probably be in an array instead). Now, you are doing much less constant field access, overall speeding up your code. 

Typically a single indentation is either 1 tab or 4 spaces. I use 1 tab. For example, let's take this snippet from your code: 

it assigns a value to the String . now, I assume that the logic was meant that should be assigned the name of either or but the code actually allows for both statements to be false and the value will then be an empty String. You can fix that by changing the flow to an one 

So now, instead of individual variables, a has a of instances. (this means that instances should be considered equal if they have same ) This design allows for iteration over the skill set of one and of course, different s can easily have different skill sets. Moving on: as I understand it, the formula for the effect of skill casting involves the base value of the skill, related to the skill only, the power of the being, related to the being only, and the level of player in that skill. Perhaps in later version you will want to add defensive skills? also, in some RPG games, a random factor is added so that every skill casting can vary in effect. I would say that this complex logic merits its own that receives two s (attacker and target) and the skill that was chosen. If the is an interface, you could write different engines that evolve in complexity. the engine would apply all the above factors (including if the skill is casted on self....) and modify the s stats according to the outcome. 

Your code is quite nice, so I don't have that much to say about it. Here are a few points I noticed about it. 

I may be missing something, but it doesn't look like anywhere in your code are you using the library. In that case, I don't see why you ed it. 

More refactoring and simplification Your three functions are all very similar except for a single line. These lines: 

I changed goodroll to use and , rather than "yes" and "no" because boolean comparisons are much, much faster than string comparisons. I moved the final statement out of the while loop so, in the case of an invalid move, the move won't be printed. I go rid of the part because, if the conditional before it was not , then would not have been set and will remain . 

I think should be it's own, immutable, separate class. It should probably hold the 2D array that is the sudoku board. Now thinking about, the should be the class with the method (I'd call it ) because the method is to validate a sudoku board and the class is holding a board to being with. Here is what I came up with for the class: 

If wasn't a function, it's going to go to else. Then, you call . Well, if it wasn't a function, how are you supposed to call it? 

since I know Java :) I have the following comments to add to the previous answer: resources handling Resources, in this context, are the input files you are reading. Their lifecycle is not handled properly. In other words, you do not close the files, leaving OS resources open after the file was read and parsed into memory. This is not a big deal in your program since you only open two files, but it is still a glaring omission. Since proper handling of lifecycle of resources can be tricky, starting with version 7, the Java compiler gives you the feature of try-with-resources, offering automatic closure (and better exception handling) 

You can replace the for loop with a java 8 of the collection of the properties map. You can replace all the nested if statements with a you can have your choice of separate s for each if statement, or just concatenate all of them together with operator. after the , you need to tell the stream to end (aka Short-circuit) by finding the first item that matches the filter. The operation returns an since it is possible that no item satisfies the filter's predicate. in the question, it is required to take an action only if a match is found, so you can add an that takes a which does something to the matched item and returns void. does nothing if no item satisfies the filter's predicate.