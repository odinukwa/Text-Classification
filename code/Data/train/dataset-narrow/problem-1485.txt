This is a very broad question. I advice you to think things differently. In Rust, you can give a thing, or only lend it (the thing is borrowed). The general answer is: if you do not need anymore the thing, or if the receiver needs a full control on it, give it away. In this specific case, the thing is copyable and small (as small as a reference, in fact). So, borrow it does not give any advantage: just take it (or take a copy) and do not bother with references. 

So either a is the minimum of the list in which case b and c or it's not and it's one of the numbers you want to keep. The other is the max of b and c. 

This looks like a fairly reasonable brute force method. From what I've gathered though, the loop will try for all combination rather than just the first valid one. However the will sequence the operation to avoid a huge memory overhead. However if the puzzle is not well constructed it may have more than one valid solution, and I suspect this code will print them both. $URL$ A custom loop that breaks when a solution is found would on average run in half the time, and never give you more than one solution. But I'm not going to show you how to do it, since there are several solutions, and it's not a huge improvement. A few minor things. 

I will post comments not about your performances, but about your writing style, because some things can be shortened. Simplify vector creation: 

If you only need to read one line from a file that will not change at runtime, you can use As already said, the whole program can be simplified a lot using a functional programming style on iterators: 

You better express your attempt with this. Also, you do not need to put the type of depth, this is by default. If you want to run at least one time the block, this is better (in my sense) to write this: 

The last bit is the hard part to explain. When asked for the in-order permutation of lefts and rights, you can start forming the next permutation with either the car of lefts or the car of rights. In the nested s here the inner is evaluated first because the scheme interpreter does eager evaluation. The value returned by examining the permutations that involve picking the left side is going to be one or more permutations tacked onto the existing known permutation at that point in the calculation. This returned value is used as the accumulator when examining the permutations that involve picking the car of the right side instead. As far as effeciency, this loop executes once for every element in every permutation. Nothing fancy there, but it will do it in a memory stack no deeper than the sum of the length of the inputs. 

Explanations: gives you a shifted string. makes the iterator cycle infinitely, remove the first (replace it with for the second part. You the zip the two iterators: one on the string, one on the shifted string. Then you keep the pairs with same numbers: Then you convert each to and you discard the failed conversions. Then you make the sum of all the numbers. If you want to do the two days in one like in your code: 

Not sure if my explanation is legit, but when you give a thing to another function, this function can do whatever it wants to this thing: it can take it as mutable or not. That is not anymore the problem of the previous owner. 

This works as any multiple of n still in the partial sieve must also be coprime with all primes less than N. (of which the partial sieve is a complete list) Now while not purely functional instead of keeping the result and reversing it in the end on your second iteration, you could implement it as a tail-modulo cons. While not stickly functional on the inside, it is functional from the outside. Another optimization would be to pass the maximum canidate to the remover of multiples and just return the xs when i is smaller than the last search. 

You do not need to take the numbers by reference. Do not put an underscore at the beginning of the variable name. A variable name beginning with is used to say to the compiler that the variable is unused. 

My question is not only about the algorithm (I think that it is ok, and the problem is not that difficult) but also about the "haskellish" style. Because I am used to Rust/Ocaml/Elm etc., at first I wrote: 

then I read that Haskell people prefer to compose functions and then pass the parameter, not doing the forward thing. What do you think about that? Also, I searched over the Internet, and I found some divided code, more like that: 

This evaluates right-fringes first, That way at most you have at most log(n) number of fringe-helpers on the stack waiting for a return. It's the same as the second try in your link, with some abstract procedures instead of directly using null? pair? etc. 

Now I know I've messed up brackets or parenthesis somewhere, but I hope I've given you and idea on how much cleaner the code can be. And now as a bonus, because I've abstracted how the loop interacts with the data, you are now able to replace the list of lists data structure with a better data structure. Not that it would make a huge difference for a data set this small, but could give you order of magnitude savings on different sorts of problems. 

This cannot work as-in, because cannot be borrowed twice, but if you rewrite your data structure differently, this could be ok. Do not use Use instead. Be careful about code formatting This could seem meaningless, but people can be embarrassed by missing spaces, or other badly formatted things. Do not be afraid to use the official code formatter. 

I am learning Haskell, and what is better than advent of code to do so? The day 1 problem is about adding together the digits that are followed by the same digit from a "circular" string (the next of the last is the first). My solution is the following: 

is more simply written as '(not (or A B ...)) And a little more DSL would make the code more self-documenting. And notice how you have almost exactly the same in two different locations, and the only difference is the next board you pass along. A good candidate for a little more abstraction. 

The best case as for time in any complete tree traversal is O(N log(N)) as is yours. The big problem is that it's memory overhead is O(N) 

Since lists are built last to first and you want output to read first to last, we need to reverse the inputs. We will also need two accumulator (one for the permutation and one for results so far and some sort of recursion. Given that it's just a matter of messaging the logic into place.