In this refactored version both roots are returned as an array. I included solely for clarity. You also had an variable that wasn't being used at all. Always be aware of those, as they clutter the code and leave readers wondering what they are for. With this new roots calculation could be way simpler: 

When we look closely to we can see that the code is barely the same, except for the very final returned root. So this leans towards repeated logic and creates all sort of problems. In this case it also makes your code less efficient because you repeat some part of calculations. Better would be to restructure your to return an array with both roots. 

The function actually parses the coeficients for each degree term. I won't dive too deep in to this one, but i'll start saying that you do a lot of . And many of them are almost identical, being not only inefficient as well as confusing. Consider this one for example: 

Note how you are constructing the same selector 3 times with the . So this not only repeats the selector construction as it also fetches the element from the DOM multiple times. Save the fetched element in a variable and then use it: 

Which makes it super compact and easy to read. Objects One downside of the way you have your code structured is that you have multiple global variables. This creates difficulties in managing state and also opens the possibility of colliding with already existing global variables. Those may either be from the object or even some other plugin/library that gets included up top. All the game logic can be moved into one or multiple objects/classes, which helps you separating it from the presentation in the page. Sure you can consider this a bit too much for a such a simple game but it's definitely a way to improve especially if you want to keep adding features. As a first step you could consider the following approach: 

There is a similar question that you may want to take a look at for some extra insight, even thought it doesn't have the contrasting color feature: JavaScript Random Color Generator Now lets get to the review. Naming 

Just adding a couple of things to what @Blindman67 already said, and focusing a bit on the code itself. 

Don't need to be separated in such a simple statement, regardless whether you use destructuring or not. You can directly do: 

Note how i used instead of . With ES6 you now have both and as other ways of declaring variables. In this case i know i don't want to change or , and with it will give me an error if i accidentally change them. This builds on writing defensive code that gives you errors sooner rather than later. The itself can also be shortened with an Arrow Function: 

Which given what it does, a better name would be . Given that all it does is sort the roots, its even questionable if it should exist, and probably better would be to do the sorting directly in . Considering we are talking about two values, you could easily get away with: 

While the whole code would now be longer, as you would have to manage both the page visual elements as well as the logic itself, it would also be more modular, organized and easier to maintain or add functionalities. It would still be necessary for some other function to call the game functions and update the corresponding page elements depending on the game state. A more modern way of doing what i did above is using ES6 classes: 

My application accepts different messages. A is described by its . MessageFormat: represents . (, , ) Message: represents an abstract Java Object for . Schema: represents an abstract Java Object for descriptor. Contains MessageFormat. SchemaFormat: represents . (, , respecively for each MessageFormat) MessageParser: has a method . There is one concrete for each MessageFormat. SchemaParser: has a method . There is one concrete for each SchemaFormat. At start-up, all of the supported schemas are loaded and parsed one time each and kept inside the memory as concrete objects. When a message comes, we pass the message with its schema to the appropriate parser. It would be optimal to also have each appropriate parser instance inside memory (schema - parser, one-to-one). What is the best way to achieve this? My current layout is to have a switching the static parsers by asking a for the reference at the static parser that is inside that factory (as well as all of the parsers, for schemas and for messages, all are static). Strategy: 

That way I can just completely delete the and the classes. If they are present, however, each Parser in lazy-initialized and as soon as it's initialized, it's kept in the memory for the rest of the time. If I have all of the Parsers inside the enum then for each message an object gets declared and then discarded. But what happens with the performance when the application obtains 150 messages of 5 different types within a short period of time? I'm concerned that it would be really slow and the memory will bloat until the garbage collector comes and cleans it. I also don't have the way to load the schemas at the start-up, so I may choose the option with putting the s inside the just for the reason I will parse them once. But several data providers may choose the XML schemas, so, I that case I will instantiate the XML parser twice but that isn't a big deal, because there will not be more than 10 data providers. 

Result: msgJson is now: {"Metrics":{"agentId":"12230","callsPerDay":"15"}} Now, I'll explain the classes briefly (too much code to fit here): Serialized: Has a private field, sets in the constructor, there is a getter. Deserialized Serializable: just an empty interface. Should I implement Serializable? I don't really know much about it, just seems appropriate. Schema Deserialized: represents an abstract Java Object for any kind of . Has a getter for FormatMessage value. Message Deserialized: represents an abstract Java Object for any kind of . Has a toJSONString() method. Parser: empty. Because for a message I need 2 parameters, for schema one. ParserMessage Parser: has a method ParserSchema Parser: has a method Format: empty FormatMessage Format FormatSchema Format For each FormatMessage value, there is a concrete class for Message and ParserMessage. For each FormatSchema value, there is a concrete class for Schema and ParserSchema. Obviously, ParserSchema returns its corresponding Schema and the same with messages. Now, the main part: Deserializer: has 2 methods: and . For both he accepts a Format (for message in a form of schema). Inside those two methods this class uses a by calling methods named and . Inside those methods, there is a call to a ParserFactory which holds all the concrete Parser static instances and gives away references to them by by the given Format on the appropriate . The problem is that I'm afraid that the Deserializer class abstracts everything too much that I have to cast a lot, even the caller has to cast a little. My team accepted this design, but I just want to make sure :) UPD: The code for and the as requested.