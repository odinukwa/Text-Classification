Introduce and AbilityCaster class, which is basically the instance of an ability owned by an Entity. This would know about the owner (but not the target list). The idea is that calling StartCast() would take a list of targets as a parameter, and return a new CastTracker (you can return a special "already finished" cast tracker for instantaneous abilities). Introduce a CastTracker class that just tracks the timing of a cast, and maintains the list of targets. This would have the Tick() method, and a Cancel() method if something other than timing can cancel a cast. Each tick would call back into the associated AbilityCaster class, with the necessary information to decide what to do. Remove all time tracking code from the Ability class, so it just becomes a stateless specification of capability. This could potentially be abstract, with just one level of implementation for the different capabilities. Something like an abstract DoDamage(Entity owner, IEnumerable targets) method. 

Inheritance is the devil. Never implement an "is-a" relationship with inheritance. Any time you reach for inheritance, you need to cultivate an instinct to stop and do something different. Note this is different from abstract definition and sealed implementation - that's just a strategy pattern, which is absolutely fine. Make more classes, that do fewer things. 

Your code is going to log an awful lot of "GameObject is not null" items, for very few non-null game objects. Basically, you've made an O(n * m * p * q) algorithm, where all you needed was (at most) an O(n + m + p + q) algorithm. This would achieve the same effect - beyond the fact that you'll get fewer logs of the same non-null combination over and over again. This code assumes that the library requires an enumerator. 

The advantage of this design is that you'd quickly find that you don't really need much inheritance at all. I would aim to have at most a single pure abstract base class, and implementations for the different abilities. Any time you need to share some code, just make a new class, and have the other classes own one. LEAKY ENCAPSULATION Make everything private. If something needs to be public, check to see where it's used. If it's only used somewhere else, move it. Never use public fields - anything public should be a property. Never set data on another class instance - all setters should be at most private, but better, simply non-existent (i.e. either set in the constructor or implicit functions). That's it for now. Two general points to always bear in mind: 

I was working on the Project Euler problems today in C#. Here is my code for this one. nhgrif's technique is excellent, but you can shave your code execution time down to an extremely fast 50ms without any advanced techniques. The only thing I did to optimize the code was iterate from instead of . I didn't even implement code to skip even numbers, which could make it even faster. Perhaps your technique of storing every prime, instead of just the current one, is why your code is slow? Your technique is to store every prime in a advanced data type. Instead, you could just store the current prime and current prime count in or primitive data types. 

As you can see, in this class any method called from Main is declared as public, and any method only called from within the class is declared as private. Structuring this program as a class instead of a series of functions makes it easy to re-use the code. It makes Class PrimeFactors like a library that you can easily include into any main that you want. I agree with the others about commenting less. I was reading Clean Code by Robert C. Martin the other day, and he argues that comments should be minimal and pragmatic. Ideally you want to choose very succinct names for your variables and functions/methods, and you want to make as many chunks of code into functions/methods as possible. And what this does is it names everything, which helps to avoid you needing to make as many comments in the first place. I think you're already on the right track with this because you wrote multiple functions and you tried to give them all good names. 

Thanks for the comments. I understand what your webpage does now. Suggestion #1 - Descriptions Of What Your Code Does - You might want to create some functions (or add some comments) just to make it more clear what each segment of code does. The OOP people like to make tons of functions that describe chunks of code, and the non-OOP people like comments. You can go either way, in my opinion. In my example here, I will use functions. Suggestion #2 - More Whitespace - I would also add some spaces after your commas and maybe some enters after your commas in your bind_param() functions so that everything wraps nicely and is easy to read. You can do the same thing with your prepare() functions. It isn't a big deal for single line SQL statements like "SELECT * FROM table WHERE field = 'value'", but it starts becoming very helpful when you're doing long, complex INNER JOINS and other complicated SQL statements. 

I got annoyed having to do things like when it seemed as if would perfectly suffice. Therefore, I wrote a small, simple library to wrap the static methods of primitives in extension methods. I don't suppose there is much to critique about the code itself, as most methods are one-liners, but I'm wondering if what I have done violates any best-practice principles. Is there some insightful reasoning behind why these methods were left out in the first place? The class dealing with strings is also very long, as I separated the classes based on which primitive they operated on, so all the and methods belong to the string class. I also further wrapper the methods, making and methods. Is that an unnecessary layer of confusion? CharExtensions.cs 

Some of these do feel odd, like they are too Linq-heavy or just unnatural ways of accomplishing the goal. The top method has an array cast to avoid "multiple enumeration" as ReSharper says. Is that really necessary? 

This class represents a single query on an Active Directory. It is given the type of query to run and the types of data to return, and performs the query and returns the data when it is commanded to do so. The goals I had with this class were to ensure that the query is run async so it doesn't freeze (and crash) the UI and to be able to create the query without executing it immediately. The queries also support cancellation (it is handled farther "down" the calling tree in the and classes). Questions I have: 

which is far simpler. The odds that someone will be randomly working with are pretty slim in my opinion, so you should perhaps consider changing your method(?) to accept a if not a or even an instead. Speaking of "method," it seems that this code should be one. It effectively takes an input and produces an output, so why not isolate it to be its own piece of code that you can call wherever you want? You could also get rid of that statement in favor of a proper . It would look something like this: 

I am trying to get active directory groups with their users, all while disposing of all assets when they reach the end of their usefulness. The groups and users are passed into a method that extracts certain properties and adds them to . This requires a decent number of nested blocks. Since the method is private, and most of the variables only exist in the blocks, I gave the variables very short names. Naming them properly as or would involve breaking even more lines to fit the long names.