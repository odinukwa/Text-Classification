There is an interesting Springer volume on applications of Gröbner bases in coding and cryptography: 

Sorry if I'm mistaken with the place to ask the question (maybe I should go to stackoverflow.com/mathoverflow.net?). I wonder if there is a proof that when evaluating extended Euclidean algorithm the Bézout's coefficients (that is s and t in identity as + bt = gcd(a, b)) will not exceed some reasonable values (depending on a, b, I guess). In particular implementation on some general-purpose programming language I'm interested in overflow correctness of the program. To be precise I can mention that I use Victor Shoup's description of the algorithm (4.2 in his book “A Computational Introduction to Number Theory and Algebra” freely available from his homepage). 

I'm interested in why natural numbers are so beloved by the authors of books on programming languages theory and type theory (e.g. J. Mitchell, Foundations for programming languages and B. Pierce, Types and Programming Languages). Description of the simply-typed lambda-calculus and in particular PCF programming language are usually based on Nat's and Bool's. For the people using and teaching general-purpose industrial PL's it is great deal more natural to treat integers instead of naturals. Can you mention some good reasons why PL theorist prefer nat's? Besides that it is a little less complicated. Are there any fundamental reasons or is it just an honour the tradition? UPD For all those comments about “fundamentality” of naturals: I'm a quite aware about all those cool things, but I'd rather prefer to see an example when it is really vital to have those properties in type theory of PL's theory. E.g. widely mentioned induction. When we have any sort of logic (which simply typed LC is), like basic first-order logic, we do really use induction — but induction on derivation tree (which we also have in lambda). My question basically comes from people from industry, who wants to gain some fundamental theory of programming languages. They used to have integers in their programs and without concrete arguments and applications to the theory being studied (type theory in our case) why to study languages with only nat's, they feel quite disappointed. 

Does it follow that there exists a closed term $\alpha:e\to t$ such that $\phi^a =_{\eta\beta} \alpha a$ for each constant $a$? 

Suppose that $\mathcal{L}$ is the language of a simply typed lambda calculus of two base types, $e$ and $t$, with infinitely many constants at each type. A substitution $j$ is a mapping from constants of type $\sigma$ to arbitrary closed $\mathcal{L}$-terms of type $\sigma$. $j$ extends to a mapping on arbitrary closed terms of type $\sigma$ in the obvious way: $j\alpha$ is the result of substituting the constants in $\alpha$ with their $j$ counterparts. Now suppose that for each constant $a:e$ there is a term $\phi^a: t$, and suppose moreover that: 

Given a full model of the simply typed lambda calculus, it's possible to characterise the lambda definable functions as those that are invariant under every "Kripke logical relation". (See here.) I was wondering if anyone knows whether it is possible to give a similar characterisation of the functions definable in the $\lambda I$ calculus: the functions definable from $\lambda$ terms without vacuous $\lambda$ abstraction (or equivalently definable from the BCIW combinators). A natural conjecture is that they are just the functions that are invariant under every "Routley-Meyer logical relation". (A Routley-Meyer frame is the analogue of the Kripke semantics for intuitionistic logic but for relevant logic --- the propositional logic axiomised by the types of the B, C, I and W combinators. World relative logical relations can be defined from them in a completely analogous way.) 

For a quantum channel $\Phi$, let us write $J(\Phi)$ to denote the associated state: $$ J(\Phi) = \frac{1}{n} \sum_{1\leq i,j \leq n} \Phi(|i \rangle \langle j|) \otimes |i \rangle \langle j|. $$ Here we are assuming that the channel maps $M_n(\mathbb{C})$ (i.e., $n\times n$ complex matrices) to $M_m(\mathbb{C})$ for whatever choice of positive integers $n$ and $m$ you like. The matrix $J(\Phi)$ is sometimes called the Choi matrix or Choi-Jamiolkowski representation of $\Phi$, but it is more frequent that those terms are used when the $\frac{1}{n}$ normalization is omitted. Now, suppose that $\Phi_0$ and $\Phi_1$ are quantum channels. We may define the "diamond norm distance" between them as $$ \| \Phi_0 - \Phi_1 \|_{\Diamond} = \sup_{\rho} \: \| (\Phi_0 \otimes \operatorname{Id}_k)(\rho) - (\Phi_1 \otimes \operatorname{Id}_k)(\rho) \|_1 $$ where $\operatorname{Id}_k$ denotes the identity channel from $M_k(\mathbb{C})$ to itself, $\| \cdot \|_1$ denotes the trace norm, and the supremum is taken over all $k \geq 1$ and all density matrices $\rho$ chosen from $M_{nk}(\mathbb{C}) = M_n(\mathbb{C}) \otimes M_{k}(\mathbb{C})$. The supremum always happens to be achieved for some choice of $k\leq n$ and some rank 1 density matrix $\rho$. (Note that the above definition does not work for arbitrary mappings, only those of the form $\Phi = \Phi_0 - \Phi_1$ for completely positive maps $\Phi_0$ and $\Phi_1$. For general mappings, the supremum is taken over all matrices with trace norm 1, as opposed to just density matrices.) If you don't have any additional assumptions on the channels, you cannot say too much about how these norms relate aside from these coarse bounds: $$ \frac{1}{n} \| \Phi_0 - \Phi_1 \|_{\Diamond} \leq \| J(\Phi_0) - J(\Phi_1) \|_1 \leq \| \Phi_0 - \Phi_1 \|_{\Diamond}. $$ For the second inequality, one is essentially settling for the specific choice $$ \rho =  \frac{1}{n} \sum_{1\leq i,j \leq n} |i \rangle \langle j| \otimes |i \rangle \langle j| $$ rather than taking the supremum over all $\rho$. The first inequality is a bid tougher, but it would be a reasonable assignment question for a graduate course on quantum information. (At this point I should thank you for your question, because I fully intend to use this question in the Fall offering of my quantum information theory course.) You can achieve either inequality for an appropriate choice of channels $\Phi_0$ and $\Phi_1$, even under the additional assumption that the channels are perfectly distinguishable (meaning $\| \Phi_0 - \Phi_1 \|_{\Diamond} = 2$). 

Linear logic isn't complete for coherence space semantics since $1$ and $\top$ get identified. But it is, I believe, complete for the fragment of linear logic whose only connective is $\multimap$. I was wondering if there's a full completeness result for theories in the fragment of linear logic whose only connective is $\multimap$? I think this is equivalent to asking: is the term model of $\lambda$ terms whose variables only get bound exactly once (over some signature, modulo $=_{\eta\beta}$) a coherence space? Since the system I'm interested in is very limited, I was also wondering if there are any simpler structures for which full completeness holds? 

In John Mitchell's book "The Foundations of Programming Languages", he considers a typed lambda calculus with unit, exponential, product, (binary) coproduct types, and arbitrary recursive types (p126). Later in the book he shows how to construct models of all these types. (I'm pretty new to all of this, but I assume this is a pretty standard system.) It looks as though it is not possible to extend this system with a 0 type for the following reason: Let $\sigma$ be $\mu t.t\to 0$. $\mbox{unfold}: \sigma \to \sigma \to 0$ and $\mbox{fold}: (\sigma \to 0)\to \sigma$. Then $W(\mbox{unfold})(\mbox{fold}(W(\mbox{unfold}))): 0$, where $W = \lambda xy.xyy$. From this you can prove all equations between terms (e.g. from the existence of a closed term $t:0$, $\lambda x.t:A \to 0$ is an isomorphism between any type $A$ and $0$.) A natural thought would be to work in a linear or affine type theory where the $W$ combinator isn't allowed, and which therefore might allow solutions to type equations like $\sigma = \sigma \to 0$. My questions is: Is the resulting type theory consistent, and can anyone explain to me how to go about constructing models? (References would also be welcome, but the papers I've looked at so far have generally presupposed more knowledge than I have). 

Various results are proved in this paper about classes of the form $\mathrm{PCP}_{c,s}[r,q]$, which denotes the class of promise problems having a PCP where the verifier flips $r$ coins, makes $q$ queries, and has completeness and soundness probabilities $c$ and $s$, respectively. Someone with greater expertise in this area could point you to more recent references that are relevant, but this was surely an important and influential early paper in the area. 

There will generally not exist a set of $n$ linearly independent vectors $x$ such that $Ax = x$; this can only happen for $A$ being the identity matrix. On the other extreme, there may be no such vectors at all. For example, the matrix $$ A = \left(\begin{array}{cc} 0 & 1\\ 1 & 1 \end{array}\right) $$ has full rank, but there are no nonzero vectors $x$ such that $Ax = x$. This is consistent with the fact that the characteristic polynomial of $A$ is $\lambda^2 + \lambda + 1$, which is irreducible over GF(2). If you want to find the maximum number $k$ of linearly independent vectors $x$ such that $Ax=x$, compute the nullspace of $A - I$. This can be done using Gaussian elimination in time $O(n^3)$. Several other algorithms for this task also exist, and are described in textbooks on computational linear algebra. 

For the sake of clarity, the fact we will prove is $\mathsf{NP} \not\subseteq \mathsf{P/poly}$ implies $\mathsf{NPI} \not\subseteq \mathsf{P/poly}$. Under the assumption that $\mathsf{NP} \not\subseteq \mathsf{P/poly}$ we have $A_1\not\in\mathsf{C}_1$ and $A_2\not\in\mathsf{C}_2$. It is clear that $\mathsf{C}_1$ and $\mathsf{C}_2$ are closed under finite variations. Schöning's paper includes a proof that $\mathsf{C}_1$ is recursively presentable (the precise definition of which can be found in the paper), and the hardest part of the argument is to prove that $\mathsf{C}_2$ is recursively presentable. Under these assumptions, the theorem implies that there exists a language $A$ that is neither in $\mathsf{C}_1$ nor in $\mathsf{C}_2$; and given that $A_1\in\mathsf{P}$, it holds that $A$ is Karp-reducible to $A_2$, and therefore $A\in\mathsf{NP}$. Given that $A$ is in $\mathsf{NP}$ but is neither $\mathsf{NP}$-complete nor in $\mathsf{NP} \cap \mathsf{P/poly}$, it follows that $\mathsf{NPI} \not\subseteq \mathsf{P/poly}$. It remains to prove that $\mathsf{NP} \cap \mathsf{P/poly}$ is recursively presentable. Basically this means that there is an explicit description of a sequence of deterministic Turing machines $M_1, M_2, \ldots$ that all halt on all inputs and are such that $\mathsf{NP} \cap \mathsf{P/poly} = \{L(M_k):k=1,2,\ldots\}$. If there is a mistake in my argument it is probably here, and if you really need to use this result you will want to do this carefully. Anyway, by dovetailing over all polynomial-time nondeterministic Turing machines (which can be simulated deterministically because we don't care about the running time of each $M_k$) and all polynomials, representing upper bounds on the size of a Boolean circuit family for a given language, I believe it is not difficult to obtain an enumeration that works. In essence, each $M_k$ can test that its corresponding polynomial-time NTM agrees with some family of polynomial-size circuits up to the length of the input string it is given by searching over all possible Boolean circuits. If there is agreement, $M_k$ outputs as the NTM would, otherwise it rejects (and as a result represents a finite language). The basic intuition behind the argument (which is hidden inside Schöning's result) is that you can never have two "nice" complexity classes (i.e., ones with recursive presentations) being disjoint and sitting flush against each other. The "topology" of complex classes won't allow it: you can always construct a language properly in between the two classes by somehow alternating between the two for extremely long stretches of input lengths. Ladner's theorem shows this for $\mathsf{P}$ and $\mathsf{NPC}$, and Schöning's generalization lets you do the same for many other classes.