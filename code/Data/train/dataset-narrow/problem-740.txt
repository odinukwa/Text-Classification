If you want to be able to track that a particular retailer used to sell a particular product but no longer does so, you could add dates to indicate when they started and stopped selling the product. If you want to track that and allow the retailer to stop selling the product for a while and then start selling it again, you'd need to tweak the primary key. Normally, for pricing, you'd store something like 

The export utility will use the environment variable specified for the client session. If all your data can be represented in the Windows-1252 character set, that shouldn't be an issue. If you want to do the export using the AL32UTF8 character set, you'd need to set the . In Windows, that would be something like 

The privilege allows you to create database-level triggers (server error, login, and logout triggers). It also allows you to log in regardless of errors thrown by a login trigger as a failsafe. If you inadvertently coded your login trigger to throw an error no matter who was logging in, for example, you need to allow someone to log in to fix the trigger. It appears that the trigger is behaving as expected in this case. You wouldn't in reality create a database link from one database to another using a DBA account. 

Your list of privileges contains a number that don't exist. There is no privilege. Nor is there a or or privilege. You can grant a user access on individual tables that are owned by other users. 

The only way to be sure that the remote database is up and that the listener is up and that the database is registered with the listener properly would be to actually make a connection. You could use the SQL*Plus utility (assuming the Oracle client is installed on the linux box your application runs on) to attempt to make a connection. Something like Create a file check_db_up.sql 

I'd rather have the environment be the suffix assuming I had to pick one convention. Otherwise, it's too difficult to navigate through lists of login names that all use the same first five characters. Of course, if given my choice, I would prefer to use neither the prefix nor the suffix. I'd rather keep the same username in all environments and vary my password and TNS alias to identify which system I'm connecting to. 

When you run , one of the things that it tells you is the location of the Listener Parameter File (the listener.ora file) 

If you try to compare strings, you'll get string comparison semantics. That means that you are asking whether one string is alphabetically before or after another. Since the string '03/01/2001' comes alphabetically after '02/01/2016', that is going to result in a bunch of issues. Presumably, you want to use date or timestamp comparison semantics so that dates in 2016 are later than dates in 2001. I would guess that you'd want 

Flashback Data Archive (formerly known as Oracle Total Recall) let you store history for all the changes to one or more tables automatically. If you have the Advanced Compression option, Oracle will apply a number of optimizations to the history table that will significantly decrease the amount of space that is required and that will generally make queries against history more efficient. 

If your is AL32UTF8, any column will support Unicode (via the UTF-8 encoding). In 99.9% of cases, you'd never want to create an column. The column, which uses the which will almost always be AL16UTF16 is really only useful in a couple of cases. The first, and by far most common, is when you have a legacy application whose doesn't support Unicode and cannot be migrated to Unicode but where you want to support Unicode data in a handful of columns. That's not the case here. The second would be when the database does support Unicode but you want to use the UTF-16 encoding for some reason such as the ability to store primarily Japanese and Chinese data using mostly 2 bytes per character in UTF-16 rather than 3 bytes per character in UTF-8. But if you do that, you're still (barring 12.1 and the ability to have 32k columns) limited to 4000 bytes (2000 characters in a UTF-16 column). Hence the error when you try to define which would need at least 8000 bytes to store 4000 characters. 

If you want to return every row in if there are any rows in with an , you can eliminate the correlation using the key. But that would be very odd 

returns all the columns in the table along with three additional computed columns , , and . The fact that always has exactly one row makes it useful when you want the result to have exactly one row but other than that, there is no logical difference whether you use or a single-row, single-column table that you create yourself. 

show you? If you have 26 extents, you should see that extents 0-15 are 64 kb in size and extents 16-25 are 1 MB in size. 

That can create some rather interesting query plans where the object you're querying is nowhere to be found in the plan 

My bias is to use a single table with appropriate row-level security. There are potentially huge maintenance advantages to a single set of tables. If you end up with copies of each table, that means that you have to run copies of each script every time you want to make a change. Frequently, that means that you end up with at least a few very slightly different versions of the application running at a time because someone forgot to apply script 7 of 23 in a monthly build to one set of tables and someone else created an index on one set of tables to address one customer's issues without adding it to every customer which makes debugging much harder. A single set of tables has significant scalability advantages. Adding new customers just requires adding a new row to the customer table not deploying a new schema/ database with the new customer's copies of the tables. Adding new customers also doesn't directly add ongoing work for the DBAs. If you have separate copies of the tables, you need someone to deploy tables to create a new customer and every new customer means additional work for the DBA at least to run the scripts one more time every time there is a change. A single set of tables may also offer performance advantages. If you're using a separate set of tables, each customer would realistically need a separate connection pool in the middle tier. It would defeat the purpose of having separate tables, after all, if your middle tier is connecting as a user that can see every tenant's data because then you'd be implementing row-level security in the middle tier and dealing with all the complexity of multiple sets of tables in the back end. That makes it tough to scale across servers-- do you create a connection pool for every client on every server? Do you send certain clients to certain servers? Do you not preallocate connections and incur the cost of waiting for connections to be established more frequently? That being said, there are cases where separate tables might be preferred. If your customers are frequently large institutions, for example, separate tables will make it much easier to do things like move a customer to a dedicated box (or at least a dedicated VM) if the customer wants to upgrade to dedicated hardware so that they don't risk performance being affected by other customers. Those large institutions may want greater control over outages and upgrades so it may make sense to have separate tables to allow different customers to be upgraded at different times in order to work with that customer's schedule. Those institutions may find it easier to tell an auditor that their data is physically separate from all other customers rather than explaining that the data is physically intermingled but security controls are in place to guarantee row-level security. If you're going to have relatively few relatively large customers, the amount of maintenance overhead you introduce by having separate tables may not be particularly significant given the general day-to-day maintenance tasks that each client likely requires. In that sort of environment, different clients often have sufficiently different configurations that the problems they encounter are relatively unique even when they're running exactly the same version of the software.