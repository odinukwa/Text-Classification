For these to be truly prototypal, you need to assign some properties to the constructor's prototype. But this case is very unsuited to inheritance in general. Nothing is shared by the subclasses except a single call to a per-instance logger. Bring in the Clones Prototypes To demonstrate how it would look using prototypes, assume that exports a function to be shared by all components, and will call a template method in the subclass instead of accepting a callback in the constructor. This would be more beneficial if it had to do a bunch of common setup work and provided more methods useful to the subclasses. 

The handler for this is straight-forward, but let's break it up in anticipation of adding more features. Note that you no longer swap out the handler for each scene. Instead, a single handler picks the course of action based on the current scene and the key pressed. 

* Coincidentally, $5 is the maximum amount of money you should spend trying to optimize this code. ;) 

Update Since each AJAX call sends a single counter's value, you're losing updates when two readers view the same story. To fix this, denormalize the counter table: 

Once you've deleted the desired number of friends, print the processed list of friends and the remaining friends in the line (no need to parse and add them to the list first). If you run out of friends to read before then, remove the last friends in the list. Finally, you may need to employ some micro-optimizations as the others have pointed out: using buffered input, using a different tokenizer, or even scanning the input yourself given that it has such tight constraints. 

To test , you need to provide a mock random number generator. But if the constructor creates it, you can't. Instead, have the factory provide it, and create an implementation that takes one with pre-configured values. Now you can give that factory to the root game object that uses the factory to create monsters. 

If you don't mind formatting an empty message that won't be sent, you can extract the format/check/send logic to yet another function. 

The application bootstrap is the place to tie the configuration source to the resulting objects. The Factory and Builder patterns come in handy here, though they certainly aren't necessary for small projects. This separation will let you write simple code for tying the objects together. 

Taken together, you really must combine the maps into a new data structure which is returned to clients and replaced in whole by the background thread. Storing it in its own atomic reference allows this new class to avoid concurrency and locks altogether. 

I highly recommend Clean Code: A Handbook of Agile Software Craftsmanship by Robert C. Martin. It's an excellent source of great advice precisely aimed at your questions. The earlier you start, the fewer bad habits you'll need to unlearn later on. Formatting Your line length and whitespace seem okay, though you a little off from Sun's (now Oracle's) Java Style Guide. I always put whitespace around keywords (, ) and between closing parentheses and opening braces. Naming Ignoring and which you've already explained, I would get in the habit of using fully-spelled-out variable names now. They are clearer and help you practice your typing skills. There are a few abbreviations that everyone will understand such as and , but they don't make good names by themselves. 

Your question does not match your code. You ask to check that a key does not exist in the array, yet you are actually testing the value mapped to that key against some other value, presumably doing something else if the key doesn't exist. 

Comments You can remove a lot of these extraneous comments simply by using more expressive names. One of the main problems with comments is that they aren't compiled or checked for correctness. They can flat out lie to you like "Get the given key" which actually returns the value for the given key. Comments like "Find the key" in a method that by it's name obviously looks for the given key don't add anything. 99% of your comments should explain why you are doing something in a particular way when it's not obvious or trivial. If the code is so complicated that you can't tell what it does, rewrite it rather than adding a comment. In other words, avoid comments that merely translate the code into prose. JavaDoc Yes! It's never too early to build good habits, and they are very easy to write. Here's an example: 

I'm going to hit the high notes on my phone and swing back later with details unless someone beats me to it. Allow Add a separate boolean field to track when holds the actual next element rather than using as a signal that it needs to be populated so that elements can be supported. Avoid Recursion In this case, there's no reason for to call itself. Continuing the loop should have the same effect. Use Generics Even though you're stuck using for variables which may hold an element or an iterable, you can still add a generic type to the class and specify it as the return type from . At least, I think you can. :) Testing When using the annotation, you don't have to prefix each test method name with . However, you really need more descriptive method names, and each test should validate one specific condition. Burn this into your brain: Arrange, Act, Assert. Arrange the test fixture in the initial state, perform the action being tested, and assert the results. It can become tedious to setup the fixture each time, but helper methods can ease the pain and promote DRYness. 

While this will require more code, it will be pretty straight-forward and allow you to make moves without iterating over the same possible numbers again and again. 

The major problem here is using imprecise floating point values. Not only does it slow the entire process (minor quibble), but it will produce incorrect results once the values pass the integral cutoff of the field width. If you truly want to allow calculations approaching infinity (or what? 24 bits?) you need to switch to which can model "exact" integers of any size. 

I try not to cover ground already touched upon by @janos's great answer except to emphasize formatting. You mostly do a good job with the indentation which is clearly the most important factor, but has a loop whose body isn't indented. Consistent spaces around operators (looks like you do), structural parentheses (, , etc), and braces is important, too. As I scan your code, each case of and sticks out like a sore thumb and distracts. Naming two traversal methods is misleading. You aren't searching for a specific value. Use traverse or visit instead. Why are the traversal methods static? Tree traversal cries out for recursion! So many of your methods would be simpler using recursion instead of loops, stacks, queues, and visited flags (is that flag even necessary with the looping algorithm?). 

I would add an error message when the input is not okay. If they know about or I would use them after displaying an error message. Better yet, loop until the input is acceptable if they know about looping. 

First, serialize in parallel, no pun intended. Each thread can perform its own object serialization without making the other threads wait. Here's how would look: 

That's a big mess of conditionals. Hopefully they all match the comments near them, though given typical code that's likely not the case. You are repeating a lot of HTML code that could be addressed using variables as @V31 demonstrated. If this is the entirety of the code I would probably stop there, but as this system grows you may want to generalize the conditionals and how they apply. First, you can create short functions to help ensure the comments match the conditionals and are clear to future maintainers, reduce the code duplication (DRY), and possibly allow reuse in other areas. The very first conditional provides a good example. 

PostfixCLI This class is very simple, but there are a couple small changes you can make to start teaching good habits to your students right away. 

Why are and using ? They are already being called with the correct context, and rebinding to the same context changes nothing. Edit: Instead of using plain functions to implement "private methods", promote them to proper object methods and mark them private using JSDoc. This will save you those extra calls to . 

Since you'll be using this table format with each conditional block, we'll create a function to build the table cell using the data tables and person. 

The object gives access to sections and top-level values. It makes sense to expose sections using a or method. 

If implemented the interface, you could use the built-in intersection method to do the lookups for you. 

O(k + log n) seems highly suspect to me. For small values of n this is equivalent to O(log n) while for large values it's equivalent to O(k). That they specified O(kn) up-front processing leads me to consider the use of a hashtable, but I don't see a structure that would provide the "closest-neighbor" capability required by the problem statement. Obviously this doesn't answer your "How can I do this?" question, but I question that it's even possible given their requirements, assuming you captured them accurately. At this point someon will likely provide a perfectly valid solution to blow my mind. :) 

Data Structures Every time an needs to grow, it doubles in size. This applies to all those lists in the subject/object maps plus the list of sentences. You could drop the list of sentences and instead store lists of (now unique) sentences for each subject and object, but you would save even more space by instead using a map from sentence to count for each. 

While I applaud your effort to keep methods short by refactoring, I question the benefit of replacing 

This question boils down to the number and sequence of operations. If you are building one large list but removing lots of duplicates, use a hash table or sort and uniquify the list. Sorting and making the list unique is O(n log n) at best. Removing a duplicate is O(n) at worst so removing m duplicates is O(m * n). While in general O(k * n) = O(n), once m exceeds log n the one-time cost of sorting the set pays for itself. And additional lookups remain O(1). You must evaluate the costs with realistic values for m and n to decide which method is better. Of course, their values will vary over time along with the relative costs of CPU versus RAM versus disk. But for most "probable" values of m and n over time, relying on standard library collection classes--with a sprinkle of tuned variations from Guava and the like--is the hands-down winner. 

One quick improvement to your solution would be to use instead of the chain. The only real problem I see beyond the complexity and non-obviousness of the algorithm is that it can end up doing a lot of unnecessary swaps--often in-place. While could be written to avoid them, you still pay the cost of the function call. Another solution is to do it in two passes: first pull all Rs to the left and then all Ws to the right. While it takes twice as long, it's still equivalent to O(n).