As an alternative to Infrared, you could use HDMI, if your TV has HDMI 2.0, it will support some kind of CEC () implemenatation Each TV brand calls this something else, like Panasonic Viera Link. But it all uses the same standard just some TV's implement more, some less but the basics should be there. Like turn TV on or off, navigate channels, etc. cec-o-matic is a useful tool to try and help you decode message that the array of HDMI devices are sending across the CEC network. Remember that you can also control the Pi form the TV via a remote, but that can also be an AMP, Blu Ray Play, etc. It is uni directional. You would need to build CEC-CLIENT so you first need a few dependencies 

The Raspberry Pi is good for crunching numbers. Install your MySQL database on there, write your C/C++ code to talk to the Atmega via serial port. Do not rely on the Pi's GPIO- they are flakey and experimental. Atmega uses C code with which you are already familiar and there are tons of examples online. It is easy to programme, even directly from the Pi and is extremely reliable. Do not crunch numbers on the Atmega. Keep it simple on the Atmega, just collect data and dump it via UART to the Pi. If the data is arbitrary counters of traffic then you can easily send data over GPRS in JSON format to your command server. But you might have something else in mind. Using GPRS works best with single files, like ZIP's of 1~4mb. Sending many small files is not good. Make sure to use Revision 2 Pi's. There are allot of fixes on there that helps stabilise the Pi. 

There are two types of wireless keyboard/ mouse kits available. The one you seem to have is where the Operating System needs to start Bluetooth Utilities and connect to HID (Human Interface Device) This is a standard Bluetooth pairing system. Any device with Bluetooth will be able to connect to your kit AFTER pairing. So you would need to use a wired USB keyboard to configure your Raspberry Pi first. After that "BIOS" screen, which is probaly just you will need to log in, enable Bluetooth utilities, pair your Keyboard to the Bluetooth and enable a script to restart the Bluetooth Services on EVERY reboot. 

SignalR client is basically installed into your Universal App by running the following package install commands (or using the NuGet GUI) 

Which means the 1 bit will be the same as the VIN voltage. So 3.3v input = 3.3v HIGH Bit for I2C It also supplies a 3.3v regulated voltage separately on VDD, but only if the voltage is higher tan 3.3 but when its LESS than 3.3v you actually supply the voltage into VDD. Pretty confusing but allows for flexible prototyping. In your case supply 3.3v to VIN and you will be OK to connect the pins directly to Pi. Looking at the schematics though, the circuit is always powered by 3.3v - The level shifters on I2C are responsible for using VIN as reference to produce I2C at the requested VIN voltage. 

Try and put the over-clock mode into normal position and set the GPU RAM to 32MB on Model B and on Model A put it to 8MB. If it is going to run headless you don't need GPU RAM. Try and use some networking patches. in /etc/sysctl.conf 

You can run a live Debian CD on a normal computer + USB SD card reader or a laptop with an SD card slow. 

The Pi is not a real time OS and sending PWM signals can just cause unexpected results. You cant fade LED's or mix then and controlling servos is an issue. You should really use a dedicated hardware with an external clock and real time OS so that the PWM generated signals in a timely fashion. The most popular option is an Arduino, or a MCU from the AVR or PIC family that you can connect a crystal to and supports PWM. You can program an aTiny 45/85, which has a good enough built in crystal, and is good enough to run stand alone and talk it via SPI from the Pi. The obvioues drawback is you need a Arduino programmer or a full Arduino and write some code for the 45/85 to do what you want it to. 

R1 is connected to PIN 1 to pull it down. Pin 1 is also connected to another resistor in series to limit the current for the transistors range. A transistor is a simple gate. If powered on the BASE the gate "connects" COLLECTOR and EMITTER and lets the current flow in the direction of the arrow. In this diagram its a NPN transistor most likely something like a 2N2222 (cheap and cheerful). This is also a very nice way to "BUFFER" your circuits. As you can notice the 7volt supply lights the cathode bulb and goes to GND, without ever reaching your Pi/MCU. The capacitor is not required but it seems to be used here to smooth out (debounce) the switching process) The LED is just coolness. So your GPIO pins do not drive any heavy loads directly- Doing that can burn out the CHIP or PCB tracks. Instead you supply a voltage with more amps and better copper that will give that burst of energy, while your digital circuit (GPIO and Transistor) control the flow while being protected. Remember to check if the transistor can handle the load. In most cases if overloaded the transistor will burn out before damaging your digital device. Pull Up resistor This resistor is connected to V+ instead of GND and pull the PIN high while floating. This type is not common and only required for specific purposes. 

Because omxplayer uses the hardware GPU its need GPU memory. In the file , add the line or set it using raspi-config example to stream audio via HDMI 

2. Quality is 44.1khz Stereo -or- 48Khz joint. And will be the same quality as the input signal. This is because the audio is digitized and send over ether in ones and zeros. Then re assembled on the other side exactly the same way. The drawback is it only stereo or mono. There is no 5 channel or DTS/Surround support. (But you may use several to accomplish this.) Some Bluetooth devices allow for superior audio quality and raw audio formats but that might be a bit difficult to implement on the Pi 3. No ambitious idea is ever stupid. But be careful as prototype projects can sometimes cost as much as the real deal.. sometimes even more. But take it from me. Its worth the fun learning about it :) 

A flow chart of brainstorm of what you need it to do. You will most likely need to use X to play the videos but there are command line tools to play videos and photos too. Establish what works best for you. Then choose what programming language you are comfortable with. Wire up 1 button and see if you can get it triggered in your code. If you can get it triggered in your code figure out how to stop the current video and play the next one. 

With my soldering iron I first try to remove as much solder from the points of your component. It is important not to overheat the PCB - If it is layered you will ruin it. So keeping your soldering iron longer than 30seconds wihtin in area is not recommended. Do it in short bursts and do not let the PCB get hot. This is only requires spot heat. Use normal solder to help you remove factory solder. Apply your solderin iron to the point and apply new solder. THis will help melt the factory high heat resistant solder. Let it melt a bit. 5 seconds and use the sucker and suck the solder out. It does not need to be perfect as long as the original solder is mostly gone. Do this to all the pins. Apply quick chip flux. not allot just smear it on the area. Now apply chip quick solder. It does not have to be allot. Chip quick solder will stay liquid for about 15-20 seconds after you take your iron away. Use you soldering iron to spread the chip quick solder to all point. Again- you do not need allot. do not go crazy because it is waster. you cannot reuse it later. You can then put down your soldering iron and wiggle the (in this case LAN PORT) out. side to side. If you do not get it the first time. Apply a bit more flux and reheat the quick chip solder. Wiggle wiggle wiggle wiggle. 

Sure you can! It all depends on how you configure the Pi. I can see ye'old good LAMP answers already creeping up... I would strongly suggest to stay away from Apache traditional full PHP (CPU & RAM HOGGERS) This is a fact: Instead for your front end you should must use nginx instead. It was designed for embedded devices and runs extremely well on the Pi, especially the 3. The back end is all up to you but In My Honest Opinion 

The Raspberry Pi is the brain. The relay is the muscle. The brain sends low voltage signals (5v) to the relay, which trigger it to contract (by using a coil) - This flips a mechanical switch (which isolates 120VAC to 5V) and turns on the 120VAC to the valve. You must always isolate high voltage from low voltage by using relays, octocouplers, transistors, etc. Connecting 120VAC to the brain equals death. 

On complex circuits or circuits that rely on batteries this power is very precious. Other reasons include low EMF generation. On Wireless devices pulling logic high will cause unnecessary cross talk on extremely sensitive RF receivers. On such transceivers there is a GND plane used to filter noise and this is where all logic gets pulled down to. The processor then uses the GND plane to filter switching noises. 

This might help sort the card out for a short while. But if its a its generic brand, this might only works once or twice and then into the bin because it will get worse, faster. Look for Genuine SD cards, preferably Class 8 or 10 as they are higher quality. 

If I was doing this I would use nginx and PHP CGI, Its fast and low on resources. Instead of USB I would use WiFi or LAN conenction. USB Host on the Pi is more complex. Create some static HTML pages. You need to read on the internet how to set headers for Android/Iphone to make it work like an "APP" if thats what you want. I would then create bash scripts that does a specific task of gathering data for a certain thing and execute them from the PHP. This is not the preferred way to do it on production but its easy for secured networking. ie, not internet. Output your data as JSON serialiased objects. Create a PHP "API" that executes the script, binds the data to an onbject and return that onject as JSON. This way, it is extensible, meaning you can create your "APP" or allow other thigns, like computers, of Text Overlay to request data from the PHP paths. On your static pages you would use jQuery, they can consume JSON easily, and build your HUD using any other jQuery plugins. The PHP part would be purely for data, and the website would be simple HTML pages. If all this is way over your head, then the PiUI is a pretty good example of what I described above. Not sure if it has an API though, where you could get data and use it how you like though. The concern of realtime is hwo you implement the scripts. jQuery AJAX can be run to do allot of requests locally, but ideally, like goldilocks suggest, you might want to use sockets instead, which is more involved. But you can look into NodeJS You can also do this in Perl or Mono C#. It all depends on what programming language you are most comfortable. You could also just pump data out the UART port but you need to create and conform to some kind of data model so you can reliably parse the text on the other side.