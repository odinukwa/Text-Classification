Do you have a cat? Could it have accidentally walked over the keyboard and hit the Prt Sc key? Raspbian's GUI sets up the Print Screen key to call by default. Check the config file to see if it has any references to the command. 

It's not a commercial product, but the Raspi ALU Case looks like it would do what you need. For just the extra ports, there is the FTDI RPi USB Hub Module. A custom board in the quantities you need would be prohibitively expensive 

If you're running an RRD with updates every few minutes, SD card wear won't be a problem in any reasonable amount of time. But if you're determined to use an off-disk store, you can make a 1MB ramdisk this way: 

I say partial, because some drivers aren't very good at identifying themselves as separate devices. Prolific adaptors are particularly bad at this; two or more PL2303 devices may swap ID at times. FTDI ones are better. 

This looks like it has some important ones to me. I wouldn't even try. Are you sure that the packages you installed with weren't already in the repos? 

put the entries you want in; there's a handy template loaded by crontab that shows you what fields are what. Once you're done and saved out of the crontab editor: 

That sounds a little high, but mine tend to sit in the high 50s °C when idle. Heatsinks - even small ones - can help quite a bit 

I gave up fiddling with config files and difficult hardware, because this solution is cheaper and stress-free: 

Not all VNC viewers support file transfer, as it's not part of the original protocol. TightVNC does, so try that on your Windows machine. 

Linux uses UTC. So many subsystems depend on it that you'd be better off doing a localtime conversion for the times you need, and let the system clock run on UTC as it's supposed to. You should be able to use hwclock to set and retrieve the time from a 1302. It should make the conversion to/from UTC for you. 

Address family not supported by protocol seems to be a fairly common error with CUPS. If this is to be believed, go to the CUPS printer administration page — $URL$ — and click "Resume Printer". 

The LM60 and LM19 are analog sensors, and the GPIO ports have no analogue inputs. You'll need a DS18B20 digital sensor. 

Should be doable with a RF Link Transmitter on the Raspberry Pi and RF Link Receivers on the remote boards. You'll have to use a Manchester encoding library on the Raspberry Pi (like this one [untested]), and a decoding library (like this) on your microcontrollers. Use short messages (say 1 byte address, 1 byte command) and put wire antennae on the transmitters and receivers. Note that this will send only; you'll have no idea if the microcontrollers have done their job properly. 

Download the Inconsolata OpenType file, and then create a Glyph Bitmap Distribution Format (BDF) bitmap file: 

The batteries won't force current through the system. Your bigger problem, though, will be running the Raspberry Pi 2 at all on 4.8 V. It's very close to under-voltage warning (which I saw quoted as 4.65V for the B+). You'll need some kind of DC-DC converter to get the voltage to consistently ≥5V. 

You don't state what kind of rx/tx modules your using, but I suspect that they are something like these: 433Mhz RF Transmitter Module + Receiver Module Link Kit. These inexpensive modules are widely used in wireless thermometers, car keys, doorbells, etc. The receivers all have one key annoying attribute: they automatically ramp up the receive gain to return occasional 1 bits, even when there is no signal. This might seem like a bug, but it's actually a feature. All of these modules are designed for use with Manchester Coding (PDF data sheet from Atmel). You have to make your data into packets, usually of the form: 

It looks like it uses a standard FTDI USB to Serial chip, so it should appear as a serial device on . 

You can never guarantee the voltage levels that come out of an RS-232 port. Unless you've got the full technical spec, assume ±12 V. 

investigate whether you need to run this startup script as root: most GPIO works fine under user control now, and it's relatively easy to create user systemd services (the files go in ); or set the environment variable for your script if you're running a GUI, and the sound will play. 

The SDIO Drive errors suggest you're running quite an old version of Raspbian (possibly via NOOBs, which isn't ideal). Card corruption is the most likely reason for the problems, but it could also be that you're creating a process that's swapping, hence all the light activity. 

Under Linux, the audio device is ‘attached’ to the display screen. The screen typically belongs to the user, not the superuser, so attempts to output audio as root will fail. Either: 

If it's legal where you are (you may need an amateur radio licence), high-speed multimedia radio can do 1 km line-of-sight with the right antennae. It's a complex system to set up, though. There is a project deploying it on the Raspberry Pi: HSMM-Pi. 

This takes 50 s on my Raspberry Pi. If you're willing to sacrifice some image quality (and if you're batch-converting RAW→JPEG without some knowledge of the contents, you're probably not too fussed about the JPEG quality), this is much faster still: 

Though it's not a stream player, it should help give you an idea of another way of doing it. The command breaks down as: 

It's not a port of Maestro, but MuseScore is in the Raspbian repository. It's a very capable scoring program. Porting from RISC OS to Linux would be a challenge: 

make sure you have all the dependencies you need. You can pull them in for the current version with something like (which pulls in the insanely large TeX Live system, which you likely don't need for anything else but building the docs.) remove the system version of libsane with or similar. Download, unpack and build the package as before, but instead of , do . It will prompt you for some input, then build a deb file that you can install. 

Yes, pretty much any reseller would be happy to quote you for this. Element14's custom hardware supply cuts in at 5000 units, which might be a bit much for your needs. But if it's a customized distribution in a particular case with perhaps a hardware add-on, it's all down to whether you can agree a price that the reseller's able to work with. As regards other boards, that's purely a technical and commercial decision on your part. The NextThing C.H.I.P. Pro, the commercial BeagleBones or any of the 96Boards might do it for you. 

I then wrote a Python 3 program to open the serial port, read a few lines, pause for a few seconds, read a few more lines, pause for a longer period, then read some more lines. The results surprised me, especially with the differences between two types of (official) Arduino boards. Arduino sketch 

Yes, you can. You can either use a single USB audio device with stereo inputs (I use an old Griffin iMic) or use two USB mono inputs. I prefer the former — not just because I already have the hardware to do it — as it means fewer devices to support, and fewer potential sync errors between the audio streams. For instance, I've used a Raspberry Pi, the iMic, and a binaural microphone set clamped to a 30 cm steel rule to demonstrate range finding by calculating the delay between the left and right channel signal. 

Unless you want to mess about with the GPIO UART port, your best bet would be to use a USB→Serial adapter. I'd strongly recommend trying to find one with a chipset by FTDI; you pay a little more for these, but they just work. Plug it in, and a serial port called something like will appear. For talking to the serial port, you have lots of options. pySerial might be a good one. Install it with: 

The Raspberry Pi has network hardware hanging off a USB controller, and needs the support of the not-very-brawny CPU to handle every byte. It's probably not the computer for this job. Something like a GuruPlug Server (if they've fixed the power supply/overheating problems that plagued earlier GlobalScale Plugs) might be better. Just for lulz, I ran a Java speedtest from DSLreports.com on my Raspberry Pi. It maxed out at 5.2m/2m. 

The upper blue trace shown below is a fairly typical Manchester Encoded packet. The header, at least, is easy to make out: 

It's not ready for general use, and far too long to describe here, but Bruce Perens has had some success in Installing the Native Debian “armhf” Architecture on Raspberry Pi 3 Instead of Raspbian. 

If you have XQuartz installed, and do to another computer, XQuartz will start automatically. You can then start X applications in the ssh window, and they'll open on the Mac. You don't need to do the forwarding bits (steps 1 & 3). Also note, you wrote , which means disable tunnelling. 

You most likely want an interface based on the MAX3232, the 3.3 V version of the old MAX232 chip. Several ways to do this: 

set up a tool (personally, I recommend scrot, as you can get it to set the file name to include the date and time) edit (NB: different for a Raspberry Pi than the instructions) to include something like this in the <keyboard> section: 

There's some possibly helpful discussion here: Connect to MSSQL using FreeTDS / ODBC in Python. Are you familiar enough with Python's database management? I'd strongly suggest you try setting up something which talks to a local SQLite database before jumping into the hairy weirdness that is Azure. Otherwise, this just seems like we're doing your homework for you … 

Does the re4son kernel include the dwc2 and g_ether modules? On your Mac, you need to enable network sharing under the System Preferences / Sharing option. You should then be able to see hostname.local (if your distro supports avahi) or a useful IP address for the local/remote side with . 

You'll need one with exactly the same circuit characteristics as the stock XO. If you're skilled with a hot-air rework station, and have all the right tools and equipment, it's not too hard. It's virtually impossible if you don't, though. Likely not. NTP is designed to work around variable system clocks through network consensus, so changing the XO won't give you much. Using a GPS's PPS signal effectively gives you a GPS/Multi-GNSS Disciplined Oscillator, so as long as you have skyview, you've got atomic clock accuracy even without a network. If you don't have skyview or network, it wouldn't be impossible to piece something together based on a used rubidium frequency standard — but even the cheapest of those have fearsome power requirements and are far from plug-and-play. 

This will trickle out new readings every minute. I might suggest printing a timestamp in your Python output so you can track what's changing. (I'd also invite you to research whether you have to use at all. Many GPIO libraries for Raspberry Pi no longer need root access, and can be run as a regular user. If you're following a tutorial that's from before mid-2015 or so, it may be suggesting when you really should no longer use it.) 

That error is pretty harmless. It used to happen all the time. Do you have a monitor attached? startx won't do much without one. It's also not typically used with : that would mean that your X session would belong to another user. startx is seldom used any more, as you can set Raspbian to boot straight to desktop using , option 3 Boot Options → B1 Desktop/CLI. If you don't have a monitor attached, you can still get a remote desktop from VNC. From , select 5 Interfacing Options → P3 VNC. You'll need a VNC viewer on the remote computer to see anything. If the remote display is really small, use , option 7 Advanced Options → A5 Resolution will allow you to set it to something better.