Like others have mentioned: You can't trust the client. All MMOs, Battlefield *, Diablo 2&3, etc, all store their characters online because there is no way to secure the client's files against malicious users. Hackers, and the like, will always try to find the weakest point to make their modifications. In this system, I can already tell that the weakest point would be memory injection, and memory injection is easy stuff. Changing your gold, your XP, and other numeric values is trivial. There are only 3 ways to fight against memory injection that I know of. 

Using some variables I made up because I don't completely know if Jimmy's interpretation is alright: 

I've made a star field, much like the one you describe. I would recommend wrapping the stars. If a star goes off the screen on one side, have it reappear on the other. This worked for me, but I also had a bajillion stars, so nobody could notice. As a side-effect, the stars always look the same at any given view point. Before I was wrapping stars, I used to recycle the star object and provide it with some new random properties on the other side of the screen; random properties included: position (only 1 axis, based on which edge it fell off), size, brightness, and speed. This worked well, but I came across problems when my screen was moved very quickly, causing stars to bunch up along the edges of the screen. The reason for the bunching up was twofold. First, I was doing a direct assignment of the star's new position on the other side of the screen instead of taking into account how far the star was off screen, and secondly: what if you move the screen multiple screen-sizes away and you randomly generate the stars' speed. Just some stuff to think about if you end up taking this route, and why I switched to basic wrapping. But I would recommend not deleting your star objects because allocating and releasing memory is a relatively expensive task, especially when you can just recycle your stars. 

I am developing a similar supply system in my own game, so I have also been thinking about how to resolve the supply-lock issue, and favoritism. To illustrate the problem, I'll create a simple example: If you have a list: [producer1, consumer1, consumer2, consumer3] and you update in order, starting at supply = 0, you'll get this: 

I think you should load your content in the LoadContent() method. If you don't have this method in your derived game class, create a method that looks like this: 

You can leave your divs as rectangles, and simply make the corners of the image transparent. You will have to a little math when detecting clicks properly, but it will be easier in the long run. I have created a modified version of your tile with transparency: And have made a rudimentary tiling system with this image in CSS: $URL$ Alternatively, I might look into using an HTML5 game engine such as CraftyJS, or Isogenic Game Engine. 

For a flexible system, you'll want to make new classes to represent a line of text that can contain multiple sections of text with a given colour. 

That was it! Changing those two methods affected everything else: what I was looking at, where the objects where drawn, where I was clicking, everything. My spaceship now looks directly at the target it is shooting, and everything is falling into place. I will be experimenting with the orthographic projection, see if it makes everything seem more 'real'. 

(or something like that). If the is greater than the 'frameTime', show the next frame and subtract the frame time from the : 

I'll come straight out and say that I don't know how to solve the problem you have described in the question (collision detection between iso-tile-shaped rectangles), but I can tell you how others have solved it in the past: The way it's done in other games is to separate the game world from the screen world. When you're starting out, it common to imagine them being the same thing, but then it leads to problems like the one you're describing. The general idea is that the game world is stored completely in memory, behind the scenes, it's just numbers, references, and logic. The fact that you are drawing the game world in isometric is irrelevant. Your game world shouldn't have the concept of isometric, or square, or even if the screen is being draw as 3D. All of that is taken care of when you draw the game world to the screen (aka the screen world). The game world should be stored and maintained in the simplest way that makes sense for the game, in isometric games, you typically completely ignore the fact that it's iso and instead store the positions as if you were using an axis-aligned grid. Most games will have methods for converting coordinates between the two worlds, I call mine and . The conversion is often done with Matrix math, but can be achieved other ways. You'll use ScreenToWorld when you use the mouse, and WorldToScreen when you draw. There are several advantages to splitting the game world and the screen world. One of the advantages is that collision detection and movement all happens in the game world, and is therefore usually quite straight forward because you're not dealing with a slanted grid, or skewed coordinates, or where the screen is, etc. In your case, you'd be dealing with axis-aligned rectangles and squares. Once the game world has been updated, then you draw a representation of the game world to the screen, keyword: representation. It may seem counter-intuitive at first, but your screen is only a representation of what's going on in the game world. This makes things like dedicated servers and terminal-like clients possible. FreeCiv is actually a great example of all these things. You can view the same exact world as any of: a square North/South Grid, Isometric, or even Hex. Every game you run has a dedicated server running in the background, even for single-player games, therefore the client is also just a display port, nothing more. Long story short: Separating the game world and logic from the screen world simplifies the game logic, reduces the game<->display coupling, and in turn, makes collision detection between "iso" tiles easier to handle and easier to visualize. 

I don't know the details for LWJGL, but in XNA, developers need to create a wrapper that keeps track of the last state of the mouse & keyboard, and the current state. That is the only way to detect a "press" or a "release". I would look for a way to remember what keys/buttons were pressed down, then use that to determine if something has changed. 

As for bluetooth, I would expect that to be similar to the peer to peer method above. I also don't think you should have any issues with NAT. EDIT: It also heavily depends on your experience. I'd start with writing some relatively small client/server games to get the hang of networking first. It's a tough topic that is easy to get wrong the first time. I got mine right on the third try. Follow known patterns, and don't try to make something up yourself. 

I'm assuming one of the two will have control over the other one, much like a fork-lift. In your drawing, I'm assuming this is the black one, and the red one is the package. You only mention you're having trouble with angles, so that's all I'll cover. When the objects latch together, you should remember the angle difference between the two (I'll call this Theta). I have drawn this in figure 2 with the arrows from the first figure drawn over each other. Until the objects are unlatched, the angle of the Red object will be determined by the Black's angle plus Theta, as shown in figure 3.