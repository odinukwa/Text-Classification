I haven't tried the following solution, but if you have a compatible Linksys router (or maybe other manufacturers), you can enable the logging feature (as codewarrior already suggested. Thanks to him). Then, you need to specify the IP address where you want the logs to be stored (your RPi's). On your RPi, install one of the implementation of . or for instance: 

You can share a USB device over the network by installing on your RPi. I found a quick tutorial on the official Raspberry Pi forum (all credits to secretagent, the OP). I haven't tested the solution by myself. On the Raspberry Pi (server) 

...then, the port forwarding works well. Otherwise, you should try another server with another server, just to make sure your SSH server does not reject external connections. 

Multi user chat (aka MUC) MUC are clients allowing you to join different rooms and chat with people you don't necessary know. A well known MUC client is IRC (not XMPP). Some web-based examples: 

As far as I know, there is no software that allows to block the network access for background processes. You can use AppArmor to block the Internet access for every software. You should be able to put every programs in a blacklist, and then put in the whitelist. But it will surely be painful! For the blacklist, you can use rules similar to this (you'll have to find every paths!): 

There is different ways of connecting to the pi. You can use a usb to uart (serial) interface to communicate. Here is a good tutorial about how to use it. It's for the Pi Zero, but I assume it could be used for the pi 1 as well. Also, you can configure the pi to appear as a ethernet device. It's explained here. For me, the best way to do it is to connect the Pi to the router with an ethernet cable and power it using the usb. Then, configure the network settings on the pi to a static IP and then access using the mac terminal over ssh. I don't know if the speed is important to you, but the pi 3 is much faster than the pi 1 and the pi 2, so, if you're going to use it a lot, I do recommend upgrading it. 

EDIT2: I don't know if this will work, but seems to me like the better aproach if possible: Create a software serial port under GPIO and wire the hardware serial port to the serial software port, then, create a python script that starts @reboot and reads the terminal TX and print it on the screen. EDIT3: I've found this. Seems to explain how to create more uart ports. 

Obviously, the problem seems to be either the port forwarding configuration, or the ability for the SSH server/RPi to handle external connections. Port forwarding configuration Maybe you should try with a specific external port. Let's say 10022 (external port) forward to your RPi IP address, port 22. Then from an external IP address, try . If you have a message similar to this: 

Remember to change the variable (don't make it root!) Change the permissions so that the file can be executed: 

List the devices shared by your RPi. You should see the same device as in the forth step of the server part. Note the busid. 

GMediaRender should do the trick. It is a UPNP media renderer running as a daemon. I've once succeeded in installing and running this soft on my RPi. A couple of tutorials explain how to install it on a Pi. It is quite tricky, but possible. I think I have followed the first link. If you are brave enough, I suggest you to share your experience by answering your own question and explain step-by-step the procedure to install GMediaRender. 

The logs make me think the startup script is not provided. To run , you have to provide such a script (in ). Make sure the file exists. 

Maybe a startup script already exists on your file system (try or to find it), or on the Internet. Otherwise you will have to write your own (have a look here, or here) 

You want to reuse the controller? You can use a usb snes controller. If not want to use a usb controller, you can wire the snes controller to the gpio, there is how to here. 

Here you can find an example on how to drive one or multiple arduinos using i2c. It's really well explained there, so, I don't see a point on duplicate the info here. Please take a look at the link and, if you have any doubts, I'll be glad to help you out. There is a couple of steps to do, but basically yo need to configure i2c as master on the pi, then configure arduino as i2c slave. You're supposed to add a level converter in between, but most people is getting ok results without it, and bad result with it, so... I don't know what to say about it. Benefits on i2c are that you can connect up to 112 nodes on an 7 bits i2c bus. So, just need to use 4 wires from pi to arduino 1, then 4 wires to arduino 2, etc. Also, you can add i2c sensors and actuators as well on the bus. 

Following this link, .xinitrc in your home directory will be read and executed. Otherwise, you can place your script under /etc/X11/xinit/xinitrc (I don't know what OS are you using). So, both ways are supposed to run the script when X server starts (again, don't know what OS you're using) 

I don't know if you are looking for a surveillance software, but I have succeeded in installing and running , a software motion detector. You should have a look in the official guide. 

Please copy/paste the result of in the comment section. & You can also have a look in the following files & . Please copy/paste the result of & in the comment section. 

At the moment, it seems there is still no stable software to encode h264 video using the hardware, even if it has been officially announced that the Raspberry Pi does support h264 hardware-encoding. So, we cannot do a benchmark to compare performances to a regular PC. I don't know if someone is working on the subject, but a developer from seems pessimistic about integrating such a module in the existing project (see his reply on december the 2nd, 09:23). I'll be glad to do a benchmark when a library or software allows it. 

If you see a similar message, then the port forwarding configuration works well. Otherwise, you should tweak your router... SSH server configuration If none solution of the above worked, the problem is probably in the SSH server or RPi configuration. 

I haven't try them, but you can try the following softwares. Single user chat Single user chats allow you to chat with one or more people that you have in your friend list. Some known clients are Pidgin, Gajim, or GTalk. Some web-based examples: 

Also, don't forget to put a flyback diode, which is a protection against the inductive current that may appear when switching "off" the transistor/mosfet. 

Relays have three pins: COM, NO, NC standing for Common, Normally Open and Normally Closed. It will depend on how you want to interface with the relay or relay module, you'll need to change your wiring. Usually, you will cut one wire coming from the power and pass it to COM of relay, after that, grab the other side of the wire and put it on NO or NC. Applying or removing V on the correct pad (usually labeled as INx on modules) it will change the state of the relay, thus, changing the "state" of the thing connected through it. 

In this stack overflow question it said that the issue is caused by " a conflit between two DNS servers : isc-dhcp-server & udhcpd" and it's been solved: 

I've found this, although it's for ubuntu, debian and derivates... but might work. Try configure X for every one: 

Does the driver need to have a network to install? if not, you can place it under the boot partition and install it. Also, you can convert your pi zero into a usb dongle and connect it using this tutorial by adafruit. From that link: