These are very different situations. As you observe, the use of in C# is controversial, but using as the type of all variables (and then needing to cast any time you want to actually use the variable) is not controversial: it's just wrong. The first page of answers on the linked SO question about in C# is incomplete. It doesn't mention that using can avoid bugs due to typing in one edge case: vs . For legacy reasons, if is a but not a the latter is equivalent to , which is not especially obvious. (In fact I misremembered and was corrected in comments, which reinforces the advantage of using here). TL;DR: blanket prohibitions on are almost certainly going too far. 

Most of the maths in undergraduate CS is proof by structural induction (and we do at least in part deserve the reputation we have among mathematicians of not knowing that there are other proof techniques). That technique apart, the "non-CS" maths can be more than covered by chapters 2 and 4 of Concrete Mathematics, Graham, Knuth, and Patashnik, ISBN: 0-201-55802-5. This book contains many exercises and solutions thereof, or hints in the case of unsolved problems. There are PDFs available online, but I'm not sure whether they're authorised so I won't link to any. 

There's no "may" about it. With brief training they will be able to offer positive comments as well as negative ones, but to give constructive advice they need to know what they're talking about. For example, anyone can tell you "I couldn't follow the thread", but to suggest specific structural changes you need to know the broad types of structure which could have been used. There are various organisations which are dedicated to training in public speaking: Dale Carnegie and Toastmasters being perhaps the best known. (Disclaimer: I'm a member of Toastmasters and have previously held various offices in my local club, so I'm not unbiased). You could look at their approaches, and if you have a branch of such an organisation in your city (or even in your school/university) you could see whether they'd be interested in helping out. Speaking from the Toastmasters perspective, there are one or two projects which people on the leadership track can complete by running a training session with a recruitment plug: you may or may not consider that appropriate for your setting. In addition, particularly if there's a club in your school/university, you might be able to get a couple of members to come along to a lesson on the basis that one of them gives a speech for evaluation, your students offer their feedback, and then the other gives an evaluation which confirms or corrects the students' feedback. (If necessary, explain that the rules allow one project in five to be done outside club meetings provided that another member is present and gives a written evaluation. I haven't seen this option used much, so the members of your local club might not be aware of it). The good thing about this is that someone who's done a few projects in Toastmasters will be used to being evaluated by people with differing levels of experience, and being a volunteer will find it less stressful than your students. That way they can learn to give feedback without destroying their peers' confidence. The second visitor will also (I hope!) demonstrate how to give suggestions for improvement sandwiched between affirmation of positive observations in order to (quoting the title of the manual) "evaluate to motivate". Since you probably won't have volunteers to come to every lesson for several weeks in a row, this might be best saved as a final practice before getting into real peer evaluation. You could build up to it with a series of lessons in which you teach a specific skill (speech structure, body language, word choice and sentence structure, visual aids, ...), watch a video (maybe a talk from TED, Ignite, or something similar), and then ask the class to give feedback. 

Tell them they need to prove the correctness of the programs they submit, for it would be irresponsible for you or for their clients to execute code that they do not know for sure that it will not go havoc (a demo might come handy to demonstrate this). These students probably think it is boring to prove the correctness, or even the termination, of their programs, too. So, since they are good coders, ask them to code a function that given the source of a program, computes whether this program halts for all relevant inputs. And to prove that this function itself is correct, of course. 

When introducing and in python, I refrain from reading them loud with a name that contains "equal" (or rather « égale » in French). Instead, I always read as "x takes the value of y" (« x prend la valeur de y » which happens to be literally what the pseudo-language used in earlier classes mandates) and "x has the same value as y" (« x a même valeur que y »). And this leaves "x equals y" (« x égale y ») for $x=y$ to my math colleagues, which they usually use. 

I am teaching a general introductory CS course to 18-19 year olds, with Python3 as a support language, and I am not satisfied with how some students respond to strings and string literals. That is some of them struggle to understand when you should use quotes and when not. For example, when trying to a file, they will write instead of and fail to correct themselves. This is just an example ; the question is not about file/filename confusion. Conversely, some students, when asked to write a function a parameter of which is a string, will write 

Re too broad: I don't think the question necessarily is, but "Azure" is. I think you could spend an entire 5-hour session just listing Azure services without going into any detail on any of them (and in evidence of that I've been to a two-day MS training course on Azure which only managed to scrape the surface of less than 5% of the available services: it was more a starting point for research back in the office than training. And that was aimed at experienced developers). IMO pricing considerations should be a small subsection of "Why cloud?". People signing up for a workshop, and especially if it's part of a technology club, expect to be doing hands-on practical training, and (excepting the introduction/overview) for the teaching to be geared towards the specific things they will be putting into practice. They can read price lists at home. With regards putting into practice, are they going to be working on a project which you define or bringing their own ideas to the table? If the latter, I'm not seeing where exactly you brief them on the right kind of project for the specific services you're going to cover. Or are you intending to choose the two or three data services which are the best fit for the majority of the projects after talking to the participants about what they're trying to build? But then point 3 looks like PAAS and point 4 like IAAS, so maybe they're going to be working on different projects in the different sections? 

It seems to me that the mistake is using C++ for an introductory course. Complete beginners do not need help shooting themselves in the foot. The curriculum may be out of your control, but if you have the option then teaching the introductory course either in a strongly typed LISP (SML, Haskell, or something similar) or at least in a concise portable language (Python, Ruby, etc.) should make it easier for both the students and the graders. 

As an avid Programmer and Theoretician (both in my spare time), I can clearly state, that, with my Logical Mind, it is very difficult to grasp at new theories without first ripping them apart and reconstructing them myself, figuring out WHY they work, HOW they work, and WHAT is broken that requires the modification of my Mathematical Formula which I've Constructed and Applied to the Simulation. It makes things very difficult to explain to me, because I simply can not for the life of me figure out why it is broken. As far as a way to explain Theoretical Application to Coding, perhaps it might be easiest to go Old School on them using and . If you have 500 Items to Sort through, and pair up, you could do it Logically, writing out a single line of Code for each and every available option, but if I'm not mistaken, that would be 500 to the 500th power number of lines of code. It's not Impossible, by a long shot, but is takes much longer than explicitly stating the 500 items within a few simple Groups, and running a on the Array you have created, which if my estimates aren't too far off, might be around 2,500 lines of code depending upon the Grouping layout. The sheer workload difference might jog them out of their lack of interest, but your real challenge is yet to come, You will also want to provide some type of applicable example to keep their attention. If they are Logical like I am, they will have one major Deal Breaker for whether or not they should actually attempt to learn it, it is simple in practice, very optimal in application, and created for efficiency of Brainpower (as ironic as that might sound to you, I'll get back to that in a sec): 

What are the objects? You've sketched a database table definition and a visualisation, but I don't see a sketch of the application program's structures. As far as I can see, all of the additional information in the visualisation can be made available in a purely relational database view. I've done this kind of hierarchy visualisation with CTEs. 

There's pipelining, parallelisation, maybe even branch prediction (cashier fetches tray before asking whether it's to eat in or take away). * Speakers of en-US: read "fries". 

This is the wrong question, and by trying to answer it you're falling into a trap of accepting and reinforcing the students' misunderstanding of what university is. If I had applied that standard of value to the courses in the bachelor's degree I studied, I think I would only have attended 30 hours of lectures over the three years. You may be right that most of them will not end up earning their living by programming in functional languages, although given current industry trends I wouldn't be entirely surprised if you turn out to be wrong in the long term. But if their goal is merely to gain a superficial knowledge of whatever is currently popular in industry, they're not just in the wrong course: they're in the wrong institution, and should drop out and find a bootcamp. 

I don't quite see the logical connection here. Becoming better speakers won't make them louder speakers, and the louder speakers will continue to be heard more even if they're terrible at actually speaking. 

One which most of your students are likely to have seen, and some of them may have participated in: production of an order in a fast food restaurant. 

There seem to be an underlying poor understanding of what a variable (or identifier) is. However these students are generally coping with programs that do not manipulate strings. A related question (maybe I should post this one separately) is about the pros and cons of introducing strings before arrays/lists or the converse. Some background This takes place in France, in the CPGE (Classes préparatoires aux Grandes Écoles), a two-year curriculum that students may enroll in at the beginning of higher education (post-baccalauréat or post-A level or equivalent) but is physically located in high schools (lycées) and prepare students for national competitive exams (concours). As a result, the global content of the course is mandated nationwide (including the use of Python3 as an example language) ; I can only choose the order and the manner in which I teach things. The course is mandatory for students but is not the main field of the curriculum (I have 1hr/week of blackboard course and 1hr/week lab session, compared to 10 to 12 hr/week of math and 8 to 10 hr/week of physics). Computer science is not taught in France before university/higher education. There is only some algorithmics, taught by math teachers as well as they can, using pseudo-language and calculators languages, and not dealing with any data structure (only numbers) and no functions. So I start from zero. Even in CPGE, the idea of teaching CS as a field in itself is quite new and not universally accepted. As a result, the nationwide CS curriculum for CPGE mandates that problems and examples should be taken from math and physics situations, which leads to string being scarcely used except for file names and data input from files (csv). Yet any concours may ask a problem about strings, since they are mentioned in the nationwide curriculum. 

On the basis of my industry experience, which includes all of the above, I opine that option 3 is the easiest, not the hardest. This comes with the caveat that by "C# with Dot Net" (which I think should really be ".Net with C#") you may actually mean a set of specific APIs which are hard to learn. However, there is another consideration. A little knowledge is a dangerous thing. There are enough subtopics of web security to make an entire course; but if you take the .Net/C# option then there are ways to steer it which will support an accompanying project which isn't a Swiss cheese of security holes. E,g, the accompanying project goal could be a WPF application which consumes a third party public REST service, and the relevant security issues will come up in relation to the (hopefully securely designed and implemented) third party service. 

is far from the only controversial subject in programming praxis. The solution in industry is the style guide: whether as a formal written document or as an informal internalised set of opinions which are imparted to new team members by word of mouth when they submit changes which violate the house style. If you're explicitly preparing your students for industry, it is perfectly reasonable to dedicate a bit of time to explaining the concept of the house style, and then when you introduce new material to explain the house style you will enforce for that feature. The really heavy-duty approach would be to prepare a full industry-style style guide and then to produce a series of increasingly large subsets so that every couple of weeks you can give them a link to an updated style document which specifies how to use the new features you just introduced, or the new features you're about to introduce, and highlights the additions from the previous one. 

Try asking them for an example of what they are working on in their spare time, see if you can get the Class involved in improving their Program, similar to what everyone does here on StackOverflow, or to put it into more familiar terms: Brainstorm and Think Tank their Projects in order to display Practical Application of the Theories, they will absorb it like a Sponge once they find out it is useful to their interests. Back to the Brainpower Optimization comment, I realize you find it odd that their lack of interest in such things would be a Mechanism to actually improve Brain Performance, but if you pay really close attention, you might notice that some of the more optimized students seem to be more forgetful, absentminded, or simply focus on whatever interests them (sound familiar?). There have been a few studies done on this subject already, I forget if the Larger Scale Studies are already ongoing or if they are still gathering Funding, but initial results have shown extremely promising results, along with studies of behaviors of some of the most notable scientific minds in our distant past. Einstein for example was noted as stating that he never Memorized how to get Home from Work, he never saw the need for it as someone would always Drive him Home, so why would he need to learn their Job? The Logic behind why is that he had better things to think about, such as his work, which we've come to reference long after he has died. The Theory behind the Logic is that he had more Brain available to apply to his Active field, because he didn't fill it up with things he never used, such as the path Home, that is what the Study is trying to figure out specifically. If I have anything that needs Editing/Correcting in this Answer, let me know in the Comments and I'll edit accordingly should you not feel up for suggesting the Edit yourself.