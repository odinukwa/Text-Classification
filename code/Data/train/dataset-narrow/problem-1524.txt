Do you really want to use timestamps (via function) to store datetime information in the database? I would suggest using or fields in the database, as you will most likely want to do something querying against these fields in the database for one reason or another (even if just for reporting purposes), and it is much easier to work with these field types in the database rather than UNIX timestamps. 

Why are you, in some cases, passing a fully formed query to this class while at other times building the query within the class? Personally, I would rather see the query strings themselves housed in the logic that "owns" the model representation for your data, not hidden away in some central DB class. Does this mean that you end up potentially writing more SQL in your application code? Yes, it does. Should you consider this a problem? Probably not. This makes it easier for a developer working with a particular object model to see all of the SQL logic associated with that model in one place. 

Should try block only wrap call? You earlier code shows no indication that can throw, so there really is no reason for that to be included in the try block if that is the case. 

You also have a potential edge case you might need to address. What if subject string is all caps? Since you use case-insenstive match you could end up with an all-caps plural word geting lowercase letters replaced into it. Should you really be case-insensitive here? Should your function name indicate that the function is only applicable to Portugeuse? 

I am having significant struggle understanding how a caller is to operate against these two classes. It is just not clear from reading this code. Let's look at two use cases - one where you are creating a new vote and one where you want to read out information on an existing vote (i.e for rendering on page). In the insert use case, it looks to me like you would need to so something like this to work with answer class: 

For better depth of knowledge around securely handling sessions, I would recommend you read and understand the PHP sessions "basics" documentation at $URL$ In particular, I would point you to this section: 

In this case, perhaps the response object need to implement interface to provide instructions on how to serialize data to JSON. By thew way, the more of your framework object you make into classes, the less , , etc. type of logic you need in your code if you use a proper autoloader. 

I don't understand the need for two queries. They seem to be retrieving the same exact result set, so why query twice? 

Again you start working with and parameters before doing any validation against it. I am guessing this controller would benefit greatly from some upfront validation. You go so far as to prepare a query against the database before performing any validation when you should bail with 4XX response before getting to this point. 

So what does this mean? It means you probably want to consider having a base class (typically abstract ) that is usually what is called a "model" (the "M" part of "ORM" as mentioned in the comments to the question above). A typical model class might present some skeleton functionality like: 

I worry about writing to as you could clobber any other classes that had been applied to a slide element. Since it seems like your code is really only worried about adding/removing , consider accessing on the element to add/remove this class only. 

Why the conditional here? It doesn't seem necessary. Would you ever expect to be in a condition when would NOT be set anyway? (Again I question use of at all based on earlier comment) 

So it is really easy for someone writing the front end to simply specify a given validation rule and have the code automatically add this field to the set of fields being validated. Note that this doesn't show how to change the display around the element, but that wasn't part of you original code, so I didn't expound on that area. Added 

I don't understand why you would ever need a concrete instance of this class, as I would guess usage would be something like: 

You enforce the dependency through type-hinting, allowing you to not have to write validation code in your class. Your class gets it's dependency in a proper state. VS. your current approach which might require validation such as: 

If you have any desire to leverage , feel free to use this simple REST client I have written (either as is, or as inspiration for your own code) - $URL$ 

Should be considered as potentially harmful user input to be validated accordingly before doing ANYTHING with it in your application. These sorts of validations are simply missing from your code altogether, making your could extremely vulnerable to a number of attack vectors, the most glaring of which is 

How is that handled with your routing mechanism? Oftentimes you may need to look at a combination of request method and URI (not just request method) to determine an appropriate controller and/or action on controller to call. This ties back to my suggestion on having a request object (which would store request method) that can be passed to a dedicated router class. That router should be able to inspect the combination of URI and request method to determine what controller should be invoked. Some routing strategies may have you just looking at first URI segment to route to a primary controller, which may then invoke subcontrollers to handle more complex routing/method requests, where some routing strategies may have router actually hold all controller/subcontroller mapping logic. Which approach to take may depend on how you want to use the framework and your personal preferences, but just keep in mind that you will inevitably encounter this kind of use case and likely need to build out more robust routing logic. 

There is no reason whatsoever for you to be using in these queries, since you are doing exact matches. 

This rids you of all those if-else conditionals. And also gives you the ability to lookup a provided background/text color string to determine if it exists in configuration. This could be useful in setting defaults. For example: 

I question the method name and return signature here. You are only ever returning a single (though wrapped in array). Why not drop from end of method name and remove the array wrapper on return to be less obscure about what is really happening here? This would also mean related change in method where you would replace with more straightforward array push operation. 

This allows you to only have to specify the footer include once vs. having multiple exit paths from this script. 

Is there any reason you are using loose comparison operators (, ) instead exact comparisons here? I would recommend getting in the habit if using exact comparisons by default and only using loose comparisons when there is a true use case for doing so. this will make your could less fragile to unexpected truthy/falsey condition evaluations.