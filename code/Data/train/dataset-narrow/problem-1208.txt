Question 2. Modify the contents of 'app/test2.js' and implement the functions: capitalise, extractValue, extractCompountValue capitalise - should take an array of strings It should return a new array with the strings capitalised extractValue - should take an array of objects and a key It should return an array of values for the key extractCompountValue - should take an array of objects, a string with multiple keys seperated by "."s It shold return an array of values for the compound key 

Question 4. Modify the contents of 'app/test4.js' and implement a function that will return an array of prime numbers. The function must take an number argument and generate all the prime numbers that appear BEFORE the argument. Answer 4. 

That seems like a really terrible hashing algorithm. 1001 and 10001 will have the same value. The more traditional hashing function to use is a simple modulus, although depending on your data domain that might not necessarily be the case (but it's very unlikely that your provided algorithm will be even remotely useful except in the most contrived scenarios). As others have said, you should format your doxygen comments completely differently; I'd go with a style like this: (I am making a lot of assumptions regarding your parameters, incidentally, the avoidance of which being the entire point to using Doxygen in the first place...) 

to allocate the arrays. You could also consider providing the hashing function as a template or constructor argument and have it just default to simple modulus (for example). There is no reason to do recursively, or even as a separate function from ; it is just a simple iterative loop. Consider doing this in your insert function: 

You store your palindrome substrings in a , and avoid duplicates by testing whether that already each candidate you discover. This part is O(n2) in the number of palindromic substrings. You could instead do it in O(n) and without requiring an explicit check if you used a for palindrome storage, or in O(n log n) and without the explicit check if you used a . Between and , the latter also allows you to skip the subsequent sorting, but for large numbers of elements it may be cheaper to collect elements in a and afterward dump them to a and sort. 

Your inconsistent and unconventional indentation makes your code harder to read than it should be. Although Java accepts multiple top-level classes in the same file as long as no more than one is public, it is poor form. Every top-level class, interface, and enum should have its own file, whether public or not. Among other things, this makes it much easier to find all the classes, both for you and for the compiler. It is a bit questionable that you're willing to destroy the list in order to test whether it's palindromic, but inasmuch as you are willing to do so, you could perform your palindrome test more efficiently. You would use two primary Node references, one that advances one position for every two that the other advances. Using the trailing reference, you would reverse the front portion of the list as you go, so that when the lead reference finds the end of the list, the trailing reference is at the midpoint, with a reference to the reversed first half already in hand. I'm sure you see how to proceed from there. You could also consider using an auxiliary data structure to build the reverse half-list or an equivalent; in particular, pushing the nodes one by one onto a stack would have a comparable effect. This could be done in a way that does not destroy the original list. Or on the third hand, if you were willing to change to a doubly-linked list, and especially if you were willing to represent the list itself with a separate data structure that contained a reference to the tail in addition to the reference to the head, then the palindrome test could be performed much more simply. You would just start at both ends and work towards the middle. That doesn't modify the list, either. 

Instead of using a boolean to flag if something is something (and thus implying that it isn't the other thing), consider an ; in this case that doesn't buy you anything in terms of flexibility (since it's not as if there will ever be, say, red or purple or whatnot) but it will make your code much more clear. On the game, instead of setting black and white separately, you should have a single , or better yet, have the board be a factory that provides the black and white s itself - if there's even a reason to have a Player object in the first place. 

Obviously this is not the overall program structure, but an example of how to make a closer coupling between the choices and responses. 

You can quickly compute the exact total number of grains that could be eaten over a given time span by multiplying the time separately by each consumption rate (== truncating division by seconds per grain) and adding up the results. Having such a function in hand, you can avoid simulating the entire course of the process by instead searching the space of possible times. For example: 

General comments Your code is pretty clean, but it's unclear what you imagine it being used for, except possibly just to illustrate adjacency lists. If you're looking to build something actually useful, then I suggest coming up with a few model applications, and thinking about what you need to provide to serve those applications efficiently and easily. For example, how would you model a shortest-path problem with your graph, and how would you implement Dijkstra's algorithm to solve that problem? Or how would you compute (and represent) a minimal spanning tree? graph.h As to specifics, I'll start with your API definition, as presented in the header file: 

Question 7. Modify the contents of 'app/test7.js' and write a function that will extend String so you can call "String".reverse() The extension must return the string passed in, but in reverse order. Answer 7. 

I recently applied for a job as a node/react developer. I'm attempting to cross over from a research position to web development. I didn't get the job but all the feedback I got was that my code was too academic and that it would take me too long to get up to their requirements. I'm not really sure what this means so any insight in to the code much appreciated. Obviously I'd like to improve. Also, general tips on how to improve code in all aspects (blogs, books etc) very welcome. Here are the two challenges on my git hub: $URL$ This one was posed as a front end challenge and the idea is to make all 9 of the tests pass. Question 1 Modify the contents of 'app/test1.js' and implement the functions: filterNames, objectFilter, compoundObjectFilter filterNames - should take an array of strings and a search string. It should return an array of names that startwith the search string objectFilter - should take an array of objects, a key, and a search string It should return an array of objects that have a key that is equal to the search string compoundObjectFilter - should take an array of objects, a string with multiple keys seperated by "."s and a search string. It shold return an array of objects that have a key that equals the search string. Answer 1. 

Remember that in C, a character literal is an . No need to look up the actual integer value in an ASCII table when you already have it right there! 

Instead of using separate arrays that you pass into things on each call, this is a perfect opportunity to use objects to encapsulate things. For a partial example: 

I would build a closely-coupled mapping between the item and the message, which makes it easier to add, remove, and reorder items without things going screwy. For a really simple example: 

Instead of using , consider using . Also, consider using some sort of higher-level lookup table to do your mappings, where appropriate; there's only so much you can do with pure C but you could still build, for example, an array of lambdas or function pointers that map characters to handler functions. Many of your complex comparisons could be made a bit more concise and possibly more readable using . In , it's much better to just write it as: