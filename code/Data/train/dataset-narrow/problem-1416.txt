The init method makes a copy of all groups, so that the algorithm can freely remove participants without modifying the original groups. Your 

You already figured out that the last digit of \$ a^b \$ is equal to the last digit of \$ a^c \$ where \$ c \$ is a "reduced exponent" in the range \$ 0, \ldots, 4 \$. Except for the special case \$ b = 0 \$, this reduction can be computed as \$ c = (b - 1) \bmod 4 + 1 \$. Btw, this is an immediate consequence of Fermat's little theorem. If you reduce the exponent first, then you don't have to pre-compute the array, instead you compute \$ a^c \$ with a repeated multiplication (as in your previous question). From the given bounds \$0 \le a \le 20\$ and \$0 \le b \le 2,147,483,000\$, and assuming that is a 32-bit integer (which is the case on all modern platforms), it follows that all intermediate values and results fit into an and is not needed. This gives the following implementation, where the actual computation is moved to a separate function for better readability: 

Before trying to improve the performance let's do a general review of your code and clean it up a little. Spacing The code is not indented correctly. The use of (horizontal) whitespace is inconsistent. I would suggest to leave at least spaces around operators, keywords, and blocks. Variable names Many variables names could be chosen better. For example: 

I think it is acceptable, because it is documented that the value of the is a . If you want to be on the safe side, verify the identity of the object by checking the Core Foundation "type id": 

The first thing that I noticed is that you have three view controller classes (, , ) with identical code. You can reduce that to a single view controller class (perhaps ?) which is the custom class for all three view controllers. The method in then simplifies as well: 

Starting with iOS 9, objects can be deleted directly in the store without loading them into memory. This would look like this: 

You get the same result with less code by using the bridging cast from to , which works for (nested) arrays as well: 

but that is perhaps a matter of taste. The problem with the other two init methods is that they don't check for duplicate keys, e.g. if you call 

to make it public read-only, but internally read-write. That makes the additional accessor obsolete. If the property is only assigned in the init method and never changed later, you can simply make it constant: 

First let's simplify your existing code. You already use to add the elements of , the same can be done to replace 

A more universal approach would be to define a type which can be initialized from both ISBN-10 and ISBN-13 strings (with or without checksums). Just to give you an idea: 

a operation where is the number of characters in the string. It is much more efficient to iterate over the characters with 

The separation into a non-failable and a failable init method is fine. The forced casts with are safe in your code, because it is verified before that the three variables , , have the respective types , and . However: 

Then note that not all people use the 12hour AM/PM system. You might consider to display the hours according to the locale/region that a user has configured on his computer. That is achieved simply by using the date format 

(Everything apart from the function itself seems to be prescribed by the given homework skeleton, so I am not going to comment on that.) 

for the first test case, and then traverse the list from both ends to find pairs. The time complexity is \$ O(n \log n) \$ for the sorting, and \$ O(n) \$ for the traversal, so this would be faster for large input. Another option is to sort the number in increasing absolute value, e.g. 

Your original algorithm corresponds to . Using instead reduced the computation time for a=9, b=4000 from 0.095 seconds to 0.014 seconds on my computer. If that is not sufficient, you can use for the array and work with an even larger BASE. 

Update: The Swift language changes constantly. For the convenience of future readers, here is an update to Swift 4 of the above code: 

Then you use an auxiliary function for computing the second sum, but not for the first (and the name of that function is not very descriptive). In my opinion it is easier to understand if the shorthand notation is used for both summations: 

the type annotation and the first are not needed, and the generic type can be inferred from the compiler in the second instance: 

(I also planned to tell that using instead of makes the program more efficient, but it turned out that the difference in running time is not significant.) 

But actually I would go the other way around and replace the initial values by an method. The reason is that – since you defined your own init method – there is no default memberwise initializer anymore. Therefore I would start with 

The iterator expects that no elements are added or removed to the circular buffer during the iteration. A possible solution to detect such a programming error would be to add a generation number to which is incremented with every modification. Then copy that generation number to in and verify it to be unchanged in . I would add such a check at least if the program is compiled in mode. 

which is not necessary. The if-part works for the case as well. Exceptional key values: The special handling of the case causes unexpected results: 

You could also implement the Eratosthenes sieve as an iterator, which makes it non-eager and removes the array: 

More sophisticated bit counting methods can be found at $URL$ they can be more effective for large numbers. In , the check for is not necessary, because is the empty range in that case: 

The forced casts in the method might seem safe at first sight, since you do some type-checking before. But they are not: If a default value for some key exists, but is of the wrong type then your program can crash. This can for example happen if you change the type of some default value between program releases. You can easily reproduce the problem by setting the default value to an incompatible type before retrieving it with your class: 

Similarly, the static property is used to assign consecutive names to the each created group. This is acceptable, but why not create each group with an explicit name (as you already do for the participants)? 

I'll start with a review of your existing code, and then make a suggestion for a better algorithm. The first thing to notice is that there are many conversions from arrays to lists and back to arrays: 

But the method requires that the given predicate is a "strict weak ordering over the elements", in particular that 

which returns the number of terms in the given expression. This is a property of that expression, and therefore better modelled as a computed property: 

is bad because it wastes CPU cycles. In my test it caused almost 100% usage for one CPU core while a network request is active. Network requests are asynchronous in nature, and there are better (and less resource intensive) ways to handle that. First change the function to take a callback instead of returning the result. It is also sufficient to create the once: 

does not assign the number to but the closest number which is representable in the IEEE 754 format for double precision floating point numbers, which happens to be 

if you make the initializer public. means , i.e. it is a property of the type (and not an instance) and cannot be overridden in subclasses. The two statements can be combined into one. The class then looks like this: 

I would move the computation part for a single string to a separate function. That makes it easier to add test cases and makes the main function shorter and more clear. Putting it all together: 

But why create an instance of the object in each recursion step? The GCD is a property of two (or possibly more) numbers, and you might want to compute it in other places as well. So make it a static function of the (or some other) class, taking two integers as parameters: 

is an array of dates, each date representing the start of one month, this can be used to compute the number of sections and the section titles. For each month, 

But the more modern interface is (which works for both IPv4 and IPv6 addresses). Written as a separate utility function: 

Your view has three characteristic properties: the outer and inner gradient color, and the width of the border. The values of those properties are spread in the code: width and outer gradient color are arguments in 

The return expression maps each phone number to a (number, sortOrder) pair, sorts the pairs according to the sort order, and finally extracts the phone number again. This guarantees that the function is called only once for each phone number. 

You should do the computation of the "nth rare number" in a function, so that it is separated from the rest of the program, and can be tested easily: 

is not needed, the remaining code already handles the case of an empty string. Determining the unique characters from can simpler be done with a filter operation instead of a for-loop: 

Note that the size of the array is limited by the tree height. In my test with a tree of 1,000,000 nodes, the traversal is done in about 0.2 seconds, compared to 3.5 seconds with your original method (test done in Release mode on a MacBook). 

You use the 's property to identify from which button the action method is called. This is OK, but note that (zero) is the default tag for all views. It is therefore better to tag the buttons with instead of , and adjust that in 

A faster algorithm In order to determine if \$ n \$ is a practical number, you test all numbers \$ 1 \le i \le n \$ if they are a sum of distinct divisors of \$ n \$, and for each \$ i \$ that is done by building all possible sums of divisors, until \$ i \$ is found. It is more efficient to work the other way around. From the list of divisors of \$ n \$, build a list of all sums of distinct divisors. This can be done iteratively: Starting with \$ 0 \$, the first, second, ... divisor is added to the numbers obtained previously. Then check if all numbers from \$ 1 ... n-1 \$ are in that list. The following implementation uses a boolean array to mark all numbers which are confirmed as sums of divisors. In addition, it uses that powers of two are always practical numbers (using the method from Determining if an integer is a power of 2). 

On many (and on all POSIX compliant) platforms, is a 8-bit integer which may be unsigned or signed, so the maximal return value would be or . Another problem is that you count the number of occurrences in an , which means that – for example – a count of would be returned as if the character type is (8 bit) signed. A better choice would be (which is guaranteed to have at least 16 bits) or (at least 32 bits). To be completely on the safe side, use , which is a type than can hold the size of any object. Const parameters Since your function does not modify the passed strings, it is a good habit to declare them as constant: 

ChainDrive.swift - The type describing the complete chain drive system. Also contains the code to compute rotation directions, tangent angles/points, and the length of the various segments of the chain. 

Swift errors are not exceptions. The Error Handling chapter in "The Swift Programming Language" explains that 

This reduces the time to 4.6 seconds. But any “real” Eratosthenes sieve is much faster. As an example, with this one from Rosetta code 

is a keyword, therefore it must be quoted in the enum definition (but only there). Alternatively choose a different name, e.g. . IMO describes the first case better than , and , (or ) is a better than and . I also would omit the labels ("n:", "x:", "f:", "g:"). They are somewhat arbitrary and the code is better readable without, e.g. in your function: 

Since creating a number formatter is "expensive" (compare NSFormatter - NSHipster), you can improve that further by creating the formatter only once – for example as a static property. 

The first problem can be solved by computing the new string after the replacement first, and then check if that is valid (only digits and at most one decimal separator). The second problem can be solved by using a to check if the text is a valid decimal number. That would lead to the following implementation (which is essentially a translation of the code in Big Nerd Ranch Bronze Challenge: Disallow Alphabetic Characters to the current Swift 4): 

But actually you don't have to create an array with all characters at all: You can pass the string itself to the function, and enumerate its characters: 

would be easier to understand and also makes the variable obsolete. The iteration over all possible start/end positions is better done with a for loop. Avoid unnecessary conversions In your code, the big number is converted to a string repeatedly, it would be sufficient to convert it only once. You could even provide the given number as a string directly. The substring is also not needed because we can access a character from the original string directly. Putting it together Summarizing the suggested changes so far, the generator-based version could look like this: 

and the multiplication of the digits to a number can be done with . Then your function would look like this: 

If you don't pass the type in the unpack function then the compiler has to infer it from the context and either of these would work: 

Your code looks correct (apart from the typo in case #4). Note that the final is not necessary. If none of the first 4 tests passes then you necessarily have a tie, so a simple is sufficient here. The variable is named badly, as it contains the maximal score and not the winning player. But you are using far too many comparisons, and the code does not scale well for a larger number of players. What you need to know is 

to create an array with the first 1000 happy numbers. Also it is a good habit to put add a "main guard" so that the source file can be imported as a module: 

Finally: You can replace the loop by recursion, using the method of and the nil-coalescing operator : 

vs You declared properties a constants where possible, which is good. The property of is also never modified after initialization, so let's make this 

(Remark: Usually, forced unwrapping with should be avoided, but here we have a programming challenge with well-defined input data.) To increase the legibility of the code, I would assign the three parameters of a query to variables , , . The code then becomes almost self-explaining. The entire code then looks like this: 

Again, this gives better error descriptions for free. So the complete method would now look like this (no optionals anymore, no forced unwrapping with ): 

Your function is slow for large values of because the intermediate values of and quickly grow to huge integers, making the multiplication slow. You can improve that by reducing each intermediate result "modulo m", so that all numbers will always be in the range . The final division must then be computed as a "modular division": 

Your approach is indeed not optimal, after determining a unique set of property values, the original array must be searched for each value separately. This lookup can be improved slightly by using 

which becomes apparent only with large input: A negative sum must also be reduced modulo \$ 10^9+7\$, before adding the modulus to make it non-negative. Putting it together, your code would look like this: 

If you have to toggle the case of arbitrary letters (from any language) then the string methods must be used, as there is no simple "arithmetic operation" which does this transformation. 

conversions. You can do a pattern matching on and instead, this avoids all unnecessary type conversions and does not require at all. The statement checks if and are both (two integers), both (two strings), or if the values are of "mixed type": 

It would suffice to check only the rows which are changed by the last move. On the other hand, with 8 winning combinations, that does not make a big performance difference.