Represent a simulation You should mention "What happens if" in your code explicitly as a simulation. 

In any of these situations all other code is not touched. That is because this sequence only defines the process. If you do this with your code some changes may be easier than others but all of them will have effects on either compilation units that also have other responsibilities and/or your changes will affect multiple compilation units to make it work again even if you want to change only one aspect. Another indicator that you have high coupling is that you chose an integration test to test your Calculator. I do not say "do not make integration tests". I only wanted to mention that decisions made have reasons. These reasons may be valid or not. But for me integration tests are an indicator for less useful code separation. AskFor... These classes are wrappers for the Scanner. But they also assume that the console output is available. Introducing the console output will produce a second ouput beside the validated return value got from the console input. Removing the console output will make these classes well-defined and reusable even if no console ouput is available. That doesn't affect providing a context message: 

You are asking the UI component for a state. This state should be encoded in a model. As the code provided seems to be incomplete in the context of all requirements of your customer it is hard to argue for a model because currently you will not see the big advantage for this procedure. That why I provide an example where the model drives the UI in a little more complex way. Main.java 

Beside the things already mentioned I recommmend to omit the Iterable interface. It distorts the semantic of a Stack and inflates the responsibilities. You also can already build an iterator-like construct with the methods exposed by the stack. This should not hinder you to introduce a StackIterator passing the Stack to the constructor to provide an element that is usable in for-while-loops. The difference is really small but you clearly separate responsibilites. Without Iterable interface: 

Any number that remains unnamed remains a magic number. It's not related common usage as common usage is relative. The problem with it is "when" or "where" to draw a line... when does a number changes its state to non-magic... 2,71828... may not be magic for mathematicians (Euler) 1760 may not be a magic number for anglo saxons (Yards per mile) 10000000 may not be magic for south inhabitant of south asia (crore) 1 may not be magic in the context of multiplication (neutral element) The relative approach will lead to a discussion that will evolve a local aggreement. And the result to consider a number to be non-magic, will depend on when and where you start the discussion. Unfortunally this discussion has to be lead for each number separately. The absolute approach is simple an clear: Every number that is not named is a magic number. Discussion over... for all numbers... Of course this is only a (one) definition. But this definition has inherent properties that will make it possible to evaluate it exactly. So if you want to discuss, go for the relative approach. You will find the discussions never ending. And if you think it is over another number comes along. Or you go and find a definition that can be used in boolean expressions that will evaluate to true or false. I go the second way with following definition: Every unnamed number is magic. Even if you practically ignore it the statement stays the same. 

Changing the key stream to a parallel stream will cause concurrency. Noticed the synchronized method in the KeyGenerator to work properly in parallel? 

Your solution looks good. It's a really challenging task. This is because you have to "flatten" an algorithm with recursive nature. Furthermore you have to break it apart into single steps and to be able to resume at the last step made. So there are little things that I would change: 

Introduce strategy pattern Associate a WordSearch-Object within "Searcher" and delegate to it. This is called Strategy pattern. 

As some other stated I am also convinced that there is less or no beneficial usage for enriching a simple associative map to throw an exception if an element is not found. I suggest to go with a use case specific exception handling as the context is important where a not available value is an exceptional case. 

Controller Now following this structure your Main-class (I named it ThreadController) looks like this: 

Some information with that you may or may not be able to construct a right triangle An algorithm that identifies if a construction with the given information is possible A strategy to calculates missing elements A representation of a valid right triangle 

Where is the synchronizsation??? The work of synchronisation is done by the "LinkedBlockingDeque". As we only delegate to ONE synchronized method of the "LinkedBlockingDeque" in "getElement" and "registerElement" we do not need our own synchronisation. 

You will have a hard day to "combat" this design. My view on this subject: People either want to get around semantics, do not care about it or even don't know that such thing exists. As the "Anemic Domain Model" does not care about encapsulation it is easy to get around semantics. You do not need to think about where attributes and algorithms are located "best". You can easily pass the structures around that you need at a certain location to do whatever you want with it. I have to explain "best" because this is the main point I always struggling with other developers. I suggest to read the next paragraph too if you get a bad impression on my view here. First of all I want to mention that for me there is for one special requirement only ONE (the "best") solution. The point is: If you talk about code quality and what kind of code is better everybody implicitly say "There is one best solution". If you do not do this: ANY sugestions about "improving" code would be totally subjective. On the other side WE ALL have cognitive trouble at some point of complexity and/or the programming languge hinders us to express the semantic properly. That is why I am convinced that we nearly NEVER reach the point of the "best" implementation. BUT I am also convinced that we can evaluate the path through trial and error and falsification. Nothing else is done in in science. They try to produce good models of reality. And they want to be as close as possible because they want to make forecasts with these models that will be beneficial for the society. But to do that they have to be clear in semantics. One thing a want to mention on which assumption my statements are made if I talk about "reality": 

The OverloadedException may not be signature relevant (RuntimeException) but it expresses the intention of the method. Beside that I would split responsibilities and introduce a method: 

We developers try to produce models od reality as well. But there are developers that do not care about reality as there are people who do not care about the reality that science try to evaluate and describe. The point is: We as developers can make up fiction in the programm in our programming languages as long as the interfaces produce beneficial results to those who hired us. We can unneccessarily iterate over a collection twice but returning the correct result. We can build up huge structure and destroy them instantly. I have to admit that my models are bad in contrast to the models that science produce. Doens't matter if it the fault of the programming language or my cognitive troubles. So we as developers build models... May goal is it to have the model matching best with reality AND the code we produce matching best the model. Currently object-orientated paradigm is seen as the best paradigm to model real world elements. You have a car in reality, you create a model of a car, finally you get an object of class "Car" in your object-oriented language. A car in reality can be started, so you may have a model of starting engine of your car that may result in a method "startEngine()". And here comes the problem: The more specific AND the more abstract the things are we have to model: I think we get cognitive troubles. This unfortunately also correlates with the persons perceptions on reality. We have one great advantage over the management: We can only be tracked by other developers that are familar with the our code. This has been discovered at a point of time when software came up that could not be developed by one developer alone. Collaboration was neccessary. The problem: The different perceptions of reality of the different developers (persons). Todays approaches to solve this problem are to have experience, IT expertise AND high social competence. I personally do not care about social competence when I answer questions here. So I put out the sharpest sword have to argue with to pass it to you: The SOLID-principles together with the Law of Demeter. I am convinced under the assumption I made (reality, semantics etc.) these principles will improve code quality on the semantic level and reveal things that compromise reality so you are able to adjust your model to fit reality better. The SOLID-principles will lead to a domain model that clearly is NOT an "Anemic Domain Model". 

The listener pattern adresses the dependency inversion principle as the Calculator can communicate with subclasses of the Listener-contract "CalculatorListener" without knowing the concrete implementation. Also we adress the single responsibility principle when we unburden the UI class "Display" of "writing" something. 

All Threads that should run must be known by the Monitor (before any Thread was started) because The Monitor should decide when all Threads are alive to give the signal to all threads to continue. Threads notify the Monitor if they are running ("notifyIAmRunning"), so the Monitor can remove the Thread from the list of not running threads. The notifying thread pu itself to "waitUntilAllOtherThreadsRunning". if the last Thread is removed the Monitor gives the signal "continue" to all Threads. 

Passing the parent id to the constructor of the Child object and resolving the parent through the DAO: 

Counting while iterating over the interesting elements until there are no left Decide how to find the next interesting element and provide the information if there is no element left Provide an efficient search for the case of mass data 

There is a symmetry you can make use of for this special right triangle case. I suggest to first remember the given names and then "normalize" the given information. After that you are able to reduce the possible cases to 4: 

I am not a mathematician. Maybe there is a more efficient way (a shortcut) to calculate it. But I won't cover that. So here is a refactored version. It's more verbose but it has less accuracy problems and shows the responsibilites of the two algorithms. They communicate through a result object that contains the calculated base value so far and the information if the method was satisfied by the factor given so the base value is a valid result. 

There is only one concern for me: you should not allow to instantiate the object with max elements below 0 (IllegalArgumentException ). Therefore a proper handling for this situation in your methods has to be made to avoid a neverending blocking. I suggest to return null. Expecting a timout for your poll-method may be beneficial in several situations. Concurrent implementations of the Java API do define both: a non-argument poll-method and one with a timeout. But I do not see this as mandatory. Some developers will suggest to make synchronization intransparent to the user of your class introducing an internal lock object and mention thread-safety in JavaDoc. They argue with "defensive programming" to prevent deadlocks. My personal opinion to that: You send the wrong message to the using developer. Don't get me wrong: Preventing deadlocks is important. But it is more important to know what to do when. That is known as competence. Preventing others to make mistakes is ok. That can be done in several ways. But others to allow a lack of competence is exactly the message you would send. You would try to solve a potential future errors that are not your business. On the other side you allow misusage of objects without habing the other force to correct thhis. My way is: If someone is doing strange things with objects he doesn't own he either should know exactly what he is doing or handle occuring errors and deadlocks. You should know that this is how the majority of developers will NOT argue. 

Currently you are copying Bank objects several times at different places for your simulation and to avoid side effects (e.g. State, solve()-method). Instantiate Bank-objects once and never copy them. Use Sets to represent state instead. Always make defensive copies of the Sets. Omit Element.FARMER You also see that I omitted Element.FARMER in FINAL_STATE as this element is not an element like the others. You see the special nature from the Element.FARMER in the take()-method and the drop()-method which is leading to special cases. Introduce a boat A good way modelling the problem is to represent real involved objects. In this case you are at least missing a boat. 

StateRunning As the state pattern has a context object (here LogService) this context object will be used as the monitor (synchronized(LogService.this)). Calling start() will lead to a NOOP. Here you have the choice to throw an exception as well. Calling log() will accept new log messages but as the service knows that a thread is available (StateRunning) that may wait for new messages it is notified. Calling stop() will safely shutdown the thread by communicating a stop request. We will change the internal state of the LogService within the monitor and waiting until the thread terminates outside the monitor. 

This is the typical problem the relational community (relational databases) answers with OR-Mappings. As we do not have a relational datastructure more an object structure the mapping impedance is less but it remains. But as we have to do a mapping it is not the question IF but the question WHERE the mapping is neccessary. Finally you have ALWAYS a big switch-case-statement. It may not be obvious and maybe it is not done all by yourself but there is no way around. You cannot escape the mapping but you can get help with it. A pragmatic way would be to use the "org.json" API, Here is the Maven dependency: 

Check only odd numbers Check only numbers to the square root of the number under test You maybe want to count down instead of count up 

continue, break Avoid using these control flow breaking statements. They hinder you to make refactorings like "extract method". Also code extensions are more difficult. If you use loops (while, for) quit the loop through a condition in the loop header. System.exit(0); Do not use this. It's better to quit the application through the normal control flow. System.exit(x) does only make sense if you want to communicate a serious error to the calling environment (x > 0). I omitted it in the whole and let the control flow do its job. Object scope I prefer object scope rather than class scope. So in my example I only declared the constants as static elements. Naming I did some renaming to make the intention of each variable clear. Decomposition If you are using an OO language you should decompose long method into smaller units. That can be other methods or new classes. If you are using design patterns you always will do this. The small units can own scopes and names and my be reusable in different situations. You gain more flexibility if you keep single code fragments small although it may be verbose through all the structural code of the language. Design patterns Make use of design patterns. Of course for this game it looks too much. But to get an understanding about design patterns you should exersise them at an easy level like this. The question here is, will you use design patterns in complex situations correctly if you do not exercise them in easy situations. In this approach I am using following design patterns: 

Do I violate the law of demeter with "price.getPreviousPrice().getRegion().getValue()"? Why should a previous price have no region where it is valid? 

A http request, returning a set of elements that are provvided asynchronously to the stream from multiple threads that provide message elements 

Standard Stack Try to use the standard implementation of a stack like java.util.ArrayDeque. You have reinvented the wheel here. State Pattern Introduce the state pattern. I here provide you an example. 

The problems we had when writing a parser were solved by breaking down the parsing to a state machine. We parsed every single character and tried to represent every state as a separate class. We got rid of deep nested if-statements and got expressive little classes that either remain the state machine in the current state or go to the next state. We remember once read characters in a buffer and put them on a stack to support recursive structures. Finally we called our expression parser recursively when we determined a separate expression. It's a lot of additional structure code (classes) to introduce. But the effort will be benifical to future requirements. I really suggest to have a look at following resources: