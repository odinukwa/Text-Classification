Profile the code, and with each change test it again, the only way to really improve performance is to know where the bottleneck is. Sometimes it is in the last place you expect. 

It is up to you, but if I was designing the social media footer, I would use one nav tag, and just include all the link and image tags inside an unordered list, like the nav-bar. It means you can style all the buttons the same, without changing multiple lines of code in your CSS file. 

The padding works well up until 45 rows are entered, after that, it was too wide for my screen to properly read. 

Each call to this is an O(n) operation on the list, m times where m is the number of times the element occurs, x times where x is the number of keywords. So in big O (and worst case) we have O(nmx). We can be smarter about this, and do it in O(n) and in one iteration. We will use extra memory to store the keywords in a dict So replacing this: 

This function is weird. It highlights that the game board is strongly coupled with the players. The reason I say this is because this function assigns the names and characters each player uses at the same time for both players. What makes player1 and player2 special and need to be handled all at once? The code in this function could be halved and called twice, once for each player (or for an arbitrary amount of players if the game was a team game with a much larger board for example) 

What happens if on player1's go, they win? The game should be over, but player2 still gets to try and make a futile move. 

Now the first line says this: is of type , as long as the constraints in what we call the context are met. Here the context is what comes before the , and what it says is that , the type, is a member of the typeclass. This means that we're saying that any type which maps a to any type of is itself an instance of . Why are we doing this? Well, let's start with the simplest case. is an instance of typeclass , because we defined this 'base case' explicitly. Okay, so then is also of typeclass prop, because we said that any type is in class . This gives us the functions which take in one boolean argument and return a boolean. Examples: , , , . (In fact, these are all such functions). How have we defined whether to determine whether one of these functions is ? Our definition says that 

It says that a boolean function of one boolean is valid if and only if and are both valid. Of course, the validity of boolean is just that boolean. So in this case, can be thought of as being a bit simpler: 

What we're doing here is creating a new typeclass called Prop. We need the syntax because we need to define the behaviour of an instance of the class. If we don't introduce a symbol for it, then how will the compiler know what we're talking about the in the typeclass definition? For example, the line says that for every instance of typeclass , there must be a method called which maps to a boolean value. Likewise, there must be a similar method for . Now the line may cause some confusion because appears twice. It's important to understand that , being an instance of a typeclass, is a type. There are no "objects" as in object-oriented languages. Remember: is a type which satisfies the typeclass contract given by . The Java equivalent would be a class implementing an interface . What we're saying here is that for type which implements/is a part of this typeclass , there is a method called of comparing them. And its type is meaning that it takes in two expressions of type and returns a boolean indicating whether or not they're equivalent. 

This is equivalent to a list comprehension (or a filter) that might be easier to read. also reusing peiceSet for both the iterating variable and the list seems weird and possibly buggy 

You have inconsistent spacing, generally if you have 4 spaces for indentation, stick to it for the rest of the code, nothing is saved by not including it, and it makes it easier for other people to read. The same idea for names, shortening them doesn't really give much other than saving a few bytes, and makes it much much harder to understand what goes on in a few months, so descriptive names are better, unless the abbr. is really obvious or defined Below is your code with better spacing, and suggestions for better variable names, although the suggestions are not perfect, try and improve on them 

In addition since self.pieces are never changed from instance to instance, you can move them out of the init 

I will admit the code right now is not the most readable, but I think that is down to variable names now, as opposed what is going on in the code. 

I may have missed some bits and pieces, but the idea here is to give you a starting point so you can look at your own code and decide what is good, and what needs to be changed menu.py 

You could reduce this to a single any with two loops inside it, but it gets a bit long and unwieldy. 

and are used without or , if you are using them for the size of the text, this is easily fixed with CSS. There is also a break-line tag inside the for some reason? Again, style with CSS, not with whitespace. 

I'm late to the party here, but I thought it'd be interesting to consider some more optimisation you could do. First let's consider the number of 'modulo operations' your code does per 15 integers: 

This is the key: asks the question "Is this proposition false for all possible inputs"? To test this, we split into two parts: its first argument and the rest. If the first argument is , then is it possible to satisfy proposition with the remaining arguments? If not, then it's a contradiction. This is the part . is itself a function of 1 Bool argument, so it is in class , and so we're able to apply to it to see if it's a contradiction. We also need to be sure that it's not possible to satisfy if the first argument is either, which is why we this with . I'll leave the function as an exercise, and move on to the next inductive step. Inductive Instance Definition - Inception Since is of class , then so too is . I could be mistake, but I'm fairly sure that is actually just short-hand for this. So this means that a boolean function of two boolean variables is itself a proposition. How do we determine its validity? We check if both and are valid. The former means 'if and both evaluate to True'. Hopefully you can see now the recursion that's going on (I haven't done a great job explaining it; sorry)-- what we're doing is recursively defining the ity of the type so that such a function is valid if and only if it evaluates to for all possible inputs. 

What stands out to me is that you initially perform a check against every grade range and insert into the map in the right one. By that point, you've already found which grade is right. But then you initiate another loop to start searching for the grade corresponding to . I think instead, you ought to alter your method to output a enum, and delegate the string handling to another function. I feel that it's better practice to return a Enum from the first method because of the strong typing-- you may want to use this information for other methods besides finding the grade name. In fact, s are particularly nice because you can use a on them. 

There is a bug here, if you reach the end of the array, and the longest sequence is at the end, what happens? I'll leave it to you to figure out the fix. A hint towards what I would do is try to add an extra check at the end 

If it makes it through the loop, we should just return true The second thing of note is the definition of a palindrome, here are two ways of looking at it 

It has been a while since I did any c++, so I'm going to focus more on the concepts rather than the language features themselves. There probably are more concise ways to implement this in c++ than I can illustrate. Note #1: Typos. You can use a spell checker on code, there is no reason you couldn't. Why I think it would be a good thing to do is because it will highlight 

You call this 3 or 4 times a round, put it in a variable so it is called once and only once a round. I would change the logic a little bit, check if there is no difference between the shot and the enemy 

The fact it calculates the distance is important, that it converts from degrees to radians is not, maybe something like 

I attempted this problem from the ieeextreme, and I got timeout for just over 40% of the cases. Now that the competition is over, I was wondering what could be improved. The problem is as follows: 

This is not really written pythonically. Opening and closing a file (or anything with buildup/teardown) can be done with with. One small point is that loop=0 is essentialy trying to break out of the while loop. There is a nice keyword break that will do that just fine. The code would look more like: 

Alright, so is valid if and only if it evaluates to for both arguments! That's what we want. Now for : 

Now to be fair, I don't know what the bottleneck in this code actually is, and I'm sure your application probably doesn't call for such niggly optimisation, but I still think it's interesting. I'd wager that the third version is the fastest. 

Boolean Instance Definition All we've told the compiler so far are our promises: there will be methods for checking whether an instance of is valid or a contradiction, and a method for comparing two propositions of the same type for equality. To start, we implement these procedures for the most basic type of proposition: one that is just or . 

Here, says that in the expression above, the type whose behaviour/implementation we're defining is the type. How do we check if a is valid? Well, it takes no arguments, so a proposition that is just or is valid if it's true, and otherwise a contradiction. 

says that the function mapping our proposition type of to whether or not it's a valid formula is the function . (This function just returns whatever it's given). says that the function mapping the proposition type to whether or not it's a contradiction is the function . Just as well, because takes just one as an argument, and returns a . This is compatible with the contract we laid out earlier in the typeclass definition of . says that the way of comparing two of these propositions (once again, of type here) for logical equivalence is to simply invoke the already existing method . 

Notice how as soon as the grade matches the range corresponding to something in the Enum, the method immediately returns. Now an example of how you might use that : 

This also means you only have to check if both of the input co-ordinates are valid and on the board, which can be done before the method 

This piece of code doesn't actually achieve anything, you are basically copying a String array to another String array, using an unnecessary parse too. Since it is not needed, you can just delete it, and change any later references in the code to it, to input instead. 

This is exactly what padding was made for. I don't really know how to pad with cout, but printf makes it very easy. It looks like: 

Presumably, from the many links you have many pages in the site, changing the header and footer on each page, every time there is a small change gets tedious, and a waste of time. A server side script like PHP would be able to fix this problem, or if you really want, you could encode the headers and footers in javascript and have to wade through that code for ever small change. I think doing it server side would be much smarter in the long run, and you can then learn how to make other features like a login, or a contact us page that sends emails 

There is no need to overwrite choice with the default again and again if it fails. Also a more explicit error makes debugging and reading easier. Finally I only catch on ValueError as something unexpected would be better off thrown back up rather than silently dying here. 

This code appears many times. It would be a great candidate for a function. That way, adding a new set of problems doesn't require a whole load of copy pasting 

to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

Alright, this is the first time I've used Typeclasses so someone feel free to slap me with a tuna if I mess something up. First of all, I don't understand why the use of "FlexibleInstances" is necessary, and it scares me because these kinds of warnings are usually put in place for a reason. With that out of the way, I'll go through the code. 

Not that you need these grade messages, but that's an example of the power of holding on to the type rather than converting the grade directly into a . Sorry if I've made syntax errors as I've not used Java in a while. Edit: Just realised that you might like to put , and into the itself as static methods. 

Inductive Instance Definition - First Step This is the fun part. We're using induction. Here's the full code snippet, and then I'll break down each line. 

The first thing you should realize is that in Haskell, typeclasses are basically the same thing as Java's interfaces. They define a contract of behaviour which instances of the class must obey. In this case, the typeclass I'm calling promises the user three methods: 

It won't be very often that a number is , so let's tuck that check away so that it only fires if the number passes the check first: 

These correspond to three questions which we could ask of any proposition which is a function of any number of propositional atoms. In case you're unfamiliar with this terminology, an 'atom' is one of the inputs to a proposition which is a function taking some number of atoms and itself evaluating to either or . Typeclass Declaration The name for the type class bears no meaning for me, so I changed it to short for "Proposition".