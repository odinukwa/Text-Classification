But then, from here it is clear that you are taking filenames that you will open inside the function to write to. This is not ideal. As a user, I'd want to use or : 

At this point, the string will contain the sum, plus possibly an irrelevant char at the beginning, which we have to detect and remove if necessary: 

This function is really big. It's 97 lines long. Break it up into smaller functions. Notice how you have comments for several small sections of code? Those are ideal for turning into functions. Yes, you will have many functions, but the readability greatly improves. However, many of your "functions" can be replaced with standard algorithms. 

Alternatively, if you really like the temporary variables, put some empty lines in there to separate logical sections. Also, consider using Project Lombok, where you could just do this: 

It's fine for it to not be thread-safe, but in that case, it is very important for the documentation to make it clear. If you are going that route, however, it might be worth separating the from creation like so: 

Make the strings the same length (e.g. and ) Compute the sums for each digit () Transfer carries (from the right) () Convert back into a string 

A function with the name should return a value, but this function returns . Also, since the operation isn't cheap, and "get" tends to bring to mind a getter, I would instead use the word "compute" or something similar. I would expect the signature to look more like: 

You do not have to use those exact requirements, of course. In this case, though, I really advise you to use a constant-time method: all standard containers have a constant-time method since was brought back into the fold in C++11. Without this constant-time requirement, there are two valid implementations of , one using and one using a data-member. With this requirement, only the implementation using is valid. 

Algorithmic An insertion sort is generally described simply as: read each element in turn, and insert it in the right position among the previous read (and sorted) elements. The cost of the algorithm is thus: 

In the case of , you can see the length is only incremented if construction of the object is successful, for example. In the case of , note how it reuses the current class to handle the destruction of already copied/moved elements if an exception is thrown in the loop. 

What does do? Finally, a trick question: what do think is and does? is a so called stream manipulator, it is a function whose signature is: 

Note: in C++17, where throws can actually be tested with the trait, which can be used to SFINAE those methods or with a . This is an exercise left to the reader ^^. 

1 Doubly linked lists are actually very tricky from a memory management point of view; there are risks of cycles, ... Putting this altogether: 

It's cheaper and easier so pass by value! This will get rid for the weird thing. Expression oriented language Rust is an expression oriented language. In short, it means that practically everything is an expression. Notably, a block is an expression which evaluates to the value of its last expression (or if its ends with a statement). Therefore, the body of a function is an expression, you can simple use at the end instead of . Avoid recomputing primes over and over At the moment, the complexity of your program is horrendous because you keep recomputing the primes over and over. This is unnecessary. Instead, you can compute the primes up until once, and then filter those primes. First Draft Applying the two above strategies already cleans up the code quite a bit: 

Know I know **exactly* what my code is doing, and I can debug it much faster if something breaks. Indentation This is a pet peeve of mine, and it is a pet peeve of the community as well. Always indent your code (properly) and never post code on SO that is not indented. We will be cursing your name as we indent it ourselves (or, even more frequently, we just refuse to help). A lack of indentation will make bad code even harder to read. Shameless Plug For Rubberduck Mat's Mug and his team have a tool called 'Rubberduck' that goes a long way towards enabling you to fix these problems. Everything from indentation, to variable naming and variable use, even to Function and Subroutine calls. I highly suggest checking it out: $URL$ . In Closing Whatever you do, don't simply copy and paste my code, throw it into your module, and just go on your merry way. I spent time on this to help you learn, and my hope is that six months from now you will be in my shoes. If you do decide to forego the learning opportunity here, you will miss out on all of the things VBA can really offer. Best of luck! 

To get you started, you have a number of unqualified references within your code. This is particularly puzzling to me since you declare and pass worksheet objects, but you never use this object when determining a reference. For example: 

Admittedly, this is uglier than Mat's Mug's approach, but this is the approach I use because it suits my style and needs a bit more. The benefit here is that you can choose your approach to handling the error. So, for example, handling an error in the routine can be different than handling an error in the routine. I also avoid statements as much as a possibly can. There isn't anything wrong with them when used well, but I try to anticipate errors if I can. On that note, and as others have noted, some of your subroutines need some cleanup. Someone in the RD group recently reminded me of the 'Single Responsibility Principle'. Everything should be responsible for one thing, and in turn, that thing should align with it's own intent. Along these lines, I would argue, that one unique thing should only ever be returned by one owner of sorts. For example: 

That is, the value is bubbling up toward the front until it finds its spot. This is suboptimal in terms of comparisons: the optimal algorithm to find the position to insert is using a binary search rather than a linear search, for O(log N) complexity rather than O(N) one. In terms of number of moves, well, you may have to move all elements, so it could only be improved by a constant factor anyway. Standing on the shoulders of giants, we can improve the code by separating the search and the move, and use pre-existing algorithms to do so: 

Beware of recursion While recursion is elegant, in languages like C++ it can lead to Stack Overflow. As such, unbounded recursion should be avoided, and therefore your implementation of or or should be converted to an iterative approach (use a loop). Encapsulation It is generally recommended to encapsulate functionality. At the moment, anybody can fiddle with your internals (and point its member to whatever they want without using your functions). Once becomes however, only a specific set of functions will be able to access it: 

One hard cold truth is that C-Strings cannot be fixed: not knowing the size of the buffer (either inbound or outbound) is a recipe for failure, and the band-aids (, , ...) are just attempting to patch the symptoms. Another hard cold truth is that is broken by design as it is non-portable (16 bits on Windows and 32 bits on Unix). Therefore you should not use it at all and instead rely on explicitly sized types and . 

This allows me to convert a range to an array, and then use those values more efficiently. Variants do have their place when used properly, but they shouldn't be used out of laziness. For example, in your code, (which should be ) and (which should be ) are used as numerics (and as such, should be Longs) but are declared as Variants. I assume, it is because they are then implicitly (without explicit direction) converted to strings, but even this doesn't justify the use of variants. You could do something like: 

This would then be called by creating a new instance of the class, and then usually by calling the 'Add_TableItem' routine. EDIT: As a side note, I am a super noob when it comes to classes. I know the basic ideas about how they work, but when it comes to terms like immutable, or encapsulation, etc I have no clue what I am doing. I have been working on improving my class knowledge, but putting it into practice is the more difficult part. EDIT: Very simple example of the kind of data that would be loaded in and used (the tables usually are about 100-200 columns with 30k-60k rows): 

I am certainly not an expert on naming conventions, so find what works for you. Definitely be mindful of what your names tell your 'reader' though. The other point worth noting here is how you have names that are inconsistent: 

And it is now a range reference (the only difference being the keyword). While it is easy to read the code and determine what is happening for us, you will inevitably lose a bug in there that you will have to search for. Option Explicit to the Rescue! is one of the best things in VBA. It is truly simple, but it makes the simplest of bugs super simple to prevent (and even simpler to find). With at the top of a module, the compiler will throw an error when a variable isnt declared. 

This might be a bit nitpicky, but and aren't that good of names for classes. Granted, they are in your namespace, so it should be fine, but why not just write out the names and ? I do find more ambiguous than , because I see "desc" as shorthand for "descending" more often. 

This isn't too complicated, so there isn't that much to say. Your code is perfectly clear, but there are a couple things that could be improved. 

The compiler will then be likely to be able to optimize it to the correct function call, especially if was instead , but I don't think that will cause any problems. Either way, the performance penalty will probably be small, so it's probably not worth your time. 

By doing , you require that is a RandomAccessIterator, whereas you only need an ForwardIterator. Use instead: 

This modifies the result. You almost always want your functions to act like mathematical functions rather than procedures. Additionally, Wikipedia lists the CGoL rules as follows: 

Basically, the compiler is allowed to order the assembly such that the following happens (psuedocode): 

Also, rather than comparing , you should use . Note that it is a functor, so you don't need to wrap it in a lambda: 

You should use the member initializer list. You don't need all the , but some people do prefer having it. 

Then you can note in the documentation that returns a if there is no instance present; in a "global" scope (like main), they should call . 

This is easily handled with a simple function that checks for a potential error instead of triggering an error. Code first, and then an explanation: 

Use existing functions/code where possible. This not only reduces the risk of bugs, but it can, at times, be more efficient. For example, denotes a and can be used instead of introducing an entirely new variable. This also makes your code easy to read. When I, as a reader, see I know what it is, whereas if I see I have to look for its meaning. Indent your code properly. I don't think this point can be over-stressed yet it doesn't always sink in properly. If you ever have code that is touching the window, aside from the Sub/Function declarations and Line Labels, something is wrong. For example: 

Aside from the couple of instances of a single ratio being matched to two different aspects, they are fairly consistent. So then I checked each of the original aspects and their results: 

Option Explicit I cannot stress the importance of this being at the top of ALL of your code modules. What does is it causes a compile-time error when a variable is undeclared. This prevents run-time errors when you try to use variables that aren't set properly, and it will save you countless hours of debugging time. Go To Tools > Options Editor > Require Variable Declaration. You'll thank yourself later. Variable Naming Not to be a jerk here, but your variable names are horrible and difficult to understand. You have rng, rng2, rg, q, s, r, cell and the worst part is that you don't need all of them. I declared four variables total (and one of those you didnt even have a variable for, but you did need). Here's a tip, make sure your variables make sense. You should be able to look at them and have a pretty good idea of what they do. is easy to understand: it is the range we are searching in. is just as easy to understand: it is the cell we are currently searching in. Finally, , you guessed it, is the cell we found using our criteria. It is pretty much bulletproof when you start to code like this (actually, not really. You'll learn that bulletproof coding takes a lot more work than a handful of good variables.) and it makes your code easy to maintain. Additionally, there is no need to declare two variables if you need one. In other words, if is used only for the first loop, and never needed after that, I dont have to make a for the second loop. I can just use . General Names Just as Variables need good names, so do subroutines. It is all too easy to take the that the recorder gives us, and to leave it this way. When you have larger projects, and become undistinguishable, and god forbid you have a and as well. Name everything. That's pretty much my mantra. From Worksheets to Tables, and PivotTables, and Workbooks, to code modules, subs, functions, etc., give it a proper name. The sooner you get in the habit, the more time you'll save. Implicit Object References You'll likely hear this one a lot, so it is important to learn. Whenever you are working on an object, you must consider the scope of that object. While looks fine to the untrained eye, anyone worth their salt in the VBA community will point out that it is a unqualified Range reference. Even worse, is if we have and one step further is this nasty bit: 

Use to manage dynamically allocated memory by default, although here / is necessary because of the doubly-linked aspect1 Always initialize built-ins with a default value Use for constructors that may be called with a single argument Follow the Rule of Zero (no need to define any special member, or if you have to, define them all) Use wherever possible is unnecessary if you define a method inside the class definition 

1. Header Names I recommend using for purely C++ header files, and reserving to C-compatible header files. 2. Header Guards As mentioned, you should rather than . If you really wish to use the error prone header guards; then I recommend following the Boost convention for naming: which helps prevent clashes in header guard names. It's significantly more work, of course... 3. Namespace By defining symbols in the global namespace, you open your code up to conflicts with C libraries, or other uncouth C++ libraries. Instead, decide on a namespace, generally the project name, and wrap any single item you define in this namespace. 4. Use , and pick an underlying type. Any new should really be , which introduces a scope for the enumerators rather than injecting them in the surrounding scope. Since you are no longer polluting the surrounding namespace, you can without fear pull out at namespace level, making it easier for people to name the type. I also encourage you to pick a type. By default the compiler will use , which is... 3 bytes too wide in your case. You can easily use instead, it is large enough. Also, you might as well dispense with pointless abbreviations. This gives: 

The only main difference is that now we are using an object instead of a type, and we must manually copy the object any time we want to create a new one (whereas, with the Type, we just changed the field). 

I've done my best to get you pointed in the right direction, but your code is difficult to follow as is. Here is what I have: 

The code below is in two parts. I have pasted code with your old code commented out, and then additional comments for clarity. I have also posted a cleaner version with just comments. Note: From reading the code, it likely wont run properly. I was unable to figure out exactly what your loop is doing, and as a result there are still some bugs. Be sure to fully debug this code before using it. Full Version 

This class uses a code pattern I learned from Mat's Mug. Declare the for the class as a , then declare a private that refers to that type. As a result, you have an organized to hold your variables, and you get intellisense. Once you do that, you just need to open up the property accessors. In this case, I made everything public. This isnt good practice, but I am avoiding teaching you too much at once (I would prefer not to use a class as is, but it is the best approach at this point). This Code Goes in Your Module 

Again, this is a very simplified version. Usually I am extracting more data than just a few simple scores. The worst I've had was Day-Over-Day tracking of roughly 40 students on an assignment level basis. This is what led to the need for a dictionary over an array.