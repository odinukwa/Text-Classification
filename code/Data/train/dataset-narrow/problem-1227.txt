The problem with Dijkstraâ€™s Algorithm here is that there is no guarantee that the target node is connected to the graph, and the code does not appear to handle unreachable goals in an informative way, e.g. 

Avoiding explicit mutation. Pattern Matching. Folding rather than looping over the string. Lambdas rather than named functions. 

Create a higher order function that takes a structure and returns a function that can serve as the argument for . The returned function is also a closure over a particular . 

is a typical way to handle long lists for improved readability. The style guide also favors over and it's related forms. The advantages beyond readability include not having to debug against the differences between . Proximity Explicitly naming is good. Limiting the scope of symbols lexically can avoid subtle bugs. The first definition in the code is it is not used until the last definition and it is only used there. Nesting the definitions is probably appropriate here. It might also have made my confusion in Naming 2. less likely. 

Abstractions The code defines a Node to hold edges. It works in the trivial case of binary trees, and in fairness a manifold of object oriented tutorials use a node object with left and right children to illustrate the wonders of object oriented programming. For graphs in general, however, defining nodes to hold edges fights against the mathematical dependencies. Code Review There's a lot of code in the implementation and the author is not clear that it works. Of course testing is the way to determine if code works, but a large implementation of a simple algorithm suggests some areas for improvement. Abstractions Defining nodes to hold edges is driving code complexity. Instead of a graph being a compound of a simple structure holding a set of vertices and a simple structure holding a bag of edges a graph has become a list of complex Node objects. 

This should not be public, nor should the class be. This allows someone to mess with the content of the list, and make it crash (e.g. by removing arbitrary items from the list and not notifying you). If is to be public, you need to add getters and setters and make sure the setters can only be called from within the , by making the class an inner class. 

You'll notice that since the array is size 2 and known to be that way, the complexity is , while if you actually sum the numbers, it becomes where n is the amount of numbers to add. 

Like Barry mentioned, you are probably expected to use Gauss and the property of triangular numbers. is a funny way of accessing your array without touching the indexes, hence without needing to verify that they exist. (consider what would happen if your function was called with or ). The one-liner you give is very close. In the final function you have and being the and values in that order. just apply the sum formula to it: So: 

Since k will be if the search did not work. Likewise, you can probably find a regex that will do all the work and allow you to remove the from 

Because the fastest operation is one that is not performed (but only when performing it is not required). Of course the code is not very interesting in Python. The code for such an approach might be more interesting in a language that provides compile time calculations -- for example Lisp via its macro facility. The cost of more interesting code is often similar to that of execution optimizations: the code is harder to read and to understand. Arbitrary Fizzbuzz By 'arbitrary FizzBuzz' I mean that the values for 'fizz' and 'buzz' can be arbitrary (for some definition of 'arbitrary') as is the case in the question where values for fizz and buzz are supplied as arguments and not hard coded as in classic FizzBuzz. As is the case with Classic Fizzbuzz and problems in general, performance optimization of Arbitrary FizzBuzz requires tuning the code to take advantage of the structure of the problem in order to minimize the amount of work the computer has to do. The underlying arithmetic creates a structure that repeats: 

and there is no functional requirement to store or pre-compute all the permutations. Any non-functional requirement such as performance may be addressed with a non-functional solution such as memoization or caching. Iteration Mapping to is an operation from one constant to another constant. This mapping can be represented as a function . We can get any member of as by where is the corresponding member of . This means that we can iterate over the entirety of simply by constructing . The good news is that this means we are no worse off spatially when we construct than we were with . The bad news is that we are no better off. The Bad News Permutations are in NP and the only way to get back into P is to know something about: 

Conventions in boudaries is that the low bound is inclusive and the upper bound is exclusive (in your code both are inclusive.) By changing this, you can drop the , and : 

Infinite recursion! Edit You can avoid the infinite recursion by considering the value in the first case: 

in regex means . I think in your case you are mistaking it for a concatenation operator. I think you could factorize a lot with the help of better regex. For example: 

TL;DR If you want reusability, in a nutshell: Don't have a single club name in your code. Not in strings, not in constants, not in class, variable or method names. Get it as parameter. Either from a configuration file, from the command line, or from another program that has the sole responsability of providing the club names. 

Here you are doing bounds checking. Should be . Typical implementation will throw if the index is not within the bounds. is a valid value, and can return for a valid index. You may want to consider implementing the interface, so you can use your implementation where a is expected. 

Try to replace by , or by to avoid the need for casting. You are sorting in , then copying to , then merging back into . It is not optimal. I don't quite like private constructors to prevent instanciation. I would use an abstract class. 

In other words, must return something that was pushed onto the stack (or an error, but that's an architectural issue not a principle of computer science). Architecture Strictly speaking could return a void and write a message to the console, but it is conventional for it to return something of the same type as the top element of the stack - in the case of reference types, the question of whether it should be a copy [and what type of copy] or a reference to the object itself muddies the waters. The current implementation of points to a larger architectural issue, a low degree of modularity. Currently, user interface is spread across the code and the stack data structure even writes messages to the console. The effect: 

Using an internal function, recursion, and a trampoline is a good way to structure recursive procedures on a lists. The code fragment is the same as . The name suggests an accumulator, however, the value it stores is the maximum, so might be better. Because of the letter can be confused with , can be read as slang for 'first'. I prefer as the name for a list of 's. The nomenclature has become more common in Lisps over the past few decades due to the influence of other functional languages. No matter how it is dressed up, there's a procedure in the code somewhere. And it has to be written. It is better to be explicit about it than to try to hide by embedding it in some other function.