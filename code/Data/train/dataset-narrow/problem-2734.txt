Although my game uses a peer-to-peer model, I've still taken the approach of assigning each player to be a partial authority. What I mean by this is that each player acts as the "server" for a number of objects, and all the other players are "clients" for those objects. It also uses a fixed update interval and variable render interval. I'm considering a 50Hz update frequency, so the rendered time lags behind the current time by 20ms in order to guarantee two states to interpolate between. When a client recieves authoritative state information from the server, it comes with the timestamp of when it was sent. Because all the players use a synchronized clock, the client can correctly place the state along its "update timeline", the state history of which is stored for up to 100ms back. However, in order to hide latency, each client also predicts the behaviour of all objects in the vicinity, regardless of whether or not they are the authority. The difficulty I'm having is figuring out how to correct errors on the client side and stay synchronized with the server state, when server information for a specific object will be coming far less often than updates happen. What is a good way to smoothly correct current information with information from the past after several prediction steps have been done on estimated information? 

It sounds like you're making an RTS, so let's say you need to have a building that automatically attacks the nearest enemy within 100 metres. 

The only real reason to write API code in classes vs. free functions (I hope you're grouping them in namespaces!) is so that you can swap in concrete API code if you decide to switch implementations. To do this, you have interfaces for all your API-specific objects (renderer, mesh, texture, etc.).Program all your high-level code (like models, lights, materials) to these interfaces. 

You could call it texture warping, or simply texture deformation. In XNA you could achieve something like that by transforming the texture's pixels' coordinates. You map the pixels of the texture to a grid, then modify the positions of the grid's vertices. Since the effect in Castlevania is quite unique, you will have to experiment and play around with your own deformation algorithm until you achieve an effect you like. There's a nice tutorial for a similar technique here: Screen-space deformations in XNA 

There are many solutions, depending on what kind of effect you want to achieve. Here's a simple 'rebound' solution: When a collision between object 'A' and the wall is detected, do the following: 

If I detect another collision for obj1 in the same Update cycle (with obj3 for example), I just add the obj3 to the coll1.Colliders list, and create a new Collision for obj3 (unless one already exists). 4 . Once I went through all the objects in the scene, I have a nice list of Collisions. Now I can go through that list, and apply the collision effects to their "Victims". 5 . I handle the collision effects in the Player, Bullet etc. classes. For example: 

Where (ScreenWidth * ScreenHeight) is the number of tiles shown on your main screen at any time, and GridWidth * GridHeight is the number of tiles your grid holds. For example, if your window shows 30x20 tiles, and your Grids hold 100x100 tiles each, then 

When searching for a specific tile, you iterate on the pointer list, and check the properties of the tile that the current pointer is pointing to. In C#, with a List representation for example, a search would look like this: 

I also use complex maps with "lots of irregularities" in my game (pretty much like the game Worms). I have premade graphical elements which I put at arbitrary positions. These elements have minimal bounding rectangles (MBR's). When a character is inside the MBR of a map element, I do a per-pixel collision detection. It is important, that I'm taking into account only the intersection of the map element's MBR vs the character's MBR. TL;DR: Minimal bounding rectangles, then a finer (e.g. per-pixel) collision detection when they intersect. 

The best practice is to create the new window first, sharing the resources with the old window's context, and then destroy the old window. However, it doesn't seem like GLFW (even v3.0) supports resource sharing yet. For now, you may have to retain the data in RAM and then just recreate the OpenGL objects in the new window's context. To accomplish this in GLFW, you pass an existing object to . (Thanks @tecu for the clarification!) 

So how does this relate to collision detection? To ensure that you always obtain a collision normal that will point away from the surface, only detect collisions from the front side. If, like in your example, you want to be able to collide with both sides of an object, put two collision surfaces, one flipped, on top of each other. Again, refer back to the two triangles and how the winding order defines which side is the front. If you layer the two triangles, now you have a double-sided triangle with a different normal (the exact opposite!) on each side. Since you only detect collisions with the "front" of a surface you always obtain the correct normal. Respecting winding order is how convex hull algorithms are still able to determine which is the "outside" despite not being given that information explicitly. The Quickhull algorithm uses tetrahedra that are eventually used to build a triangle mesh, and if the winding order is maintained properly from the start all the normals will be facing in the correct direction. 

Usually, the reason that consoles perform better than PCs with equivalent hardware is that the hardware available on a given console is well-defined, and it is possible for programmers to make optimizations that are not possible for PC games, which need to run on a wide range of hardware configurations. AMD's Mantle API for PC boasts the ability to make these optimizations, but only because it works based on certain hardware assumptions (GCN architecture). The biggest difference is that PC code has to go through a very complex operating system, while code for a PS3 goes through a very thin layer that goes right to the hardware. Most of the performance differences come from the high cost of memory allocation on PC and the system resources that background processes use. Most of the game's code would be very similar. The biggest differences would appear in the code associated with file systems, memory management, rendering, and sound because the APIs are different. Even so, the PS4 uses OpenGL and the Xbox One uses D3D, which are both APIs that PC games use, so the code is going to be much more similar than, say, the code between PC and PS3 or Wii/Wii U. See points 1 and 2. 

In your collision detection loop, when examining obj_A for collisions, you create a new , and add all other objects to this, which collide with obj_A. Once this list is built (you finished examining obj_A), you can call the ApplyCollision method with the list as an argument. In the ApplyCollision method, you're stepping through the items of the list, and yes: you will probably need a switch statement at this point, since a Bullet will probably be destroyed with a nice visual effect when it hits a Wall, while the Wall might only get a decal. And the Bullet will cause damage to a Player or a Vehicle, etc. But everything else is generic in the collision detection method. 

3 . Make transitions smooth (if necessary). If your grids are really large, and it takes 1 second to load one into the memory, then you might want to start loading it sooner. For example, when the Player is at a (ScreenHeight/2 + 5) distance from the edge of the Grid. However, it's only necessary if you experience lag while loading a Grid. This might happen if you're reading the Grid data from a huge file on the HDD, or from a distant server. 

It really depends on the style of your game (or the style you wish to convey). The only game where I have seen this kind of localization is the Worms series. It was a really funny feature, which added so much to the fun factor of the game. However, it might not have been so without the excellent voice acting. Localization can be a tremendous amount of work if you have lots of text. You must think about the value it adds, and compare it to the effort it takes. How many people are going to play with the Welsh settings, if you have no voice acting? A hundred? Are you gonna lose those players if you don't have a Welsh version? It seems that you already have a nice, constructive community. I think you should just provide them a way to make their own localization packs. Make it really easy (like an XML file), and your community will do it. 

Alternatively, if you were doing a more complex physics system you could implement gravity as a generic, persistent force. This would make it easier to do things like different gravities in different regions of space. 

RK4 is an example of a numerical integrator. Euler integration is a similar concept, but it is much less precise. Numerical integration is not exact, but much better for a computer to handle in a real-time situation such as a game. The reason that you use RK4 instead of Euler is that RK4 takes into account the integration of the second and third derivatives (acceleration and jerk), and thus fits the analytical solution much better. RK4 is essentially a Taylor series expansion of the differential equation that defines acceleration with respect to displacement and velocity. This allows you to integrate forces that depend on these quantities, such as in constraints and even universal gravitation. Taylor series expansions are useful in programming as computers can evaluate them very efficiently. The function used is an example is a simple damped spring system, not gravitational. is Hooke's spring constant, and is used to damp the system (remove energy). For pretty much all spring-related constraints in your engine, you will want to damp them as numerical errors can cause a huge accumulation of energy, causing the simulation to explode. If you were using Euler integration, this would be much worse. With regards to , a more complete physics engine will calculate both linear and angular accelerations based on forces (torques). The forces to sum could include gravity (constant or based on Universal Gravitation), buoyancy, and springs (most constraints can be modeled using stiff springs). Your third question is easy to answer. In kinematics, there are three basic quantities: displacement (position), velocity, and acceleration. Acceleration is the derivative of velocity, which is the derivative of displacement (both with respect to time). A derivative is just the rate at which something changes. means "the derivative of ". Because the simulation assumes that the spring is anchored at the origin and has a rest length of zero, a displacement of 100 means that the particle will start to oscillate. The test simulation ends when the particle is not moving and is close to the origin. 

In my collision detection loop, I make a new Collision instance for each object in my scene that happen to participate in a collision. For example, if obj1 collides with obj2, I will create two new Collisions so: 

You will probably find what you're looking for here: Steering Behaviors For Autonomous Characters Maybe in this article: Steering behaviors (full article) 

The reason I'm using CardId's instead of CardName's, is that your card names might change with localization, or patches (typo fixes etc.). If you associate an Id with each card, then you won't have to worry about those changes. 

Take a snapshot with the method. Load the resulting data into a with the method. Render the Texture2D. 

You can check the button state easier using the and methods. These both accept an parameter. See the MSDN article. 

The list (grey box) has a dynamic size, starting at 0, and growing with each pointer (red circle) you put in it. So if you've only generated 3 tiles so far, you're going to have a list of 3 pointers. This way, you won't have to reserve the memory for millions of tiles in advance. 

You should google for the keywords 'database normalization'. A good practice is to normalize to 3NF (third normal form). 

Software design is not an exact science. There's no "the right way" to do something as complex (and vague) as a 2D platformer game. Didn't your teacher show any examples of UML? You should think about this as any other software (or complex system). A nice UML diagram should answer these basic questions: What are your entities and what are the possible interactions between these entities? Try following a top-down approach - going from the abstract, high level elements towards the small details. 

This already narrows down the cases, but I added some further optimizations: 3 . I have a Collision class: 

Edit: Here's a method I'm now considering. Hopefully I can program the systems to make use of this layout while still avoiding memory problems. 

You should use the D* algorithm, which is designed for this exact scenario. Specifically, the D* Lite implementation is the most efficient and simple variant. 

The reason two tessellation levels are needed is because the GPU doesn't tessellate individual lines, it tessellates what it calls isolines, which fill up a rectangular area in the tessellation basis space. Since we're only tessellating one line we don't need to worry about how that works. Note: The tessellation control shader is actually optional. A shader as simple as this can be replaced by setting hardcoded values for the tessellation levels from the application itself, although that is typically not done in practice as it is not very useful. 

If you put together all your different entity designs, you'll probably realize that there's a lot more behaviour than you think that you can generalize. If not, it's fine to create systems specific to certain types of entity. 

Pretty much all resources relating to game programming, especially 3D open-world games, talk about how you have to constantly be unloading and reloading assets to and from disk, system memory, and video memory. I can understand this on consoles, as they have very simple memory management schemes that cannot deal with any potential overflow. However, on the PC, the situation is very different. There is virtual memory provided by the OS for system memory and the graphics driver handles swapping back and forth from the CPU to the GPU. So why is it that it's not sufficient to load everything at once and only have to deal with prefetching and possibly making sure that there is no blocking while a required asset is being swapped?