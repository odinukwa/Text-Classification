Should be refactored into a common method. doesn't clear the . This probably won;t cause a problem but it would be more consistent to do so. It can also be condensed a bit by consolidating the checks and turning the into a loop. Resulting code: 

It is obvious from the generic type parameter that a class is generic - no need to spell it out in the name of the class (i.e. should be and should be ). You expose both and as public. From the code should be named because that's what it does. seems to perform the synchronous request and it should therefore be be named . If you want to expose both methods public then you should consider making their interfaces more consistent - one expects a for the data, the other one a request object. Otherwise declare the synchronous method private. You only need to synchronize access to resources which can be accessed simultaneously by multiple threads. As far as I can see your static methods (when you make static) are all self contained and do not share any data so you don't need to put any locks in (in the code you have shown). If you insist on keeping a singleton then you can just use the class initializer for then you don't need any lock: 

Similar for Also, is there a reason why your are using the loops with the iterators instead of for example ? The method could then read something like this: 

The standard naming convention for properties is in C#. I try and give default "magic constants" a name. In this case I admit it's fairly obvious however you never really know what your code will turn into. It is also good to form habits so you wont forget these things. 

The method could accept an or a and use it to write the result to it. Return the results as a list from the method. 

I wouldn't have bothered implementing my own queue. Just use a or a plain with an index pointing to the current head element. Saves a bunch of code which you don't have to test and maintain. You shouldn't use the mutex directly, you should use a instead to make sure the mutex gets released automatically when the scope is left. You should reduce the scope of the mutex to a minimum to avoid unnecessary lock contention (in this case probably more of an academic point but still a good habit to get into). So the method could look like this: 

Naming conventions ( for properties) You now have introduced a property but that doesn't affect anything (the property is not used anywhere in the class) Although you have introduced a named constant you are still using magic numbers in various places. You have added some rules but they are implemented inconsistently - in you enforce the rule in the while in you do it in the . The way you have added the rules is simply bad - you silently coerce the values and the user of your class won't have a clue what's going on. Assume this calculator is used to process the payroll in a company with lots of employees. Further assume that some of those are contractors which have not worked in the last week for whatever reason. Now you read in the work hours for each employee and everyone who hasn't worked at all () will get a full week payed - ouch. If properties have restrictions on what range of values they should be in then enforce them in the method by throwing an stating what was violated. It's better for your program to crash with an exception than to spit out bad data. One of the few places where coercion of values makes sense is in user controls which force out of range values back into the range and then feed that back to the user (e.g. numeric up/down controls which a given min and max) but in most other cases it will do more harm than good. 

You are doing a lot of parsing and re-parsing by passing everything around as strings. This is not really a good way of doing it and also very inefficient as you are constantly throwing away information and having to reconstruct it via parsing it out of the string. Here is how I would split it up: 

.NET has a type which is ideal to store this kind of information and it become obvious what unit it is and works nice with as well. So something along these lines: 

The task says that the problem is to find fractions with as one of the requirements. Further down it also states that the input will be given and that it can be in the range . The first thing you do is to compute the factorial of the input. You should be aware that factorial grows very quickly and is in the order of which is way beyond any native data type in C. As you compute the factorial in your code will fail for any input larger than 12 but even (64bit) won't get you much further than 20 for the input. This means you will have to find a different approach to solve this problem. You should take care to properly format your code. Any IDE will do that pretty much automatically for you these days so there is no excuse for poorly formatted code. Well formatted code is easier to read, understand and therefor maintain. Don't use single letter variables - variables should be named in accordance to what their value represents. Even if you think it's not necessary for a little one off program like this you should still practice it - Train like you fight because you will fight like you train. 

Right now the programmer has to remember whether a node was added via or in order to call the proper delete function. However this could be solved by having a flag in which indicates whether the node owns the content or not. Delete could then automatically do the right thing. 

In the comments to you state: which is not immediately visible that this means the binomic formula. The text representation for power of is typically which would mean the comment should look like this: While the binary search in is in production code I'd consider using the same solution as for . While this is it has some advantages 

Note: Never in this context means I killed it after 10 or 15 seconds. So it's not surprising that a list with 50,000 random elements can easily yield in a higher setup time than 100,000 depending on the distribution of the values (the algorithm attempts to re-create the table everytime there is a collision). As per given example it's easy to generate inputs which will make it run for a long time for very few values. Given the problem restrictions I'd say you can get away with the fastest perfect hash function there is: Identity. You could simply use a bitset with the values as indices and flip the bits on of the value is present. This requires a bitset with 10^9 bits - approx. 125MB of memory which is not all that much these days at least on desktops. Resulting implementation: 

Your code duplication in (2x in there) and is around the differences of how the keyword is handled and how the prev/next links are enabled/disabled. Lets look at the link enabling first. To me the logic of disabling the links should be very simple: 

If you want to add another item to the game then you add another entry into the and some additional rules and you are done. One thing to improve with my version is that rules just effectively define winning rules and all other cases are implicitly ties which in the context of this game makes sense but could be made more explicit. 

Now, we only review working code but because the above things are mostly access modifier problems rather than actual code bugs I'll continue with the review anyway. However you should test that your code compiles and work first before posting here. Review: First off: The idiomatic way to create tuples is to use . This way the compiler can infer the generic types automatically which saves you some typing work. In your case this means: - much shorter. 

This is an interesting approach. I would have used a queue by default since it seems to express the semantics a bit clearer (the queuing is slightly more obvious). Also creates a wrapping the original task which I'm not sure if that has any form of performance downsides (it probably shouldn't). I hacked a quick benchmark together with the alternative being implemented using the : 

So in the end you'll have to decide if simpler code is better (better maintainability, lower chance of bugs, etc.) or if the object pool really is the performance bottleneck. 

is not a good name for the function as it does not say what it checks. It returns false if all numbers below are present and otherwise. So a better name might be . You can make your loop body a bit shorter by inverting the condition: 

Don't put a blanket catch all into the constructor of your view. If any part in there throws an exception your view is now in an inconsistent state - or even worse you entire application might be in an inconsistent state. At most the caller instantiating the view should catch the exception and handle it, but in most cases the application should just be terminated (logging the exception of course beforehand). looks like a static singleton instance - this creates an implicit dependency. Better would be to pass the in as a parameter of the constructor (ideally there would be an interface of some sort). This might be tricky sometimes depending on how the view exactly is instantiated. You should be able to use delegates for the message handlers. So instead of this: 

You have a static dictionary as backing store which means that all cache instances share it. Not saying that this is wrong and it might be intended but you should be aware of it. Your cache apparently is not thread-safe. You need to protect access to the dictionary with locks or if you are using .NET 4 or later use . If you make the backing dictionary non-static then you might not need to make it thread-safe if you can ensure that you never access the same cache instance from multiple threads at the same time. Items only get evicted when they are being accessed again. This means if you only ever access items once they will stay in there forever. Make the magic number at least a const member or maybe even a tunable property/field (in which case you should prefer making it a as it's easier to use than plain ticks) Your method will throw an exception if the entry in the cache already exists. You either need to check if it exists and just update the entry (or do nothing, whatever makes sense) or replace the entry by using rather than . Depending on your use case you might want to rename into and update it whenever someone accesses the entry (read/write) with the same key (which means items will be evicted a certain period after they have been last accessed rather than created). Last but not least you might want to look into the class if you are using .NET 4 or later. 

You should separate input and the actual check into two separate methods. Your algorithm is not actually dependent on how you get the string so it should be extracted into it's own method which gets the string as parameter and returns as a result. is not a very good name because it implies it's the allowed set of characters the input may contain while it actually denotes the parenthesis symbols you are interested in. So maybe would have been a better name. There is no need to use a static instance for the . Static singletons can have their uses but in general they should be avoided. They cause implicit dependencies and make unit testing the code in general quite painful. 

You split strings in the same way three times - I find it cleaner to extract this into a common method to perform that action. I would extract the scoring of a single title against a specific file name into it's own method - this encapsulates the core scoring logic and then lets you deal with the scoring of all file names in a more condensed way. After you've done 1 and 2 you can apply some LINQ magic again to make it more succinct. I don't have the code of the class but since the seems to be linked to the title name it seems weird that you'd have to pass this in for every file you add. The code would become a bit cleaner if this is tidied up - I haven't that in the below code yet though.