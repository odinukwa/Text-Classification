This suggestion is, I'm afraid, highly speculative and untried. But I'd be tempted at least to give out an assignment of the following form, perhaps using a structure like that suggested by @BenI. here. Prepare a numbered list of exercises from quite simple (in your estimation) to quite complex. The numbers correlate directly to the difficulty. Tell the students that they can do any number of them (say at least three) that they wish and that the grade will depend only on the most difficult one they get correct. The justification for the structure is that the students who get these easy will just work on a few of the harder ones and the ones that struggle will start farther down your list and work until they feel a bit confident. The students who need the most work will, hopefully, get the most practice. The rating by difficulty can also help them get "into the flow." In the exercises I'd also stress a variety of vocabulary for things so that they get some practice in matching human language to the technical forms. You could even try to state each exercise two different ways to help students with the correlations, but you need to be careful that your explanations of the requirements really are equivalent. 

Some instructors also permit students to simply skip the final exam if their point total is sufficiently high at the end of the course. Of course, this can be incorporated into percentage grading as well. This benefits your best students who can then spend their efforts on other pressing concerns. 

Note the interface type on the LHS and a specific class type on the RHS. This makes it easy to replace the concrete type with a different one without changing the LHS or the code that follows. This is actually the preferred method of doing such declarations. Why does it work? It works because all of the provided implementers of List have, as their only public methods, the methods defined in List itself. It wouldn't work if that were not the case. Then, if additional methods were defined (and used), changing the concrete type would become much more difficult. The good practice in the libraries (not adding public methods) is good for a reason. I'm simply suggesting it as a general practice that makes for better programs. It is also a simple and safe rule for beginners to learn. The rule is frequently broken, I realize. But poorly designed software is frequently written, also. And note that this problem is more severe in Python, which is dynamically typed and variables (identifiers) have no type at all. Java declarations at least give you some sort of managed knowledge of what sort of thing is referenced. In Python (Ruby) you need to do that yourself or include frequent type checks or suffer frequent errors. 

then a half a page later, when you see $x$ again, you want to know what can be done with it. What messages does it accept? So, say the following, instead: 

There are, of course, situations in which the cost of modern textbooks can't be ignored. Providing low cost or free resources may be essential in these situations. 

This question seems like a minefield. The obvious answer is "Don't Do That." No group of people, students or professionals, is going to interpret two pages of instructions in exactly the way the writer intends. It isn't going to happen. They will misinterpret individual steps, skip steps trying to optimize, crash the machine when they don't have a conceptual idea of the goal, etc. In the first place, your instructions may be clear to you, but until you vet them with others they won't be clear to most other people. This is why textbooks have editors and why authors re-write continuously. There are, however, a few things you can do. 

I also teach objects from the start (before and ) since I value large scale structure over small. That is, providing a solid framework for the smaller scale issues. 

However, if your daughter has been studying algebra, you will need to make clear that what a mathematician calls a variable is quite different from what a computer scientist does. In CS, a variable can actually vary, so the term is much closer to the truth. In math, especially algebra, the word variable is often used for an "as yet to be determined" but definite value (or set of values). It doesn't actually vary. Mathematicians also call them "unknowns", but that just means "not yet known until we solve this thing" but still, a definite value. In CS, variables have definite but changeable values. They are never "unknown" to the computer, but may be to the programmer who isn't actually tracing the program. 

If you are a believer in separating design from implementation in a traditional way, then a design course followed by an implementation course might work for you. A language principles course, for example, might have elements of design followed by a compiler building course. Other sorts of projects might work as well. 

I'm surprised that you didn't ask this teacher why she asked this question and how it fits into her overall evaluation. I don't think anyone can answer this question without more information. We can speculate on situations in which it might be a good question and we can speculate on situations in which it might be a terrible question, but we can't know unless we know why it was asked. Some of the other answers here provide such speculation. Moreover, you don't say how accurate the teacher expected the answer to be. And we don't know anything about how the teacher intended to use the answer. I have, myself, asked students at the beginning of a project to tell me how big their self-defined project will be using various measures. That sounds especially stupid until you know that my only goal was to get them to start to think about estimation, which they had never done. The numbers they gave weren't a goal for the project, but only a source of reflection at the end. So at the end, such a question would be completely natural and expected. And expected to be widely divergent from the earlier estimate, of course, since this was their first attempt. 

Ideally, interfaces come first. Before Classes. Interfaces define concepts. Classes implement those concepts. Don't think of them as an add-on to OO programming. Think of them as the essence. In fact, if you present a pre built class to students, my guess is that you already, probably informally, give the interface first. Here is a class with public methods "accept" and "spitOut", or something like that. You probably talk about the public methods first and the necessary parameters and return values. More importantly, you probably talk about the intent of the class and of the individual methods. Most likely, and I think most common, only then do you discuss the implementation of the methods along with fields, etc. If you start your discussion with the fields, on the other hand, you are (IMO) making a big mistake and that students will start out by thinking at too low a level and will write their code too often in terms of getters and setters. In other words the encapsulation will be inconsequential and possibly leaky. Then, in a program with a few tens of classes and a few hundreds of objects, but, perhaps thousands of fields, they will be thinking about the fields and how they mutate, rather than the concepts represented by the objects in the system. Their thinking will be at a lower level than is efficient (or even possible, in some complex programs). But if you introduce the concepts first, and get them to (a) think in terms of those concepts and (b) implement those concepts faithfully they will be naturally led to think at a higher level of abstraction, which is really what programming languages are for in the first place. Some rules that I'd adhere to with rare exceptions and no exceptions at the start. 

You give one answer yourself here - Automate It. In fact you can improve the automation if you distribute the code yourself and execute it yourself from a central server. Automation isn't foolproof, however, as some of the machines in the lab will, perhaps, have different initialization parameters baked in that defeat your script. Another possible solution is to decide on a standard startup process and configuration that you always use. The students can learn this and only struggle with it for a day (or week, ...). Make the startup description shorter. As short as possible. Then a bit shorter. Vet it with someone else who is skeptical about it. Re-write it using their feedback. 

I think that all of your suggested items are needed and some are difficult to teach other than by example. But let me focus on one aspect, especially, that can be taught. A good programmer needs a variety of strategies for getting their own questions answered and the desire to get them answered quickly. This means that you cannot be their sole source of information. If you teach at least part of the time in a lab situation, or with a projected computer screen image you can demonstrate how you use, google, wikipedia, language documentation, StackOverflow, etc. in answering questions. If a "what does ... do" question arises, you can quickly write a code fragment that illustrates it, giving them the hint that they can do that too. You could even make an assignment to have students write short code fragments to illustrate an idea. But some answers can also come from people, especially their peers. This is one reason for encourage pairing and teamwork. It isn't the answers themselves that are the key here, but the strategy for quickly finding the answers. And, since writing isn't one of your suggestions, but is important to any professional, you could have students who answer questions for others, write the answers up. I used to use a wiki for this purpose. Over time, it became a valuable resource in itself. Mailing lists to which every student can ask and answer questions also help. Also, being helpful to others is a valuable skill as well, so this helps with that, also. Programming assignments could possibly be accompanied by footnotes that reference relevant online (or book) material to show how their code is related to what has been done by others. You can probably think of other strategies, but don't keep them to yourself. Be sure that you demonstrate them and have the students utilize them with some evidence that they can do so on their own.