The two nested are better replaced by a single and the program should return at once, so that is not required. This would reduce the indentation of your code. Also it seems that the check for equality and the check for early stopping are quite similar and could be done together. 

I know that efficiency is the last thing to worry about in such a function. However I would rewrite answer of @Martin R as: 

I think your code is very well written. Also very nice structure. I enjoyed reading it. Just two notes. One. This seems too much involved, to my taste: 

I think the code is very well written. But, as you suggest, it should be more object oriented. I see two objects which are calling to be extracted: a Tokenizer and the InfixToPostfixConverter(better name required). The Tokenizer should read its input from the scanner and have a method to get the next token as a string. The Converter could be feed with tokens and fill the outputQueue. This way you separate the two problems. Moreover you can put the tokenization process in parallel with the shuntingYard algorithm without the need of a buffer to keep the tokens. 

there is a division by zero when the lines are vertical. You should moltiply both sides of equation by the denumerators to avoid this and to have a more stable condition. Anyway it is almost always wrong to check for equality of two floating point numbers, as already said. The function and are not used. Why did you include them? Anyway note that vertical lines have no slope defined. So the function is not very useful. The function also has the problem above (checking for equality of two floating point numbers). And due to the problem of it will not work if one of the two lines is vertical. 

you can write since returns the element removed. The s in the merge function are not properly aligned. Notice that the use of the method could alter algorithm complexity (because I think that is \$O(n)\$). It could be better to use two indices to keep track of the position in the two lists. 

I always feel not comfortable when both operations and are computed separately, since the second one can be computed in terms of the first by means of sum and multiplication (which are much more efficient operations). Also this alternative "stream of thinking", i.e. modify the input values until they satisfy the requirements, requires less use of imagination to find the names of variables. 

so that in the case there is no need to access self_db and user_dbs. This is particularly convinient if the case count==2 is more frequent than count==0. 

You are requested to implement a data structure which can implement the three commands: , , . What is the minimal information you have to hold? To respond to a command it is enough to store 216 possible answers, corresponding to 216 possible values of . That is enough. When you a number , just add 1 to the count of all such that . To a number just decrement the counter. So here is the core of a possible (not tested) implementation: 

Here your code can be simplified and made more clear. You are checking if the character is alphabetical and then looking into your map to find the corresponding translation: 

You want to detect otherwise the function might hang if there are no left. For this reason always use to get the result of . 

you can easily replace this line with a for_each or an iteration. This would result to be more clear, since you are not really hiding anything in this method. EntityManager: as already said, I see nothing useful in this class. I read somewhere that whenever you name a class XxxxManager you should ask yourself if such class is really needed. And if it is needed you should be able to find a more explicit name which explain the purpose of the class. 

This makes it clear that is assigned one and only one value (while in your code this depends on the content of ). Notice also that the code is simpler and the is no longer necessary. The following code is ugly: 

Just a funny note: I asked my students to write their own implementation of Player... but I was disappointed to see that most of them were beaten by my Random player! 

which can be achieved if you define a dictionary of classes. The code could become even longer, but separates more clearly the logic of your Range class by the information about different Tokens. If these Tokens have other functionality using a class becomes even more convenient. The definition of token is clearly separated and does not interfere in the logic of the application. Also, adding a new token is a matter of defining a new class and registering it in the dictionary of tokens. Similar token could benefit in inheritance. For example: 

This check is non very useful. It does not decrease the algorithm complexity. In particular the check is wrong... you want the function to fail if the arr is not a list, otherwise you hide possible errors in the caller's code. 

All these simplification do not change the algorithmic complexity of your code. PART TWO Your algorithm is \$O(n^2)\$ since you are iterating on all pairs of names in a huge list of length \$n\$. This can be terribly slow when \$n\$ is becoming very large... so you should try to find if it is possible to make a single iteration on the list. The key point, here, is that the computation on a pair of persons only depends on the number of occurence of the characters P,A,I,R,S in their names. So if two person share the same count of P,A,I,R,S occurences they share the same perfect pairs (if they have any). So you can start by construction a dictionary mapping "PAIRS count" to the number of people with such a count. Moreover every PAIRS count can be reduced modulo 9 (because we use modulo 9 arithmetic) hence the number of items in the dictionary is bounded by \$9^5\$ which gives constant time access and update of the dictionary. So the dictionary can be constructed by a linear sweep over the list of names in \$O(n)\$ time complexity and constant memory. Once the dictionary is constructed you can make the double iteration on the dictionary. Every match in the keys of the dictionary must be multiplied by the counts of both "PAIRS" to get the count of actual people matching. Since the dictionary has less than 100000 entries this counts as a constant time operation. Of course when \$n<100000\$ this could be not better than your algorithm (but also not worse) but I would predict that even for smaller numbers you have a gain, since real people names are not so long and contain very few occurence of five choosen letters (imagine any name with a (9,9,9,9,9) PAIRS count) hence I expect a lot of collisions in the hash dictionary which will sensibly reduce the runtime of the algorithm. Possible implementation: 

your pattern is always the same so you could cache the computation of the array . This would double the speed when you fill array you could stop whenever . This could speed up your algorithm a lot in some scenarios. For example you skip a position at once if the letter in the text is not in the pattern. you are making copies of strings just to add the null terminator. You can avoid this by adding the length of the string as a parameter to your first function. This would help point 2 to be quite fast in the scenario already mentioned. you can update the array incrementally. You decrease the count of character which exit the window and increment the count of characters entering it. 

Since you are interested in an OOP approach, I take the opportunity to show you a toy program I did during a programming course. The comments in the code are in italian (sorry) but I hope it is clear anyway. The code comprises: 

in the main function you have a small repetition when checking argv to determine if the FILE should be closed or not. I would prefer checking which is telling the real reason for the check. Alternatively I would simply neglect closing the files... since you are in the main function, at the end all file descriptors are guaranteed to be closed anyway. i would prefer instead of . I see three reasons for this: it is shorter, you don't introduce the arbitrary constant 1, it is clear from the beginning that the loop has no termination condition. i would expect less invasive error checking. Since your and functions are perfect candidates to be reused in a library, you should not write errors to and should not terminate the execution with . A better approach would be to use return codes as signals for errors and let the main function write the messages and terminate. i would always enclose with braces the blocks of an statement even when there is a single line. This is to avoid the risk to forget the braces when a line is later added. As an alternative I would put the single line on the same line as the statement. 

I don't like too much the names of these functions. I know that also python uses ugly names (words without any separator) but I think you could improve this... for example: or seem better to me. About the functionality. Managing dates is a quite difficult task. The python library in my opinion makes a great job in distinguishing and datetimes. Your wrapper module simplifies this by considering each datetime as a localtime (if I understand it correctly). I think it is not good to hide this decision in your code. Explicit is better, even if it could me more verbose. Also I think you missed the function, which could be used in your code.