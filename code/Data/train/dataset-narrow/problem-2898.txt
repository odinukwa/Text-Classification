And now for level design... This article mostly covers newer games but contains some fascinating insights into level design in general - you might find it helpful and at the very least an interesting read: $URL$ This is an article about a technique to manage the difficulty of, well, difficulty. It's scalable to infinite levels and uses DDA concepts: $URL$ The information in both of the above articles could be applied to arcade environments - level design tricks to keep people playing, ways to dynamically adjust difficulty so as not to discourage people, etc. You could apply more linear concepts at the same time as well. For example, your game may use DDA in conjunction with a linear difficulty scalar so it consistently increases in difficulty over time while slightly lowering or raising it at certain points based on the player's performance. 

I'm working on a strategy game. It's turn-based and card-based (think Dominion-style), done in a client, with eventual AI in the works. I've already implemented almost all of the game logic (methods for calculations and suchlike) and I'm starting to work on the actual game loop. What is the "best" way to implement a game loop in such a game? Should I use a simple "while gameActive" loop that keeps running until gameActive is False, with sections that wait for player input? Or should it be managed through the UI with player actions determining what happens and when? Any help is appreciated. I'm doing it in Python (for now at least) to get my Python skills up a bit, although the language shouldn't matter for this question. 

Ray casting is a very fast and efficient way to determine line-of-sight. It basically involves sending a ray (think of it like an infinite laser that can't be redirected) from a certain position in a certain direction. Using this ray, you can determine things like which point(s) it intersects and how far away from the origin it was when it crossed a certain point. So for example, in a player/enemy scenario, the ray could originate from the enemy with the direction being the location of the player. If the ray collides with a solid tile, the enemy can't see the player. If it doesn't, the enemy can see the player. Here is an excellent tutorial that will should help. You can also consider Bresenham's line algorithm (summed up, it creates lines) for something that might be more easily scaled to tiles. 

Going off this information and the fact that were will likely be several hundred objects rendering on-screen at any given time, my question is as follows: Which method is likely to be the most efficient/optimised and why: 

I've created a tetrahedron by creating a BoundingBox and building the faces of the tetrahedron within the bounding box as follows (see image as well): 

To make things easier, I would probably cut the requirement the algorithm should be able to generate tracks of different lengths. Since you've specified a range, it will need to keep track of the length anyway. You might as well pick one before, at random if you like, keeping in mind the starting and ending locations determine whether the length will be odd or even. Imagine a checkered board to see why. Start out by drawing any one of the shortest possible tracks. If it is too short, select a random point on the track, then a second point a few nodes (Q) beyond the first, break up the track in between, and redraw the section using the two points as start and finish, but this time with a length of (Q+2), for instance by moving up at random until the traveled distance plus the minimum distance between the current node and the finish equals (Q+2), and start moving one tile in the direction of the finish every step after that. If at any point, you get stuck, revert to the last valid track and try again. This algorithm will probably try to draw a lot of invalid paths, but leaves a lot of room for optimization, allows you to balance efficiency against 'flatness' of the probability distribution of all theoretically possible tracks, doesn't use relatively expensive tree searches and scales well, because you can make the redrawn sections as small as you want. 

As drawn, full power to thrusters B, D and E will maximize the rotation, but will also accelerate the ship to the right. Shutting down D will prevent this. If instead, accelerating right is intended, but a clockwise rotation is not, the most efficient way to go is enabling both C and F at two thirds of full power along with D. If this isn't beyond the scope of what you're trying to do, you would have to write some sort of solver for the equations of motion, clearly not a simple task. 

The yellow line indicates the intended behaviour. You can see the blue line (timesteps of 0.1) starts with the right slope, but isn't updated for a while. It's a little high, but doesn't cause any major issues. The red line has more time in between steps (0.2). By the time the slope is updated, the rotation has overshot its target. There are more elaborate ways of tackling this problem, but you are somewhat handicapped by the fact that the target rotation might be changing too. The simplest way would be to specify a range around the target where the rotation is 'close enough' and should stop moving. How large this range should be depends on your timestep and maximum angular velocity, but I suggest some experimentation. 

Using a single quadtree with boolean checks for collision between the different types of objects. Using three quadtrees at once (player, enemy, environment), only testing the player and enemy trees against each other while testing both the player and enemy trees against the environment tree. 

I understand the concept but applying it is another thing entirely for me. And to clarify, I'm not wanting an animation, I simply want to create an icosahedron from the vertices of a tetrahedron. EDIT: So I now have an alternative way to create an icosahedron using golden rectangles. That's fine for the purposes of my particular project. However, I'd like to leave the question open for solutions to the original problem, i.e. mathematically converting a tetrahedron in Cartesian co-ords into an icosahedron (not vice-versa). 

Seeing as javamonk has already linked some good technical articles, I'll try to approach this from more of a theoretical angle. 

I'm creating a highly flexible 2D tile-based map editor in XNA to make some of my future projects easier (will work for side-scrollers and top-down games). This editor can work with any sized tile. This editor is based on a standard system. It has pre-determined layers such as Base, Fringe, and Collision. However, I've run into a bit of a problem. I don't know how many Fringe layers to use. I'll be working with fairly detailed tilesets and will want enough Fringe layers to be able to render a wide variety of fairly complex scenes (e.g., forests with lots of trees overlapping). I'm also considering having multiple Base layers to enable things like a player walking both over and under a bridge. So my question is this: Is there a "right way" to approach this situation, and if so, what is it? Just lots of Fringe and Base layers? If you were a map editor, how would you expect/want this situation to be approached? Also, while I have this question here, is storing layered maps in 3D arrays a good way to go about things? Meaning the first level is an array of layers, the second is an array of tile columns within the layer, and the third is the array of tile rows within the column. 

I know that I personally always prefer to have complete control over the flow of dialogue, except in real-time situations. I get annoyed when a game prevents me from reading at my own pace. One major plus for me is when games have a setting that changes the default speed at which text is displayed on the screen. One possible approach to your specific situation would be to implement manga iconography (or something similar) to convey emotion, while allowing the user to control the flow of dialogue himself. Admittedly, whether or not this is feasible depends on the style of your game. 

Here, F is the magnitude of the force generated by the thrusters, rx and ry are x- and y-components of the vector from pivot point to thruster. Positive torques tend to rotate the ship counter-clockwise. Using the four formulae above, it is trivial to deduce the sign of the torque each thruster produces. For a modestly accurate representation of physics, you need not only know the sign of the thrust, but also its total magnitude and the rotational inertia. Moreover, you might not simply want to activate all properly aligned thrusters to do a rotation. 

So you're looking for a parabolic function y(x) that equals zero at two known points. Let's call those points r1 and r2, after robots 1 and 2. One solution is easily found: y(x) = ( x - r1 )( x - r2 ) On top of the robots, one of the terms in parentheses becomes zero, which, multiplied by something else, remains zero. For that reason, we can multiply the entire thing by a factor a. This stretches the parabola vertically (or flips it upside down for negative values) without changing the location of the zeroes. We manipulate a to make sure the curve passes through the vertex, defined by coordinates (xv, yv). We solve the following equation for a: y(xv) = yv a ( xv - r1 )( xv - r2 ) = yv This yields: a = yv / (( xv - r1 )( xv - r2 )) We get the function y(x) we want by multiplying our original function with the scaling factor a we just obtained: y(x) = ( x - r1 )( x - r2 ) yv / (( xv - r1 )( xv - r2 )) 

Only in exceptional circumstances will players notice or care about the accuracy of your physics simulation. Most games fake calculations like these, which has several advantages; fake calculations are easier to code, computationally less expensive and most importantly, they allow the behaviour of the game to be tweaked in favour of fun rather than realism. If playtesting reveals physically accurate bullet drag is less appealing than some other model, faking it becomes a deliberate design choice. If you still believe realistic drag is an important feature for your game, here's a bit of physics. The drag equation can be solved analytically, though if you should want to involve other forces on the bullet, you require numerical integration. Combining the drag equation with Newton's second law of motion, we get: m v'(t) = -½ v(t)² ρ A Cd, the solution of which is: v(t)=2 m / (ρ A Cd t + 2 m v(0)-1). This gives us the bullet's speed as a function of time, not of distance, but we can integrate v(t) over time to get the distance travelled x(t), then invert that to get the travel time as a function of distance: t(x) = 2 m(eρ A Cd x / (2 m)-1) / ( ρ A Cd v(0) ). The many symbols in this formula obscures its relatively simple exponential nature, which becomes apparent if we simplify v(t(x)), the speed the bullet has when it reaches x: v(x) = v(0) e-(ρ A Cd/ (2 m)) x. The plot below shows the bullet velocity against distance with the parameters you supplied (air density: 1.225 kg/m3; bullet radius: 11.43 mm; initial speed: 251 m/s; drag coefficient: 0.45; mass: 10 g). 

This example is far from perfect and it would have to be adapted to any specific needs, but it should help. 

From my experience, mass is either: a) A global value that applies to all spatial objects equally (or no mass scalar at all). or... b) An individual scalar value (e.g., pounds, kilograms) directly associated with each individual object. This approach obviously doesn't scale well. or... c) Defined by a base "type" (e.g., wood, rock, water, flesh, weightless...) with a scalar value associated with the type. That value could be used on its own or it could be used in conjunction with the size of the object to determine the final scalar, depending on the accuracy required. Not sure about the Frostbite engine but I would assume it uses something similar to c). 

I have no clue what I'm doing with regards to events. I know how to use them but creating them myself is another matter entirely. I've also made buttons without using events that work on a case-by-case basis. So basically, I want to be able to attach methods to the OnClick EventHandler that will fire when the Button is clicked (i.e., the mouse intersects Rec and the left mouse button is clicked). 

What would I then have to do to transform this tetrahedron into an icosahedron? Similar to this image: 

As the title implies, I want a Button class with an OnClick event handler. It should fire off connected events when it is clicked. This is as far as I've made it: 

Arcade game difficulty... From my own personal experience (not sure there are many or even any articles to back this up but I'll keep looking), arcade games are almost always consistently incremental. Every level the enemies get a set amount stronger, they move a set amount faster, the timer is shortened by a set amount, etc. There are variations to this, like when entirely new enemies or other gameplay elements are introduced at certain points, but in infinite games these will run out eventually. DDA (Dynamic Difficulty Adjustment) is an interesting difficulty concept that can be found in some arcade games. One good example is Astrosmash. The game gets progressively harder in the form of more and more asteroids, but it can also get a little easier for a short time if the player is struggling. One example of purely linear difficulty (no DDA) in an arcade game is Robotron: 2084. As the player finishes the levels, enemies progressively become more and more difficult with more and more of them appearing in each level. The game was specifically designed to be extremely difficult and yet people have still managed to "beat" it (after 255 levels the game reverts to the original screen). Not because the developers specifically made it so that it could be beaten, but simply because some people are dedicated enough to do so regardless of the odds (barring the literally impossible). On that note, if you haven't already, check out The King of Kong. Sort of relevant and offers a bit of an insight into the minds of dedicated arcade gamers who set out to "beat" games (or in this case, high scores).