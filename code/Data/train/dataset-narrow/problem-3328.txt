Well, it's implied that _BSD_SOURCE is effectively set/used by default (in the library). Linux unofficially aims for POSIX compliance, which doesn't help here much because POSIX just says the behaviour on this is implementation defined, probably because POSIX does include , which is what you are explicitly supposed to be using if you are concerned about standards, the predictable behavior defined in standards (and redefined and refined in later standards such as POSIX), etc. If not, then who cares. Use the wrong function and leave it up to the implementation. Sort of interestingly, trying to undefine : 

Yes. More specifically, it will go to ground, but along the way it will affect the state of the high-Z floating input GPIOs. WRT "floating": This is akin to a disconnected wire, except there is some clever circuitry involved to sense whether the disconnected wire is in fact connected to something with voltage. Going with a water analogy, if you have a dead end pipe connected to another pipe through which water flows, pressure will mean the water will likely fill the dead end pipe even though it cannot go anywhere (which is why it has "high impedance"). Hence a sensor in the dead end pipe can detect the pressure in the system overall. If you are careful to make sure the GPIOs are never set as outputs driven low, you can do without R1 - R3 & R8. 

How easy this is depends on how works. I don't have my camera connected right now so I cannot check without digging into the source, but it is probably easier for you to just try my suggestion yourself. The camera does have a device node, probably if there is only one camera connected. If uses this, should indicate whether any userspace processes are accessing it. However, using hacks on instead of kernel drivers is a common practice on the pi, and if does something like that, there will be no way to tell when it is running unless you just look for an application with that name (e.g., ), which is only a problem if you are worried someone is going to use the system and try and circumnavigate your check, since that would then be as easy as copying and running it with a different name. As for doing this programmatically, running on leads me to believe it actually checks all the file descriptors for all running processes via (which is probably why it is sometimes used with the setuid bit set, or else will not provide all the answers to an unprivileged user). You could do something like this yourself, or just parse lsof's output. For more information, see . It is a widely used tool with copious online commentaries. 

Any differences you see there will probably be due to the wifi adapter (if the pi rebooted, that's a complication, but it could still likely be true). If the first one in particular shows stuff, you are probably in luck, because it means the kernel includes drivers that should work with that adapter. Next: 

There are no pins that are set as outputs driven high for the simple reason that it is not a good practice; of course it is still possible to leave something wired up the wrong way, turn it on, and short something out, but the chances of that happening are much less if there are not an arbitrary number of general input/output pins set by default as +. 

1. Except for a brief note just added by me. I've observed this with the 2 as have various other people here over the past year. 

You also need to be root to do the writes (). Anyway, relative to the above directory, to see the available governors: 

It's not something that is going to show up like this. Where it might show up is occasional misreads; if you try to push the Pi over 1 Mbps you may notice this (although I also think the implementation could catch the potential and throw an error, I don't know if it does). UART timing is done with hardware clocks that may have some miniscule skew relative to one another. However, that potential, miniscule skew is not something that could have a cumulative effect over the course of hours. The clocks run faster than the actual transfer rate; a rule of thumb you may find with regard to implementing a UART interface is that the clock should be at least eight times faster than the bitrate -- it's probably still pretty feasible at four, but less than that and it won't work. Or not well and not for long. To explain: If there are (at least) 8 clock ticks per bit, and one bit is a continuous pulse either high or low, it isn't hard for a patiently waiting receiver to sync when it arbitrarily receives the start bit of a transmission. Further, even with 8N1 there's two extra bits per byte which always follow the same pattern for this purpose (last bit high, first bit low). I've done this with an FPGA and so has this person; have a look at the diagram at the top there, which is much like this one from Wikipedia: 

I have not used Xbian but, since it is based on raspbian, this is probably how its image is too. If so, you need to write that image to an SD card (as you already have) and copy the second partition from the SD card. But do not boot the SD card to do this. Windows doesn't even see ext partitions, last time I checked, so you will have to insert the card into a linux box, look at it with to make sure there are the two partitions there, then the 2nd (ext4) partition and squashFS it. It would probably be a good idea to start with the image freshly installed to the SD card, or to boot it and shut it down properly first. If you don't have a linux install you could use a live CD from ubuntu, fedora, et. al. I believe there are ext tools for OSX -- technically, you don't need to read the partition anyway, you just need it recognized as a partition and use some block level copy tool like . 

Yes. Bus connections require a common ground because they require a common voltage, and since inevitably the circuit on both sides are electrically powered, any connection between them requires a common ground. In this case the hat is being powered by the pi and a 3.3V and 5V pin are indicated, as are the grounds, which may imply that they are all also connected on the hat -- but you only require one since it is very very unlikely there are independent circuits on the board. 

Then run . This may take a few minutes. Searching for the package should now show it, and you can try . You may have to pull in further substantial updates from jessie. 

I suppose it could be a combination of both, although my problem with the wifi dongle persists regardless of the size of my power supply. If you need to be plugging the USB reciever in and out, you'll have to use a hub. 

No SD card is not exactly an error, though; in that case the ACT light will never flash or glow. If it does not and there is an SD card in, the card reader may be broken -- or maybe you did not quite push it in all the way ;) 

Their github page makes it clear this is a node.js based application included in a (slightly) customized Raspbian distribution. I would guess based on skimming through what's there that it is not a fully independent distro but rather one where changes have simply been made to the initial image, and thereafter it will just be normal Raspbian. So no, you will not have to give up something as fundamental as terminal access. 

Convention, convenience, and efficiency would be the obvious answer. How long should they be? If I sell you a $5 device with 10' of lead on it, a significant portion of the cost will be that wire and 99% of users are just going to chop it and save (or throw away!) the extra wire. You need enough to keep it simple to use and that's it. 9" is plenty; if you want more you can attach more. Obviously just don't keep wrecking the ends and cutting the wire down until you have none left, although even if you do likely you can open this up and solder some to whatever's inside easily enough. If you solder the wires together (note you may not need to, although stripping and twisting thin wire may break if you do it repeatedly -- a caveat about soldering is it will tend to melt the plastic unless you can cleverly sink the heat before it gets there), desoldering braid and a magnifying glass will help get it apart. 

To see if this is being logged to file to, then you could have a look in the file to see if anything else pertinent was logged at the same time. 

You could try a piezo sensor. Mine's still in the drawer awaiting some free time, so I don't have any experience yet, but the idea is they can both generate and respond to vibration or pressure. You can get very inexpensive ones from any electronics supplier. Piezos are used as pickups on acoustic instruments such as guitars (although an electric guitar pickup is not a piezo -- they generate an active EMF). A banana is probably not much of an acoustic instrument, but if you can wrap or coat the piezo in something and put it inside the banana, something might be made to happen. I think a simple touch would be too subtle, though. 

Ideally, the logic and the implementation of something like this, on the server (pi car) side should be independent of communication protocol used. I say this because it means you could develop that on its own first so that it doesn't need a direct relationship to a server at all; you just in and control it that way. You could then develop that into something that will work with a simple custom protocol over sockets that you write a basic TCP/IP server and client for and/or something with a web interface. I.e., the core program/API for controlling the car should be independent such that it could be used with any of those interfaces. So you do that first, probably using ssh for development, and then, since you've left yourself that freedom, decide where to go. The preliminary interface would just be something you can start from the command line and then hit keys for control. 

That's for 115200 baud; generally the constant is predictable that way (e.g., for 9600 baud, for 1 Mbaud). They do not have to exactly match settings in , but they are limited to a standard set.1 Going beyond 1 or 2 million on the Pi may be tenuous and result in lost bytes. At or below that, with a solid connection, it is pretty reliable. That struct is now associated with the fd: 

This should show you a few things most of which are internal (eg., the pi's USB hub). See if it looks different with the mouse plugged in vs. unplugged (a mouse will usually be pretty clearly labelled). Next, unplug the mouse and . Then plug the mouse in and do exactly the same thing. This shows you the last 20 lines of messages sent to the system logger; it includes stuff from , which is from the kernel. It may indicate some kind of USB error. 

Ideally the logic of the relationship should be such that the Arduino can be easily reset by the Pi in the event of some condition such as this. As in, via a connection between a GPIO on the Pi and the reset pin on the Arduino. By "ideally the logic..." I mean something that is probably pretty simple, since if the Pi can't be sure of what's going on with the Arduino, then likely the only useful thing that can be done is reset it anyway. And a hard reset is bulletproof. You don't have to restart the python program on the Pi, so it can maintain state, know what the Arduino is supposed to do next even if the Arduino doesn't, and that division of responsibility should be clear; whatever the Arduino is doing, it should be functioning as something with little or no need for long term accumulation of local data (especially since it doesn't have any potential for such) or long term independent changes of state, meaning having it stop and start again should't matter much (especially at the point where what it's actually doing in relation to the Pi has become ambiguous, perhaps very wrong, etc). Where it restarts from should, by definition, be a known state, and whatever states it's capable of should be ones it can then immediately be put into by the Pi. Looking at your problem, if it were me, I'd start by blaming myself, i.e., assume I've done something wrong (likely on the Arduino side) that I've missed. The arbitrary reset is a ham fisted and not very satisfying solution, but: 

Make sure that file remains all one line. Parameters should be separated with spaces. You'll probably notice is already there; these are not the same thing. From (these are actually parameters that are passed on by the kernel to init, i.e., systemd): 

To run an Android app, you need an Android userland; you cannot run them on a GNU/Linux system except with the use of an emulator. Even if you could get this to work on a pi, it is going to be too slow to be worthwhile. It is noticeably slow on an a big x86_64 desktop; the emulator is intended for development purposes. You could install an Android userland on a pi. Since there are few if any ARMv6 Android devices, finding such a userland will not be easy. It is open source and can be compiled however, and people apparently have done this (see here halfway down), although it sounds like it is a pretty old version (2.3) -- but of course that article is two years old. Android on the Pi 2 is much more feasible; besides the architecture, a big issue with Android is fitting it usefully within 512 MB of RAM. 1 GB, though, is enough. I'd assume sooner or later this will happen.1 Razdroid is project which aims to port Android 4.0 to the pi, although it does not appear to be ready for prime time. 

On Debian (derived) systems, the file references . What this means on a normal such system (e.g., desktop ubuntu) is that takes precedence over the hardcoded paths in point #4. But the base libraries on raspbian are arranged a little oddly -- e.g., libc is actually in a non-standard location, . This and a parallel directory in are listed in the file .1 Consequently, since that file sorts lexicographically before , these standard libraries take precedence over anything in . Not a very nice choice to make, since this inverts the common practice precedence on Debian. Anyway, to fix that (as root): 

Unless whatever is on the other end of the FTDI cable is sending data to the pi then this will do nothing but wait for something that never happens. 

The directory on the second, larger, ext4 formatted partition is a mount point for the first, smaller, VFAT partition when the system is running. So, if you stick the SD card in another computer and look in on the second partition, there should be nothing there. If there is, it won't serve any purpose as it will be hidden and inaccessible underneath the mounted filesystem once the system boots. In case this isn't clear: don't bother to put anything there. The you are looking for does exist, but it is on that first partition, not the second one. 

As Loko says, it depends what you want to do. You can connect the GPIO pins to a breadboard, and then connect individual electronic components to the breadboard without doing any soldering. The arduino and the pi are the same in this sense. I imagine you can go a long way in learning the fundamentals of electronic compenentry doing just that. Soldering is necessary if you want to make a more permanent assemblage, or if you want to connect another board that doesn't already have breakout pins attached. This would include various small sensors, complex arrays of LEDs, etc.