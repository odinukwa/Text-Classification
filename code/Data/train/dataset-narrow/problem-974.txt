And this will save you lots of time for redundant calls to here. is true only generally. Use which gives that guarantee, and then makes sense. Or better yet divide by . That way nothing is going to surprise you in the future. I'd also avoid calling every test together: 

You're just wasting time here by searching memory to reallocate. Since stl container call default ctor your above code could be replaced with: 

Make a switch statement and call only one of them per run, so as to avoid compiler further optimizing the switches between those statements. If you turn off optimization flags, then you'll get quite an interesting picture of what's happening but your insights wont be applicable once the optimizations kick in. I think its true that measuring timings without optimization flags set to true is quite pointless. 

usage: My output of for every case after trials was always 85899345920000, which is incorrect - due to wrong specifiers - . Correct ones are if you declare and as long long. Why not use i wonder? Using for division results. Then again after fixing this in some cases of a small container with few elements i've kept getting . Thats not good, so you'd want to use a floating variable to store the duration divided by . Otherwise the precision is reduced due to implicit conversion of the division result to integer. Preparing for measurement. Also as this part goes: 

Your loop has a potential complexity of R * M (R number of words in ransom, M number of words in magazine). Additionally you use in the inner loop which which does linear search in magazine. The solution is to count occurences of words in both, magazine and ransom. this is done in a single sweep and of linear complexity R + M (dict get/set is average linear). the moste dense and readable solution is 

the first definitely do not belong there, this shall be done in main or in a UI. for the latter if no user interaction is required this could be logging. if requred it should be done on the dedicated UI. getting the message there could be via return values or more pythonic via raised exceptions. so we remove the print from 

unfortunately we find a big bug - if fails we switch user (and run out of player indices). we fix that later. we continue with 

we also fix all the column indices in (where we find 9 winning cases which is one to many). Do not repeat yourself now we have a close look at as it looks now. 

So, did you actually have a question? Yes, I did. Firstly, is there a name for this variant of the visitor pattern? I assume that I will not be the first person in the whole world to think of or implement this. And I assume that with the collective wisdom of all those who have gone before that this class can be done better. Secondly, if this is not the case, then is there a way I can do this better? Doubling up the visit methods seems wasteful, but I always get stack overflow exceptions when I try an implementation without it. Thirdly, I am concerned about type safety. In the toy example all the composites contain base . In the real-life code most that contain another hold a derived type. Is there a way of making the visitor type safe so that no upcasting is needed? I couldn't find one - but that does not mean that it doesn't exists. And if not, is there a way to make it easier for a developer to write correct code. This looks like a powerful pattern and as Uncle Ben* said: "With great power comes great responsibility". If it is not possible to make it provably typesafe according to the compiler, then the code should not get in the way of writing correct code. 

Proper error handling so now the big bug. if we cannot place the player in we switch user. if something is an error report it to the caller. that does not mean to print something to the screen but to return an error condition or raise an error. Output to console shall be done from main only. so we refactor to return success and remove the print 

Before adapting we have a look at the names which are not reflecting reality. the loop shall be because it is a single row. likewise should be as there are several data/spacing/separation parts in there. That said we change to (still not perfect) 

If you want to design a class you have to remove the from it. then you notice there is a little problem with the which forces you to expose internal implementation details to the main loop by requiring a call to as well. by the way does the job correctly, one input resulting in one call to the board. ensure functions/methods do what the name promises does not rotate the board, but a matrix only. it would make a perfect name for a method of a matrix class. a board method should do the complete job and apply the gravity as well. reuse what you have you could insert tokens on the top only and use to let it fall down. not only this resembles physics, but also there is less code to test. shows high complexity and repeated code. handle errors your does detect an error if a column is full. however it does not forward this to the loop, so the player is turned over. separate I/O from core do not do I/O from core functions, but from main loop only. this requires providing state and error information to the loop by return values or raising exceptions. or by providing getters for state. this will immediately lead to better design and testable functions. there shall be no magic numbers in the code, define constants when you decide to go for a 9x9 instead of a 7x7 board, there shall be only two edits. you make it worse by having those numbers as attributes, but you do use them only for drawing. when checking for wins, applying gravity or handling input you have raw numbers in the code. this is the worst possible combination, pretend to handle your constants properly in the but ignoring these later on. seriously, this is an absolute fail. also have a definition for and write correct expressions for all the dependent values subtracting it from or . some python sugar 

It calls the copy assignment operator and copy ctor without dtor. And you're spared the calls to .at operator and incrementation of . Though even if you leave it the timings will be quite close. Such alteration seems more or less close to your broadly stated purpose. 

and inside the loop add then by calling after the loop you should get the actual number of distinct memory location used by first element. Answer is 2. One for container and one for copy. In a real life application you'd probably copy the container and let it be consumed by some other function, meaning that a call to would probably have to allocate a new space for copy's elements on the heap. So while moving the stack pointer up down is a single instruction, what can become a bottleneck is allocating new memory on the heap. So with this in mind, if you provide a copy ctor that wont really help measuring imo. I'd try to narrow down your request. What do you actually want to measure? Copy of arrays with dtor? Without dtor? Memory reallocation on the heap? If you declare outside the loop 

You already got some advice on coding style. however there is a big flaw in your algorithm which is not addressed by the accepted answer. you try to iterate downward to get an effective implementation but you got the inner loop wrong. while you expect the outer loop to do few iterations your inner loop does check relatively low numbers early. you tried to limit that by stopping the iteration at 900, a magic value without reasoning. so your implementation may give wrong results as a pair of 901*901 is much smaller than a lot of untested pairs. you need at least a check if your product is bigger than the biggest untested one 999*900. on the other hand if we do the inner loop right all problems are gone. we use the outer loop for the lower value and the inner loop for the greater one. we do not need an arbitrary limit any more and we are quite efficient. 

comments and docstrings in you use a parameter choice which is one-based. this is not common and not mentioned in the docstring. so while there is a 6 line docstring one of the most important facts for correct usage is not mentioned. While your parameters and return values are listed by name there is no hint about the correct type nor the value range. 

is the abstract base class for all visitable classes, and has an method. and are concretes that are extremely simple. They don't do anything, but just represent that there can be different types of leaves. and are also concretes that can contain other - either a collection, or a Left and Right (respectively). The method overrides handle recursing to the contained . I also have some Visitors that visit each of the . All vanilla GoF visitor so far... (I'm not looking for feedback on this class hierarchy, I'm just setting the scene with a simplified version of the real classes that I am working with). What I want: I would like to use a visitor to alter the structure of the tree. For example, in this toy example I might want to append a to each composite element, and if the composite element is a to convert it to a before (and also recursively visit all the children of each composite element too...). 

The vanilla visitor does not cope with this well. When you visit an you can alter the content of that but not return a completely different . I could check the children of each and as I visit them to see if any of the children need to be transformed from a to a . However, this would violate the DRY principle as the check would have to be in both visit methods. This would be compounded by the fact that in the 'real' implementation there are many composite type elements - not just 2. Finally the code: DotNetFiddle (sorry for the terrible ToString implementation on this one) or download csproj/zip from dropbox (no terrible ToString, just put a breakpoint in the the end of the main method). I have left out some "clutter" bits of code from the snippets below. There is no error checking or null checking. Base classes (I've not included as it would also increase clutter. All of the methods on are on ): 

still there is an if clause which we could make shorter. there are numerous techniques to toggle/select/cycle values from a limited set. here i am tempted to use a very lazy one (as the number of iterations is small) 

it is clear and readable and tells all and shall not be done any other way. Now about sorting a . You rely on a 3.6 implementation detail that will be guaranteed in 3.7 when released. whenever you do such a version-stunt you shall check the version and either raise an error or implement a fallback (e.g. ). However when 3.7 will be released there might be a sort for implemented as well. Your solution is most likely becoming obsolete when becoming legal. About coding You define an inner function for no reason introducing a lot of complexity. In your inner function you check the existence of an outer to decide on returning a , that's awful. You mix and exception handling in for control flow. your clause is a completely regular case. You shall not implement a silent fallback to sort by string (or whatever the type is) when the user requested sorting via . this is a complete fail, hiding a user error and presenting false data as regular result.