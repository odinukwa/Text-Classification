You might be overcomplicating a bit by reaching further than you need into builder mechanics. If you rewrite the signature of to 

Option is not an appropriate type to return here. There is no doubt about whether a particular input can return a result or not; anything below zero will fail, anything above it will succeed. For once, failing hard is acceptable in the case of invalid input. if...else if...else if...else chains are fragile and smelly in any language and really never necessary in Scala. Here, you are testing on precisely the same value each time. Use pattern matching. 

One way to do this would be with a trait or abstract class defining the basic behaviour of a check. Then you extend that for the actual checks you want. 

Returns a list of two maps. If sorted by size, the map with fewer keys will be first in the list. This done, point 2 (loop updating mutable variable) could be made more idiomatic with another for...yield block. Putting these together, one way of addressing my points is this: 

Similarly, the second transformation could throw an exception if the input doesn't match and the third could complain if the divisor is 0. Another way to add useful information to error reporting would be to add as a new, first transformation so that the number of the line in the file is available. Note that combining two or three of the transformations into one would make the error-handling pattern matching more complex and fragile, although not combining them would make it more complex to report the line number and line content if the failure was in the later transformations. There are more functional ways to deal with errors but that's a more complex topic. 

You haven't actually implemented a binary tree. But I'll make some points about your existing code before explaining what is missing. That's not a node, it's a tree 

My final two observations... Firstly, you should have an apply function in the companion object, so that you could create a CrockPotTree like this 

(If you use a trait rather than abstract class, you also have the choice of making some functions concrete in the parent trait). Option 1 is the functional approach as seen in functional languages which don't offer OO. I've written tree types in Haskell code and that's just how it is done there. Option 2 is more OO (pattern matching goes away because each case class knows how to deal with itself) while still being good functional code if you do it right. Option 2 is the way most functions in the Scala collections library are done. Ironically, your function is very much Option 1 style despite the fact that you put it into the class. It could be moved into the companion object with almost no modification, because it doesn't use polymorphism properly. Since I have already given an example of how walkTree would look in Option 1 style (which is how your code is effectively done), here's how some simple functions would be done Option 2 stylee: 

Once you have these classes and created each object, your game could consist simply of a loop which takes the first situation, runs its method and then runs the of the returned situation and so on. Note that I haven't told you which kind of collections to use for any of those fields. Lists, arrays, sets or maps could all be used. Which do you think would work best for or ? Another question to ponder is "What if different decisions (in the same situation or in different situations) have the same result, leading to the same situation? Would that need changes to the Situation or Decision class?" In my simple suggestion above, Situations describe both the action of the decision you make and the situation you are in after the action. If you think about this carefully, you will realise that what I haven't explained is how you would end the program. There are several interesting ways to do that, but rather than just give them to you, I think you should refactor your game to make it use classes and then try and solve the problem yourself (maybe asking for help on a StackExchange site). Once you have working code, come back to this site and ask for a review. EDIT OK, I'll give you a hint for the simplest solution - a which has in the field. But I think that is the worst solution. There are much better ones. 

This style is more expressive and less fragile than your imperative implementation. Make functions generic Later I'm going to argue that arrays are no benefit at all anywhere in your current code, but my point now is that should not dictate that it be passed an array. janos's solution only really requires a - and so does your explicitly recursive solution, as discussed elsewhere in this answer. Janos's solution could be rewritten as 

Which hopefully makes the structure clear. If your framework works with yield, all you need to do is add @ in the appropriate places. If it does not, you might have to do something like this: 

It should be clear that this is simpler. It separates the business of matching the sublist to the current list from deciding whether to return a definite result or recur over the tail of the list. In the latter case, we recur using the outer function, not the inner, making it easier to backtrack and maintain appropriate state (recursion does this for us, simply). I only used pattern matching and recursion in the second half of the function to make it simple and obvious. I would prefer to fold over the list and to apply fold or map to the Option[Boolean] result, but I don't know if you have covered those subtleties yet. However, because I have separated concerns in a functional manner, it is very easy to change either or both halves of my code to use fold/map. The outer function can be redesigned simply with no change to the inner function, or vice versa. EDIT: adding map and fold examples as requested Using map and getOrElse to replace the outer half: 

If you add those, you can also make EmptyTree and NonEmptyTree private, further protecting the soundness of your module. 

and nothing would break, because in Scala implements the trait. Any -derived type will have , so there is no reason for this function to demand one. That gives you much more freedom in the rest of your code. If you decide to switch from arrays to sets or lists, this function does not then have to be rewritten. Note: my pattern-matching variant on your explicitly recursive function can also be rewritten to be more generic. Can add an example if you want. sumFractions is redundant Your class deals with a particular representation of rational numbers. I've already mentioned that it might be useful (via implicits) to make them work with integers. However, if you go further and do the work to make part of Scala's Numeric type class, then pretty much anything you can do with a sequence of (or or other numeric types) can be done with a sequence of . If you do that work, you can simply replace with . Here's one way how