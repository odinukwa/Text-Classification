It records a user's bid on an item. You have to provide the bid and the item. Also, it might throw InvalidBidException (presumably because the bid is invalid). And it returns void, so I guess the recording is "saving" or something. There was no new information in the javadoc, as a result the javadoc is just meaningless noise. I don't blame you, from the problem brief you have no real business rules to describe here, but still. Don't put javadoc on methods just to tick a box. 

After this bit of code, you . There's an else block, but it's not executed if this snippet of code is reached. In that light, there's no other uses for and in this function. Additionally, was to begin with. So all that's actually relevant is to do this: 

Which divides the money like so: 1 for me, 1 for myself, 1 for I, none for you. 1 for me... I'd recommend in this case to fall back on relative percentages: that is, sum the percentages and then set the cut to be the percentage of the summed percentage. So 10, 5, 5 = 20 total, 10/20 = 0.5, 5/20 = 0.25, so it's 0.50, 0.25, 0.25. 

This I like. Higher order functions. Start inserting the entity, insert the child entities, and then finish up. Scrolling down, it's good that you did, because those three functions look pretty big. 

And it becomes easier to spot if you made a mistake (like if you accidentally swapped the win condition for scissors vs paper with scissors vs rock). If you want to learn more about that, I suggest googling about "enums" or "magic numbers". Additionally, we might want to use the style convention that constants are UPPER_SNAKE_CASE: 

To handle the undesirable cases, I've tried to use and/or to run the code in a process (then I can call ), but I'm not having any success capturing stdout/stderr. So my question is: What can I do to make this better/more robust to handle bad code snippets? (And yes, I know this is a bad idea in general; I'm running it in a virtual machine just in case there is malicious code in there somewhere) Python version is 3.5.3 

My Thoughts I haven't profiled any of these, but I'm going to assume speed is not a priority. I like #2 the best. It is clean and simple, and easy to understand what the code is doing at a glance. I think #1 is ugly, and the sequential array slicing makes me nervous and seems easy to break. If your number sizes change at some point in the future, this one would be the hardest to modify. I think #3 is better, but not as clear or concise as #2. 

Set Unions Looking at your code, when you loop through the attrs, you are breaking after you find the first key that is in and in and in the passed . This is also known as the of the arrays. As such you can simplify the inner loop with: 

Ruby has several ways to conveniently print text. First there is string interpolation. You use double quotes on the string, and use inside the string. When ruby parses the string the code is executed and the results replace the code in the string. 

This one is tricky. For now, I'd let it stay... is only two characters. But when you have an acronym, treat it as one word. That is, . This because you end up with class names like later, and reads a lot better than . Especially if you're not familiar with the acronym. Instantiating RemoteControl 

I'd start by sorting relevant lines. is defined as some value in a try catch, but then not used until 10 statements later. By sorting the statements you can say "this region handles fPath, that region handles..." I would give examples, but the code is a bit confusing right now. Lastly, once you have blank lines, I'd suggest migrating whole paragraphs to separate functions. The function as a whole is too long. A good start would be migrating and out of the function, as the listeners take a lot of vertical space. 

If both cases end with , then you can just move the line to outside of the if statement. In the else case of this if statement, you have this: 

You should make use of existing libraries where you can. In this case, you can make use of from the Collections API, and there is no need to go through the effort of creating your own linked list class. Looking some more at your code, LinkedList might not do what you want. What you want is a . That's why you called your variable that (). But there's also a that you can use. If you're concerned about memory usage, you should be able to reduce it slightly by getting rid of the boolean , because you never write to it. For performance concerns, iterating a tree is not a whole lot different than iterating a list. They should both be \$O(n)\$. But your LinkedList implementation makes it \$O(n^2)\$. Take a look: 

Make the base class meaningful Right now you've declared as a base class, but all it really does is set up your two variables. One way to utilize it more would be to assign a unit of some sort to the class (I've chosen Kelvin, but it could have been anything). In my version, stores everything as Kelvin. Any class that inherits from it only has to know how to convert back and forth to Kelvin (So Celsius<->Kelvin and Fahrenheit<->Kelvin). Later, if I wanted to add operators to add/subtract/compare temperatures, since the base units are all kelvin, everything is easy. You'll also notice that I've moved to the base class and the threshold temperature is in Kelvin. This gives all sub-classes the functionality without having to know anything about where the theshold is, and likewise the base class will always work without needing to know the details of a particular unit of measure. Finally, while I've used Kelvin as the unit for , the base class could have just as easily been called . 

I think you can add functionality to to make the common ancestor search more ruby like. (I can add a search by value later, if you want.) I've added a parent member that is set automatically, and I've added and enumerators to enable easy traversal up or down the tree. Note: Thinking about it, the search function needs a little more work in case node 2 is higher in the tree than node 1, but I am out of time right now. Let me know what you think. Testing indicates that this is not an issue. 

This part of your constructor could be moved to a private function . The rest of the code seems fine. There's comments you can make about various things like 

Type mismatch, "Num" implies numbers which are not strings, could be really helpful to explain this in documentation. Also, don't shorten function names like this. You're one step away from . Reduce typing via autocomplete, not text compression. 

If you build the string that changes dynamically, you'll have a much smaller section of code. You have 4 different things that may or may not be included in the string: - replaced substitutes - removed substitutes - delay characters - triggers replaced and removed substitutes are exclusive to each other. (but you can also have neither) Delay characters and triggers are ALWAYS in the string. So if you write 

will do. But in the future, I think this method will change to some where PlayerAction is an enumeration of actions a Player could take. 

That can be a function , where you determine or . Maybe it doesn't even add to the class list, it just gives you the class name. 

And then went on to show a picture of a grid. They're not talking about an Ocean. They're talking about a grid. You can't have the same grid represent two different moments in time, for the grid will have changed. You need two grids to make a timestep work. The last part of the sixth paragraph hammers this point home: 

This would allow a player to only enter a single digit AND have a visual guide. You could also make other visual changes, like drawing the board grid lines like I have (or even using extended ascii). Finally, you have one major design issue, in that you allow a players to overwrite each other. There is no logic to prevent a player from playing in a cell that has already been used. 

Update It occurs to me that there is a little more flexibility in this situation. I have a function, that accepts a the code submission as a string and alters it. Mostly I've been using it to swap out the value of some variables using regular expressions. Here is an example implementation: 

Dom2 was the fastest because it has the fewest number of operations by far. As a weak rule of thumb, when optimizing math, try to avoid BigNum and Float when feasible. Also try to avoid things like converting numbers to strings and then back to numbers. Conclusion Know that more often though, that your slowdown will usually come from lots of branching and flow control, and being inefficient (like calculating the same things over and over rather than caching them), and those are the places to optimize. If this problem were part of a larger, more complicated task, I can practically guarantee that your bottleneck would not be ANY of these functions, but something else entirely. 

Theoretical Code Evaluation Let's do some math to see how many operations you are doing. I'm going to use as my variable for whatever value you assigned to You have a loop that for every multiple of , it does modulus tests. For , the correct answer is 2520, so we can calculate that you code did For the correct answer is 360360, which is also the same number of operations performed. This doesn't seem too bad. However you are also calling every iteration. If you look at the source code for this, it loops through every value in the hash. This means that in the first iteration, the hash has one value and this is one operation. In the second iteration hash has two values (requiring two operations) but now we've done a total of three operations between the first and second iteration. In the third iteration there are three operations which makes for a combined total of 6 operations. After the fourth iteration we've done a total of 10 operations. This is a series of the sum of natural numbers and the formula for it is: 

This assumes pizza's always have bacon, cheese and pepperoni. Consider treating cheese, bacon and pepperoni as toppings (four cheese pizza? How would you currently model it?). You can then make use of streams and : 

By using the method, you prevent counting ALL the elements. This should increase performance, which is an improvement of the code. I don't know whether use of for such a thing is common in C#, though. If it isn't, you might want to add a comment. Additionally, in , you name the return variable . Shouldn't it be ? If not, shouldn't the method name be changed? 

You're constantly redeclaring the and variables, this is not needed. Use once at point of instantiation, then just simply assign to the variable afterwards. Additionally, you've gone through the effort of adding comments for signalling that certain parts of your code carry a separate function. That's good, but we can do better: actually turn them into functions. 

Your function causes a if the stack is empty. Consider returning as well, since that's the value you use for "there was no data". 

I tried hacking around this in various ways and practically the only way I could detect it was wrapped was by having an old reference to and using . Since you state your code will run before any other scripts will run, this shouldn't be a problem. That said, there's also , , , so maybe you'd want to wrap those too? From a code quality perspective, your variable naming needs work. You can haul it through a minifier later; what you have right now is unmaintainable. I don't even know what half of it does thanks to the variable naming. 

The name for this type of parsing is called the shunting yard algorithm. Your code itself seems fine, as long as you don't intend to support strings with curly braces, e.g. . The biggest issue I see is that it's not very ruby-like in the naming or formatting. I've made brief attempt at cleaning it up a little below. 

The BackgroundWorker.RunWorkerAsync() and RunWorkerCompletedEventArgs only accept/return a single object and you need to pass two (the block index and the block itself). You will need to either use a tuple/struct/class or something else to hold both objects when passing back and forth. Finally, You may need special handling for the last block of the file. Some encryption algorithms (zero) pad a short block to the expected length (1K in this case). This means that your encrypted file may be slightly longer than your unencrypted file. If this is the case for your chosen algorithm, your allocated output file size may be slightly longer than the original input. Depending on the file contents, this may or may not be an problem, however you should be aware of it as a potential issue. 

Shorthand if/elseif syntax You can use the keyword in conjunction with and to cut down on the whitespace of your if-eslif chain. The syntax would look like: 

New Classes Now there is opportunity for new classes, perhaps that reads the rules/substitutions, which contains a list of divisors, the substitution, and perhaps it supports the comparison operation <=> so that the rules can automatically resolve ties. There could also be an class for iterating through 1..100 and applying the rules. There are a couple of different ways you could define the classes or even the problem here. In general though, OO solutions to trivial problems aren't a good fit.