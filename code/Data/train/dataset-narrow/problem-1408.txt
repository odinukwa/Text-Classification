is the same as first handle specific cases and the the general case: this way augmented indentation concerns only the specific cases you can iterate over an empty (or even nil) slice use unpacking I don't think that initializing the slice capacity brings much 

Instead of creating you final slice during the loop, you could do two loops: one for creating the and another to turn it into a slice: 

A major point is that you can only import parent (sub)packages. For instance your subpackage can not depend on the subpackage ( should only depend on the interfaces defined in - for instance). The only exception to this rule is your (or your tests). For instance, you import and and connect them : Since the implements the it is transparent for the package which expects a 

No, because the code you are talking about is not concurrent (the statement will run only one of the two loop). 

We actually just moved the issue : we now need to know when to close the ! The make sense here (a local variable is all that we need): 

Instead of an for , you could use a with and instead of and . You could then return this waitgroup, for the caller to do (but then you won't be able to know how many urls are currently in the work). 

This branch can simply be replaced with a condition at the very beginning to check if and immediately return if it is the case. 

Edit statement "extraction" (to fulfill @Mat's Mug's comment) In the original code, the only way to get to the is when is 0 and the is empty. 

And if you want to go further in python, instead of returning a list you can make an generator (which returns an iterator). The following should work fine for python 3: 

A first step could be to add docstrings to your methods: it helps your readers understand the goal of your methods and it help yourself know what those methods should and should not do. Then you should check the user input: I suppose, that the variable is a string. You should enforce it and raise a when it is not the case (for example a list of strings should not be accepted). I would rename the method to , to show that it computes a hash between 0 and 255. You currently store the actual values either directly or in a list. I think you should stick to one data structure: a list, or even better a set (it has and method just as you need). You could also use the same conventions as the set for your public method naming: , (and I would suggest instead of ). You could also implement some of the python magic methods like and 

Why don't you want to leak outside? I find it quite explicit. It seems that you are wrapping your errors with some context: there is a very nice package for this: $URL$ Using it, your code would look like this: 

As is, the (my) code is really hard to test (needs actual registry modifications or env variable edition). To ease the testing, one could change some functions: 

With this change and become self contained and can be easily tested! This incurs a minor rewrite of (which does only some plumbing): 

Use docstrings And then you might think that the way to call it is not trivial and want to document it: let's use a docstring ! 

You pass the to your callback, but you then continue inside the function: if you couldn't dial, why do you continue? 

If you have a multicore processor, this should improve the overall performance: instead of having 4.5s + 12.5s, it should be much closer to 12.5s (with some overhead for the first run and the synchronization) 

Is it expected, that even if some batches were sent in the meantime, a new batch will be send at 5 seconds? Shouldn't the timer be reset, when a batch is sent? Anyway, I would recommend you to put this in a struct, for instance like this: 

Miscellaneous Instead of printing each time, you could append to a You have good variable names, except for . Maybe is more appropriate? (or ). Simplifying conditions You could start your at 2 and your at 1.0, to get rid of the condition inside your loop (if is 1.0, then the loop will simply not be executed at all). 

(maybe could generate some tuples with the and , or even ) Usage You can then do a . If you have a list of data, you can then do . Plotting For plotting a limited amount of points, you may use itertools.islice 

Performance If you need to make your code faster, you will need to identify the bottlenecks. For this, I recommend you to profile your code : $URL$ 

As a further refinement, you could change the computation functions to be just and add helper functions to call them and fill the expected channel: 

Said the other way around, we do not return while is positive or the has some elements. We just write this sentence into the following code: 

What kind of extension ? Using iterators to get the samples For your input functions, you could use a generator instead: 

To really understand the blog post, I recommend looking at its example project ($URL$ - see also branch). Ben Johnsons posted another post detailing its steps: $URL$ Regarding the organization of your code, it would be like this: 

When you parse the URL, you just take the . If it is a relative link (or a ), you won't be able to parse it further. I might need to use the function (beware of names collision with your type) 

can be implemented with a dict of list: is just a refactorization (move the ... code into it) has already been studied by @Quill. 

You can do without the : As you mention, the main issue is to quit the properly. Since it is listening on 3 channels, it is quite complicated to achieve. To solve this, I recommend adding a which would (concurrently) receive the string to print from the 3 others channels and close once they are done. The becomes (it could actually be directly written in the ):