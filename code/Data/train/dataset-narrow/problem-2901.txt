The problem is neither of the conversion functions, the problem is the input matrix. It is not an affine transformation matrix, because the rotational part is not a pure rotation matrix, it has one or more flipping/negated axis in it. Only Rotation matrices can be converted to quaternions. More specifically rotation matrices are orthogonal matrices with determinant 1, other input matrices will give wrong results. A) The input: 

Although rotation-matrices and unit-quaternions both can represent an orientation/rotation in 3D space, that does not mean that negating each of its individual terms will result in the same geometrical operation. 1. Negating each number of a unit-quaternion There are always 2 unit-quaternions that represent a single unique orientation. One on each hemisphere of the hypersphere, pointing directly away from each other. In other words, each component of such quaternion is simply negated, however, both represent the same orientation. Here are 2 examples: 

Bullet's btCollisionWorld has member functions for ray casts and sweep tests: btCollisionWorld::rayTest btCollisionWorld::convexSweepTest Those should get you started, they are used in bullet's demos. 

will rotate and translate the world in a way, that the camera will be located at and looks towards the negative z-axis. This is the camera setup used in OpenGL. The camera actually never moves, the world does. Sound confusing? Hell yeah, let me try to explain :) Lets take this example: 

I like RuneScape's method (at least, the old method back when the wilderness was PvP). Most of the game world is only PvE, but up north there is a huge desolate area called the Wilderness; it's PvP. When you first cross the clearly-marked border into the wilderness, you see an icon in the corner of your screen and it reads "Level: 1". So you're in level 1 wilderness; you can attack people +/- 1 combat level from yours (combat level being your character's overall level, determined by a formula from your more specific combat-related skills). As you keep walking further north, deeper into the wilderness, the level keeps incrementing, and at any place in the wilderness you can attack other players who are +/- the wilderness level from your combat level. This introduces some interesting dynamics. First, a lot of wimpy people sat at the border of the wilderness, hoping to find other people that were just +/- 1 or 2 levels and then attacking and stunning them (so they can't move). Second, you have something of an incline; someone who is not so brave can stay in the lower levels of the wilderness and try to find people near their level. There were some good resources near the back of the wilderness (around level-40 wilderness); some rare mining rocks and high-level monsters for training. But of course, by going that far, you are risking that someone 40 levels higher than you can come and beat you down in a few hits. And of course, when someone does attack you, you can try to run south and retreat to a level of wilderness that is outside the "range" of your attacker's combat level. Nowadays, they switched it so that the wilderness is also PvE, but there are dedicated PvP servers in which the entire world is PvP. The only danger in the wilderness now are ghosts which are supposed to imitate the old PKers (player killers), but most players agree that the ghosts are much more powerful and have much worse rewards than PKers, so many people were upset by the change. I think this level system would work well in an all-PvP game, if the "wilderness level" was implemented as the distance from the nearest city's borders. So the no-man's land between cities is PvP, but cities are safe zones except for structured, agreed-upon duels in the streets. Then you can also introduce some cash sinks, by having transportation NPCs which will take you from one city to another for a price (for those players that wish to avoid PvP entirely). There should also be plenty of training zones where players can fight NPCs without the danger of PvP, again for those who don't want to participate in PvP. But really, at some point you must draw the line between players who never PvP (like myself) and players who only find fun out of PvP. 

You don't say anything about what your game is, so it's hard to know whether you should or shouldn't have such collectibles. Some platformers do have additional tokens to collect, and some don't. There's no tradition that requires they be included in a game. What matters is if they fit in how your game should be played. I imagine you're more likely to be able to think of games where there's some sort of reward for collecting them. Some games offer extra lives for collecting enough things, others allow unlocking additional features (areas, characters, all sorts of stuff). If there's a purpose to them, they can add additional replay value or extra goals for skilled players. The Super Mario Bros. games award extra lives (among other things depending on the title) for collecting enough coins, giving them a specific purpose and a reward. The reward for players skilled enough to collect more coins, is that they earn additional chances in-game. Mario games are more arcade-style gameplay, and the player benefits directly from being able to earn additional lives. Metroid, on the other hand, does not feature similar non-upgrade collectibles. Your tokens are either direct upgrades (new armor, weapons, etc.) or health and ammo. There are no extra things that exist solely to be collected. This doesn't hurt the game because the game isn't designed around the need for such collectibles. Both of these series are considered classic platformers, one has them, the other doesn't. The list could go on, of course... Look at the design of your game and determine what the purpose for collectibles would be. If you think your game would benefit from them, try it. 

None of those four discusses creating a history of experiences. I think this would be a good one; take Minecraft, for example. A whole community has arisen out of Minecraft because it is so open-ended that people build things and remember those fun experiences long after their physical (virtual) manifestations have been destroyed or deleted. They continue to have fond memories, and hopefully continue to return to the game. The same can be said of many games; it's not only how you are currently playing the game but how you have played it in the past that gives you a good feeling of fun and excitement even after hundreds or thousands of hours of play time. And very few games have that. 

From the way your question is worded, I get the impression that you think there needs to be one incoming port per player connection; this is not at all the case. Each client connects to one public port, whichever that port may be, and all communication comes in through that single listening port, even if there are thousands of players. There can of course be several ports open, but the main point is that each port can handle more than one simultaneous connection to or from it, so you need only open ports on your firewall corresponding to any ports that the game server listens on; this may be one or a few, but it should not be thousands of ports. On a low level, a "port" is just a number tacked onto a packet. The firewall can read it and drop the packet if it's out of your specified ranges, and the operating system obviously obeys it and hands the packet to the application listening for that port, but the network system doesn't care if two or more people send and receive packets over the same port. They're just packets, they don't somehow "collide" if they are of the same port. 

Here is another paper about it called "A Real-time Capable Impulse-based Collision Response Algorithm for Rigid Body Dynamics" from Florian Schornbaum. You can find that calculation at Page 23. 

The argument against glut in big projects is that you don't have access to the application loop, so you can't change it to fit your needs. All it has are some callbacks which are triggered from glut, but you don't have much control about it. However, the purpose of glut is to create demos and test apps easily and cross platform, without the need to deal with ugly OS code to create windows, its just a question of some lines of code using glut. 

If you are interested in programming the PS3's Cell processor with its SPUs, you can download the Cell SDK and the simulator for linux here If you have access to a blade-machine you can directly compile it for the CELL and execute it natively. It used to work with old PS3 OS versions too, unfortunetely they removed the ability to install linux. However, its fun and a great learning experience in case you like low level programming :) 

As explained in the comments, each physics engine will do it, so will Bullet. You can use btCompoundShape to create a rigid body from multiple "sub"-bodies, each with its own mass. 

Putting code into seperate Windows DLLs sounds promosing in theory, but in practice you should be aware of certain limitations. 

If you are using OpenGL, the OpenGL FAQ section 9: Transformations covers exactly how to do this. And no, it doesn't involve raytracing, as that's understandably a very inefficient (but high quality) way to accomplish this. 9.170 How do I render a mirror? Here is essentially what the FAQ entry says, and the example code demonstrates: 

Essentially, all the files at JogAmp can be found at $URL$ The latest build can be found at $URL$ I can't attest to its stability, so I don't know if it is a "latest stable" build or not, but I think it is. There's not a clear definition of what they mean when they suffix something with "-next". You can browse around other builds by just exploring the folders at $URL$ 

If anything I would go for a computer science degree; I'm doing it myself. But I am also pursuing a game development concentration. Whatever school you are planning to attend, you may want to investigate if they have this option; I highly recommend it! I will graduate with a computer science degree and all the same courses as any other CS major, so if I choose not to enter the game industry I still have all the education of anyone else with a CS degree. But I am also taking some game-related courses, which give me focused knowledge in game development. For example I am currently enrolled in a general game development course which is taught by the president and CTO of a local game company, so I'm gaining a lot of practical and real-world knowledge from him (as opposed to some other CS courses which can go deep into theory at times). But I'm also taking a course in software engineering, in which I am practicing Java and proper software engineering methods which apply to all areas of computer science. At the very least, do your research about the school you're planning on attending. Find out who the professors are and look them up; do they know their stuff? Are they in the industry or have connections? Are they IGDA members? Look at the list of courses and see if it appeals to you. Check out the area around the school and see if there are any game companies. All of these factors play a big part in figuring out whether the school has a genuinely great game development degree/concentration, or if it's just a gimmick because game development is the latest "cool" thing. 

Bullet has a build-in model/world-loader. Export everything in blender to and simply load it using Here is a wiki explaining the details 

You can render the normal game objects using perspective view, and then when the render func is done with that, switch to orthographic view and render your GUI or whatever it is, this way. Using glOrtho you can define your screen going exactly from left 0 to right 1 and the same for bottom and up. Since there is no perspective distortion anymore, those coordinates directly map to screen coordinates then. 

note, all 3 variables are 2D vectors here, they have an x- and an y-component, i.e. for this internal_pos [0.5, 0.25]: 

A) Yes, fake it Don't synchronize each bullet with a single shot sound. Rather play one sound having multiple shots in it as long as you are shooting. As long as your damage and impact effects code is setup properly nobody is gonna see any difference. 

As analyzed in the comments, the matrix was the inverse matrix. Inverting it gives the correct results. Here is the first example from the question: 

Even though the original GLUT is not in active development anymore, its still a good tool for its targeted domain, which is quick OpenGL testing and demos. It was never intended to be a framework for developing complex OpenGL programs. from $URL$ 

Multiplying their positions seems like an interesting approach but I am skeptical of it's ability to work in every case you'd want. There are, usually, many ways to multiply numbers to reach a common result which would give false positives (or surprisingly incorrect recipes). For example, , , etc. I think it depends on exactly what you need to match. If any types items can be in any orientation, just making a specific shape, you can treat each block as a boolean value ( if something is in the slot, if not) and write an algorithm to verify / values for the shapes you're looking for. (I can expand on this if you have specific shapes you'd want help identifying.) If you need specific items to be in a particular shape regardless of which item is where (like and in a ), you can use the above to verify the shape, then check the contents against the required types of objects. For example, if you've verified you have a , check the contents, find you have and in the inventory, then you have a match. If you need specific items in specific orientation, it's probably best to just maintain a list of usable recipes and verify them each in turn. If you need across the top row, check against a master recipe list that includes across the top row one cell at a time (also verifying the other cells are empty) and find you have a match. 

This isn't a question, so: yes! Also I'd recommend getting a personal website so that you can hopefully direct them to it, or even show it to them in an interview if there is a computer in the room. Make sure the website is as standard as possible; use HTML5 video and Flash (whichever one the browser is compatible with), and have screenshots in case the computer is so locked down that none of these are available. Also if you have a portable video-playing device (iPod, phone, etc.) load up videos of your portfolio and bring that! There might be nothing more impressive in an interview without a computer, than pulling out your insert device here and actually showing the interviewer your work. Also, one final note: there is a big difference between pretty and polished. It doesn't have to have stellar graphics; but the graphics that are there should at least look finished, not placeholders, no glitches or bugs, etc. Just because it doesn't need to be fine art, doesn't mean it shouldn't look like a finished prototype ready to present. 

Choose a random number, and then write an statement to return the appropriate new object based on the number. I'm not an ActionScript coder so I don't know if this is correct, but generally it would look something like this: 

Just because your question doesn't really belong here, doesn't mean I won't try to give you an answer! :) If you are set on hacking this thing and adding a battery, that's fine. But might I suggest obtaining an alternative instead? The everything2 post on SNES Backup Units lists several others, some of which do retain their memory through a poweroff: