I think that hiding the form on the textarea's focusout event is a bad idea because this event could be triggered by the user tabbing out of the textarea. Hiding the form at this point would prevent the user from submitting the form. I think a better approach is to take our direction directly from your requirements and hide the form when the user clicks outside of it. We can do this by attaching a click handler to the . In this handler we will call only if the clicked target was neither the form element nor an element within the form. 

I will use less verbose selectors for creating my jQuery objects and I will cache them by assigning them to variables. 

In the showForm function, we will attach our window click listener so that we can capture clicks while the form is displayed. Note that we do not want our click of the to bubble-up and trigger our handler, so we will ensure our call to is outside of the current call stack by using setTimeout with a delay of 0 milliseconds. 

If we want to hide the form when it is submitted, it will be better to listen for the submit event on the form rather than the mousedown event on the submit button, because the user can submit the form without the mouse, for example, by pressing Enter. 

I would move all of the functionality into a single document ready handler. I will use the short-hand notation. 

Notice above that the click event has been namespaced with '.TheForm'. Namespacing will allow us to easily remove the event handler without removing any other click events that may have been attached to the window. I will wrap the click handler code from above into a function so that we can re-attach this handler as we please. I will also create a function for removing the handler. 

First, I would rename that variable since also refers to a current index - how about instead? (I even debated going with and for clarity.) I also renamed to because I think the "is_" prefix makes my booleans instantly identifiable as booleans. Next, I would improve readability by assigning those look-ups to friendly named variables, like and . I don't like the inconsistency caused by the fact that the limit on questions is , but the limit on chapters is - that "- 1" is awkward and it looks wrong to me, but I have left it in my answer in case it has to be there. I have also renamed to for clarity. I think a lot of the redundancy in the conditionals can be replaced with and an . The code in my answer assumes that cannot be greater than and that cannot be greater than . If you wanted to take a more defensive position, you could throw an error if either was greater than its limit. Finally, I cannot understand the purpose of decrementing when we reach the "done" block, so I have omitted it. 

Correctness I'm not sure what exactly you mean by 'correct'. Personally, I regard this code as poorly written, so I would reject it during peer review at my work. It's using C++ as if it were C, and violating several OOA/D heuristics. Class Message knows it has subclasses Class Message shouldn't have that 'type' member - a base class should not know anything about its subclasses, not even that any subclasses exist. At the moment, class Message knows that it has <= 2^(sizeof(int)*8 - 1) subclasses (else that int would need to be a 'uint128_t' or something). And if you changed that 'int' to be an 'enum message_type', which is what it really is, then Message would know of the existence of each of its subclasses, which would be even worse: addition of a subclass would require modifying the base class. It seems to me you can simply delete that 'type' member, and the lines that set its value, without any loss of functionality. The take-away point is: C++ objects (instances of some class) already 'know' the class of which they are an instance. You don't need to store this information a second time using class data members. Encapsulation (Google for this term) Classes shouldn't have public data - where you're setting public members directly, you should either be passing arguments to constructors, or (less preferably) calling setters after instance construction. Performance Do you really care about performance of this code? Think very hard about why this code is performance-critical. Chances are, it's not. If this code really is performance-critical, for example it's executed thousands of times per second on a small embedded processor in a real-time system on which lives depend, then consider instead using an optimised binary format instead of JSON, using superior algorithms elsewhere in your code, offloading work to other parts of the system that are less time-critical or have more resources, or simply reducing the scope of the project to something easier to accomplish. Pros and cons of using inheritance (instead of a variant member) Pros of inheritance: Uses C++ in the way its designers intended and in the way later readers will expect. Allows for polymorphism (Google for this term). Promotes future code re-use and eases modification, by making it easier to add additional subclasses later on, or modify the superclass behaviour/implementation. Cons of inheritance: I can't think of any. You'd be mimicking inheritance by use of containment, which may be sadly necessary in some circumstances but seems worthless to you in this circumstance. Strange JSON The JSON is redundant, which means it's possible for it to be inconsistent. What does it mean for the JSON to contain a 'type' attribute with the value 0, meaning email, but then inside its 'typeProperties' sub-object, it contains all of the the attributes appropriate to an SMS and none of the attributes appropriate to an email? If this isn't possible, then why does the JSON design permit it? Why not just treat it as an SMS if it has SMS members, or an email if it has email members, and dispense with the 'type' attribute? If this is possible, then how are you intending to handle it? 

You do that for every run you got thru your label, but in fact it won't change: neither nor are changed elsewhere in this method. So we can safely move this operation above . Same goes for , , and . Then we convert your into common-knowledge . To do that we simply replace with , enclose all code below in loop, add in the end, and instead of every . Inside loop we have three s. If we look closely, we'll see that they are mutually exclusive. We will mark it explicitly, so we don't have to guess. If we follow this line of thought, we'll see that every time we don't hit inside our we can safely return from call. So let's invert those conditions too. What we've now come to? 

Why are and , if it's not assigned anywhere in code? It should not be. Only things that implies assignment is call to , which should not modify anything, because it's only writing. You have not included your code, but let's assume that it's not doing any assignments inside too. So we get rid of those s. Next thing in here: you're passing in an array of s and some , most likely an index. But everywhere in method (with exception to calls to ) you're using . So we can safely extract it into temporary variable. Let's call it , for the lack of best option. 

Now I'll do some strange thing: I'll extract your call to to variable. I do this only because it is the only thing that operates with and and I can not make any decision about it without seeing it first. So I'll just save entire call for later. 

And now, thanks to this, all our code operates on . So we can safely move it to instance method, because all this processing is coupled to single instance of . Let's call this method (of course, all the code inside it does not use , but uses implicit . Now, all that's left of yours is: 

All that's left is . Most of it happens only when . Let's invert that so we don't have to think what happens if both bests are 0 (because we simply return at that, don't leave us hanging!). 

With exception of that still need improvement, and where you can apply same process, it seems to me that we've done pretty good work here. But I must repeat: with exception of one operation (moving inside instance) all we've done here is a function-based refactoring. As it's already said here, we might be as well programming in C or JS. I would highly recommend you to rethink your approach into more object-oriented one. 

You obviously don't do enough encapsulation. I see at least three classes with no behaviour (, and ), your "main" class () contains only static method... it does not seem like good OOP for me (and when we are talking C# we should mostly talk OOP). Let's try to fix it, one thing at a time.