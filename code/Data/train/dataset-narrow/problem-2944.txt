Before contributing to an open source project it can be useful to become familiar with the tools and concepts involved in version control systems. 

Websites such as $URL$ and $URL$ are great for students to practise this type of competitive programming activity. In order to prepare them for that type of competitive challenge it can be good fun to create opportunities for competition and collaboration early on when you're introducing new programming concepts. For example: 

The easiest way to set the conditions so that they can all be reached continuously in every class period is to make the conditions so easy that all can achieve them with very little effort. However, this is not at all motivational and sells the students short of being stretched, inspired and challenged. Dumbing-down the curriculum so that all succeed can get great results on paper but is counter-productive in the long term. A good lesson almost should contain some objectives that can be reasonably achieved by all students whilst also featuring others that create scope for curiosity and intrigue for the fastest/brightest learners. Any teacher knows this isn't easy: 

You could point out that a file has an owning user and an owning group. Since “owner” appears twice, specifying for “owner” would be ambiguous. That's weak because the owning group doesn't really have any special privileges on the file, unlike the owning user: the owning user can change the file's permissions and other metadata, but the owning group only has the privileges granted by the file's permissions. I think the best approach is to pair up user and group so that people remember them together. There's user and group: and . There are basic file permissions for one user and for one group. ACL entries can apply to either a user or a group. The command has two columns for ownership, one with the user and one with the group. Beware that sometimes the naming is not consistent. On the system there's a user database () and a group database (). The command takes both a user and a group, but there's also a separate command and so is often used for the user only, which tends to reinforce the association between “user” and “owner”, so avoid mentioning that if you're trying to dispel the association between “user” and “owner”. 

Split students into groups Give all students some code that is deliberately incomplete or broken. Award points to the first person who fixes the errors or completes the challenge Once someone in the team has finished, their job is to support the other students without touching their mouse or keyboard. Award points to the first whole team to complete the challenge. 

How about IP addresses being countries and ports being sea ports? In the UK it works well because there are so many different sea ports that students recognise from looking at an online map of the British Isles. You can extend the metaphor by talking about firewalls blocking off access to ports (e.g. sea blockades during WWII) or increasing security by removing external access (landlocked countries don't need to worry about sea invasion). The main advantage over an address / flat number analogy is that you can extend it by talking about different types of ports (e.g. airports) for different protocols (e.g. UDP / TCP) with various implications for speed / reliability. No analogy is perfect though - students who want to understand it fully should have experience using or hosting different services on the same server. 

I'll now put my teacher hat back onto the shelf where it was gathering dust, and put my engineer hat back on. I regularly read and write requirements documents. (A test question is a kind of requirements document for the answer.) Requirements documents should be precise, but they should not be subtle. If I notice a subtlety in a requirements document, I'm not going to blindly implement what the document says, I'll send it back for clarification. If I'm writing a requirements document, I pay attention to being clear, I'm not going to convey a requirement through something like a plural. If the plural is at all important, I'll at least highlight it with a word like “multiple widgets”, and probably “multiple simultaneous widgets” or “multiple concurrent widgets” or whatever it is I actually want. 

You're grading attention to wording details, and not comprehension of the material. Grading attention to wording would be appropriate if you were teaching reading comprehension, but it isn't specifically relevant to teaching computer science. 

I tend to avoid multiple students working on the same code simultaneously (Google Docs style) because it's really difficult to assess what has been done by each student or to stop one student dominating whilst the other doesn't understand what's happening. Either that or students tend to get distracted by what the other is writing. Having said that, you could try: 

Ask them to switch their screens off. They don't like it if you do it too often or for too long but it's surprisingly effective, saves you having to repeat yourself unnecessarily and forces you to try to make your instructions clear and concise. If you can't see their screens you can always tell by the glare from their screens on their faces who hasn't followed instructions. 

You can get a fast-paced, fun lesson where there's enough challenge to get the brightest students being competitive with enough support for those who take more time to understand and complete the work. 

I don't see how that follows. (After all, random grade assignment would get a good spread.) I think your students would be somewhat justified to consider your grading unfair, since it isn't based on knowledge or comprehension of the material. Yes, attention to detail is a useful thing, but trick questions, not so much. You are also heavily penalizing students to whom your course is in a foreign language, and possibly students with reading disabilities. The former may or may not be acceptable; the latter, if it is the case, isn't. 

If you ask a trick question, you're playing a trick on your students. Ok, so I used a word trick in my last sentence, but there's some truth to it. You aren't making the question difficult by requiring deep knowledge of the material, but by requiring subtle understanding of the question. A good trick question announces itself. To give an example, as a TA in a programming class, I gave my students some very short code snippets and asked them what they did (more precisely, I asked what the code printed, or the final value of a variable). I started with easy things like and finished with subtle things that I only expected the most advanced students to grasp, like (it was a C class). I warned them in advance that there would be trick questions. I don't have exam results, since I was only TAing and not doing the exams, but from reading the students' faces, I do think that the brightest students understood, and the slower ones didn't but kind of got the idea that there was a difficulty, which is what I was aiming for. Note how the subtlety was packed in the code and highlighted, not hidden under a word trick. To test a deep understanding of the material, explore finer points of the test material. For example, put some concepts that were covered in the lecture together in a way that wasn't covered, and see if the students are able to relate them to the lecture material. 

Problem solving and computational thinking is a hugely transferable skill in itself. Almost any science / engineering route through academia into the workplace is greatly benefited by the ability to write / modify some code that will process data efficiently and generate exactly the sort of analysis / evidence that you require. For example, a substantive part of a Psychology degree involves collecting and processing statistical data. Even without the logical and analytical benefits of CS, the ability to write code to automate the analysis of that data immediately gives you huge advantage over peers without any CS skills. 

I don't think that student learn that much from just running someone else's code without going through it. Copy & pasting can be really useful for sharing code that has been deliberately 'broken': you can demonstrate / explain code that is working and then introduce deliberate mistakes for students to find and fix when they copy / paste. That way they get the speed advantages of copy / paste but they also have to engage their brains whilst getting experience debugging. Alternatively, you can give students code to copy that they then have to comment / adapt / extend. 

What's your students' reaction here? If it's “ah, I see, I hadn't understood/remembered that part of the lecture”, you're doing it right. If it's “ah, I see, I hadn't understood the question that way”, you're doing it wrong. 

Many coding standards for embedded programming forbid using goto for anything else. In languages that have a better clean-up mechanism, such as try/finally or C++ destructors, goto is useless. Understanding goto is a secondary skill for programmers, part of understanding how a program's code relates to the way the machine executes the program. A good programmer understands goto, but a decent programmer understands how to program without goto. The primary skill for a programmer is understanding how a program works, not understanding how a machine works. (There are exceptions, obviously — I write OS code, doing things like memory management and context switching and accessing peripherals, and that obviously requires a precise understanding of how the machine works. But that's a highly specialized field.) The real difficulty with goto is, as I mentioned before, that it isn't just a jump. It's a jump to a different context. The invariants that hold at the location of the jump may not hold at the target location. A goto introduces a non-local connection between two points in a program that makes it hard to figure out how the program state evolves and what invariants hold. Paul Powell's statement that “GOTO (…) is easy to understand” is just wrong. What's easy to understand is how a machine executes a goto statement. But the most important part, understanding how a program that uses goto works, is difficult. The statement that “it can be used to explain what loops and other items of structured programming actually are” also completely misses the point. Goto can explain how structured programming items are implemented on a processor. It explains an implementation, not the concept. Goto is an advanced step after structured imperative programming, not a step before. Using goto to encode flowcharts is also very misguided. With goto, “we can code directly from a flow chart” — this is true: goto makes it easier to write a program from a flowchart without understanding how the program works, without figuring out the structure in the flow of events. But when you do that, you end up with a write-only program. Sure, you've been able to write it, but you won't be able to explain its behavior when a parameter that isn't reflected in the flowchart turns out to be important, or to modify it in a way that isn't easy to draw on the chart. Write-only programming is the mark of a mediocre programmer, capable only to fumble in the dark until they somehow manage to pass the tests. Goto has its place when you teach how a machine executes code. It's what's happening under the hood. It has little to no place in teaching how to program, and Dijkstra would be quite right to complain about its use in this context. 

Write some code that is unfinished with some deliberate mistakes and share it with your students on GitHub Get your students to clone / download your code, find and fix the bugs then talk about the problems with having so many different versions of the same code in the classroom. Get your students to fork your code into their own repositories and commit their own changes. Discuss code and commenting conventions and why they're necessary (e.g. PEP8) Get your students to go back and recommit their code in line with the conventions discussed Ask your students to issue a pull request on your code so that their changes can be contributed to the original resource. 

Once they've been through that process in a safe and controlled environment they'll be much more confident joining in with an open source project. It can be intimidating jumping in for the first time, no matter how friendly and supportive the contributors are. You might also want to look at GitHub Classroom which automates the process of creating, sharing and collecting programming assignments from students. 

Flowcharts are a useful tool to understand programs that perform moderately complex sequences of interactions. They aren't always a good way to describe an algorithm, but they are a good way to describe the behavior of a system that reacts to external events in different ways depending on its state, with a non-linear control flow. Note that by flowchart, I'm not referring to a specific formalism — at this level of detail, I might as well call it a state diagram (although a proper state diagram requires a more precise understanding of what the different system states are before you can draw it). Flowcharts have their place in an imperative programming course, but only at a fairly advanced stage, after the students are familiar with basic control structures such as conditionals, loops and subroutines. They're a visual aid to understand complex control or data flow, in the same way that decision diagrams are a visual aid for complex series of conditionals. The only good reason I can think of to introduce flowcharts early on is if the students started with a style of visual programming that resembles flowcharts. Otherwise, teach while loops first. Goto is an instruction that's hard to really understand. (If you think it's just a jump, you don't understand goto.) It's perfectly fine to teach imperative programming without goto, if you're doing it at any level that's higher than assembly (in which case what you'd teach is jumps). Goto is very rarely useful in the real world and is rarely used. Its place in a basic or intermediate imperative programming course is as an incidental mention, as something that exists, that you mention for the students' interest but isn't part of the curriculum and won't be on the exam. I work in industry. I write software for embedded systems in C. Think I should be insisting on the importance of goto? Wrong. In my world, is almost exclusively used for one thing: a forward-only goto, a generalization of that allows breaking to the end of any block. The single common idiomatic use of is to jump to a common cleanup code before returning from a function in C: