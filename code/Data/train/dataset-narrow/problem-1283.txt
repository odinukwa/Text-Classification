So, the sum of all 3 and 5 multiples less than n is easy, but there's a probem.... if we add the two sums together, it will count the multiples of 15 twice..... so, the sum of one 15's series is: 

This question of leap years is an interesting one... and seems to be a rite-of-passage (when you do Zeller's Congruence, you should get that reviewed too... ;-) In Java, (and other languages), it is common to return-early. You can use this to your advantage to reduce code-nesting, by choosing whether to do a negative, or positive test in if conditionals. You have done this a couple of times in your code, but not always. For example, your code contains: 

There really is not a wrong answer to this. Different places in the Java libraries use different strategies. For example, the new Java 8 code uses with a bunch of utility methods, and the same is true for the and utility classes. On the other hand, these require specific imports to make them happen. In your case, since you have to import the class anyway, it makes sense to make the utility constants part of that class, instead of a new utility class. I see nothing wrong with: 

Have you tried something simpler? I know that chaining greps together is not hugely scalable, but, it should accommodate as much as your commandline can. Including single-quotes as commandline expressions may be a problem though. 

and then call that constructor from everywhere. If there are a lot more parameters though, it gets messy to call the constructor: 

Goto conditions are often maligned as being bad practice... and, for a reason. In almost every situation where a goto is used, it's because you are doing too much in a method. Consider your main method: 

etc. Performance Your code loops for divisors from 1 to just less than . There is no need to loop this far. Each time you find a factor for your number, you actually find 2, the low, and high parts of the factor. If you loop to the square root of the number, then that's all you need to do, except, for each factor less than the root, you also find one larger than the root. The exception is if the root of the number is also a factor.... then that only counts as one factor, not two. So, for example, the input 20. The square-root of 20 is 4.47... We know: 

Matrices ... 1D or 2D format In computing it is common to have matrix-like problems. Graphics, mathematics, and Tic-Tac-Toe. It is often easier to have the matrix data stored as a 1D array, or 'flattened'. Whether you have it as a 1D or a 2D array does not really matter for the functional aspect, but it can often have a really big impact on the readability. A matrix of dimension would be stored, for example, as : 

This is a complicated setup you have, and this problem has been successfully solved in a few ways.... but, all of the mechanisms have two things in common.... 

When working with Jar files you should remember that they are just zip files with some restrictions. As a result, there's no need to go through the whole extract-to-temp folder, and instead you can do the 'simple route': 

As for the actual criticism from your course... your Tuple class is not publically visible.... what are they talking about? It is 'package private' ... only classes in your package can see it. If you wanted to, you could nest the Tuple class in your AList class as a protected-static class, but I am not sure that is any better... well, actually, it is better. So, let me change my mind... Tuple should be a protected-static nested class in AClass. I have not inspected the logic of the Depends processing, but at face value it looks right. I think the interfaces is fine. One possible extension is to use another (a second) interface so that you can support classes that do not implement , just like there is and . 

Shouldn't the answer there be 1 for both situations (unless mynode.next == mynode)? To my mind, this method should look like: 

but I think if you just selected a random member (using ThreadLocalRandom), instead of a full shuffle, you would be able to reduce it to: 

Your question is surprising in the sense that you use the somewhat obscure method (not many people are aware of that one), yet you do not use the similar method. Using that method, you can remove the second loop (as you suspected). It also answers the second question - there is no need for a StringBuilder, or the int conversion: 

That 1 word is 'static'. In this case, each and every Node shares the exact same OBJ_LOCK instance. But, that instance is only used to control details inside the actual . What you are doing is locking all threads accessing ANY Node, even though you are only changing the details in one node. Remove the , and change the case to , and you should have better thread concurrency. Listeners 

you identify that a client handler has completed a task (using a blocking queue, and a separate thread?) you register the socket for OP_WRITE with the client handler attached. you get the Write-ready notification, and copy the data on to the socket output. you return the state to Reading 

The sort used will be the native sort in Java, an efficient TimSort, I believe. When possible, use the library functions available.... Alternative I would recommend creating a number class, that implements , then, when you process the system, just create a new instance of that class for each input value. The constructor should create the lexographical value at that time, and the comparator will then be much simpler too. If you add the values to an always-sorted collection, like a TreeSet, then you can just do it all in one go. Hmmm... in retrospect, I played around with it, and came up with the following class, and a 'simple' lambda expression to arrange it.... Note, the compareTo function is a 'clever' trick of appendign each value in opposite orders, and then comaring them. It makes the relative order easy to compute. It may not be the fastest, but it sure is simple to read.... 

Here you have two instances, and the comparison is a , which will 'unbox' the Integer vlues to int primitives, and do the integer compare. That's not broken, but it's not great either. For a start, it's slow. The better way is to use the natural ordering of the Integer object... 

Synchronization and other locking mechanisms are complicated concepts, and they are hard to write, and hard to read. There are rules which make it easier: 

Your algorithm is functional, but is not necessarily very efficient, and it will collide more, and more often if the count of numbers increases. It's generally neater to start off with a unique set of numbers, and to extract a random selection of those numbers, instead of selecting random numbers, and testing for uniqueness. PHP makes this relatively neat, because it has a built-in shuffle function (that's essentially doing a Fisher-Yates shuffle using the same random system that you are). So, get an array of the unique values, shuffle it, take a selection of it, and sort the result: 

The finally.... You are using a on the file handle close... that's what the try-with-resources does for you. 

That will process each line, as a line, in the stream. In Java 8 this would almost always be superior to a BUfferedReader and other wrappers on your file. You can then chain up the filters you want on it. I suggest using Regular Expressions, they are good for this. A pattern that looks like: