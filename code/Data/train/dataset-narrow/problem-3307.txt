I believe the minimum is a 5v 2.0 amp power supply however most kits provide a 5v 2.5 amp power supply. Part of this depends on what you are actually doing with the Pi and what devices you have turned off as part of saving power. See this posting about power use Raspberry Pi 3 vs Pi 2 power consumption and heat dissipation See this FAQ from Raspberry Pi $URL$ which contains a table of recommended power supply requirements. For the Raspberry Pi 3 Model B the recommendation is 

Testing out YouTube with a Raspberry Pi 3 Model B under Raspbian using Chromium I ran into the choppy video with good audio. I went into Preferences and changed the GPU from 64 to 128 and then to 256 and found that 256 worked great. I was using a 23" 1920x1080 monitor, full screen over HDMI. Changing from full screen to windowed and back resulted in a bit of temporary choppiness. I was using WiFi at the time. I would not be surprised if using an Ethernet cable rather than WiFi would help with choppy video as well. 

The Pi 3 has a 1.2GHz quad-core processor and 1GB of RAM, while the Pi Zero has a 1GHz single-core processor and 512MB of RAM. It's expected that the Pi 3 would be faster on things like this. There's not really anything you can do. Your comment about the HDMI output not having this trouble does make some sense. I don't think that the BCM2837 (the chip in the Pi 3) has a different GPU from the BCM2835 (in the Pi Zero), so the speed would be roughly the same for both on HDMI. But with the touchscreen, speed is throttled by the GPIO pins, which (to my knowledge) are controlled by the CPU, which is slower for the Zero. Hope this helps. 

This looks similar to what I did with a DHT11 temperature sensor with first a Raspberry Pi 3 and then with an Arduino. The Arduino code is at this URL: $URL$ One thing that I did was to write the DHT11 function, in my source code, so that I could collect statistics on how the read function was working. What I found was that the value check needed to be around 25 for a Raspberry Pi 3. However for an Arduino the comparison value was much less. You may need to increase that value to more than 30 for a Raspberry Pi. So an edited version of your function with the statement modified follows. The statement checks the value of the variable which is really the width of the pulse received. One thing you can do is to print the actual data received out as hex values and check that if the data is all zeros or all ones. 

You can make the Pi act as a USB gadget and impersonate a USB device. Adafruit has a tutorial on how to do that -- or you can just keep reading for a summary. Plug the SD card into another computer. Depending on the OS, you may see one or two new storage volumes. (If you see more, that's because you're using NOOBS. If you only have one OS installed, the rest of the tutorial will work.) Find the volume with the files and in it. Open a text editor. If you're on Windows, open it in WordPad or Notepad, not Word. Scroll down to the bottom and add on a new line. Now save and close. 

Addendum: Java classes, JVM, JNI (C Extensions) overview Here is a brief overview about Java and the Java Virtual Machine and hardware specific libraries that use the Java Native Interface (JNI). The Java compiler compiles the source code of Java classes into Java Virtual Machine byte code as class files. When the application is run, the Java Virtual Machine (JVM) loads the initial application class along with any additional classes needed for the application to run. In order to find the class files for the additional classes, the JVM uses the list of directories to search for the additional classes. Some Java classes need to access specific hardware or operating system features that are not part of the standard Java installation. The Raspberry Pi hardware is an example. This requires that a Java class that is providing access to those specific features will need an additional component written in C or other programming language to provide an interface to those features or functionality. The Pi4J classes used with Java on the Raspberry Pi provide a way to access the hardware pins of the Raspberry Pi. In order to do so, the Pi4J classes use the wiringPi library as the mechanism to gain access to the Pi hardware. So the Pi4J classes provide a Java interface to the wiringPi library which in turn provides the interface to the actual Pi hardware. What this means is that in order for the Pi4J classes to work, they require access to the wiringPi library which is loaded long with the Pi4J classes. So the JVM needs to know that the library is required and how to find it so that when the Pi4J classes needed for your application are loaded, the needed wiringPi library is also loaded. To make using the Pi4J library easy to install and use, the development team included in their install a copy of the wiringPi library. However if there are changes to the wiringPi library the version bundled with the Pi4J classes becomes out of date. This answer is how to trigger the Pi4J classes and the JVM to use a version of the wiringPi library other than the one bundled with the Pi4J class install package. 

Here is where you have to decide if you want the Zero to act as a serial gadget or an ethernet gadget. If you choose a serial gadget, it will simply give you a login shell and you can go from there. However, you'll need to be to access a shell on the Pi some other way. If you choose an ethernet gadget, it will show up as a network interface. This gives you a lot more flexibility because you can do things like VNC in -- which will give you a graphical desktop -- or you can share your computer's network connection with the Pi (Adafruit's tutorial talks about how to do that under "Ethernet Tweaks.") If you choose an ethernet gadget, enter instead of in the next paragraph. You'll also want to create a file called (no file extension) on the SD card to enable SSH. You don't have to do that now, but it's convenient. 

The first directive is to set the environment variable by adding to the existing the directory where the Pi4J library jar files are located. The second is to provide the necessary directive to when running an application using Pi4J. 

There is this article that provides a fairly indepth look at power requirements of the Raspberry Pi 3. $URL$ .75 amp will not be a good idea and probably won't work reliably. I remember reading that phone charger seems to be something that many people first think of but a phone charger is not designed for the application of powering a Raspberry Pi and it is not a good idea to use one. Remember that the entire package of Raspberry Pi and its electronics as well as the USB ports for keyboard, mouse and HDMI, WiFi, Bluetooth, and Broadcom GPIO board (if you are doing electronics experiments with your Pi) need power. Power consumption by the CPU will vary depending on the processing load and the number of cores in use. 

Next, open . This file is one long line, so don't add any newlines. Go to the end of that line and add a space followed by . Now eject the card and plug it into the Pi, but leave it off. If you decided to go the serial route, you'll need to boot the Pi, log in by some other method, and run to enable using the connection as a serial console, followed by to power it off. Now, use a micro-USB to USB cable to connect it to your computer (make sure to use the port labeled "USB"). The Adafruit tutorial goes into more detail on how to connect to your Pi from there. 

This article Updating Raspbian on your microSD for the Raspberry Pi 2 describes updating Raspbian however mentions to update NOOBS requires using a PC or Mac to download NOOBS and put it on an SD card. The commands you mention are to update the installed operating system and not NOOBS. 

I ran into this same problem using Java with Raspbian on a Pi 3 and found a posting from the Pi4J development team indicating that the problem is that when Pi4J is automatically installed, a copy of the wiringPi library is also installed and the copy of wiringPi in the installation package is old. I think this is a problem with Pi 3. See $URL$ Also see $URL$ The suggested work around is to cause the Pi4J component to dynamically load the wiringPi library rather than use the old version in the Pi4J package. This is done with a system properties addition. The command line to run an application must include the option as in: