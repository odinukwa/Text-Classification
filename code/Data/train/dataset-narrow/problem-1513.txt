I've left the algorithm unchanged for now. It could be improved, as Paul Martel shows, but using lists for this purpose at all is really not ideal. I'll return to this point later. 

Unfortunately, this is a distinct disimprovement. Using raises an exception when it can't parse the user input, which makes it needlessly awkward to use. Rather than messing with catching exceptions, we'll whip up a replacement using the function, which returns a list of possible parses, and use to indicate success vs. failure. 

It's more typical to have begin a new line, in order to clearly distinguish a clause from a multi-line expression. Using tends to be tidier than repeated , and again improving a name--for an arbitrary predicate makes sense, but here we have a specific predicate, and should indicate such. 

A slightly different way of writing the same list comprehension Paul Martel used. Many Haskell programmers prefer using map, filter, &c. directly; doing so, it would look like this instead: 

I note that you keep the Excel file open and then parse one or more text files. Have you tried closing and opening the Excel file for each text file you parse? Also, have you considered other ways to open and edit Excel files besides Microsoft.Office.Interop, like OpenXml? 

Why do you have the class? Why not make life much simpler for yourself by making a , and having classes like implement ? You can then query your assembly file for classes where is implemented; that way you don't even need to fill "by hand": 

I'm not a big fan of some of your names. For instance: doesn't really convey what it is. (Also please be consistent: in one place you name this .) 

Also, be consistent in naming : . I would expect the database field to map to the property , instead it's called . 

What are these, fields of properties? If they're fields they should be private; if they're properties they should have a getter/setter. 

Model In a similar question I provided an example. As a matter of revisiong I will provide it here as well so you get an idea how to separate the concerns. Main.java 

2. Create components After you identified strong cohesional code fragments through create-methods and lazy init-methods you should extract logical UI components. The most obvious component is the JFrame. You should derive a class from it and build up the UI within this new XJframe. You already have a class named MainView that can be extended from JFrame. Maybe you can reuse it so the inner JFrame-object becomes obsolete. I recommend to at least do that: 

Learn the theory of sequence, selection and iteration Train your algorithmic thinking by solving problems with the elements of 1. in a programming language of your choice by increasing difficulty Get familiar with the language mechanisms Apply programming paradigms like functional or object-oriented programming Formalize you code fragments by learning the currently identified 26 design patterns and learn to to apply them in the correct situations Organize your code by following the correct semantic of each code fragment and learn and apply the SOLID principles as they guide you through the jungle of design decisions Learn the restrictions of the language you use for a problem. Maybe in another language you are able to express the solution in another way that is more elegant. 

Note that this is basically example code, just to give you an idea in which direction to go. Once you start copy-pasting code, consider it a sign you're doing something wrong and you should move things to a separate method. The point is not so much to "shorten" code, but to avoid repeating/copy-pasting code blocks and to make it easier to maintain. By using this base class you can easily add another without having to copy-paste half a dozen lines and making some minor adjustments. Instead you add a new class and focus on the one important piece: the contents of the method. 

But I fear your refactoring might need to widen its scope, because even if you apply this you still have an ugly or . 

But if I were you I'd rethink this entire logic. A is ugly and unwieldy; IMHO the nested dictionary should be a custom class. I also feel this code is odd and possible buggy: data is retrieved for an yet this parameter is completely absent in . The that is passed is assumed to be present as a key in , same for the . 

Learn the theory of sequence, selection and iteration Train your algorithmic thinking by solving problems with the elements of 1. in a programming language of your choice by increasing difficulty Get familiar with the language mechanisms Apply programming paradigms like functional or object-oriented programming Formalize you code fragments by learning the currently identified 26 design patterns and learn to to apply them in the correct situations Organize your code by following the correct semantic of each code fragment and learn and apply the SOLID principles as they guide you through the jungle of design decisions Learn the restrictions of the language you use for a problem. Maybe in another language you are able to express the solution in another way that is more elegant. 

Learn the theory of sequence, selection and iteration Train your algorithmic thinking by solving problems with the elements of 1. in a programming language of your choice by increasing difficulty Get familiar with the language mechanisms Apply programming paradigms like functional or object-oriented programming Formalize you code fragments by learning the currently identified 26 design patterns and learn to to apply them in the correct situations Organize your code by following the correct semantic of each code fragment and learn and apply the SOLID principles as they guide you through the jungle of design decisions Learn the restrictions of the language you use for a problem. Maybe in another language you are able to express the solution in another way that is more elegant. 

The module is imported qualified to avoid name clashes with various list functions. I've also renamed to to be more explicit about what it represents. 

Converting the game state functions to use . They're much simpler this way, and some functions I've eliminated entirely. 

As Paul Martel did, I've separated the string representation of the board from the printing. Note that is simply , so replicating suffices. The use of here is because of using rather than . 

There's no reason for to take an , so I've removed the superfluous and binding steps. This also allows using guards for the check, removing the conditional expression. 

There's really no reason to use except for number-crunching with small integers. Not that it's likely to matter here, but getting in the habit of using by default means you don't have to worry about bugs due to, say, a counter in a long-running program exceeding the maximum size of . Mystery bugs that only occur on large data sets or after running for a long time are not fun to track down. The only problem is that some standard functions take only arguments for no good reason, rather than any integral type. This is a misfeature of the standard libraries and not one you should emulate. 

Avoid magic strings. Things like the names of session variables -- e.g. -- should be constants, preferably in a separate class. 

My main issue is that this code follow the "arrow anti-pattern", which makes it hard to read. Once you start nesting s, your code quickly becomes hard to follow, especially when there are blocks involved. I know how to solve this in C#; however I'm no Java expert so I can't advice you on how to solve this. In C# I'd possibly convert this method into a class and each would perhaps become a method, but I don't know if that's the right way in Java. 

is a bad name, is even worse. I have no idea what this represents. I also have to object to , especially when . 

You have an called : that's wrong, only interfaces can use the prefix. Instead I'd expect this class to have in its name at the start or the end (whatever is your preference). 

Do not return any value (void) from Verify() and only throw exceptions Catch exceptions in Verify and return false, true if everything is fine 

LDAP access If you have access to the LDAP interface of your Active Directory you can query LDAP for a specific computer account: 

Make them a "public static final" constant. Resources should be loaded only once and not every time an object is instantiated. There are other variables that may be declared as constants like "listS1" or "listS2". If they are not meant to be changed then they are also constant candidates. An common convention is to write constants UPPER_CASE. Listener registration The listener registration should be within the configuration part of the component (see lazy getter) and not in the listener itself. 

Do not make the builder pattern return mutable objects, always return new objects. The "builder" pattern is meant to "build" something not to update something Only build transient, never involve persistence in the builder pattern Have a proper design for CRUD-Operations for your persistent objects (business objects??) and well defined responsibilities Distinguish between proposal, creator/updater/deleter and result