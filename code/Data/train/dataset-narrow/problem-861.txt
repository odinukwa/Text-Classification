You can create a list before creating the parent thing so you can assign in the object initializer. I don't think your code works currently because you're not specifying the DTO in the foreach loops and not getting the values from the dictionary that's passed in. If the object initializer is too long, you can expand it to multiple lines or create and use a constructor for each class. 

In , you can get the product names before the loop and loop through those instead of looping through dictionaries, filtering, and then getting a product name each iteration: 

I agree with your teacher that you should have the print method do as little else as possible. You should try to have methods that do only one thing because they are easier to read and test. Another thing is to keep your code DRY (Don't Repeat Yourself). If you have code that is repeated, you should refactor it into a separate method. So you have two reasons to print the results in a separate method. Also, you can replace the loops with LINQ, which is more concise, safer, and easier to read in my opinion. I prefer to explicitly declare whether each method is public or private. 

You can declare the possible values outside of the loops because they are going to be the same each time: 

Note that arrayD does not get shuffled each time. I'm not sure if that will affect the randomness. This: 

You probably don't want to call in . Instead you can declare a class level variable and assign to it using in . It's your choice if you want to refactor the code into more methods. The main reason I declare more methods is if I can use a method multiple times, reducing duplication. It can also help with readability. 

In , you can move the statement outside of the loop and get rid of the part, keeping the statements. You can also combine the predicates of the successive statements using . If you want, you can calculate the "constants" using a specified board width a edge width. 

For , you can filter out the indexes that are out of bounds instead of hard coding the indexes for each edge case. So we get the indexes that are in bounds, iterate through the combinations, and ignore the combination where the indexes equal row and col. 

I try to avoid implementing because is verbose, and, as Zack mentioned, you also have to override and . Instead of implementing and writing this: 

Then we declare the main method for getting the highest combination. I decided to make a line in four different directions for each point and check to make sure the line's points are in bounds before creating it. 

The class should have better naming. Properties should be UpperCamelCase, and constructor parameters should be descriptive: 

This implementation is a little different in that the backTests are ordered in reverse. I think this makes it easier to see what the order of things will be, but if you want to keep the original ordering logic you can make the required adjustments to You can then use in the method: 

The main reason to have a as a parameter is so you can specify different predicates. If there's only one predicate you'll be passing in you might as well just move that logic inside the method and remove the parameter. Then, in your case, you may convert the array of tests to an array of abbreviations of type string and use simpler logic for finding a common string in two arrays. looks at two collections and returns the items that are in both. Then you return true if the intersection has any items. 

In , the lambda expression only needs to be written the way you wrote it if you want to have multiple lines of code in the body. A simpler way to write it is like this: 

I don't have any advice for dependency injection, but I see some other improvements you can make. These changes require . In , you can replace most of the code by using : 

If maxReactionTime is not , then it has to be , so you can turn the into an . You can then refactor it to one line: 

Here's an alternative way to write . It's shorter and uses expressions instead of statements. You can't do as much in an expression, so I use them instead of statements when possible because there's a lower chance of things going wrong. Readability is more important than those things, though, so I recommend using what is most readable to you. 

If you want to use LINQ to create an array with an x and y, you can use jagged arrays instead of multidimensional arrays. 

gfv posted the optimal solution, but there is also a lot you can learn from finding out how to improve your code. The most important thing is correctness. As AlanT said, you don't have to write special code for the cases where the array has 0 or 1 elements, and your special code for those cases is incorrect. The code for assigning is incorrect as well. The range to check against should always start from 1 and have the count be . So you don't need to sort at all. And if you did want to get the minimum value, you can just call instead of sorting and then calling . should always contain exactly 1 element, so you don't need to check if is equal to 0. If the count is 0, then the input or your code is incorrect. Calling and is wasteful because it causes the calculations to populate the to get performed twice. If you have to call two methods that cause an to get enumerated, you're usually better off converting it to a list or array first. 

If you have a group of related constants, and it doesn't matter what their values are, you can put them in an enum. So the values could look like this: 

Method names should be UpperCamelCase, so should be . I'm guessing you want to access a child's property instead of the method because the method is private. 

I agree that the method has significant room for improvement. The major thing I notice is the method name is plural, yet the method only returns a single item. I would return a collection of suggestions and order them by score or something like that. Why doesn't your code handle all the categories? Method names should be UpperCamelCase. That is, , , and . The spacing is messed up in many places. For example here: 

The method can be improved. It doesn't check if or are equal to 167 or 334, so, for example, if and were both 334, then and would both be 0. I recommend checking for all values you don't want in the first statement. So it could look like this (remember to use constants): 

This uses Enumerable.OrderBy() and Enumerable.ThenBy(). Edit: If LINQ isn't allowed, here is an alternate solution: 

One optimization is to skip sequences that contain a 0. Another is if the previous sequence doesn't start with a 0, calculate the current sequence by dividing the previous product by first digit in the previous sequence and multiplying by the last digit in the current sequence. I hope you had code to convert the 1000 digits from the string into an array of digits. I know you're going for speed, but a lot of times readability and maintainability is more important, and in those cases you'd want to calculate a product using loops or LINQ instead of coding an increment to the index 13 times. You should also calculate the currently hardcoded value of 987 using something like . 

The returned function takes an item and returns its sorting order, ranging from to , with 0 meaning it didn't match any tests. You can call the method like this: 

Note that the second parameter is the count instead of the end number, so you'll have to keep that in mind when replacing a loop. You probably shouldn't hard code the logic about things being multiplied by 10. Instead you should use a constant for 10. That way it's easier to modify if you want to change what things get multiplied by and it's easier to tell what the code is doing. I'm going to use the naming convention for constants, but you can use another one if you want. First declare the constant: