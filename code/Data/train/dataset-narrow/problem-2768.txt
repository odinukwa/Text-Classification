I am designing the game so the objects I create (Character, Enemy, Enemycast...) can inherit all from 

What are the advantages of transforming coords, since you can still render isometric graphs having normal 2D coords? 

Calculate module of initial point O, initial speed So, destination point D. (Aceleration module A is given) Use these terms to calculate the time we need to arrive to D with the equation: D = O + So*t + 1/2 A * t^2 Find out the value of alpha from this equation, knowing time: Dx = Ox + Sox * t + 1/2 A * cos(alpha) * t^2 

Both D2D and D3D inherit from . D3D also is supossed to apport the functionality of an additional axis. When the object is drawed in screen, the object is scaled and repositioned in (X, Y) with some calculations. Collider inherits from D3D, because all my colliders are going to have 3 axis, and it creates its own AABB box from D3D interface -to be implemented by the graph type Sprite//SpineDr...-. I am trying to have two vectors to hold all my graphics, and , because the D3D ones will need to be sorted depending on their . The problem arise because D2D///D3D classes inherit , and I am using my class inheriting from , which inherit as non-virtual function from in Sprite.hpp of SFML. So I got two questions 

A simple transaction would be, if the player with the id 5 sells 10 steel to the shop, to reduce the 'amount' value by 10 where the 'tradegoods_id' is 3 (steel) and the 'player_id' is 5. Of course you have to check if this is a valid transaction... But I think you get the idea. Edit: Important to note that your clients should NEVER access directly the SQL database. They only communicate with the server application, which will access the database when necessary. 

The list (grey box) has a dynamic size, starting at 0, and growing with each pointer (red circle) you put in it. So if you've only generated 3 tiles so far, you're going to have a list of 3 pointers. This way, you won't have to reserve the memory for millions of tiles in advance. 

If you have a bunch of images, here's a tool you can use to create sprite sheets: $URL$ It's completely free, and will pack a bunch of images into N number of sprite sheets. 

I'm looking into doing a 2d lighting system with a result similar to this: $URL$ This thread I believe disregards color, as well as doesn't really list a clear final solution, which is something we could provide here. What I'd like to do is start with a solid black texture, and render colored lights to it. When I render a colored light onto the texture, I'd like it to subtract the alpha away from the solid black texture but also add in the color of the light. In the end, my goal would be to have a texture that I can blend normally on top of my scene, using glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA), which would let the background show through in the "lighted" areas in addition to adding some of that lights color to the area. To start I fill the texture with black: 

To detect the direction where your character is moving, just compare the character's current position with its position in the previous game loop update: 

Software design is not an exact science. There's no "the right way" to do something as complex (and vague) as a 2D platformer game. Didn't your teacher show any examples of UML? You should think about this as any other software (or complex system). A nice UML diagram should answer these basic questions: What are your entities and what are the possible interactions between these entities? Try following a top-down approach - going from the abstract, high level elements towards the small details. 

You should google for the keywords 'database normalization'. A good practice is to normalize to 3NF (third normal form). 

How do I define an elliptic motion system knowing two points of the orbit (and Vo)? I'll appreciate alternatives to design a guided rocket too. My attempt for solving this: 

I am using SFML, but I need to add some emulation of 3D by wrapping the sprite with a Z component. When sprites are drawed (or when objects moved?), their X and Y will change depending on Z. My question is, which component should hold the sprite, and the wrapped x, y, z coords? Supossing I have objects that inherit from Sprite, GameObject and Collider (and I am not yet sure about this or if I rather should have used compositio), I could have: 

The guts of my question is what type of blending would I need here, on the second line of this code block. 

The RPG I worked on stored both the level as well as the current percentage to next level, instead of just a raw XP amount on the player. We did this so that if we ever wanted to change the values in the experience tables, the player wouldn't see a sudden drop or rise in level. For instance, imagine your player has 1000 XP, which is enough to make him 50% through 3rd level. If we were to suddenly make it so that 1000 XP is actually only 90% through 1st level, the next time the player plays the game you would need to level the character back down to 1st level. As experience is earned, you can add the percentage amount of experience to the player's current XP percentage. Most RPGs are actually designed so that the amount of experience given for an encounter is easily converted to this percentage. If the percentage is ever greater than 100%, increment the level of the player, subtract 100% away from the experience, and for the extra amount over 100% give them something like: 

4 . When you have for example 3 players with 5 skills each, you shouldn't store the name and description of those skills for all the players. Something I would do instead is: 

In my opinion, the Elder Scrolls approach is more viable in a single-player game. The player doesn't have to start over if he wants to try a different play style. In Morrowind for example, you can be an armored melee fighter for the first 30 levels or so - and then decide to try the thieving skills / quests without receiving any penalty (or having to create a new character and start from level 1). 

I have recently implemented a similar scenario in my game. I have the same principles (e.g. no friendly fire etc.), and this is how I've done it: 1 . All objects (even Environment) have a PlayerID property. In your game, for example: Environment.PlayerID = 0, Player.PlayerID = 1, Enemy.PlayerID = 2 etc. If a bullet is fired by the player: Bullet.PlayerID = 1, and so on. 2 . The first step in my collision detection is to check if the two objects I test for collision are actually the same. The second step is to see if their PlayerID's are the same: 

...in the end, if you did it that way you'd be storing the player's current level. Yay for no for loop to determine players level. 

You can use MatLab, but I personally dont. Whenever I want to type out a bunch of quick code to test a formula, I actually use the python interpreter. Python is great for something like this, and running something in the interpreter is really quick and easy. 

I don't know anything about the flash port, but is it possible that you are using an older version of box2d (or the port is from an older version) and you moving the b2body outside of the range of the b2World? If I remember correctly, you had to specify min/max coordinates for the world, and if anything went outside this range it was no longer simulated. I'm not sure what happened at this point if you changed their position back into the world.