Answer for most XNA users: This is because your game is probably running at the highest framerate it can. You can fix the framerate to solve this problem. Inside of your function place this code: 

I was able to solve this problem by optimizing the shader. This first change will get us down from 68 instructions to 67. We have logic in the shader that only occurs for pixels of terrain that are below the water level, you can see this logic separated by this code: 

If you're trying to rotate an entire plane then I suspect you have a rotation matrix, if you're using DirectX you could use something like I'm not sure if that's the exact function name. 

At a previous company I worked for we had a component-based system with state-based AI. We had an AI component that controlled all behavior for that object/unit. When the AI was active, like wandering, attacking, etc, it would receive an update each frame to do any logic that was needed. When the AI was idling or not moving the component was deactivated and not updated each frame. The component, while deactivated, could still receive event-based messages, so it would receive a message for something like a player entering its aggro radius, and could respond to that by reactivating the AI component so that it could do frame-based updates. The AI component has sub-components, that it could create and destroy on the fly, based on what type of actions it was performing. For example if it was wandering it could create a wandering sub-component and update that each frame while wandering, and then if aggro'd while wandering it would close that sub-component and open an attack sub-component. The AI component should be independent of all other components on an object. For example, we had an input component, that would simply query for movement values on a unit. The query it made was something that both human and AI objects would respond to. This allowed the AI component to simply set movement values on itself during things like wandering, that the input component could pick up on, just as a human controllable component would set values that the input component could pick up on. Things like this allow the AI component to be independent of any other component on the object. 

The JVM is implemented differently on each OS. It may be using slightly different software to compute the same game logic on a different OS and thus using your HW differently. You can narrow it down b writing generic code that only does computation and data manipulation (benchmark) to see if the issue relates specifically to the rendering or not. Each one is running different processes in the background. 

Like I stated before which I think does not require any references: more objects mean more memory usage and more processing power. This should be obvious in most cases. The op did not state a valid game reason for adding multiple timers. This suggests to me this decision may be based on reasons related to learning and practicing programming. This is a bad idea from game design perspective. When you are working on a game, you need to invest your time wisely. Games require a lot of work. If you happen to find a way to produce games quickly. Make more games! Instead of worrying about programming practices. Unless there is a serious problem you're facing with the current architecture, continue concentrating your effort on developing a great game. That is a difference between a game developer and a CS student. OP also did not suggest a bottleneck exists in the game that will be resolved by threading. This also hints to the possibility that threading was not used to alleviate some game performance issues. If such issues existed, game code should be looked at as there aren't any good reasons a simple 2d-game should have performance issues on a modern machine. 

Since these rooms are Graph vertices embedded in a 2d plain, this could in theory be done by solving the traveling salesman problem (which would be fine with only a few rooms). Obviously, a simple heuristic would be fine and allow reasonable scalability. You compute the edges (corridor lengths) between all rooms. You sort them by length. You add the shortest corridor unless it creates a cycle or increases the degree of the vertex (room) above your desired max value (3-4) (Repeat). To check for cycles you could apply UnionFind or do a quick BFS on small data. 

I'm just giving a generic example on how to move your enemy toward a player. That question alone is pretty broad. 

As stephelton said in the comments to your question, vector math is extremely important for pretty much any 2D or 3D game. However, physics knowledge isn't necessary for a lot of simple games. There are physics-like concepts you should understand a bit about, like collision, but you won't need calculus or physics classes for that as long as you keep it simple. A lot of things you may want to do can be simulated simply enough that players won't care much, like friction, or sliding, or gravity. A decent grasp of physics will likely help in many situations though. 

You'll want to include the time elapsed during a frame in your calculations if you want to maintain a constant movement. 

I've never used Bullet, but in Havok you could constrain a model on certain axes. If you can constrain rotation of your model on both horizontal axes that may stop it from falling over. Alternatively Havok let you have a special type of physics called a CharacterProxy, each from you could for it to face straight up, and you could also run your own code for its physics simulation so you could prevent rolling. This is similar to how the JigLib/JigLibX physics engines handle it as well. I'm willing to bet Bullet allows one of these methods. 

This isn't a complete answer in itself, but this wouldn't fit into the comments below your question. If believe this part of the function is what should be disallowing reverse facing triangles to be given as a result: 

Below is the full resulting shader after the changes. It's quite a bit larger, but it meets the necessary criteria. 

Anytime you applied a positional change (translation) to the camera, you would flatten that vector out. Let's say in a non-restricted situation, where the camera could move along the Y-axis, that you have a movement vector like this: 

The clamp is to keep the value between 0 and 100, but we already know it must be greater than zero because of the condition that , so instead of clamp was can use min: 

If the game design requires that some instances of creatures gain flexible access to certain data through methods or POD, it may be useful to inject this data as optional parameters to the constructor. See dependency injection and/or the Strategy pattern. For instance , and smell could be instances that provide information about visibility of and or the sound other objects are making. These could be used to compute the needed data of how creatures senses their environment. The advantage is that you can control the state of creatures dynamically. For instance, to simulate blurred vision, you could hand over a instance adds a random vector to the result. If you always need the same functionality for all creatures, it is not unheard of to simply include it in the class as a static member. Please note that I am not suggesting access to every other object and rather, to an object that has access to other objects' data and returns only the needed information. For instance, or ? 

I read the answer by @Randomman159 and am not going to repeat what is written there. Two important tools for processing a large quantities of data in parallel are SIMD and the computation shader. These allow you to perform a lot of computation in parallel. Another tool used to improve performance with tasks that can be parallelized is multithreaded programming. You need to try them out and check the results before making a choice. Sometimes (for instance) writing to the graphics card memory is more time consuming than the benefit from using a computation shader. 

tl;dr I suggest making the players' brush paint a visible (or invisible) 2d plane. Diff the users' painted image with the origin (the desired silhouette or 2d model). If you want to increase accuracy then make the guiding lines and brush more narrow, to allow more room for error, make brush and design thicker. Otherwise, you could measure the distance of each (x, y) the users click / touch on from the spline by calculating point to segment distance. Then you can average the distances to compose a measure of accuracy and efficiency. It will require more work to get a meaningful measure of completion and realize how effectively the user performed. 

Here is an idea: you probably know of the dimensions of the screen, you know of the resolution of the squares, and at any time when a point on the screen is touched, you know this points x and y coordinates. 

I have the following problem: I have a a class called Stage, that keeps an list of entities, which it iterates over every update loop, and updates them. One of these entities might be a weapon (PEW PEW!) that when updating spawns new entities (projectiles, KA-ZOOM, KER BANG!). How do I add these new entities to the list in of entities in Stage? Currently, I have Stage as an singleton with global access, so that the entities which in turn spawns entities just calls the instance of Stage's addEntity method, but that feels silly. Stage -> Entity (weapon) -> Stage again? I have a similar problem when creating enemies: Stage -> Entity (enemy wave) -> Stage again I've been thinking about passing the List into all entities that can create other entities, but then I'd have to change the update method for the base Entity class so that it takes this list, a list which most entities have no need of. Also, when adding an entity to Stage, Stage must be made aware of a number of graphics components for that entity, in order for Stage to be able to tell the renderer (which has an OpenGL context) to load the appropriate resources for those graphic components. Any ideas what I should do? Am I doing it the wrong way now? Also, while we're at it, why is Singletons so frowned upon? 

This is how people usually do it: Create a framebuffer 1 Render your triangle, and all glowy things to this framebuffer 1, but also things that should occlude the glowers. Make sure depth testing is on. Create another framebuffer 2 and bind this framebuffer 2. Now take framebuffers 1 texture and do a post processing effect on it, what you probably want to do is a gaussian blur. Bind framebuffer 0 (the one that actually draws to the screen) Draw framebuffer 1s texture as a full screen quad Turn on blending, make the blending equation additive Draw framebuffer 2s texture as a full screen quad You can achieve the pulsing in two way, either you can make the triangle less opaque when rendering to framebuffer 1, or you can modulate the resulting fragments from the gaussian blur step with some coefficient. Of course, the level of opaqueness and the color modulation would have to depend on some period of time, eg. 

Currently, I have a part time job and any time I spend on this engine is either taken out of my limited free time (I'm a student working to support myself through school) or out my time working at my job. I really believe this engine can make life much easier for people designing Tower Defence games, Shooters and and Platformers while also possibly improving their results. It could also support RTS, RPGs and racing games very well. It continains original algorithms that could be used for procedural generation of organic round and smooth levels. The algorithms I used are new and are not available in any other level editor I've seen. In order to constantly improve the Engine and have it tested thoroughly I think the best route is releasing it to the public. What are the best ways to benefit myself and others with my new framework? I want to have some lisence, allowing me to share the framework and still benefit from it. Any advice would be appreciated. This issue has been on my mind a lot this year. I am hoping to find a solution that will bring me some relief. I am thinking of designing three sample games, releasing them and starting a kickstarter, any advice and thoughts on the matter would be valuable. My goal is like Markus von Broady suggested, to get people involved in developing the engine and let people use it for games for either a symbolic fee or for free and charge for support. That or use some form of croud sourcing. Do I need to hire a lawyer to get some sort of legal document to protect my work? 

Picking random (see the black dots) and randomly decide if they are grass or dirt. Then for over all tiles, check if it's closest to a of dirt or a grass. Done! 

You should probably let player use their own tool and allow them to mod/upload an icon for this purpose into the game. Drawing it in game, is a matter of tracking the mouse position and clicks, designing the drawing tools gui and simply adding and removing pixels at position (x, y). It is not complicated but sounds like a waste of time if you could allow them to upload an existing image that was created with a good tool. This depends on the budget of time / hours you have set for you game and how critical the painting of symbols is to your goals. To place textures on top of existing ones, I would suggest you add a rectangular mesh to the model where you want the symbol to be and add the icon with a transparent background as a texture for that mesh.This should work well for starters and save you the trouble of writing extra code.