Use USB network tethering, possibly after installing a different build of Android which supports this (your Nexus was designed to be re-flashable) Operate the tablet in USB Accessory mode, using software on the pi to be the host (rather than the original idea of something like an Arduino with a host shield) Enable USB debugging on the tablet and use an ADB port forward for tablet-bound network connections. If you want pi-bound connections you can ssh in and enable a tunnel back through which you can forward them. 

If these are wrong-baud-rate garblings of the the messages produced by the Kernel startup code, you could remove them by commenting out or disabling the lines in which produce those, typically something like: 

There are embedded USB host chips (really special purpose microcontrollers with embedded USB stacks) such as the Vinculum from FTDI, which can be controlled over interfaces such as SPI or perhaps asynchronous serial. One of these could be interfaced to the GPIO or alternate functions on the GPIO pins. However, this would be an expensive and limited solution compared to using the built-in USB host capability, extended with a hub if needed - they really exist for the sake of people who just have to hang a USB device off of something like an Arduino which lacks any native USB host capability. And it's not like an embedded USB host would get around the limitations on power passing through the pi, either - you would still need to rig up an alternate power routing, at which point you might as well just use a powered USB hub plugged into the pi normally. Perhaps the one narrow case in which it might make sense would be if you wanted to run a very primitive bare-metal program on the pi, without bothering with incorporating a USB host stack into your custom firmware. 

plus some atypical error cases, which you might want to leave intact. The actual justification for this answer though, is that if you don't feel like setting up a build environment for the kernel, you could also leverage the fact that these are null-terminated strings, by using a on the raw kernel file to overwrite the initial characters of each argument ("U" and " ") with null (ie, 0x00). Make sure if you do this that you overwrite rather than insert, as the latter would render the remainder of the kernel meaningless. An electrical gating of the transmit data line with a GPIO should also be fairly simple. 

You probably could make a distribution which would run atop a FAT filesystem and store data of interest in what look like new camera images. If there are issues getting this to work as the root device, a simplification might be to connect it as a secondary one with a usb-sd adapter. However what you could do with it would be limited, and there is a lack of documentation. I believe wifi adapters are available quite inexpensively. At best it falls in the category of things to try if you already have one of these cards, or plan on buying one for the intended use in a camera. 

Since you are using a cross binutils, try arm-xxx-xxx-objdump -D --target binary -marm With the actual name of your appopriate cross objdump. You may also need to play with -mthumb depending on what instruction set you have targeted - during execution arm and thumb mode can be distinguished, but it's not always possible to tell when just looking at binaries without heuristics or simulation. Often thumb code is preferred for the internals of a program, but arm code often shows up in interface stubs, still that depends on the build flags that were used (or in your case, instructions manually written). It's possible there's a comparable way to get the iphone version of otool to parse an arm binary for the pi, at least to an extent. 

Generally speaking, this is a task for a small barebones embedded MCU (like the referenced ATmega), not something running a multitasking operating system like a pi typically does - the pi is not only drastic overkill for the task, makes overcoming interrupt latency a challenge, it is also the type of exposed platform with galvanic connections which one must be exceedingly careful of when working in the proximity of line voltages, even when optoisolation is theoretically employed. Further, MCU-based TRIAC dimming is the type of problem with general details which really belong far more on EESE, rather than on a pi-specific site. However, to address a very specific problem in your design, your apparent attempt to use PWM with 50 Hz frame timing generated by the pi is inconsistent with how a TRIAC dimmer works. TRAICs are essentially one-way-controllable switches - they can be turned "on", but not "off". However, they are useful for AC circuits, because they will automatically turn-off when the current falls below a hold-value at zero crossing. As a result, you can achieve a pulse-width type of modulation with a TRIAC, by waiting some time after zero crossing to turn the TRIAC on, and then having it be on for only the remaining part of the cycle until the next zero crossing. To do this, you would not use a PWM configuration, rather you would implement a programmable delay from the interrupt indicating zero crossing, until the output driving the TRIAC. In some MCUs with versatile counter timer blocks, you might be able to do this using mechanism somewhat resembling those used for PWM, but still fundamentally different as the "framing" of the waveform comes from the AC line, and only the delay producing the duty cycle comes from the counter-timer. When I prototyped a similar system recently, I had the Linux-based user-interface, talk over I2C to an MCU (ATmega in the prototype, TBD pending cost analysis for production) which did the actual tight-timing zero crossing and TRIAC activation delay, along with closing a loop based on measurements of what the TRIAC is actually controlling. That permitted clean segmentation of the software and removed latency concerns of the Linux scheduler from the actual TRIAC control function. It also meant that the application-specific powerline electronics could be contained on an inexpensive and easily revised 1- or 2- layer PCB, while the far more costly to develop Linux processor board could remain task-agnostic. 

No, you cannot access it via HDMI, as the camera in your monitor is a USB webcam and has nothing to do with the HDMI system of the monitor. You can only access it via your USB host interface, or via something hosting it as a USB peripheral and forwarding the data to your pi (for example, you could plug it into a another pi and have that send you the data over a network). 

Another option would be to use a low voltage USB-serial adapter on the tablet and the UART pins on the pi, or else another USB-serial on the pi. 

You can change the ownership of the required GPIO device files to a non-root userid under which you run the web server and associated helpers. Even better, assign them to a user group including both the web server and your test account, and set the group permission bits. Or you can write a daemon which runs as a user which has been granted access to those files, and accepts commands and queries which it carefully sanitizes over a channel such as a unix domain socket, named pipe with file-level access restrictions, etc. 

There are two problems with your approach. First, asking the tablet's boost converter to power the pi is a bit much - at the least it will give you short battery life, and there is a real chance of ultimately damaging it. Next, putting the OTG adapter on the tablet end means the tablet will be the host and the pi the device. It seems that because the zero does not have a USB hub, it should be possible to operate it in a USB device mode, but as of the moment there doesn't seem to be much support for that (it is possible the introduction of the zero will give momentum to such efforts, but pursuing that path would just duplicate the existing model A / zero device mode questions). If you want to do a direct USB-USB connection, you should probably turn things around, so that the pi is the host and the tablet is the device. Provide external power to the pi. Then use the USB OTG adapter on the pi end of the cable, and the normal USB cable on the Nexus end so that it's ID pin does not get grounded and it remains in device mode. Once you have a pi-host to tablet-device connection you will have several options for establishing communication, however their details are Android questions which are more appropriate to the Android site than the pi one.