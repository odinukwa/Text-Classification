I want to return an iterable collection of all q-grams of a provided string. This means all sub-words of length . Let be 3 for example: as an already whitespace-stripped and upcased word or string. and are constant strings and that are put surrounding the string before splitting. That is a common trick to get more q-words. For the word the resulting q-grams are therefore: 

The exception are "tight loops" when the frequent initialization and destruction would cost to much. But actually, is quite cheap and this is not a "tight loop", so I would recommend it. 

I want to show how to interact with C from C++ and chose a simple and small library to demonstrate. zlib's , and looked like a reasonably closed set of funtions. Does anyone see anything fundamentally wrong with my presentaion? The main code I present here is in . Intro section: 

In big files you may want to "sectionize" the using by from which they came from. (Edit, thanks to comment below) Best do not introduce before other though, you can group the using afterwards. E.g.: 

Given a boolean 3D matrix and a set of actions specifying bit flips at certain positions, a set of resulting matrices can be obtained, one matrix for each action, as if executing each bit flip individually. A statistic (feature representation) defined on a matrix which for each row, column and depth counts the number of active bits at the same depth within some hexagonal distance in the first two dimensions of that row and column. What's the fastest way of getting such a statistic for each of the resulting matrices (afterstates), given the previously mentioned original matrix (grid) and actions (, and )? For example, given , , the first afterstate of can be obtained by . Actions are guaranteed to be bit flips. If the feature representation for is known, the feature representation for can be derived and need not be found from scratch. In the code below, the naive approach () and an incremental approach () are given. The naive approach should be easiest to understand. This is the hot hot hot path of my system and I want to make it faster, but I'm no speed demon. Any tips and comments on anything else, small or large, is also appreciated. Below the code is some background which is not required reading but may make things more concrete. 

Note that creates a copy in the inner loop, where one can add before adding it to . Instead if the new C++11 ranged- and one can of course just use lengthy iterator-based -loops. Using instead of would also work, I guess. There are no set-operations involved here. Actually, now that I think of it, would be much better... hmm... One could save some copying by pulling out of the loop, initialize it with a a size of and use to put the values into it. And if one does that, one can even save the copy of all values by just replacing one in the inner loop, but I can not see how right away. Ah, well and you need a printing routine, of course. 

I feel like some places could be improved, maybe. The iterators maybe? Getting rid of the loop in favor of an algorithm? Maybe even not returning a full at all, but only an iterable proxy-object, but that would too long a shot for this small example, I think. 

This algorithm sorts a list of Individuals, each with two fitness values, into what's called non-dominated fronts. A non-dominated front is a set of individuals where none of the individuals dominate each other. An individual is said to dominate another if is equal or lower (<=) for all fitness values and lower (<) in at least one fitness value. And so dominates both and , but neither of the last two dominate each other. The rank of an individual indicates which front it is a member of. would have rank 0; and would both have rank 1. Non-dominant sorting is a small piece in bigger puzzles such as multi-objective optimization with genetic algorithms. If you are interested in how the algorithm works you can check out Jensen 2003, but I'm completely new to Haskell so I'm sure there's a lot to pick on without understanding squat about the actual algorithm. Here it goes: RankSort.hs 

naive: 10.82 incremental: 4.74 There are some asserts in the code which all hold and might help you read it. The given benchmark parameters and grid are all typical of my simulation. Background: Imagine a geographical area divided into disjoint regions (cells), where each cell has a base station which provides service for cellphones within its area. Two mobile callers within some distance of each other cannot use the same radio channel, lest their handsets will interfere. When a new caller requests service, we must therefore find the set of channels that are free in the cell of the caller and the neighboring cells within some given distance. We can represent such an area and the channels in use with a boolean 3D matrix where the first two dimensions represent the geographical position (i.e. the cell) and the depth represents the channel. Cell areas often are circular in the real world, and we can approximate them as hexagons instead. Finding the neighbors of a cell we must therefore use the hexagonal distance. Assigning new calls requires to find the channels that are free in the nearby area (eligible channels). However to select channels that will optimize grid usage as a whole, statistics, i.e. the feature representation, are useful. So when an action happens, i.e. a caller terminates a call or a new one requests service, there's a set of legal actions to take depending on the action type ( or ) and the grid. The afterstate is how the grid would look after performing an action, and the feature representation of that afterstate, when compared with the others, informs the decision making. 

I do not do this for all names, only for the most frequent ones when it really saves space -- and most people do know anyway. Most -items I write with their namespace when I use them. I often apply a to (lots of strings in function arguments), but and I typically do not (better being explicit at the few location they are used). When I have to use lots of somewhere I shorten the code with a local or . 

My version uses several C++14 constructs. This is intended, because the code is part of a lesson for teaching about C++14. Is there anything I could do better, especially with respect to C++14-ish code? 

It is ok not to initialize , because it is a class/object. But you should initialize variables. latest possible declaration 

Very nice to list what you need by adding the comment. But instead of pulling all names you could make it more explicit 

And with C++11 you do not even need that, you have and ranged- to beautify your. variable initialization 

The code below is the core of a Genetic Algorithm (NSGA-II to be precise, without crowding-distance calculation), but I've taken out all the GA-specific parts and made a generic example. I think I've carried over most of the principles/'constraints' from the original algorithm, but I might have missed something. As you can see in , I need to convert a nested list (2-dimensional) to a flat list pretty often and I'm curious of if there are any better ways to do it. I've added some so that it's easier to follow the size and type (nested or flat) of the lists. Since expected size of input is m=100 individuals () for 500 generations (loops), speed is important. Memory usage is not that important (although knowing how to reduce it would be interesting), but execution time is. Any comments performance-related or otherwise are appreciated. 

I'm completely new to Javascript and NodeJs and functional programming in general. The code below scrapes a torrent-website containing movies, gets info about the movie from the OMDb API and lets a user choose a movie to watch by streaming the torrent. Any feedback appreciated.