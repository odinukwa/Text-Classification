Here are a few more ideas: Point out that that only $2^{32}$ values can be represented in 32 bits (or $2^{64}$ values in 64 bits), while there are an infinite number of real numbers. Therefore, not all real numbers can be represented exactly. For example, if you take the smallest positive number that can be represented exactly and divide it by 2, you can't represent it exactly (by definition). Explain that floating-point numbers are represented as the sum of powers of 2. Have them compute relatively easy values, such as $1\frac{3}{4} = 1 + \frac{1}{2} + \frac{1}{4}$. Ask them to represent $\frac{1}{3}$ as the sum of powers of 2. They will not be able to. 

In the catalog at the liberal arts college at which I teach, we state that students must earn at least a B- in the following early courses to major in Computer Science: 

I also try to model an openness to feedback by soliciting suggestions on how to improve my teaching and putting them into practice immediately. (To see how well I succeed at this goal, I add this question to the end-of-semester evaluations: "The instructor responds well to and incorporates student feedback.") I begin code reviews by congratulating students on what they've accomplished and telling them I'll show them how to make their code even better (as suggested by kayleeFrye_onDeck). 

We don't use code snapshot tools at Mills because our class sizes are small enough (usually <25) that professors and TAs know how individual students are doing. If students are having trouble, they're likely to email me their own snapshot with a request for help. :-) It sounds like such tools would be useful in larger programs. 

I teach undergraduate computer architecture and am reconsidering one of my homework assignments in which I ask students to simulate by hand (on paper) the behavior of different caches on the same access sequence. It is tedious to create such a problem in a way that the caches behave differently in an interesting way, and I'm sure doing the problems is tedious too (as is grading them). I'm willing to do the work and have students do the work if it's actually useful, but I'm not sure it is. The purpose of the weekly homework assignments it to reinforce the material the students learn from the textbook (Computer Organization and Design by Hennessy and Patterson), lectures, and in-class exercises. There is already a full set of lab assignments that require wiring or coding (in assembly language or Verilog). There is not time for an additional lab assignment on cache simulation. I have a separate homework assignment that asks higher-level questions about caches, such as which of two versions of code is likely to run faster if cache performance is taken into account. I think writing cache-aware programs is an important skill. Is simulating the differences between direct-mapped, 2-way set associative caches, and 4-way set associative caches an important part of students' education? 

In my graduate programming languages course, each student is required to learn a different novel programming language during the course of the semester and give a presentation on it to the class at the end of the semester. Learning a new programming language is hard, and, inevitably, some students present inaccurate information, sometimes in response to a question from another student or me. In my private feedback to each student, I let them know any mistakes I saw in their presentation. My question is whether I should let the class know when some presented information is incorrect. As an example, a student showed some code in a language related to Java. When asked by a student whether the statement in a doubly-nested loop exited both loops, she said yes, which was incorrect. I kept quiet, not wanting to embarrass the presenter, but I wonder if I should have said, "Actually, like in Java, only escapes from the innermost loop. Do you think it is better to correct mistakes when they occur or to let them slide? I wouldn't correct an English mistake by a student. Should I correct a CS mistake? 

I love to make jokes and allusions. Here are some examples of ways I handle my increasing age difference from my students: Explaining the reference When describing how assembly language programmers compete to shave instructions off an operation (such as calculating absolute value), I tell students about the old game show Name That Tune and sometimes even show them a clip. Challenging students to recognize the allusion After teaching students about big-endian and little-endian, I ask if anyone recognizes where the references is from. If a student successfully guesses Gulliver's Travels (from the terms or from the images I include), they get a prize. If not, I explain. Learning students' culture As a sample app from my mobile development course (to demonstrate design docs), I designed a variant on Pokemon Go where students get and evolve professors by meeting with them. I paid someone on Fiverr to create Pokemon-like images of me. Create memes Students seem to enjoy memes. Here are some that I've created. This one is about L2 caches: 

When a student comes to me with a question that neither of us can answer, I ask her to post it on Stack Overflow. (An example would be if she's trying to do something in Android that I've never done and that isn't well documented.) Some students are timid about posting online, so they need a little hand-holding and encouragement, which I provide by pointing them to resources on how to write a good question, giving them feedback on their question before they post it, making any needed edits after they post it (letting them know what I've changed), and voting it up, which I can legitimately do, because I've vetted the question. Usually, they get helpful answers. If it's a particularly tricky problem that's holding them up, I offer a bounty. These experiences help build their confidence and skills. 

In an introductory Java class, I think it's fine to see that primitives are passed by value and that objects are passed by reference. That tells students what they need to know, although I might phrase it differently. (I'd say that primitives and references are copied when they're passed.) In an upper-division programming languages course, I'd go into more detail about calling conventions and the full story about pass-by-value and pass-by-reference (and pass-by-name, so I can tell the joke about Niklaus Wirth), if there's time. While I love for students to catch my mistakes and white lies, I think it might be nitpicky to do so in this case. If you feel a need to bring it up, go to the professor's office hours and express confusion reconciling what he said with what you've read online (perhaps citing a specific source). If he's a decent professor, he'll admit to having oversimplified or he'll accept the new knowledge. 

Choosing good names for classes and methods helps students think clearly. As the great Josh Bloch says: 

I asked them to write a one-page essay with their reactions to the readings and suggested the following optional questions: 

Normally, Java 2 is a prerequisite for my Computer Architecture course. I gave permission to a strong student who has only taken Java 1 to take Computer Architecture, provided that she learn the basics recursion over the summer. (In Computer Architecture, the student write recursive programs in assembly language.) Can anyone recommend a free online source where she can pick up, and ideally practice, elementary recursion? The only language she knows is Java. Update I modified my question to make more clear that I am only asking about elementary recursion. (I teach about recursion, in depth, in a more advanced course, Programming Languages, in the functional programming unit.) I ended up recommending to the student: 

I have all of my students read Keeping Perspective, a section of So you want a code review..., which I wrote when working on an open source project. It's short enough that I'll excerpt it here: 

As shown by the following graph, the percentage of U.S. college students earning bachelor's degrees in CS peaked in 1986, with the percent of freshmen planning to major in CS peaking for the classes of 1986 and 1987. 

This has two problems. The first is the lack of parentheses, which can lead to incorrect order of operations. For example, 

Why was there a precipitous fall after these years? As always, claims should be backed by data. This question is relevant to CS departments planning to understand and plan for changes in enrollment. This question is related to, but different from, this question about gender distribution of CS majors. 

You can also teach students the XOR trick for swapping two values without using intermediate storage: 

Their answers allowed me to discuss their specific concerns with them individually and in class. For example, some women of color worried that they would be given jobs for which they were not qualified, either directly from companies or through special programs targeting minorities. I let them know that I (a white woman from an upper-class background) got my first programming job through family connections: I was qualified for it, but there's no way I would have been considered (fresh out of high school) without connections. If their families lack connections (which is overwhelmingly the case for my students), they should take advantage of other ways to get a foot in the door, paying it forward later. Alumnae Examples On the day we discussed the above readings, a recent graduate came to speak about her job and how she successfully advocated for herself, such as not letting herself get interrupted and telling people when they attributed to someone else an idea that she had originally suggested. Pre-coaching for Industry I advised students that they should maintain a network inside and outside their company, keep their resume up-to-date, and save some of their money (if possible) so they can move if necessary. If a bad situation arises, they should consult their support network for perspective/affirmation, document everything offsite, and not blindly trust HR or management. I let them know they could also come to us any time for advice. Career Counseling When students are considering accepting jobs, I steer them to companies with good reputations for their treatment of people like them and where we have alumnae or friends in mid-level or senior positions who can help them. If a student gets an offer from a company I don't know, I use my network (LinkedIn, Systers, etc.) to find out the company's reputation. 

First, I love SICP. I took and later TA'd 6.001. Like many MIT grads, I tried to teach it where I became a professor, and, like most who attempted it, decided not to do so again. The main reason it is rarely successful outside of MIT isn't the difference in student quality but the difference in the support the school can offer. If I remember correctly, at MIT, there were three lectures a week, two recitation sections, one tutorial section (approximately 4 students meeting for an hour with a graduate TA), and many staffed lab hours. A high school or small college cannot generally provide that level of support. Also, when taught outside MIT, it is usually as a junior-level course, and students still usually find it overwhelming. (An exception is UC Berkeley, which taught it successfully for many years and the freshman level.) I am not saying a high school class could not succeed, just that it would be very difficult, and the amount of work required would be exceptional. It might also be hard to motivate students to work so hard on something so abstract, when they could be learning app development, computer games, or another more immediately rewarding topic with less effort. In summary, I would advise against using SICP for a class at the high school level, although I do think it is possible to supervise an independent study with a sufficiently motivated and sophisticated individual or small group of students. 

Students should understand the importance of the memory hierarchy, including how caches use temporal and spatial locality to tremendously speed up memory accesses. Otherwise, a student would not know there is any difference between: 

I've heard this argument before and wonder if it's really true. The first programming course I encountered was in Scheme, and it seemed that students with prior programming experience (even in imperative languages) tended to do well in the course, while some students without prior experience were lost. Of course, my undergraduate days were long ago, correlation does not equal causation, and my data is anecdotal. Is there evidence that using a functional programming in an introductory college course reduces the effects of differences in programming background? 

This, of course, is ugly and will not work if you have variables named and . I'm afraid I've done the opposite of what you've requested and provided an argument against C macros. (I use the above argument before teaching Scheme's hygienic macros so students appreciate them.) 

My college requires students earning a bachelor's of science (BS) degree to take a CS course. Currently, they take the same course as CS majors: a typical Java 1 course. What would be a more useful course for students majoring in the life sciences (as almost all of our BS students are)? Some of the students hope to become doctors or veterinarians, others medical researchers. 

(This cartoon might be too risqué.) I then teach and step through the correct way to write and call a swap procedure: 

Here's how I explained it to my students after teaching with App Inventor during a pre-college summer program: With textual programming languages, your program won't work if you have a semicolon or even a space character (in Python) out of place. This can be frustrating, especially for beginners. They might conclude that programming is about punctuation, when it isn't; it's about logic, design, teamwork, and problem-solving. The argument for starting with visual programming languages is to expose beginners to the essence of computer science, rather than the superficial issue of placement of curly braces, colons, etc. If they enjoy it, they can go on to learn those things. To use an analogy, programming with blocks is like writing stories with word magnets. On the positive side, you don't need to worry about spelling or punctuation; on the negative side, your vocabulary is limited. Programmers disagree about whether using languages like App Inventor (or Scratch or Alice) is really programming/coding. To me, it is, since the logic is there. I don't see a fundamental difference between using a mouse and using a keyboard. That would be like saying that Jean-Dominique Bauby wasn't a real author because he used blinks instead of a keyboard or pen. (See also these Dilbert and xkcd cartoons.) To be fair, not everyone agrees with me. Nonetheless, I can understand the frustration of students who wanted to learn "real coding" and why visual programming languages tend to be used just by beginners. One of the most common questions about App Inventor is: Why can't I see and modify the Java code created by App Inventor? The answer is that App Inventor doesn't create Java code; it creates something called byte code that is not human readable. Learning textual programming languages is incredibly useful and fulfilling; it's like moving from Lite Brite to an unlimited set of paints and brushes. I hope that some of you go on to do so. Disclaimer: I am one of the creators of App Inventor.