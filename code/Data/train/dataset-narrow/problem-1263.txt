The check for self assignment. Yes it looks like it speeds the code up when you do self assignment. It does. But conversely it slows the code down when you don't have self assignment (not very much but a tiny bit). The problem is that actual self assignment is very exceptionally rare. So the question becomes: Is the size of smaller than . People have tried this and found the most efficient version is not to test for self assignment but always make a copy. 

Declare your variables as close to the location that you use them. This also allows you to initialize them on declaration (which is always nice). 

This is creating a temporary object. Which goes out of scope at the end of the expression (the semicolon in this case). And thus the temporary objects destructor is getting called just after the constructor completes. 

What happens if you have more than MAX_ELEMENTS. In C++ you would generally use a vector to hold this information. 

You have the 1st list but seem to cobbling the second list out of thin air each iteration. Code Review. 

What I would take away from this is how the standard library does this. It disassociates sorting algorithms from specific container types (by using iterators). Then you can write the sorting algorithm in a way that is independent of the actual container type. What I dislike about your code is that when you move elements you basically re-order the list (you actually move the nodes). This is a complex operation taking many checks. Personally I would leave the actual nodes where they are and move the values between nodes. std::swap() can be used for this. This: 

Type 1: FAIL Type 2: OK Of course with good coding standards that can be avoided (always use '{' '}' on if). But every now and then people can be lazy (or just careless) and the second version prevents accidents from happening. The best solution is not to use macros. Use functions and let the compiler work out when to inline. Edited: For billy: (Type 3) no do while 

Note: NOT the character but the number zero which is an unprintable character (there are no glyphs that represent the number ). Note the character is represented by the number 48 (in ASCII or UTF-8). Did you want to remove the first character from the string? 

I am confused why you are including for the C compiler but not the C++ compiler. I did not think there was anything in the boost that could be used by C (I could be wrong but seems strange). The default rule for C/C++/Linking are: 

Is there a maximum run length? (ie is single digit lengths enough) Does the input string only contain alpha? (ie no numbers). Do you encode single character runs? (ababab => a1b1a1b1a1b1 or ababab) 

Now you no longer have any memory leaks (its not as if dimension is a huge object the standard copy constructor will work (and 99% of the time it will be elided)). Also I would declare VecDemIter in terms of VecDim so that if you change the representation you only need to change it in one place and the change automatically cascades through the code. 

I understand you are trying to make your exceptions easier to use by adding a couple of stream operator to the class. But you can achieve the same affect with greater flexibility using std::stringstream. 

My generic build file can be found here. Have a look and take what you find useful. 7: Plug for things I do but thats because I am ecentric. The one thing I hate about make fils is the long lines it prints when building. These are useless and just confuse the output. 

Comments Most people write bad comments. Things that should be commented are idea/decisions/why. Writing comments that explain the code is horrible. This is because comments often fall out of date with the code, then you have to worry which is correct. Is the comment correct and the code is bad and thus I have a bug to fix, or os the code correct now I have to understand the code to re-write the comment. Both of these situations is a waste of time. Your comments are bad. 

Design Memory Allocation A string function can either allocate a new string and return it or return a modified version of the original. Your function CAN NOT do both of these. This is because we don't know if the returned string is returned with ownership or not (ownership defines who releases the memory). 

C++ has a better literal. is the literal that represents a . More Info Vector - Resource Management Allocation Vector - Resource Management Copy Swap Vector - Resize Vector - Simple Optimizations Vector - the Other Stuff 

The other thing you should do with is mark the function as non throwing. This allows optimizations when you use your class with the standard library that are not available otherwise. So I would have written this: 

Comments on Algorithm There is already a std::reverse() algorithm. Using this would reduce the complexity of your code to just finding the beginning and end of each word. Since does this automatically it makes the code very trivial: 

In bool you catch all and return true/false to indicate success. This is fine on an internal interface. But you should note that not all exceptions derive from . I would catch or mark the function as noexcept (or both). 

If you put it inside the class definition then it will be in the scope of all methods of that class. If fact I would go one step further and typedef the container type. 

You can access (a ) with like you would an array. So no other code needs to change (you just need any or calls). So you have no memory management calls and thus no headaches with leaks. Now a nice bit is you can replace with and it checks to make sure you access to the array is in bounds (and will throw an exception if not). This may help you track down your error. Initialize srand() one You should only initializre the random number generator once in a program. 

What if I type on the input? As user input is line based. Most programers decide to get a single value at a time. 

OK. The next one is arguable (so feel free to use best judgement). Personally I find that hard to read: 

The operator has a higher precedence than so your modulus is being applied to the last element only before the addition. 

Since you don't modify the values it can be made simpler by passing a const reference of each parameter. Thus having no copy. 

Another optimization for IsPrime() is that you only need to test using primes. ie no pointing in testing with 6 (its not prime) as all values that are divisible by 6 are also divisible by 3 (is prime). So if your loop only tested by using other primes: 

But I find them a bit disturbing being so unbound (they are in the global namespace). Maybe just a feeling. I personally would put them in an anonymous namespace. I also prefer 

C++ is all about the type of the object. Putting the star with the type helps to correctly associate the type as a pointer. Don't use unless you are required. Anything inside the class declaration also automatically marked . Also the keyword has little to no affect on the compiler (ie it is ignored by every modern compiler) and its decision to actually inline the code. 

I would prefer to re-define the C compiler as the C++ compiler and if need be then be explicit about the C++ compiler. 

Well it is linked forward and backward. But you have not facility to use the backwards part as you have to always start at the head. Add a tail pointer to your list then you can scan from the back. Personally I would also add a node. This will remove the need to constantly check for . Code Review Unlike structs use the same namespace for structures as other type definitions. So once defined there is no need to use again. 

Good first try. Rule of 5 done. Excellent. The one thing to note is that you should probably mark the move operators as this will provide extra optimization opportunities to the compiler when your class is used with standard containers (or within classes that are optimized for movable objects). Note: The swap operator is also usually . You missed a couple of functions, though in general you did rather well. 

The expression is always . There is an argument for removing this from the expression. Though I personally prefer to leave it in place (but for me that comes from writing templated functions in C++). Where the type may be changed at some point in the future. So I am OK with leaving it but others may complain. But the expression is also wrong (not multiplication happens before addition). So really this should be . If you are implying that the size of object can change at sometime in the future (by using the ) then you need to multiply this by the (len + 1) otherwise you have len objects plus a single byte. Which is not logically what you want. You want (len + 1) objects. Here you allocate memory but don;t check for success. 

The functionality you are trying to create already exists in using to help. Comments on the rest of the code: Here you use emplace back: 

All uppercase variables by convention are reserved for Macros. Don't use them its actually quite dangerous and can have unexpected results. A normal naming convention for C++ is to use "CamelCase" (As you are). BUT use for user defined types and for the name of objects (variables/functions). Prefer to use over The only difference of the two is that forces a flush. But the stream (especially cout) automatically flush when they need to. So having a human flush them is just inefficient and it the worst case can cause severe efficiency problems. So let the code do its work and flush when it needs to (it will do a better job than you). 

Both of these allocators will finish in the blink of an eye. You want a test that last a couple of seconds to get real information. You are not running the constructor. 

Create should just be a constructor. Sure you can have a function. But to use this it should be a method otherwise you need a member to call it. 

Thus using new to allocate memory for a space of size 'M' means the memory returned will also be aligned for objects of size 'M'. This also means that it aligned for all objects that are smaller than 'M'. Thus for your block of memory that will hold multiple objects of type 'N' such that `M = Count*alignof(N)' it is automatically aligned for all objects of type 'N'. 

Note rather than use (which may technically be larger than 32 bits) I would use the specific size of integer you want (32 bit). Which is now standardized as Your use of variables names. They are a little on the short side. Make them longer and more descriptive. To answer your questions: 

Code Review Move and Copy I see you deleted the copy/move operations. Fine if you are still working through it. But in the end you will need to implement these. These are actually quite simple when you learn the tricks (idioms). As a simple helpping hand: 

My one problem is here. You are passing a pointer to an observer. Pointers do not express ownership. So it is unclear for future users of your object if you should pass a dynamically allocated object or a a pointer to an automatic object. It becomes clear by reading your class that you are not taking ownership of the pointer and your class always assumes that it is not NULL. So in this case it is probably better to pass it by reference. If there are cases were ownership can be passed then you should use smart pointers. A quick search on google for smart pointers or ownership semantics should give you lots of references.