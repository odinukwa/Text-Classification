On PC's there's of course Memtest86; I've seen that catch bad RAM before. For the Pi there is a userspace application, , available through Raspbian: $URL$ Since it runs in userspace though, there are a few problems: 

You may not have quite a few of those, but you should be able to use for most of them since they will be accessible via , except, obviously, the stuff. 

That's not "setting the port to a nul value". It's forcing the init system (more specifically, systemd) to use as the unit files for the service, meaning it won't do anything. This will have effectively disabled it on reboot. The service itself is about running a login console over the serial port, not enabling or disabling the port iself. You of course do not want such a service if you are using the port for other things. However, there likely is also a problem caused by specifying the serial port for kernel logging in , which is how it is by default. This is not related to the login console, although the port may be used for both things at the same time (which, by default, it is). Put another way disabling the login console only solves half the problem. A better way to do this is via , which will everything necessary, properly, for you. If for some reason you believe you do want a login console, use to reverse the prior mask and reboot. Re-enabling it via if it has been masked will not work (but disabling it that way should be fine) -- the man page indicated by joan explains why. 

Or you could just use to be sure. If you are interested in which processes occupy the most memory, install and run , hit shift-F, go down arrow one to select , hit s then ESC and the stuff at the top of the list is it; is the important number. , the foundation of the GUI stack, may use 75-100 MB all by itself. 

1. This one is actually from Raspbian jessie and comes with systemd; it is slightly different from the shutdown in Raspbian wheezy (Greenonline's answer quotes that), which is an example of what I mention in the next paragraph about different implementations meeting the same specification. The shutdown process is actually part of the init system, which is SysV on wheezy and systemd on jessie. 

does not exist anymore because last year, in sync with the upstream Debian source, Raspbian switched to using systemd in place of SysV as the init daemon. Systemd does not use runlevels; the parallel concept would be targets although it is not in many cases an exact parallel (in this context it more or less is, however). Systemd is not specific to Raspian, Debian, or the pi and there is plenty of further reading you can do about it online. Anyway, in this case 

The original A/B models have some problems with the USB ports and power. For starters, they won't deliver much more than 150 mA each, and the USB 2.0 standard is 500 mA. This means certain things such as external drives will not work. Generally, keyboards, mice, wifi adapters, and bluetooth adapters are okay. However, I believe many wifi adapters will be close to this boundary. Further, inserting a device which requires close to the threshold (such as a wifi adapter) will cause a current surge and corresponding voltage drop, which browns the pi out: I.e., it will reboot instantly. That means these devices must be attached before you power up, and if removed, cannot be re-inserted. To summarize, you almost certainly need a powered hub to try and do what you want. 

The Xorg server, which is the foundation of the GUI, blanks the screen after a period of inactivity. You can find out how long this is via (the "timeout" value under "Screen Saver"). It is probably 600 (10 minutes). The display will wake up if you hit a keyboard key or jiggle a mouse associated with the session. You can prevent this behavior with: 

It indicates the .so is linked to another .so that cannot be found in the library path and therefore is likely not installed. If there is reason to believe this is a common library that should be available -- eg. pthreads -- you can search the raspbian repository for packages containing that file: 

If you've tested the same software on another computer and the browser is consuming all the cpu when this happens, then you've probably hit a limit. The pi is not a powerhouse. 

1. I am also positive that is a question which does not need asking here or anywhere else as it must be clear from a glance at the documentation, and there must be thousands of examples besides online by now. If you want to write code, you do have to be able to read documentation and examples or it will take you forever to get nowhere. 

Under ; there is a comment about this there too. Change it to "no" and the console will not be cleared after boot. I think this includes the logo but I can't recall; otherwise there may not be much you can do about that. This presumes you aren't using autologin, or a fresh jessie image, which may be configured differently. 

Yes. At the end of you will find a SEE ALSO list that includes . That has various examples but "for detailed information about the configuration format and supported fields" you are supposed to look at "the example configuration file, probably in /usr/share/doc/wpa_supplicant/". On Raspbian, there's actually an "examples" subdirectory instead, including one big one that contains detailed comments about (presumably) every potential field. However, it is gzipped, so an easy way to view it is: 

is the ID for Realtek, who make the chipsets used in these dongles. If you see nothing, try and see what 's are listed. The other part of the ID is , which will be either or (there are two versions of the TL-WN725N). The former should have an in-tree1 driver, try . The latter requires an 8188EU driver which you have to install as per the directions you've already found. 

in order to make something happen at a regular interval. With a standard linux kernel, this is subject to a latency of 10 milliseconds. In other words, if you try to do this with a granularity finer than hundredths of a second, you will not get the results you want. But with hundreds of a second it's fine -- if you wrap the nanosleep call above with gettimeofday and set the loop for 5 or 10 or 20 times per second, with no other significant processes running any given iteration will generally not be off by more than a millisecond. A millisecond is not a bad margin of error at that level, but obviously it is a bad margin of error if you want to do something 1000 times per second (you will probably end up somewhere between 500 and 1000). Although I am sure about the accuracy of the clock, I cannot say whether actually trying to time things into the billionths of a second will work well, since on that scale there could be a variable number of nanoseconds between and and . However, on the milli- or even micro-second level, with no other significant processes running, it should be precise. 

I think you mean without the internet or other nodes. The simplest way in that case would just be to set up the pi as an "access point" even though it is not on a network. Then you can connect the ipad to that. Of course, this probably then means the ipad can't connect to anything else, so it depends on your other needs -- e.g., if you want internet access and can connect the pi via ethernet, it becomes an actual access point. Beyond that I think you have painted your self into a corner with all the non-options. 

ARM is actually a family of processor instruction sets. The A/B/+ model pis have a processor which is ARMv6, whereas the Pi 2 is ARMv7. A few things to note about that: 

It doesn't have to be at the beginning, but don't add a line break anywhere. That file should contain one line only, it doesn't matter how long it is. Blacklist via a modprobe .conf file The preferred method for blacklisting is to add a line to a .conf file in (on the second, ext4 partition). 

This will leave you with output in ; it will get ovewritten at each boot. If you are using a wifi adapter, DHCP, and WPA, instead try: 

1. They are still treated differently because the executable can check what name it was invoked with. 

The default desktop environment (DE) on raspbian is LXDE. If you search online (e.g.) with regard to this issue, you'll find a chorus of crickets -- meaning no one cares that much. If this is very important to you, you could figure out exactly where the widget comes from and try and contact who's responsible, although I would guess by this point they are aware and do not care either. There are other GUI temperature monitors available that are configurable this way (both conky and gkrellm, I believe). There are also completely different desktop environments available for the pi, although I cannot promise they come with sensor widgets that have a Fahrenheit option. 

1. The pi actually does not have any particular style of parallel bus exposed, but presumably you could implement one with the some of the pins. 

Note the at the end to ensure this forks, since we have said this is . If does this itself (i.e., daemonizes), you could invoke it directly from . You might prefer to replace w/ for debugging purposes. 

Probably yes -- with a capacitor. Without a capacitor, you might be able to get the photoresistor to register a change from very bright to very dark, if it can offer up enough change in resistance to make the difference between a "high" and "low" signal. Attach a GPIO as an output to VCC set to high,1 and another one to SIG as an input, and of course, a ground to GND. Cover the resistor and check the state of the input, then try shining a very bright light on it and check again. You don't need/can't use the Adafruit code for this since again, that is not the principle it works upon. I have no idea if that will work but it is simple enough to try and should not damage anything. 

If you keep thinking this way you will never start. To mix some metaphors, instead of putting one foot in front of the other and surveying the ground in front of you, your head is in the trees. Here's a concrete example I frequently observe with new users. We have a badge system, and one of the first ones most people acquire is informed, which is earned if you "Read the entire tour page". You don't have that. I'll be a bit blunt and say perhaps this is indicative of you considering it a waste of your time to put one foot in front of the other -- you have your eye on more lofty goals! But, again, if you keep thinking that way, you will never cross the starting line. If you had taken the tour, you might have recognized that this is not a discussion forum, and hence, questions like this are not appropriate to the format (another good thing to read are the first two links under Asking on the main help page). Here are some questions that are more appropriate, taken from your post: 

I believe this has two different potential causes, although it's something I'm less sure about than the time out: 

is needed here to execute that command in a root subshell. This is because would execute as root, but the redirection () would be done by your current (non-root) shell. You could also just do this . After that you should, hopefully, be able to set as . 

To to get an external drive to work (e.g., that same one is flawless this way on a B+ for extended periods). But that is no help with the older B. 

Not clear what you mean here, but if it is a shared NTFS partition, sure you could do that. The native linux ext4 format probably performs better, but I believe it is a hassle under windows 

No, not directly. Arduino's version of C++ uses a non-standard set of fundamental libraries -- notice and ; the latter is for i2c stuff. WiringPi is a C library for the Pi intended to be familiar to people with previous Arduino experience. It may or may not be helpful to you in this context if you wish to use that code as a starting point. 

You've cited this source documentation, and I think you should treat that as authoritative, vs. the anecdotal blurb on elinux. Technically anyone can add stuff there, which is fine as long as you take the nature of the material into account. That's one anonymous person telling an anecdote about something they bought on Amazon, so: 

That there is nothing in when you plug the cable in is not good; the kernel should at least say something like . Try to see if there is any record of that at all. Do the green and yellow LEDs on the pi (next to the red power one) light up when you plug the ethernet cable in and turn off when you unplug it? If not, there may be a hardware problem: make sure the jack is connected firmly at both ends and your router is up and running. If the lights still don't come on, try another cable. Check the output of . Is listed there or is there just the interface? If not, try and see if it gets added. If eth0 is listed by ifconfig, this indicates the kernel has detected the ethernet jack and loaded a driver for it (whether or not a cable is connected). If that is the case and the LEDs are not on when a cable is connected, I think you may have broken hardware: on mine, those lights are on whenever a cable is plugged in, even if the interface is down and not being used. You could try describing this scenario exactly ("cable in, eth0 up, link LEDs do not turn on") on the troubleshooting forum, and/or asking your retailer for an opinion, if possible. 

If what you want to do does not fall into one of these categories, there's no point to a VM unless your goal is to play with VMs. In which case, what you have in mind is "virtualization software like VirtualBox" -- just not VirtualBox itself, since it is unavailable, I think. I don't see OpenVZ, either. What I do see is libvirt, which serves as the foundation to a number of such things. Searching for "raspberry pi hypervisor" turned up a couple of possibilities: 

The switches ensure permissions (including the executable bit) remain the same. I have done this (for different reasons) before with raspbian and there were no problems. Just to be clear: make sure you do this with the two cards mounted on a computer. Although you could use rsync over a network to update on a running Rpi system, it is a very bad idea, if the pi is the destination of the sync. 

in . If you've exported (which you'll need to if uses it at all), you can leave out . If it still does not work, the easiest way to debug it is to log to a file from . 

Note you don't want to move the directory stub () itself. You just want what's inside (directories: ). Be certain that worked (you don't have to check too hard, just look to see if the directories are there and there's stuff in them). Now delete the original: 

I get the same thing (disable_l2cache=1) without overclocking on a Pi 2 running a stock 4.1.9-v7+ kernel and the latest firmware update. The distro is Fedora 21, but I do not think the distro will make any difference except to the extent of the settings. 

As a few people have pointed out, conventionally a file is source code. If this is a shell script in , it should be suffixed with . It also must conform to the rules described in , which is why you are getting an error. See #2, re: the rules this must conform to. 

If 1.8 is what comes up for (it does in your screenshot) then that is the one being used by default. You should not have to change anything. 

So, you have to configure and build your own kernel. If you are comfortable with that and it seems worthwhile, here's the official Pi kernel source tree. I recommend cross-compiling it as it will probably take at least an hour (or two...) even on the 3 -- I don't know. If you look up a level in that github repo there is a cross-compiler there under "tools", but, for the version used on the Pi 2/3 you can also use the arm-linux-gnueabi cross-compiler that is stock on most current linux distros (CentOS has a lot less available than most though, so if you use that elsewhere you may have to install a fedora or similar rpm from rpmfind). Beware This is no guarantee that it will actually work on the Pi (just a pretty good bet), so you may want to search around to see if anyone has actually confirmed using it.