Here is my system. I give it top marks for ease of sharing, but one downside is that it does not do any kind of autograding without some scripting on my part. I purchased a paid subscription to Dropbox. This allows me to set up read-only folders. At the beginning of the term, I copy/paste all of the names from the course into an Excel spreadsheet and collect an email address from every student for a Dropbox. I then create a series of folders using a file (I am a Windows user), generated with a function like . This creates lines like I copy and paste this group into a file, rename it to , and - voil√†! - I can double-click to create a directory for every student in my class section. I run the batch file in some subdirectory of the Dropbox folder so that they will ultimately be sharable. I then go through and share each of these folders with the respective student with write privileges. Finally, I create one last folder, something like . I then copy and paste the email addresses themselves into the share box for this folder, but only allow read priveleges. Now, I can drop my assignments into to class folder (which is basically instantaneous), and I receive my submissions through their private folders. I get everything timestamped, and don't have to log into any websites to get the assignments. One more side-benefit of this arrangement is that when I need to send a file to some student, we already have a shared folder that I can drop it into. No need for emailed attachments. 

In the follow-up discussion, we get to Motivating Principle #2: always provide the least permissions that you can get away with. This is what prevents trouble, and helps Objects to guarantee their part of Principle 1. And finally, I bring them to my Warning Principle #3: getters and setters are how we grant access to a shielded variable, but if you've created an unmodified (straight/unfiltered) getter and an unmodified setter on the same variable, you are doing it wrong, and you have just made a public variable. What follows is a series of short Object-design tasks in which I tell them to sketch out, for a series of theoretical private instance variables, appropriate getters and setters. After each one, we put a student's answer up and I let the kids discuss/critique/defend what is up on the projector. This gives us a chance to practice our three principles together, and really drives the point home. I give this lesson high marks, historically, for squelching both instance variables, and de-facto created by unfiltered getters and setters on the same variable. Instead, I have found that students generate much more thoughtful object designs. 

.... right here, I stop, and ask the class how we should create our two points. This is when I get to the Motivating Principle #1: it is the responsibility of an object to care for and ensure its own variables. Which leads to the question: who should directly set the actual and values in each of the two points, the object, or the ? Given principle #1 (which I have not yet justified), we opt for the object. So, before we continue with , we go back and create a constructor for . Before we resume this narrative, the astute reader will notice that the seeds of our destruction are already present in those variables! My next stop is to finish the constructor: 

First of all, there is no straightforward, accepted answer to this question. Reasonable people define plagiarism differently, and there will be students who will play around at the very edges of what you consider to be plagiarism no matter where you hold that line. My answer is in the context of a classroom teacher in the USA. The single most important thing that you need to do is to create a policy that draws the dividing lines as carefully as you can. Sometimes, a computer science department will create a plagiarism policy together. In many ways, this is ideal, though it can constrain your instruction as well. Within such a policy should be both the formal specifications, as well as an underlying principle that guides it. Due to very high bars of evidence that I have had to meet, I have not had a tremendous amount of support when addressing plagiarism anywhere that I have worked, so it has fallen to me to work relatively independently. For years, I had strict policies, and found plagiarism around every corner. I would try to work with administration and I would provide penalties to the students in question, but I discovered that I was ultimately paying a very high psychological price for this. I started to become distrustful of my students, and it made me simply like them less. This was a disaster for me a teacher. I really wanted to be able to trust my students, and I couldn't shake the feeling that it was ultimately my own policies and practices that were setting the table for these regular heartbreaks. So, it was time to break things down and rethink it from the ground up. I knew that I wanted to encourage pair programming, so this already muddied the waters considerably. I have a habit of giving quite difficult labs, because I want my students to wrestle with meaningful, weighty problems. If I left my students without access to Google and StackOverflow, no one would be able to complete them. I also wanted to begin to grade my students with code interviews for a huge number of reasons, which would also give me a chance to assess whether the student understood what they had submitted. And finally, I have created a system of retakes with tests and quizzes that ensures a bare minimum of mastery of the material. (This system has not been discussed anywhere on CSE yet, or I would link to it.) This left me with a starting point of pedagogy. I want my students to tackle these problems, and to put time, thought, and care into finding good solutions. I want them to pull out a piece of paper, or walk over to the whiteboard, or pull a friend over, to try to figure out whether they were heading down a good path. I want them to work in Driver/Navigator pairs (if they so choose). I have provided challenges appropriate to this level of work and thought. Therefore, I made the following decisions: 

Classroom Practices Once the beliefs above are in place, we can actually do the work of motivating the students: 

I don't go in for the notion that students will be perfectly happy to laze around and get partial credit (50% is a very steep penalty!) In lieu of trying to get a genuinely good grade if they feel like they can. I don't allow test corrections, instead I have a full system of progressively (slightly) harder make-ups which I have described here in some depth. If the goal is to make sure that students learn the material that you are teaching, then the impulse to create some sort of additional pathway to learning after an assessment makes a lot of sense. And just after an assessment has gone badly is a perfect time to get strong, focused learning from students who, perhaps, thought they knew the material better than they really did until but a few moments ago. The iron is so hot at that one moment, it's really a pity if you don't strike it. Why do I say this? Remember that strong emotions are one of the neurological keys to immediate and impactful learning. Thus, there may simply be no other opportunity like this to reach a student who, perhaps, is not entirely in love with the material, but simply wants to do well and get through. This is that fleeting moment when you can help them understand that idea that they didn't quite get the first time, because this is when they really care. They messed up, perhaps badly, and if they really focus right now, they might be able to partially fix this. And maybe, just maybe, you'll get them through a tricky idea that will really help them later. Such as later in your same course, when they will really need to have already mastered this material if they are going to be to even have a good, fighting chance at the new material. I've chosen for myself a very different structure than test corrections, and what I do works very well for me and my students. I might have to recalibrate if I taught a different population. But I suspect that whatever methodology works for you is less important than that you do something meaningful with those failed assessments, because they can be one of the most powerful tools you have, and you ultimately don't get too many of them. 

ultimately prints , and how to avoid this problem. However, a more serious understanding of IEEE 754 can wait. I have my kids implement this standard (just the number representation, no arithmetic) as an elective after they have already learned about two's complement, big and little endian, and how a logical-gate 8-bit adder works. Before they've had some time to live with and understand how binary numbers work, they won't have much of a chance of appreciating how floating point is dealt with on any serious level. 

This is such a consistent trap that I ultimately created a worksheet to deal with it. At this point in my course, I have recently covered binary and hexadecimal, so I also use this worksheet as an opportunity to gently review those concepts. My worksheet may not be as physically active as some of the lessons that have already been posted, but it is highly practical. The entire activity takes 10 minutes at most, it reviews some additional concepts, and (because the distinction being made is fairly simple) they never seem to get confused again afterwards. It could also be given as a very easy homework assignment. The top reads: 

So, I am not interested in which language is better, because that is a matter of opinion. What I care about is whether making a switch from Scheme to Haskell will directly help me accomplish my goals. What programming language concepts does each language bring to the fore? So, I am seeking input from folks who have taught using these languages about the kinds of experiences they had. How did the language features of Haskell or Scheme make your students' experience better (or worse)? For context, my kids come into their junior year knowing Java, C, and Python pretty well. For their junior year, it was decided that there should be a course in theoretical computer science. In order to have labs, I further decided that we should move away from imperative programming and expose the kids to a functional language. So, while the class was not about functional programming, the kids did quite a lot of it. I used Scheme (DrRacket, to be specific), but over the course of the year, I found that kids were sneaking functions into their labs, which ran (to my thinking) counter to the goals of the class. I was also a little displeased with the rather unintuitive way that boolean functions and contracts interacted in the language. I have, as a result, been thinking about migrating over to Haskell. If I did this, I know that I would need to redesign my labs (and I wonder if the Turing Machines I have them design would suddenly run very slowly!) But, other than not having a function, what other benefits might Haskell bring to my students? I don't mind putting in the work to redesign the course if there is a sufficient benefit.