Yes, if there's extra data/rendering being performed that's outside the bounds (frustum) of your camera, it would be more efficient to not attempt to render the geometry that can't be seen. How you actually do this depends on how your game is structured - tile-based 2D games can simply figure out what bounds of the world to draw, whereas 2D and 3D games not on a grid tend to use a space partitioning algorithm such as Binary Space Partitioning 

Go is difficult for computers because there are many, many possible moves for the player in each board state, too many for the computer to brute-force and calculate all possible outcomes (unlike, for example, tic-tac-toe). Traditionally, chess playing computer programs would calculate all possible moves a few turns into the future and pick one of the moves that would lead to the "best" state, maximising the possible advantage of the computer player and minimising the possible advantage of the other player. However, there's more possible moves in a complete game of chess than there are atoms in the universe, and this applies even moreso for Go, where there are many more possible board states. There are simply too many possible moves for a modern computer to calculate in any reasonable time. Instead, different approaches to AI need to be used to play "better" at games like Go, such as deepmind being able to "learn" how to get better at a task in a similar way to how real intelligence works (learning from trial and error). So if you want to make an "open information" game hard for a computer? Have a very large amount of possible moves to make, nearly all of which could be a good move for the player. 

When I set the intersection point, if I for example use 0.1 instead of 0.001 the puck travels further before it gets stuck, but for all values I have tried (including 0 -> the real intersection point) it gets stuck somewhere (but I necessarily not get a stack overflow). Can something in this part be the cause of my problem? I can see why I get the stack overflow when using -1.0 when calculating the new velocity vector; but not how to solve it. I traced the time steps used in the recursion (initial time step is always 1/60 ~ 0.01666): 

Even though the code above seems to slide the puck correctly please have a look at it. I have a few questions, if I don't multiply by 1.90 in the newVelocity calculation it doesn't work (I get a stack overflow when the puck enters the corner because the timeStep decreases very slowly -> a collision is found early in every recursion), why is that? what does 1.90 really do and why 1.90? Also I have a new problem, the puck does not move parallell to the short side after exiting the curve; to be more exact it moves outside the rink (I am not checking for any collisions with the short side at the moment). When I perform the collision detection I first check that the puck is in the correct quadrant. For example bottom-right corner is quadrant four i.e. circleCenter.X < puck.X && circleCenter.Y > puck.Y is this a problem? or should the short side of the rink be the one to make the puck go parallell to it and not the last collision in the corner? EDIT2: This is the code I use for collision detection, maybe it has something to do with the fact that I can't make the puck slide (-1.0) but only reflect (-2.0): 

I got around my problem by re-writing my code to remove ComponentListener. Doing this I got a single response to a left-click (or right-click). This doesn't differentiate between left or right-clicks - it just picks up clicks, but that works for me. My test code is posted below. 

I have then just disabled or enabled the length option (which gives a fixed duration to a particle burst if enabled) depending on whether thrust is engaged or not, i.e. if thrust on then disable length, otherwise enable it (I have this set to 10ms in the xml config file). This gives nice, organic puffs of thrust when I 'feather' the thrust control, which is exactly what I wanted. (From my ship class) 

For any basicgame or gamestate that you write in Slick2D, you have to override the render method and so you always have control of what renders and when. You can build in logic to only render if something has been changed by a user at that point. Alternatively, the call to render() in each loop is done from within the AppGameContainer (which extends GameContainer). In theory, I guess you could override the methods there to control when rendering takes place from that point rather than in a given basic game or gamestate (i.e. for the whole application as opposed to on a per gamestate basis). Either way, that could be a lot of work if you have a lot of things to track in your level editor just to reduce the rendering overhead. If the application is PC-based then what is the problem with restricting FPS to something like 60 or 30FPS and letting it run? I am developing a game that has level menus in between live-action rounds and in the menu states the application barely uses any CPU at all. I see about 4% cpu usage when scrolling around a map on-screen for example (that's on a 2.4Ghz quad-core system, but it works just as well on an old laptop). Also, if your level editor is gui-based (i.e. a real-time, drag and drop affair) then won't you need regular graphic rendering anyway? And finally... I have just tested stopping the rendering after setting up the screen in one of my applications and the screen just goes blank. So that leads me to assume that the render() method is also ensuring that the screen is refreshed or that something at the AppGameContainer or GameContainer level is clearing the screen before each frame. Overall, I'd recommend just restricting the FPS to something relatively low, e.g. using: 

You've joined together the creation of the bullet when pressing the space bar to the movement of the bullet. You should change your code so that when the space bar is pressed, a bullet is created. Separately, still in your update method, apply your translation based on velocity to any bullets that exist. You'll also want to remove bullets at some point, likely either some time after they were created, or when they pass outside the bounds of your game - or better yet, on collision with something. 

I'm working on a tile-based 2D pseudo top-down/side-on game very much in the graphical style of Prison Archiect. More specifically, I'm referencing their style of drawing wall tiles where you can see the south, east and west sides of the wall at once. Here's an example from my engine: 

It's worth mentioning that I also plan to use UV-mapping so that only the walls facing the light source will be illuminated, rather than the pre-shaded tiles I'm using as an example. However, that would mean that the tiles adjacent to a wall in shadow may be lit and I don't think this would look quite right. Alternatively... B) Occlude light from the entirety of the wall tile 

I can't decide where on these tiles should occlude light cast out by light sources. If the red highlighted areas are the "top" of the wall, and the blue highlighted areas are the "side" of the wall, I believe I have two options: A) Only occlude light from the "top" of the wall 

I have been reading plenty of tutorials about sliding collision responses yet I am not able to implement it properly in my project. What I want to do is make a puck slide along the rounded corner boards of a hockey rink. In my latest attempt the puck does slide along the boards but there are some strange velocity behaviors. First of all the puck slows down a lot pretty much right away and then it slides for awhile and stops before exiting the corner. Even if I double the speed I get a similar behavior and the puck does not make it out of the corner. I used some ideas from this document $URL$ This is what I have: Update method called from the game loop when it is time to update the puck (I removed some irrelevant parts). I use two states (current, previous) which are used to interpolate the position during rendering. 

What am I doing wrong with the velocity? I have been staring at this for very long so I have gone blind. I have tried different values of recursion depth but it does not seem to make it better. Let me know if you need more information. I appreciate any help. EDIT: A combination of Patrick Hughes' and teodron's answers solved the velocity problem (I think), thanks a lot! This is the new code: I decided to use a separate recursion method now too since I don't want to recalculate the acceleration in each recursion.