I noticed a few points where you code looks as though it shouldnt actually work. You also had a mix of variables declared and never used, and variables used but never declared. The Big Stuff First, multiple statements are always preferable to a single statement for multiple variables 

Public vs Private First I would like to note the use of a subroutine along with a function. This basically just means that the subroutine is accessible by other routines/the macro's list. On the other hand, the function is only seen by other code in the same module (so we don't risk the wrong code using it, and potentially returning a bad value). This is a little bit more advanced compared to where you are, but it is a good practice to get into early. Variable Declarations I noticed that you were using Hungarian Notation (HN). I would venture to assume we all go through this phase in the SO VBA community, but the sooner you break that habit, the better. It is far better to properly name variables than to use HN to denote the types. For this purpose, the names were easy. For larger projects it can be a bit more complicated. The sooner you avoid the habit though, the better. The Good Stuff Avoiding Errors Before They Happen Error handling in VBA is not very robust. It works, but oftentimes it is misused. I am of the mindset that error handling (in the line label sense) should be avoided at all costs. The best way to accomplish this is to use logic to your advantage, and to wrap repeated operations in a single function. In this case, the appropriate method was easy. The function takes an input cell, and returns a value based on the contents of the cell. While you initially checked for the function checks for since this will catch as well as anything else that isnt a number (since isn't but will throw an error if multiplied by a number). Why Use Functions? I like to think of functions as magical creatures that really are under-appreciated by newer programmers. Maybe I am hyping them up a bit. Maybe not. What I can say for sure is I used to avoid them. Then, someone came along (cough ThunderFrame cough) and lightly-reprimanded my avoidance of using single-functions for repeated steps (I had the same command in numerous places. He reminded me that, should that command ever change, I would then have to find every single place it lived and fix it. Simple advice, simple reminder, but it changed my approach to using Functions. I tend to ramble, so the point here is this: When you have some operation that needs to be done in multiple places (or on multiple conditions) you should strongly consider a function. That way, should the operation change, you can fix it in the function, and not in all of the places that you are calculating the operation manually. Functions also allow you to return different types of values. Declare a as a and you can return a a a . Whatever you want to do. They allow greater control over the flow of your code. Final Tidbits As I do in many of my CR posts, I recommend using RubberDuck, especially when you're starting out. You can find it here: $URL$ It helps for finding those little things you do without knowing it (Implicit reference to and for example) and help you learn better habits. Over time, these small changes in habits can make or break a programmer. Best of luck on this. 

Voila! We now have completed our computations much faster than if we had done the same thing on the worksheet. I would recommend practicing with arrays and spending some time understanding what they do, how they work, and how to loop through them. They are very powerful when used well. Rubberduck If you haven't heard of it before, there is a tool called "RubberDuck" that can help tremendously with refining your code. It has inspections that can catch a lot of the common mistakes. It also improves the window immensely. Check it out here: $URL$ Locals, Immediate, and Watch Windows If you aren't using these windows already you definitely should be. They make debugging much easier, and it also improves your ability to step through your code. You can find them in the 'View' menu of the IDE. Best of luck! 

There isn't a big difference here. I have taken an extra step to ensure I have qualified the object I am working with, and I use a block to do this. As a result, all I need to do is put a period before each object I need to qualify and voila! On bigger projects, blocks can increase performance, and they make your code much easier to read. Above all else, they get rid of the pesky implicit calls. I'll insert a plug for RubberDuck here. Mat's Mug and his team have come up with a great tool that can make this process much easier on you. RubberDuck has a 'Code Inspection' feature that finds all this stuff for you, helps you fix it, and oftentimes tells you why it is wrong. Check it out if you have a chance. Once you have refactored this code to remove this beginner stuff, you may be interested in using the function, and Variant arrays in order to accomplish the original splitting of your data. Good luck! 

What this allows me to do (primarily for data) is use an empty value if the input condition is invalid (null) while still returning a numeric (or some other non-string) if the input is valid. Likewise: 

It looks harmless right? Wrong. Foo is 'ed but it isnt given a type so it is now the dangerous Type which is a known problem-child. Variants are great when you need them, but they have a habit of rearing their ugly head for those knew to the language. But wait, there's more! Range("A1") is unqualified on both sides. So this means it is actually: 

Workaholic Subroutines One of my worst habits used to be that I would pack as much of a process as I could into a single routine. I had an aversion to too many subroutines and too many modules. The way I saw it, get it all done in one go, without having to jump all over the place. See below: 

Now, we can change sheets all we want but the correct sheet will be modified. This is a prime example of why we must always qualify our ranges. There will be some circumstances where ActiveSheet may be justified. The only instance I have had this happen with is when I am detailing into PivotTables, and getting the output sheet. Even then though, I try to avoid this practice if I have the time. Next, naming conventions within your code. Overall, you are on the right track, but lets look at a couple areas where you could improve. 

Notice how I ensure that only one line has responsibility over setting the return of the function to the default string. If the user chooses not to enter a custom string, then the function skips the If block and sets the string. If the user enters an invalid string it ignores the and again sets it to the default string. Always try to strive for this. It will make your debugging that much easier. Otherwise, if you do the same thing in two places, and it breaks, you have to fix it in two places. I can't tell you how many hours that has cost me before I learned to code smarter. Finally, my last note is this, and it is somewhat counter intuitive to my first suggestion: if you are relying on Boolean returns, and "On Error" statements to catch errors, you can improve. Look at why it breaks, and then try to handle that specific issue. As Mat's Mug mentioned, bubble it up if you can. In my most recent project I am aggregating a fairly complex report, and if even one of the sub reports fails it could invalidate the data. Instead of checking for errors at every juncture, I let the functions return empty arrays if they fail, otherwise they return the data they were supposed to. In my aggregation routine, I check to see if there is data in the input, and if not I handle it appropriately. I also alert the user to what data is missing, and where I am trying to use it. As a result, the routine fails productively, and I can then trace it back down to determine what went wrong. Overall though, 17 seconds for a routine to run isn't too bad. Youre likely taking the biggest performance hit on the fileread, and on the formatting on the worksheet (any time you perform operations on the worksheet it will cost you more than it would if you did it in memory).