To explain this array, the first dimension of the array declares the amount of messages stored, while the second dimension declares the amount of languages one can output the information. So, if we would like to print in any of the languages, the following line would just do that. 

Again, as I see it, this program does not treat an interruption as such, so I'll give you an explanation of how I've been learned to treat them and how it can improve your code. First of all, an interruption is a source which interrupts the currently executing code to execute another that expects an event. Due to this behavioral, an interruption should be always as short as possible. An interruption needs to be as short as possible because if you can call an interruption before it has ended (like in the case you are experiencing) it will overflow the stack pointer at some point in your execution and cause your device to not perform correctly. This happens because when calling an interruption the embedded saves where it is, performs the interruption/s (if more than one has triggered) and then comes back to where it was and resumes normal program execution. Do you see the main problem in your code with what I've explained here? If your interruption takes longer than the time you call it periodically, you will never exit the interruption, thus regarding your code unusable while also making your embedded to perform badly or not as expected at some point because of an overflow in the stack pointer. Because of this, an interruption should only consist of flag management which will be used in turn to allow the code intended to be executed in said interruption in the main body in your code. You might ask yourself how you can do this, so I'll give an example of how to implement this on your own code. 

Since you are using camelCase for variables make sure this is consistent e.g. , The line looks like test code and should be removed. If not, then it violates the PSR-1 requirement that files should either declare something or have a side effect e.g outputting html. The s should be saved in an array or string and returned by the function instead of ing them. Several variables are only used once and should not be initialized e.g , There is no check to ensure and are not null. The code assumes each model will be saved without error. The database saves should be wrapped in a transaction with proper error handling. 

1) The class has functions that begin with capital letters e.g. and others that begin with small letters e.g. . Follow the PHP Standards Recommendations or pick one style and stick to it. 3) The and functions are poorly named. They should instead be named something more descriptive e.g. and or and . 4) Your checks for existing emails and usernames only need to be run if the email and username fields are set. 5) Your code stops the validation if an error is found. This is inefficient since you can run all the validations and check if an error has been found. 

There isn't much we can do on security since that is in the file that isn't included here. That being said: 1) Do not repeat yourself. The and inclusion of your db and lib files should be done in a separate file that is included once when required: init.php 

If you want fullName to be truly private, you would have recreate Getters and Setters for each object. 

(2) Is this fast? Emulation is probably slower than using native methods - i suppose. However, it depends on the underlying engine. V8 is faster than Gecko. (3) What about correctness? Depends on how you understand correctness. JavaScript is powerful enough to emulate classical inheritance to some extend. (4) FYI If you want a more Java-like access to the parent-prototype with "super"-sugar, you can do something like this: 

However, bear in mind, that "super" is also a foreign concept to JavaScript. You cannot type foreign syntax and expect it to behave identically with comparable performance. Additionally, you may emulate "super" as shown above, but you will have to use with great care, meaning 'ParanormalStudent.super' and 'this.super' may point to the same function, however, the latter will result in exceeding the call stack. This seems to me like a bad practice, since as a programmer you will have a tool which may either work or produce chaos. 

(1) Any opinion about this? Emulating language features/idioms which are not supported by the language itself (e.g. classes in JavaScript) does not seem to be a very good idea to me. JavaScript is not an classical OOP-Language (yet), but there are Prototypes: 

By returning an array you can still get the first unique by applying [0] to the result and indicate no unique entry with an empty array. It also does not change your complexity: avg. n+k with k being the count for different values, but still 2n tops. 

First and foremost, You now don't have to worry if it takes longer for the code to execute than the timer to fire, since you have control over whether or not the program has to read from the ADC. Secondly, your program can execute many things while the ADC performs a conversion (essentially we've made the ADC conversion a task which we launch and later ask for its result), this might remind you of asynchronous code. 

The problem here is the lack of functions or subroutines to avoid repeating code, thus making the code less mantainable. There are here other issues which are also important, for example, multilanguage support, which I'll address in the following To carry out multilanguage, I would declare an n x m array to store the n strings in m languages. To provide an example of what I mean, to store the greeting message, an array like the following needs to be declared 

I see a major flaw in this code right off the bat and that is your interruption management. In my opinion, you are not treating an interruption as such, you are treating the timer as a function instead of a source of interruption in the behaviour of your normal code so a question arises. 

The code works as intended what I am concerned about is optimization, how to improve this code in both, execution time and stability. What I am doing in this code is compare each element from one list with ALL of the elements of the other list (I see a problem here, but don't know how to approach it well, the foreach seems not to be the best option here). 

(1) Usage of prototypes "from my understanding, prototype should be used when the particular behaviour/property is shared with all objects" Yes, this is more or less correct. Functions on prototype are shared with all objects, which inherit it. They are not recreated, but simpyl executed within a different context (this) for each object. However, it depends on your design, if this is desirable. For instance the Getters and Setters in your case can syimply be by-passed: 

This way, you have only n iterations for the first application of remove. Then you reduce the size of the remaining array to at least n-2 for the next recurrence, depending on the distribution of multiple occurences. This should sum up to O(n log n), but i'm not sure when it comes to the exact math. This solution might be worse space-compexity-wise. 

(2) Usage of undefined If your requirements state, it has to be undefined, then make it undefined. But whether that's useful, depends on the use-case. I would go with neutral elements of the desired type for each property. (3) Usage of this Also correct, this is the common usage of this. PS: Also bear in mind, this approach tries to emulate classes. However, JavaScript has no real concept of classes. Emulating foreign language features is not necessarily a good idea. $URL$ 

OLD ANSWER: Seems to me, the more optimal concept is to remove multiple occurences once you can. Given the worst-case scenario, that the unique element is at the ende of the array, filter and find would have to loop over all elements. Then, if indexOf and lastIndexOf are supposed to be O(n), you would be stuck with O(n^2) 

So to conclude, an interruption should always be as short as possible and only used to manage flags which alter the behaviour of your main code block. Hope this helped, comment any question that you might have with what I've explained. Note: The code only wants to give you an idea of how to manage interruption, so it may not be the one that fits your needs. 

I've made a Collatz Conjecture sequence calculator and I would like some feedback on what I can do better in regards to the code I've implemented, i.e. bad practices you see, improvements that can be made to make it faster, errors that might arise from this code that I am not managing, etc. 

The code works as intended but, as said, I would like feedback on what I can improve in this code. That explains why I post this question even though there exist duplicates of this one, I just want feedback on my code, that's all. Thanks in advance for your responses. 

We are given two list on integer arrays, and the objective is to retrieve another list which contains the duplicates in both lists. The code developed is the following: 

This code would make the greeting valid for both languages, while also making the code more mantainable if you want to change the greeting message for any language/s by having all the messages in the same place. Keep in mind I substract 1 from since arrays are zero-index based. Implementing language this way can save you a lot of code, make it more readable and also more mantainable since you don't have to look in n lines to fix an error that has propagated through all your languages due to copy pasting code. This can be applied too to handle any amount of users, further reducing your code and making it, again, more manageable when maintenance or improvements happen (which you are bound to do). If you need help in developing anything, comment my post with what you need and I'll try to give you an answer as clear as I can. Hope this helped explain how to handle multilanguage. Note: To ease the maintenance of interface messages, you can switch the matrix, n for languages, m for messages, that way you will have in the same first dimension the same message for all the languages, rather than having all the messages for a language in the first dimension. 

Your code doesn't just compare candidates, it also creates new records. As such your function should be appropriately named e.g. . Comments are useful. You can declare a phpdoc style comment for your method and add comments to clarify any corner case e.g. the reasoning behind the code block. Searches with imply that unique identifiers are not being used. The should be removed if the fields are unique. If not, you should find a unique field or a combination of fields that is unique for each entry and use that instead. Two candidates in different parties and constituencies cannot share the same name i.e. a John Smith will not be created if another exists in the database. The criteria should be updated as in (3) above. Since you are using laravel you should stick to the PSR-2 coding conventions e.g. for control structures: 

You can then display the list of errors. 6) You are checking for empty strings but not for strings that only contain spaces. You are also not checking if the field actually exists in . Also there are multiple checks for this empty string. You can use a foreach loop. 7) The required and valid error messages for the email can be combined: 

TL;DR: Be clear, consistent and efficient, don't assume things and verify that the output of functions is as expected