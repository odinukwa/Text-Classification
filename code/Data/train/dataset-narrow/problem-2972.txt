Always try to explain it some other way. Try it in another language - there are reasons why BASIC and Visual Basic are used as 'beginner languages', although I would look for 'teaching languages' that entrain a better understanding and good coding habits. I would no more teach someone to program in Java than I would teach them to fly in an F-104. However, this isn't about syntax and choice of programming language. There may be some flaw in your logic, or a gap that you're skating over without even realising that there's an unaddressed assumption or assumed knowledge. There may be some error in your student's understanding - some unstated assumption or 'gap' that she's filled-in incorrectly and internalised - and she might not be aware of it. If that unstated error leads to a dead-end, that's it: game over. The exercise has failed. It would be entirely unsurprising that she isn't able to elucidate and express the 'blocking' point: you are working to develop this ability formal logic in your student and you are both well aware that it is developing from a very low base. The question is: can you reframe the exercise in a way that might reroute you both around a problem that neither of you can identify? That's enough on teaching technique from me. I coach something else entirely unrelated to coding - although I do coach and mentor my fellow-programmers - and you need to discuss this with your professional colleagues in teaching. Now to address the more general question: are there students who simply cannot be taught to program? I'm assuming we're discounting students who have a generally-poor intellectual ability, and that this is about intelligent and able people who have some specific cognitive impairment. Dyslexic people may have difficulty and it isn't just 'they can't read'. They can interpret symbolic information, but layout and formatting are far more important than you realise. There are people who simply cannot dial a telephone number or retype an eight-character code unless it is broken up into smaller groups - and you will empathise with them if I tell you to type in "1101110111111111101110111111101" on your keypad right now. What if your code sample is wriggling in front of them, like ones that binary, and they cannot pin down extract the logic from this unusable and illegible text? It doesn't matter that it's perfectly legible and comprehensible to you, or even to ninety-five percent of your students. Dyslexic people are very good at concealing their impairment, and at working around or under or over it. Often, so good at both these skills that they work out how to read all by themselves, despite the ineffective assistance of their teachers, and are never even aware that they have dyslexia unless they are tested by professionals. And now they've met source code, which is another reading skill: text that conveys formal logic, and has none of the structure of spoken language. Or at least, not the structures that they have learned in their internalised implementation of reading. Try the same problem in Python. And discover that there are coders who are fluent in slicing and never, ever, code a loop - not even in those rare cases where it really is the best way to proceed: I wonder why that is? Be warned, dyslexic people are also very, very good indeed at spatial visualisation and logical abstraction: the mistakes they make as beginners, including the attempts they make to 'bridge' over gaps like unstated assumptions and assumed knowledge, can be incredibly convoluted. This will be especially true of the mistakes or 'blocks' that they cannot elucidate and explain to you! It is in the nature of dyslexic peoples' unconscious (but highly-developed )strategies for reading (and, say, successfully associating names with faces) that they apply extremely complex abstractions to everyday problems without even knowing. This isn't about dyslexic students: I'm using them as one example among many, of students who can program - and program very well indeed - but can be surprisingly difficult to teach. There is, of course, dyscalculalia: a fundamental inability to perform arithmetic. Or so I'm told: I'm still sceptical, and I would classify these rare students as "people that a long line of increasingly-specialised teaching professionals are unable to teach arithmetic". If it's real, it probably does have an analogy in a fundamental inability to program. I am reminded that Bertrand Russell's wife, who spoke seven European and oriental languages fluently, and who was regarded by her husband, among others, as his intellectual equal, never understood the operation of canal locks: despite all attempts at explanation, with working models, by the most eminent engineers philosophers and professors of the British Empire. So yes, you are probably right that some people will never program; and I am completely in agreement with JWZ's assertion that the extended abstraction required to 'get' pointers, rather than merely use them in a pro-forma way, is absent from all but a tiny minority of the human beings alive today. A final point, and a deeply unpleasant one: you may have inherited the results of bad teaching in the student's past. Be warned, some people who are labelled 'introverted' have been very, very badly taught and it is a common malpractice in bad teaching for girls to be conditioned, by a sustained campaign of extremely negative feedback, to step back and step out of a challenging problem that they are not 'expected' to be able to solve. They will have internalised this, and they will have been very thoroughly socialised in the skill of diverting themselves - and you - around that. And they will absolutely steer you around the dangerous confrontations inherent in considering the problem to be anything other than their problem, and their fault. This is less common with boys but it exists: and the higher education institution that you work in is, perhaps, more of a place for people who have been encouraged or permitted to excel than the place where all excellent students can enter and reach their potential. You may be very fortunate, with this particular student, to have been given an opportunity to undo that; and, whether this is the case or not, I am very pleased to hear that you have both the will and the resources to find out what she can really do. 

Hate to add yet another answer, but this needs to be said: there are three things that matter: how to communicate with people, how to communicate with people, and How to communicate with people. Frameworks change. Testing practices change. Version control systems change. Languages change. Algorithms change (simpler but slower as the hardware gets faster). Hardware changes. At some point hopefully in my lifetime hardware architecture will change (away from Von Neumann to cellular automata et. al.). Even a person can change. But people don't change. Peopleware, Mythical Man Month, etc. are every bit as relevant today as they were decades ago. You will have to deal with bosses and coworkers. You may also have to deal with vendors, clients, customers, direct reports, and employees. You will have to go on job interviews, pitch ideas, give presentations, write documentation, send email, and even write policy. Software is a second career for me, I was already an adult when I went into the field. Before doing so I interviewed a bunch of people through my network who were in industry and I asked them what they wish they'd known going in. To a man/woman they said some variant of "people skills". If you are sending your graduates out into the workforce without a solid grounding in this area then all the technical prowess in the world won't help them. They will be rated "hire, but not for my team" in interviews. 

TL;DR Those two aren't your only options. The main concern is cognitive load: learning to program is difficult enough without adding incidental complexity. We've seen an explosion of hybrids in the last few years with good cross-platform support: sublime, atom, etc. And while you couldn't pry vim out of my cold dead hands, learning it is easy if you already know programming but would be a nightmare if you had to learn it and programming at the same time. Ditto for emacs. And that also applies to IDEs like Eclipse and Visual Studio. They have their own way of doing things. They take forever to open. They are user configurable but not easily. I'll never forget the first time I opened XCode and basically said "what the hell is all of this?" Have your students download atom which works reasonably well out of the box with a healthy plug-in community for growth. It's scriptable in JavaScript and themeable with CSS. Unlike notepad it gives you features you actually need to program, unlike nano it uses standard keyboard shortcuts they'll already know from e.g. MS Word (Ctrl-C, Ctrl-V, Ctrl-S, etc). And unlike VS/Xcode/Eclipse it doesn't obscure what you're doing: editing text files. Edit Can't believe I forgot to mention this but... They more or less made us use Komodo Edit (free version of the Komodo 'IDE') in my first programming class, which is exactly the kind of thing I'm talking about and I think it really helped. Simple, no configuration necessary, things that should be easy were easy, etc. Don't know if they still offer it or not but I'd Atom is better along just about every conceivable metric. 

This helps them at least understand why we need to program. After this I give them an exercise on "giving instructions to someone". Intentionally ambiguous so that they can easily misinterpret it in hundred different ways. Like ask them to get me a Peanut butter and jelly sandwich the next day and we'll snack it in the class. Say it's for "me" (i.e., the teacher). Intentionally critique them like "but I wanted it toasted" or with "less butter" etc., Students usually go "But you didn't tell us that! How do we know?". That's exactly what you want! Now educate them to the benefits of being precise! When you give instructions to a computer you have to be very precise. With humans the more ambiguous you are the more confusing things get. So, now we come full circle to why learn programming? It's the art of being specific - that is what we want to teach/learn. No matter what job you do, it'll come in handy. You'll realize what it means to be specific and "how specific" is good enough. The act of talking to a machine is just a fun way to teach you this. You may not use it, but at least you'll know something about it! I've had great success with this with kids of all ages. It helps sink things in. Know why it's useful and what's the point are the best questions IMHO. 

A computer is blind conceptually speaking. Even if you gave it a camera, it cannot "see" per se. It has a translation of what is viewed to bits. Now to the blind student. Image Processing is similar to how folks without sight process things - they "feel" their environment for "signals" and make a conclusion about what it is. A computer does the exact same thing, but with math. Ask them to feel a stick. Easy. Now draw the stick on the floor/paper and ask them to say if a stick or triangle exists on the paper. Really hard. Ask them how would they know if a triangle is on the paper. Feel the edges? Anything else? How about everytime there's a triangle a new sound is heard? Be creative. Now talk to them about "rasterization". Think of handling them one sliver at a time, and if anything is different by feeling, they note it. Can they "conclude" a triangle after seeing various cuts of the paper? This exercise can be naturally extended to Image Processing and then math can be explained. Computer Graphics is different. It lives in the visual plane and the idea is to "draw" it. A good introduction is this: Problem statement: Draw a line on a graph/matrix and each "cell" must be filled in. Which cells to fill in between points A and B when "drawing this line". Extending this to blind students could be done with toys/pins etc., How would they know which spots to "fill in" to get as straight a line as possible? What does a "straight line mean"? This discussion could lead to things about using a line's slope (i.e., math) to figure which pixels to color on a raster display. Same thing with Circles. I'd start here first. Once that's done, to move to transformations - moving things in space. Easy to feel and then take to the math. I haven't worked with the blind, but I imagine such exercises/parallels with their sensory world could be useful.