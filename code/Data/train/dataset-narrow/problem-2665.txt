Can I just suggest that you absolutely forget about biomes if you can't make and use height-maps yet. Step by step is the way to go. 

imagine the +'s as the vertices of your mesh. Simply randomize the height of the corner verts (A,B,C,D), then average the mid-verts between these, with a little randomness as well. Keep doing this foreach mid-vert until all your verts are positioned in the z direction. You'll end up with a fairly natural looking terrain. There are all sorts of ways in which you can modify your height algorithm, using various noise and smoothing methods. There's not really any math behind generating a simple terrain mesh. Not until you look at more complex methods, when you're after more interesting results. But you have to be comfortable with generating height maps first. 

To compute the camera size you will only need to scale it down from your maximum camera size if the map is smaller than that size. When scaling, you need to select the smallest dimension of your map, vertically or horizontally, and work out the >1 ratio of width:height or height:width. You want to do this because you always want the graphics to fill the scene-view and the larger of the two dimensions to reach off-screen. Working that out and using it to scale your map will assure that your scene-view is always full. You also want to do a separate bounds check, as Cong Xu mentioned, so your camera follows your character, except the camera's position is bound within a camera safe region. That region will be 1/2 camera width and half camera height in from the edges. Notice that this will need to be recomputed for each map as the camera size will change. 

If anyone knows how to set a uint to the shader that would be useful. Though now that I know the 'unpacking' works ok, I'll be passing in the blendweights via a Texture2D. 

you just have to provide the vertex data, which you've edited during the frame. Maybe even read about dynamic buffers, they might give you even better performance, but I don't know about that yet. edit : Just to clarify, this is SlimDX (DX11) code, so it should translate easily to straight DX11 code. edit2 : And just to answer one of your questions above, you can also have flat geometry and use the vertex shader to shape your terrain, but you still need to get the height data in to your shader. So you can avoid sending new geometry in, but then you have to send a height map in. So you are still updating gfx resources. Which is faster depends upon your vertex and height map formats.. importantly, their data sizes. In my case, the terrain only has Position & Normal, so it's not too large. My UV's are derived from position. And I think by updating the vertex buffer itself, then it's done, and you've got your vertex heights precalculated, rather than having to sample from a heightmap, which does have a cost. 

Well, this is both funny and painful because of how much time I spent trying to resolve this issue. The corruption might have been a clue. I loaded up the program tonight and the issue is non-existent now. It turned out to be a driver issue, because I have just installed the AMD Catalyst 11.10 Preview driver and haven't touched the re-sizing code. That makes sense. :) 

I would supplement those questions with specific questions relating to the team and project that you personally want to know from a management position. 

AI in MMOs are pretty ignorant. You're dealing with a world where you have the potential to reach millions of players all of varying skill. If AI in MMOs were really present you would see creatures constantly rush attack your healers, then go after the cloth wearers, etc. But we don't see that. We see a system that gives a mob x health and an attack rating depending on it's level, and a faction that it falls under (which makes it attack people whose faction differs). They run (sometimes) when health < y, and might trigger more mobs to help if condition x is met. The system might do a DX roll to see if the attack/spell hits or not, and goes from there. If one player is attacking a lot (raising threat), creatures turn to that player. So this system is very, very basic. There's not a way for a casual player to flip a 'casual' switch. From there we do get into some 'advanced' encounters that appeal to the hard-core crowd. But even these are not fully automated by AI -- they're scripted events. Once a high level guild takes a week and figures out how to kill the King of Dreams, then they can pass the encounter details to casual players. I remember back in EverQuest that you could start a conversation with NPCs and you could trigger different actions by saying certain things! Some linguistic AI. 

It probably sounds obvious, but... Don't full-screen your game while you're recording the video otherwise it will 'obviously' be incredibly slow because it captures your screen resolution. I'm guessing this is what you're being bit by. FRAPS will take care of this just fine. So will many others but I found FRAPS the most convenient and easiest to use. I used FRAPS to record and Windows Movie Maker to put together some maps I made in Starcraft II -- example. 

Two things... The first one being the most critical Don't Ignore Marketing You're indie. Nobody knows you. You absolutely need to get yourself out and start building your brand as early as you possibly can. You can't expect to have the next big hit so you need to start dipping your toes into the water early. Marketing is hard. Building a brand can be a full-time position. Spend an hour or two everyday talking to your community or other people to help them discover you. Nothing sucks worse than spending a year making something and you don't meet a fraction of your expectations or even reach anything close to your potential. Don't Sacrifice Quality Don't fall into the trap of thinking that just because you're independent that you can't produce something of extremely good quality. Yes, it will take you more time to develop than someone with a powerhouse of developers, but you're just going to have to be more creative. If you don't like your artistic style, fix it. If your procedural algorithm routine sucks, fix it. 

I would really like to hear how other independents generally approach marketing their game with limited resources. I know how critical marketing is since I've seen it first hand on several fronts. I've been part of teams that didn't put an ounce of marketing into their project and didn't come close to meeting expectations. I've also poured a lot of time into visiting forums to discuss our previous title which resulted in minor bumps over time. I really think Wolfire is doing some amazing grass roots marketing with the way they are managing their community around their Blog. They've massed a following that is willing to pay (far in advance) them for their game before they finish it to help support them. That's awesome. But how many people are really willing to divulge such information that early? Should that be a concern? Should I start talking about my next project before I really have anything implemented? What has worked for you? I would be particularly interested to hear how people approach Apple's iTunes store. I believe we're looking at around 33,000 games on the store these days. 

Isn't it as simple as rendering your gun geometry (or 2d HUD style gun) near the camera and narrow the field of view. 

It probably depends on what it's for and what your employee is telling you to do (if you get to that stage). If this is just for yourself, don't bother with Autocad, just use Max, it's so much more fun. Max and Maya are great tools for 3d visualization, I've seen some wicked home interiors made with these packages. You can model everything in Max for visualization, but if you need technical specs then Autocad might be the way to go. Listen to what anyone says about Autocad, because I don't know it much, I've studied Max and to a lesser degree Maya. So an autocad user might have some things to consider. 

I can't find a way to simply set a uint to a shader constant variable. But the following is a workaround : 

I agree mostly with Asher, XNA is ... was a good language to learn on and C# is very intuitive and far easier to work with than C++. C# and Java are incredibly similar, so you'll feel something familiar there. What you know in C++ can be applied to C#, you just have to forget about all the annoying and confusing stuff :) But if you are going to learn a framework, just start learning SlimDX, I've recently given up on XNA because well... it's based upon DX9, an aging framework, and it looks like XNA has reached the end of the road. It cannot run DX10/11 under the hood, and that's what you want to be using. That is current technology. Using SlimDX is incredibly similar to using XNA but it is far more powerful and you know you are learning current technology. 

Forget about tessellation and compute shaders. You simply want to maintain a system copy of the terrain and send it (or parts of it) to the GPU every frame. Yes it's slow, but it ain't that slow :) The trick is to make the section your updating small enough to not bog down the computer. So you don't want to be updating a terrain 1000x1000 tiles. Use chunks of terrain, I use 16x16 tile chunks with 4 tri's per tile, indexed. I can update a terrain chunk in real time no problems. I was going to suggest a dynamic vertex buffer, but you don't even need that.. here's the code i use to update geometry, just use the default resource usage : 

Can I recommend getting 2d shadows working first, even if it's just for the level that your avatar is currently on. It will be easier to start looking at the code that way and get it working. I have implemented shadows in 2d tile maps in a couple of ways. One shadowcasting method which I found described by Eric Lippert at Microsoft works quite well. And the other way, which I did myself first time i looked at this kind of thing was to orthogonally sweep the visible tiles and tile-edges and generate edges (and maybe corners iirc) describing the scene in the lowest number of edges. You can then cull hidden edges and form any custom shadowing features such as recessed shadows if you want to show a little bit of wall. Then create your shadow geometry (projective shadow casting ?) and render it over the top. But if I try to take that idea to 3d, it just becomes easier to do it in 3d. While the method described by Eric Lippert could presumably be converted to 3d. But I think you'll find that doing it in 3d is expensive. Perhaps take a look at the source code for Brogue as well. It may have a more efficient implementation for 2d visibility/shadow casting. Good luck. 

I have taken advantage of what apple has provided with UIKit. My last few projects have abused Core Animation/UIKit instead of OpenGL ES. For my case it worked perfectly well. My next project will use OpenGL ES and I'm not quite sure how I will manage the UI yet. I will likely still abuse UIKit. I've seen a few developers use OpenGL ES to push their graphics and actually integrate UIKit into the scene to handle the User Interface. If you're interested in hearing a developer talk about the integration check out this article he wrote. Great guy. 

It's been said above, testing is very, very tedious. Manual testing is a monkeys job. Companies understand that coming in through support is a well known path for people looking to get into the game industry. There are companies that don't like it. I recently watched an interview with Gabe Newell where he mentioned companies firing an employee who attempts and move out of QA. Companies need testers who are genuinely interested in what they're doing. So if this is your path make the best of it. 

Unity3D doesn't have any direct support for voice recognition. You would need to write an extension (System.Speech.Recognition) or find some kind of plug-in to get you rolling. If you do end up going this direction you will lose out on the unity web player compatibility with your project. I do not see any plug-ins that are already developed for this purpose. 

Introduction to the project, goals, and anything you feel like sharing about the project process Top 5 - What went right? Top 5 - What went wrong? Conclusion... Bringing it to the end. 

There are some really great indies over on tigsource.com (art board). I've seen a lot of those guys pump out some really cool pixel art. I'm sure you'll find a fair amount of people willing to give you advice. You might check out gamedev.net as well. I know Mark Eugn does a LOT of epic pixel art (gd.net journal). To showcase your work, $URL$ might be the way to go. You can break what you do down into categories so people can find their focus faster. The interface for the site is nice. 

Fail Early, Fail Often Well, it is pretty hard to 'fail early' when your project is out of the door. Hopefully the feedback you gain from the above will shed light on processes that may have been pretty dark to you. There are problems that you will run against that will sting pretty bad. It'll be pretty difficult to just forget those. To make sure that you don't forget the problem areas it could be handy to write a 'Core Value' type list that you keep at arms reach. Keep them available for others to see and for you to see. When the your next project starts I might be inclined to bring some of these to the table to get other people's perspectives. If you have new eyes on the project you might get feedback that could shed new light on solving a particular issue. As long as you're aware, and you keep your problems in the light, you're bound to solve those issues. Write It Grab all of the writings and bring it all together.