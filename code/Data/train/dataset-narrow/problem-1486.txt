Algorithm Basically your code is C. You should be wrapping state into objects. Your graph is represented by a global 

Try not to declare multiple variables on a single line (Every coding standard I have seen will hit you on this). There are also some corner cases with pointers that are not so obvious thus best to just avoid them. 

Here I would not convert to a string. I would a stream operator (then use some algorithms inside to make it cleaner). 

Note: The standard way of printing things in C++ is to use you should also be able to print a list using it. Bugs You seem to have a memorty leak here: 

RVO and NRVO will remove the copy that happens when you return by value. Also with C++11 and move semantics this makes this even more efficient. So never do this. Also this whole function can be replaced with just a simple declaration in main. Much simpler and more readable. 

What happens if is modified and does mutate slightly the internal state? By casting away the constness you have opened up your class to undefined behavior. You should NEVER cast away constness. If you must you can use const_cast to add constness, but removing it is so dangerous that this should be looked at as breaking code. If you had written it the other way around: 

Neither do I. Be consistent. Since it is just a property bag make it struct in both places. Also turn on more warnings so the compiler complains about this. 

Yes. As noted above the compiler can not apply certain optimizations when a member is marked mutable. 

Your main problem is that you have a RAW pointer in your class and don't implement the rule of three. This will break your object: 

In C I would expect to see a pointer and a size. In C++ I would expect to see two iterators (like above), but generally the end point is usually one past the end (if you want to be consistent with C++ idioms and the STL way of doing things). 

This is considered good in Java but in C++ it is considered bad practice. The only reason you need to use is to distinguish between member and local variables. Which means you have local variables with the same name as members, shadowing the members. Shadowing variables is a real no-no. Because the compiler can't tell when you accidentally do it wrong (using the local and not the member). But you can get the compiler to tell you when you shadow a member. Thus by never shadowing (and getting the compiler to error when you do shadow) your code is actually better as it will have less potential errors in it from using the wrong variable. In constructors use the initializer list: 

I disagree with the . C++ string may use a couple more bytes but if general usage will be quicker because the size if pre-computed (you would be surprised how many times the size of a C-string is re-computed). 

But are lat/long really string? Would they not be numbers? Also ID sounds like a number type thing. Global Variables: 

This is fine for simple types of . But if is expensive to copy then you copy it to the method. Then you copy it again when you construct the object. Try pushing by reference and moveable reference. 

Also your variable names are bad. Pick names that make it easy to read the code and understand what you are doing. 

Looks more normal. But more importantly. You should declare variables as close to the point of use as you can. Don't use the C technique of declaring everything at the top of the function. Declare it just before you use it. This is long winded way 

The file stream constructor takes a name as a parameter. Also the destructor of the file object will automatically close the file when the object goes out of scope. So we can change the above three lines to. 

Yes there are better ways: But exactly what will depend on your want. Do you want to maintain the original vector? Zeta has shown several techniques that maintain the original container (by using copy). Personally I think that is wrong as copy is inherently an expensive operation. If you want filter out I would say you want to remove bad items (effectively destroying the original). The the standard is the technique to use. 

You are creating (length * 2) members (that will be fully constructed). I suppose this is OK. But if T is expensive to construct then this may not be something you want to pay for. As an example std::vector<> does not initialize the elements between size() and capacity(). The rest is good you create it in a temporary and then swap with the current. But you start deleting the old stuff before finishing the update on this object. If the destructor of T throws an exception your object is now in an intermediate state. The order is: 

Thus the call th is going to start manipulating some undefined pointers. Fix by either explicitly initializing all members in the constructor or by chaining a constructor that will do it for you. Sinve your default constructor initializes the members correctly I will chain that. 

You should define the copy constructor like normal. Then define the assignment operator in terms of the copy constructor. It is known as the . Also you don't set up the members. This means unless the assignment operator only sets the values you are looking at undefined behavior when they are read. 

When you pass objects as parameters it is usally best to pass by const reference. This means that no copy will be made and the original object can not be modified by the method using it: 

I think you are going about it the wrong way. Containers already perform copy on copy construction/assignment because they are designed for value objects not pointers. What you really want is a wrapper object for pointers that performs a deep copy when that object is copied. This has the added advantage of working with all containers. If you define the move operators then it also works well with re-size operations as the move semantics will be applied to the wrapper when the the container is re-sized. The other advantage here is you can make the wrapper behave like the underlying type. So you get easy access to all the algorithms. 

Now you are probably thinking that this is inefficient as this requires a copy of the object out of the function. Which is technically true. But the compiler writers put a lot of work into making sure that this copy does not actually happen. RVO and NRVO (optimizations) basically make sure that the object is built in place at the destination (no copy required). Also in C++11 we introduced move semantics to the language. So on the rare occasion that RVO and NRVO fail a return value will be moved (not copied) from a function. moving a vector simply involves swapping three pointers (or something very close to this) so it is not very expensive. Prefer over The difference is that flushes the stream. 

You are really writing C C++ has its own language specific features to handle multi threading. Your interface is broken. The only way to test the value of the counter is via but by the time you can use the value the counter may have changed. 

Everything @ChrisWue said. Also: Design. Using does have affects on meaning (especially when copying). And I don't think you handle that correctly. Also You are building a container like structure. Usually memory management is done either by container (for groups of values) or by smart pointer (for single values). These are complementary types of memory management and intermixing them adds redundancy. You are already writing code to manage memory why add another layer on top (you can but it usually more efficient to do it manually). So personally I would have not gone with smart pointers here (because you are building a container). But the problem: 

Seems good: In llist_new() I would not pass a parameter. It does not make the interface easier to use but it does add complexity to the tests. 

Also do not limit it to sqlite. Make it so it is easily expandable to other DB types. I would go with a prefix Notation on the DB name: 

If you are in debug mode then you may see a difference but with optimizations ON seems unlikely. If there is a difference they you should add that as a comment to explain. Otherwise it is not non standard to use std::memset I would just add a comment on why. This seems perfectly valid to me: 

These last two are huge functions. Way bigger than they should be (I am betting that is to keep the member in line correctly. I have not had time to digg into them and find the problem yet. But I will come back tonight. But lines like this scare me: 

fibo_2 This is basically fib0_1 but using a while loop. Nothing against the while loop but I prefer the loop to get the loop initialization and increment all in the same place. fib0_3 Here you use a very complex recursion. I don't think I could have come up with that answer. So clever. fibo_4 This is basically the same as fibo_1 but using rather than array. As such I have one less point as vector is the better structure to use here. fibo_5 This is fibo_4 but without creating the whole array first. I prefer this over but to make sure you don't hit any issues with resizing the vector along your way you should reserve space for all the values. 

So in C++ you usually provide unchecked interface (let the user do the checking). If you want you can also provide a checked interface then that is fine but usually not the default. For example look at . Provides for unchecked access to the data. But also provides for checked access to the index. Un-needed work. Do you really need to call delete here? 

rule of three                                   Potentially broken if misused. Strong Exception Guarantee:        Potentially broken depend on T. Naming convention:                      Maintenance Excessive auto keyword:              Maintenance. 

begin is a bad name for the looping variable as you increment it and then it will not be the beginning anymore. There is no need to call end outside the loop. Most standard implementations this is so fast you will not notice it (if internally it is a problem then the implementers have already optimized the call the end() to cash the iterator so you are not saving anything by calling it outside the loop. 

Identifier conventions. One thing I notice about your code is that everything starts with a capitol letter. This makes it hard to tell the difference between types and objects. One of the most important things in C++ is type. So the usual convention is that "User Defined Types" have an initial capitol letter. While objects (variables) have an initial lower case letter. 

Did you ask any questions before you started? It seems like there are a couple of holes in the design that need firming up. 

Also for complex types of you should allow the object T to be built in place by forwarding the constructor arguments for T. 

Personally I would take this a step further and encapsulate m_Data into its own class that understands how to handle the memory then just call clear() on the new class to empty it (destructor automatically calls clear). Your get function seems very ineffecient? 

I suppose there can be. But I don't think you are at that level of sophistication yet (not saying that in a bad way). Would this not just be a method on the Library. 

Yes. Though unlikely. This loop can lock out the other thread from running completely (because it also tries to lock mtx). 

I am not convinced your benchmarks are representative of what you are code would do. That looks like an awfully simple test. Also the order you do things can be important in benchmarking so putting both tests into the same executable is not a good idea. Build separate executables for each benchmark then run the tests independently. This way you know that both systems start off with a clean environment to test in. Rather than use the allocator object directly why not overload the new/delete operators for the classes you want. Then you can turn your allocator on/off as appropriate without searching the code and modifying etc. Code Review