then you have a game no one will play becuase they couldn't get past the first level. The hardest part of AI programming is making the AI beatable, but beatable by someone with a bit of skill. Make it too easy to beat and players will be put off by a lack of a challenge, make it too hard and again, people will get fed up with being beaten all the time. So it's not about creating complex AI (which isn't difficult, after all, the AI can process everthing within its playing area simultaneously whereas a player can only process what's on screen), but more about creating a balanced game. 

To generate face normals, use the vector cross product of two edges each triangle and then normalise the result. Make sure you get the directions right, otherwise some normals will point in and some out. Vertex normals would then be an interpolation of all the face normals the vertex is attached to. 

Can the object move down one pixel without a collision? If so, move object down one pixel and end test. Can the object move left and down without a collision? If so, move object down and left one pixel and end test. Can the object move right and down without a collision? If so, move object down and right one pixel and end test. If object moved left and down (2) last time, can object move left one pixel? If so, move object left one pixel and end test. If object moved right and down (3) last time, can object move left one pixel? If so, move object right one pixel and end test. 

Why use one method of data storage? In most cases, the game you release to the world does not need the same data storage functionality that the game needs during development. Here's a comparison of some release / development requirements:- 

Ideally then, you would define an interface to your data loading module and then create multiple versions, each tailored to specific needs. On one project I worked on many years back, loading level data off CD was taking far too long (off HD wasn't great either). So I came up with a the following. I had three methods for loading level data:- 

You probably only want to do (4) and (5) for a few frame to simulate friction, e.g. repeat (4) for each preceding (2). 

Normal loading - for development time when assets were changing Pre-release - effectively a method to convert normal data into fast loading data Release - fast data only (not editable) 

If you're doing this in your spare time, I would suggest trying to write the game using several different engines. That way, you will get a good feel for what each engine can / can't do. As this is a turn based game, I would definitely start out with something having very simple graphics and probably done as static web pages and then put all your game code on the server, using .Net MVC perhaps. This means that you only have one application to worry about, the server code, and a local DB connection to manage. Once you've got that working, you can then look into doing some client side processing - animations, fancier UI, etc. You can try out the various client systems you mention to see what works best for you. 

This then requires no tracking on the side of your player or NPC's and then you can assign the event to any necessary linked classes. 

Initial idea based off your Actor structure: You are basically just wanting a character to be null, if you have removed it from the list that updates and renders it why not just set to handle resource disposing in and track the resources themselves as part of your overall design. Otherwise these items will not be handled correctly and cause issues longer down the line. MonoBehaviours are handled behind the scenes and have a lot of code behind the simple function, so it's not as simple as a one line solution: 

You really should tell us how this is being constructed as different technologies can have different advantages to your situation. Is it in Flash? PHP? HTML5? JavaSript? Java? The "web" tag doesn't give us much to go off. That being said: One of the most secure ways to transmit points score is to not let the client side decide what those points are. What you want is to create points based events: 

I would suggest not setting your vertical speed to -10 as this is essentially doubling the effect of gravity which can have some serious adverse effects later on. I would replace the collider with a spherical based one on your character: 

Your assumption isn't necessarily to find the cells but the lines it cross on this grid. For example taking your image we can highlight not the cells, but lines of the grid it crosses: 

Here we Generate the chunks by flattening the map array and then using a chunk map coordinate of and a chunk coordinate of to then look through x and y within and . Once that is looped through you can use the expression: to find the index of the flattened array, providing the values you need in a format for your chunk info. 

Your solution of either line or other graphics can vary but the principle is the same - the color you choose can be as subtle or as stark as you need it to be. 

Please excuse the roughness but I hope this gives you a decent idea for structure. Formatting your XML a little better you can then create a parser to create the scenes and the requirements in them, here is an example of both the scenes above in one: 

Just to extract an answer from the comments: Zophars Domain shows you a list of tools that you can use for NES ROMs including Graphics Extractor and Inserter which allows you to extract and insert tile graphics from the ROM. To use this you need the Extractor executable and the Inserter. Use the extractor to get the tiles first, edit them in your editor of choice (MS Paint ftw) and then use the inserter to pop them back into the ROM. Make sure you create a backup in-case it corrupts the ROM image. 

where P is position and V is velocity and the subscript is d for destination (target) and s for source (turret), which gives a direction vector:- 

The reason for the is because you calculate the angle from end point to the start point. If startX was 5 and endX was 10, the offX is -5. Which is counter-intuitive. Swapping start and end in the calculation of off would remove the need for the -1 in the calculation of p2. But then, why do you need the angle. Knowing a bit of vector maths would be really useful: 

The original Worms probably didn't do anything more complex than bitmap/bitmap intersections - i.e. does the bitmap of the grenade intersect with the collision map of the world. Moving the grenade (or whatever) would follow these steps: 

I'd probably go with 1) as there's not much graphically going on, there may be some self-generated code to blit and clip images at the edges. One possible technique that a collegue of mine was working on back then was self-writing sprites, that is, the sprite data wasn't data, it was code. This meant there were no transparency checks and the data read of the blit was effectively free (this was on a 386 where each instruction was read and then decoded so instead of read code->read data->write data it was just read code->write data). It worked amazingly well - we got lots of huge sprites on multiple parallax layers running at 25fps+. But we are talking about Romero here and there's probably a bit of exageration going on about the techniques. 

and movement is always towards a square with a lower value. When the player places a tower, update each of the eight adjacent squares: for each square, set it's movement value to one more than the lowest adjacent value. If the value changes, repeat the process centred on the updated square. Then, to check that the route to the exit is not blocked, ensure all squares are adjacent to a square of a lower value. When the player removes a tower, set the movement value to one more than the lowest adjacent square and repeat the process above. A simpler approach would be to re-do the flood fill. 

Ds and Ds' are the source directions and Rs is the rotational velocity. With all that, you want to find t for when Dsd' == Ds' and thus Rs, the required rotational velocity. Don't forget that all the P's, D's and V's have x and y components. I haven't taken acceleration into account here - that adds a lot more to the complexity. Once you've got Rs and t you could probably approximate a parabolic Rs (i.e. accelerate and decelerate) to get the same result. 

In Ogre3D, and I suspect many other engines, you'll get a callback when the latest frame has been queued to render. This can be (and often is) your source for relaying "time" to the rest of your application. 

If it were me, I'd build it from the ground up with sockets. The amount of data to send is very small, and the turn-based nature makes a little latency unnoticeable. The real question, in my opinion, is what additional features you need on it. Are the game sessions persistent (can someone drop out and rejoin, can the game be saved, etc)? If you're doing a Civilization style save you probably want to push out the save data to all clients, or have the save done client side with a server-provided key embedded for verification. Do you need any sort of between-turn reporting, e.g. "Player 2 is moving a unit" or "Your opponent may be AFK"? If so you may end up wanting to keep the socket connections open. Generally speaking, unless there's some compelling reason to deviate, I'd keep the server as dumb and simple as possible. Leaves less to debug. I also kind of like using plain text protocols, as I can test my servers using telnet without an actual game client (which may be suspect in a given problem), but this does sort of encourage Wireshark manipulation of the data (which you probably will check for anyway). Edit: If the game only supports 1-on-1 games, peer-to-peer connections may be worth looking at. 

Long-winded answer follows. tl;dr, it's a LOT OF WORK. I've used iPi Soft and found that it works fairly well, but unsurprisingly you need to do a decent amount of clean-up on the resulting animations, especially if you're using props and such. I've also used Kinect (albeit a year ago when the available free software was less polished), and you get the same thing there, but are very limited in what motions you can do, especially from the waist down. Expect any of these free or low-cost motion capture systems to be a massive time sink. Assuming you have a large enough room to do it in, you're going to spend literally days working out the kinks to get a workflow going, and expect upwards of an hour for every couple of seconds of animation in order to "fiddle with it" on the PC to make it smooth and believable as an animation for a game--unless you are an experienced animator with good middleware for this purpose. If you require relatively few animations and fairly ubiquitous actions (jump, slash, tumble, run, climb, etc), you're honestly better off spending the money for someone else's work. If you're wanting to do something more interesting, just expect to spend loads of time getting rolling. Also keep in mind that being an actor for motion capture actually takes a certain amount of traditional acting skill and a lot of dexterity and stamina. Much like voice acting, it's more demanding than you might think. If you're wanting a presentable final animation for a game, I would recommend you at least do the trial and then spend the money on iPi Soft or a similar product. In my opinion, for a non-trival motion, a decent animator can rig a model and keyframe the animation orders of magnitude faster than you can get a similar result from single unit Kinect-based solutions. All of that having been said, if you have the time, doing it this way gives you a lot of appreciation for the animation side of development, and you'll certainly learn a lot.