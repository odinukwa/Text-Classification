Next, I would suggest inverting the loops (loop on ix, then iy). Or swap the names of the x/y variables. I don't know what your target architecture is, but in general C compilers store data in row major order and it can make a huge difference to performance if you comply with that ordering. Obviously, you're going to access all the cells, but you really want to access the sells from low to high memory address as much as possible. If your and values truly are constants - you indicate the matrix is 512 x 512 - you can get a lot of good benefit by doing a bitwise with 511. For example "-1" will become 511, 512 will become 0. So long as your array sizes are always a power of 2, a bitwise and is cheap and will let you collapse all your cases into a single line of code. There are several "repeated" values. You can probably cache those values profitably. (For example, gets used a lot.) Even better, keep in mind that is the same as the last time through the loop. So you can "save" those values from one loop cycle to the next and use them in different places. Similarly, in one loop will be when ix gets one higher, so you can save that value as well. For your inner loop, you really have three values in a pipeline, call them last, curr, and next. The value is . The and values are simply older copies of : 

A much faster way to do if x is an integer is . A good name for the function might also be 'array_permutator'. 

Another solution would be to properly filter your input. It is easier, and it is also more dangerous, because it is easy to miss something. For the example at hand, you need to parse the user input into a number, and then convert that number back to string in order to append it to your SQL string, as follows: 

You could, perhaps, derive RecursiveObject from FlatObject. In the degenerate case in which all objects belong to a single lineage (every object has one and only one child, except the last one) and you have lots of objects, then your recursive method will try to use an awful lot of stack space, possibly failing with a stack overflow exception. The way to correct this is by avoiding recursion and adding a stack data structure within your function, which then works in a loop. But of course you would not want to do that unless there is a very clear possibility of such a degenerate case ever occurring. 

This allows us to short-circuit the assignment of a value such as a name. Let's remove some of that duplicate code, and make a few more names clearer. 

I would recommend an interface with read-only properties (getters, no setters) and have your final class implement that interface and return its constant values. I'm also not a fan of your Log class. 

Casting p as a less derived object will NOT invoke the less derived implementation of the method. I've tried to make the recursive .Equals call obvious enough to illustrate what is a more subtle common problem when people override it. In this answer, I am focusing on the point that casting the object does not change the method implementation which is used. Unless casting to an interface type which is implemented explicitly in the Class's hierarchy, this will invoke the most derived definition. To not work this way would violate polymorphism principles. This will work for operator overloads in .NET as you are doing. Until I started researching this answer, I was not aware that operator overloads do NOT actually use the most derived implementation. I personally find this result surprising. 

As GregS pointed out, macro arguments need parentheses. does not really do what its name says, nor what the comment above it says, because when we say "whitespace" we don't only mean the space character. You need to use from to tell if a character is whitespace or not, and this applies to all places in the code that compare against the space character. The comment looks like it has been added after the fact, in order to describe what the code will actually do, rather than to specify a requirement for the code. I would suggest that you replace it with a comment saying , because if you ever decide to implement that function differently in the future, you don't want to have to do tricks in order to precisely emulate the bizarre functionality of the old version, do you? Obviously, will fail if it is ever given to parse some text containing a word larger than some buffer, and the way it is written precludes the possibility of ever having any control over this so as to prevent it from happening, because the size of the output buffer is not passed as a parameter. In the test code, you would have a failure if you used a word longer than 100 characters. You might say, "you gotta be kidding, who would ever write a word longer than 100 characters?" One answer is, my son did, when he was 1.5 years old, and got a hold of my computer while I was in the kitchen, and he typed his first word document by holding the z key down for a couple of minutes and watching the 'z's fly by on the screen. If Microsoft Word was using your code, it would have crashed. Another answer is that this is precisely the kind of stuff that buffer overrun exploits are made of: the hacker will intentionally give the kind of input that the programmer did not expect. 

with underscores in the first two positions. There was no comment at this point. Then, down in the bowels of a function, you have a comment saying that these two bogus values are not really bogus because your code handles them separately?!?!?!?! Why not replace with or ? That would do a far better job of making this clear. Or, just eliminate those slots entirely, and subtract 2 from the indexes. (But, frankly, I'd prefer because that's as explicit as it's possible to be.) And I'd prefer to see the comment read something like: 

This is good code for a rusty coder. Especially a rusty Fortran coder! Congratulations! First, the experience. I played it, and had this on screen: 

Merge and functions You have two functions that obviously are copies, since the function still asks the user to "Pick a row". I'd suggest merging them into a single function that just prints a different word, which you can pass as a parameter: 

You've structured your code in this incredibly indented format, for no good reason that I can see. In fact, you are testing a series of conditions, and when those conditions are met, you are returning. Just structure your code that way - it's easier to understand: 

is an awful name for a class. The name of a class should always be a noun. No exceptions. Read-only fields should be marked as read-only using the keyword. is an awful name for a function. It does not give any hints as to what it means by 'File Status', nor any hints as to what it means by 'Checking' it. Looking inside, I see that it performs operations that change the state of the system, so 'Check' is an awful choice of a name for what it does. When a function begins with 'Check' it is supposed to return and to perform absolutely nothing that would change any state anywhere at all. No exceptions. is not a good name for a function that checks whether a file is empty, because it may be confused with a function that actually empties the file. Call it instead, and make it a property, not a function. This is lame: 

If you cannot modify , then write two helper methods, one for getting and one for setting the value of the day member of : Each method has a and modifies the appropriate member of . Good luck and have fun. 

That still leaves a lot of duplicate code. We will want to clean that up. Finally The truthy nature of javascript allows us to do this as well: 

You've created a tuple of parameter values equal in length to the number of parameters specified in your query. 

Yes, your while loop is suboptimal leading to increased loops and increased time for larger values. The problem can be solved mathematically. Consider this: $$ s = \mathtt{startingTotalItems}\\ n = \mathtt{newItemInterval}\\ $$ $$ f(s, n) = \begin{cases} \emptyset, &\text{when $n\lt0$}\\ s, &\text{when $n=0$}\\ \infty, &\text{when $n=1$}\\ s + f(s\ \mathbf{div}\ n + s\ \mathbf{rem}\ n, n), &\text{when $n\gt1$}\\ \end{cases} $$ Using a little algebra the last equation can be factored into a single operation. 

A common quiz question is to check if a string is a palindrome without using in-built reverse functions. In Java, this can be done as follows: 

Idiomacy Idiomatic c# expects PascalCase class names and public members. Member names should be a description of their function. Consider , , , etc. OOP Dependency Inversion Your constructor is hard-coding the values needed for your connectionString. If this is simply demo code, either hardcode the entire string or do it right and have the values passed in. Scope