In the code provided below, notice that all the signatures declare parameter types and return type. 1.1. Little Type Hint Trick Often, frameworks or libraries return objects of type . When this happens, the compiler loses the narrow type information making the code less reliable. As an example, we can see that in our Observables' map part is doing exactly that. Since we know, what object the remote service API is supposed to return us back, we can immediately cast that expression to the specific type and make the compiler our helper again: . It's important to understand though, that in runtime there is no guarantee that the return object is actually of the same type as the type we cast to. In other words, this cast is practically helpful, but is sometimes misleading and should be used carefully. 2. Master JavaScript and TypeScript idioms TypeScript is a superset of JavaScript, i.e. whatever is syntactically correct in JS is also correct in TS. 

Update 1 There tons and tons of materials that explain what are the strengths (and the weaknesses) of the OOP. You can start from here. Here are a few ideas about the application of OOP principles. In OOP-ed code, the data and the related processing functions (methods) are encapsulated into small entities (classes). The encapsulation has various positive effects, and a few negative effects. You may see that with the rewritten code we can change , , and more independently. For example, if we need to have some extra information about each location on the map, we may add some fields to class rather than creating a whole new which is by the way completely disconnected from the and other maps... It's really hard to explain the benefits of OOP in one example, but I think more will come as you learn through reading and practicing. 

Make Them (Devs) Read The Code [Maybe?] The following comment is not helping me at all -- I see what the code does. 

Side note You may want to limit the number of collections in which you do . If you have dozens or hundreds or even more collections, you this function may attempt to open as many connections (IDK the details). Also, the function execution time will be really long. A typical solution in limiting is pagination and/or filtration of the things being counted. 

Feedback I am looking for Here's the list of things I am interested to hear back (in order of significance): 

Not the Strategy yet I'd try to not have a super huge ExtraCard component class if possible. The idea is to encapsulate the data in a interface/classes: 

Update 1 Just a few months ago I was not aware of which seems to be an answer to a part of your question: 

a few samples of input and output. declare a variable that you think works as a seed. a reference to a particular algorithm you're trying to implement or at least are inspired by. OR at least a mathematical formula that you think will give you the desired result. 

If the reader has to deal with RxJs, he/she must know what does. You may still express the intent, though. To express the intent, you may extract code into a private method. This will, of course, change a bit the way we chain, but the code is still readable: 

As long as your code is dealing with configuration only, it looks good to me overall. (I assume, you don't have a login screen.) Otherwise, you may want to look at real life authentication example with Auth0. I'm not pointing to technology here, but rather how the concerns are being separated and organized. I might rename into to be a bit more specific, but I don't know the complete structure of the object and whether it holds any non-endpoint configuration or not. 

The fact that the returns a result that does not fit into the expected use cases, suggests that there is a design issue. In other words, it is a "hint" that is not really a in terms of OOP. Why so? Because it does not follow the intuitive contract in which the method returns same exact type of the vector as the one on which the method is being invoked. Things will only get worse if one will need to work against a , , etc. There's whole bunch of sources that explain how inheritance is very often not the best way to create new types nor reuse code. If I was to design the , I would make it wrap the class rather than inherit from it. 

Direction My approach would be based on the Strategy design pattern. Each of the original sections is now becoming an object that represents the rule. This object does two things: A) It defines whether it may or may not be applied to the given filter input; B) It defines the application function (logic) itself. In order to select a proper rule dynamically in run time, we need a registry of the rules which is implemented as a simple array. Benefits Implementation of a new "rule" becomes almost trivial: we'll need to create a rule object itself, and add it to a proper place in the list of registry entries, so that it's picked up. Code 

Whether I miss anything in terms of JavaScript/TypeScript idioms. Same about Jasmine idioms, techniques, approaches. General code improvements. Test differentiation/separation techniques (some are real unit-tests, other are more of integration tests). 

Direction With latest version of Ecmascript we get that allow us writing asynchronous code in synchronous style. Consider an example where function returns you , and returns . We can use the following constructions then: 

Code I really don't like sorting an array of primitive type element. Instead, I use which is a key-value object, where the key is used to sort the array by it. Please assume the code is correct (as CR requires it). At least, the tests are green on 52 data inputs ranging from 0 to 99 elements. 

Starting point Unfortunately, I am not familiar enough with node.js to make high confidence claims about the code. My guess is that I/O operations are more likely to be the bottleneck in the code rather anything else. Even the does not look too heavy computationally. Experiment with the way the data is being read. Now the code does this: 

What is ? Why and not (I like powers of 2 more) -- "magic numbers"? Why replace with ? If you extract this one-liner into a function, you can give it a good name, thus expressing your intent. At the moment, I didn't even try to understand why that manual transformation of a base64 image is needed. Unclear Intent When giving user a feedback, there's this that makes the code look only into the first result. Why is that? Put it into a variable, give it a name, and you will avoid the hard-to-read and explain what's going on. 

Question While I'm always open to any constructive feedback, there are a few specific aspects I'll be particularly thankful for. 

I believe it's better to thoroughly inspect the for various scenarios/validated object kinds, because this is what the consumer of the class will care after all. This is all correct within the context of one important assumption: is always set up to run in a single specific configuration (meaning, there's only one sequence of steps). 

After some consideration I decided to reshape it. Here is the generalized, yet more specific definition: 

method is not a pure function, it modifies the provided object in-place. This may be dangerous in some scenarios (but probably, not in your case). The code above may or may not be easy to apply due to architectural changes -- it's your judgement call. If I were you, I would not limit myself to a rigid unmanageable data structure just because my database/service returns DTOs in this format. As mentioned earlier, generic representation enables generic algorithms which are used a LOT (meaning the effort pays off). I didn't have much time to test the solution (in fact, I still don't have access to my compiler), so burden of testing is on you.