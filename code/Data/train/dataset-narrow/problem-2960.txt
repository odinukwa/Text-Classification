No Because of the way that you learn, you think of them as fundamental, to the way references work. They are not. References do not have to work this way. [I would still agree that pointers are fundamental to understanding memory in Von Neumann / Harvard architecture.] Java uses references. You can think of these as being pointers, that must point to a valid object of the correct type or to the null object. But there are other ways to thing of references, e.g. like indexes, or like references (in a book or urls). You don't even need to know what is inside. Other languages don't have references. E.g stack based languages. Therefore they are not fundamental in any way. 

Spreadsheets implement a fine and upstanding functional language. Excel also implements Visual Basic (VBA). Spreadsheets are at there best when there are functions in the cells. To make things simpler there can be intermediate cells, in hidden columns. Visual Basic is a dreadful language, is poorly implemented, a security risk (documents using VBA can have viruses), and not visual. Almost everything I have seen done with VBA, both in the classroom and out, can be done without it: just functions in cells. This may be why you are struggling to find a use for it. It you are thinking that, you need VBA, because it allows you to teach programming. Then remember that without the macro language spreadsheets implement a functional programming language. I had a teacher come to me in a panic as he had to teach functional programming to his A-Level pupils, I helped by reminding him that he already know a functional language. 

These last 3 steps also allow you to revisit front-end development, and see how this fits into back-end. 

Security vulnerabilities are just bugs. In your example the code does not do what it is supposed to do (keep the bad people out). So treat them this way. “We have a bug. The program does not meet its security requirement of …”. The worse thing we can do (and I have seen this in classes), is to demonstrate bad code, unless it is part of a “What is wrong with this?”. I have seen a teacher present this as an example of how to do things (a lesson on selection). 

I sometimes have pupils, that struggle to learn because they have a fixed-mindset (“I can't program”, “I can't use computers”, …). I the context of teaching a Computing (Computer Science, IT, Digital Literacy, Computational Thinking ) lesson, what can be done to encourage growth-mindset? 

Then we can not produce an electronic system, that can meet just these requirements. There are also other requirements, thus it is even harder (in the higher than infinity sort of way (∞+1 = ∞), therefore we don't need to look at the other requirements, to see how hard it is). How would you audit this system? You could check its source code, to see that it does the right thing (if you can read it, so every one involved would have to have a good enough level of CS, and know the language). Oh but how do we know that the system is running this code. Every single solution to this problem, has a counter measure ( a dis-proof ). This has not stopped these things from being deployed many times, and in countries that are considered to have a well run voting system. 

True novices If the they are novices, then you may be asking to much, to get them to write large programs from scratch. More useful exercises may be: 

That is, while there is value in the items on the right, we value the items on the left more. Software craftsmanship manifesto As aspiring Software Craftsmen we are raising the bar of professional software development by practicing it and helping others learn the craft. Through this work we have come to value: 

When people asked me what I did, when I was a programmer/software engineer. I would tell them one of these. 

No This may be a good way to test understanding of function calls, and the stack. However I don't think it helps much with recursion. As when we design we need to abstract. To do this we need to be able to think without having to keep all of the detail in our heads. We need to focus only on externally visible behaviour, not internal details. Yes Having said that. I think it could be useful to look at the stack, if we are considering the consequences of different algorithms, and recursion patterns. For example both of your examples, the recursion only reduces by one. Therefore the recursion depth is O(n). If you do not have tail-call optimisation then this could lead to a stack-overflow. Nether of you examples would allow for tail-call optimisation: 

I was a software engineer (not a computer scientist), I have self taught CS, some of it recently. I now teach computing. One of the think I have learn at a teacher, is not all knowledge should come from the teacher. It is better to get the students to do some activity, to actively learn. A few years ago I saw two videos, one on the halting problem. One on NP, it was the busy beaver problem. The first $O(x) > O(n!)$, that I had seen. Therefore get the students to watch the videos for homework, then to solve Busy beaver for n<=4, and spend an hour on n=4 (I think it is 4 that can be done in less that an hour. And 5 would take years on the fastest computer. But you should check.) In class discuss the findings, and then get them to act out the parts of the machine in the halting proof. Then discuss that. Bellow are links to the two videos that helped me. 

In Java we also have then all of which you have to persuade your pupils to ignore, because it is not time to explain them today. Summary My advice is about removing unnecessary complexity. I believe that much of the complexity of OO is unnecessary. 

In an ideal teaching language If the language directly supports them then the order to teach looping constructs seems simple. 

Mentor Get a mentor. They can guide you. For example tell you which routines you will need. (create a new process), replace process with external program from file-system, create inter-process pipe, copy file descriptor, close file descriptor, wait for a process. Plus other that you should have used before. Real project Find a real project to work on. There are many Free-Software / Open-Source projects that you could work on. These will give real experience. Read other peoples code Free-Software / Open-Source projects are a good source of code for you to read. You could read the source code for bash. 

Creating diagrams fast However your question seems to be about speed. Gone are the days where we had to create complex designs and then hand compile to machine code. Now we have high-level languages. A lot of what can be expressed in UML, can more easily be expressed in your chosen programming language. Therefore use diagrams where they are useful, then go straight to programming. If you need UML diagrams, because your management, teacher, or exam board, insist on them, and you can not convince them of their error, or replace them. Then use a tool such as doxigen to convert your source code into UML diagrams. 

While I have not seen any compelling evidence ether way. I as wondering if there is a true underlying gender element, or at least to deep to be fixed locally (with in CS). I wonder if this is related to “what are female roles?” and “What is a computer?”. For the first question, the answer is getting broader over time, so I don't think the answer lies here. For the 2nd this seems to change a lot. 

As well as what you have already mentioned: Provide working code, and have them modify it (top down as opposed to bottom up). I also see an opportunity to reduce time between students actions and receiving feedback. Automated feedback (this is not a substitute for teacher or peer feedback) Use a visual language, such as scratch or snap. This reduces cognitive load as pupils can see the possibilities, they just have to drag them in. (Note: Visual basic is not a visual language.) Create a program with visual output, such as python turtle, or scratch/snap. This way they can see what the effect of there change is. This can be augmented (kinaesthetic) by having pupils be the turtle, or the instructor. The instructor gives instruction in the form of the language, the turtle follows the instruction. A third pupil can be a scribe and write down the instructions. For textual languages: The teacher as well as providing started code, can also provide unit test. Pupils run the tests and see traffic-lights on the dashboard, all red at first. They then work on each light it turn, to get it to turn green. There will be clear instructions of what each function should do. There may also be some other output that builds up, as they get each test to pass. Must languages have unit test frameworks (pyunit (python), junit (java), nunit (.net), xunit). 

What I have found so far. I don't think this is suitable for teaching a class of beginners, as it is too complex. In , you can display the code of a function/procedure, variable…, by typing its name followed by two . 

Get them to write a program that would need a procedure or cut and paste. Then get them to make a small change. This will also be a small change to the code if they have made their own procedures, but a big change if they used cut and paste. Keep giving them these changes until they ask for a solution. Then use your teacher skills to remind them of the MyBlocks. Show them two programs: one with cut and paste, one with MyBlocks. Have them in teams some with one version some with the other. Get then to work out what it does. Time them. Them swap over with a different example. Discuss why the version with MyBlocks was easier/faster to read. 

Give credit where credit is due. Don't give credit for doing the minimum (handing in on time). Instead deduct credit for being late. They should feel lucky to get anything if they don't get it in on time. Intrinsic Motivation There have been a lot of studies on motivation (most of the ones that I am aware of are industry based, but that is because I spent most of my life there). They show that most attempts to motivate via giving rewards e.g. pay for performance, back fire. That is they demotivate. They show that the best way is to pay well, and make the job interesting (intrinsic motivation). The only exception, where extrinsic motivation works, are simple manual jobs, that don't involve much thinking. Therefore apart from deducting credit for late handing in, you should avoid extrinsic motivation. Try to find out what their interests are, and design interesting assignments. Try to get a culture of working in the computer lab, where students can work together. This way they will learn from each other. Provide an extrinsic motivator (pay well) to be there at certain times e.g. lab food. Mind set Do some mind set work with them. See the work of Carol Dweck (This Ted talk is a good introduction). Dwecks work shows that there are (to put it simply), two types of mind set 

I think it is bad practice to have the computer draw pictures, and then try to describe them, when in would be much easier (and better for the blind person) to interpret a text interface (command line). Having a blind person try to use a system that is optimised to sight, is wrong. Wasting power on a screen, that you can not see is wrong (though having something the teacher can see is useful). Therefore use a system that is optimised for a blind person, or at least one that is very similar. This leaves tactile, audio, or linier speech (that can be converted to audio). Here I will only discuss the speech part. I would recommend Gnu/Linux, it is a Unix system. Unix was designed from the beginning to be text based. The GUI saw added latter. This has made it a very strong operating system, that a variety of interfaces can be added to. Most of the programming languages that we teach were first written for Unix: Java, python, C. The only exception that I can think of would be C#, however that now runs on Unix. I have run it on a raspberry pi model 1b. 

For the IDE If the IDE provides faster feedback, then it can aid leaning and productivity. It the 1960s the interactive tty was a massive improvement in both of there. For an IDE to improve on this, it needs to take it a step further. See work of Bret Victor for where this is hopefully going. However most current IDEs do not do anything useful. With a few exceptions. 

Optimisation should not be taught as part of a general programming course. It should be taught as part of compiler design. This is because: 

See also no lock / zero lock structures: Most pipes that are thread safe use locking. Or are not thread safe, and expect the user to do the locking. However it is possible to get thread safe zero lock queues. There rely on a few atomic instructions. (I prefer the name minimal lock, because the atomic instructions do locking). Only use low-level synchronization to implement high-level synchronisation. If you need synchronisation, and if you do not have high-level synchronisation, then find a good library that implements high-level synchronisation, using the existing low-level synchronisation. Don't write it your self, except as an exercise (and do to it as an exercise, it is fun and you will learn a lot), as it is very hard and you will get it wrong. 

Objects are not always objects. We need to remember and teach, that not all Objects (in Object orientation), are objects. Some are algorithms (The sort algorithm, so still a noun ). 

From my software engineering experience. Some of it is useful some is not. It was put together by a committee of organisations that had a product to sell. (state machines got in there because a committee member had a state-machine editor.) A lot of other useful stuff was missed out. Take what is useful, leave the rest, and use stuff from elsewhere. There is nothing unified about it. I have used mainly class diagrams, some dataflow (I think it may be called), but as you say not too much formality. We never passed them through a linter. At one time we were drawn in to using them to create code. This was an expensive lesson. Most of the diagrams (may be all) existed before the UML. I tell my pupils that some of the diagrams are useful, but also look else where. I tell them which ones I have found useful. And I tell them what I have said here: there is nothing special about the UML (or the process of collecting together, arbitrarily, some diagrams notations). 

Look at their skills, look at their passion. It they have passion for something, then they will do much better. This passion can not be based on, I think there is money in this. 

In 2012 shutdown or restart published by the royal society, recommended that UK schools have 3 parts to computing. No longer the single amorphous blob that was ICT. (Some things from ICT, would no longer be taught.) These 3 parts should be Computer Science, IT, and Digital Literacy (that paper says that its meaning for IT, is not the same as others have used it).