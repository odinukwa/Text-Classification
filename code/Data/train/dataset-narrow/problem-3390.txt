For current measurement I would use something based on an ACS712 Hall effect sensor. There are many breakout boards available on Ebay/Sparkfun/etc. - make really sure that you have the right amperage version. The ACS712 apparently comes in 3 varieties - 5A, 20A and 30A. For your application I think I'd suggest the 20A variant - it could damage the sensor if you push more current through it than it can handle. When correctly connected (it's an analogue output, so it'll need to go into an ADC/MCP3008) the breakout board will output a voltage between 0V and 5V which is proportional to the current flowing in the circuit. You'll need to do some initial calibration, i.e. connect the sensor and put a known current value through it so that you can adjust its gain settings appropriately. After that it should be be possible to measure current flow with a reasonable degree of accuracy. From personal experience making battery powered audio amplifiers, you're going to have an uphill struggle on your hands removing noise from the system if you're planning on charging it and using it simultaneously. With that being the case, the Pi may not be your best choice as a bluetooth audio receiver - the Pi's audio output is notoriously noisy unless you use a relatively expensive add-on board. There are many low power bluetooth audio receivers which are designed for clean audio and are likely to be less problematic than the Pi. 

This project on hackster.io outlines what appears to be a successful approach using a Cottonwood: Long Range UHF RFID reader with a Raspberry Pi 2 running Windows IoT. Per previous comments it's fairly expensive at $187 per unit - some googling suggests that that's going to be an unavoidable cost for this type of unit. The reader's specs list the effective range at 1-6m (likely only achievable with a fairly expensive antenna), which would fit your application, although it does come with some warnings to check that using it complies with your local radio regulations. The tutorial is too involved to post in full, but the author gives a brief synopsis outlining the high level details: 

[Note: On Linux, the userdata folder is at ~/.kodi/userdata/] I haven't tested this approach, but my understanding of it (somewhat backed up by anecdotal reports) is that all you need to do is complete a fresh install and copy over the .kodi and userdata folders from your configured setup. That should bring in all your plugins. 

You've chosen a difficult route. If there's anything whatsoever you can do to get some cables into the freezer you should do so. You can now do things with Bluetooth Low Energy (BLE) on a Pi without too much difficulty. Adafruit have a good writeup on making a Bluetooth beacon here. While I can't say with absolute certainty, I think that you're very likely to have a hard time getting that signal (or really just about any wireless comms signal) out of a freezer (i.e. a large metal box incorporating a compressor and pump system running from mains voltage) using an Arduino. It's a ready-made faraday cage full of electrical racket. If you do manage to get a signal out of the fridge, it may have deteriorated to the point where your practical range is extremely low. Freezers, in addition to being miserable places for wireless communication devices, are reasonably hostile to electronics generally. Your batteries are likely to have diminished capacity and lifespan, the whole thing's moist, there may be 'particulate matter' (e.g. turkey twizzler breadcrumbs)... it's less than ideal. What would alleviate the issue entirely would be putting your sensors in the freezers, while keeping your Arduinos (or similar microcontrollers) outside of them. That allows you to plug them into sockets (or leech off the fridge power), puts them in open-air for better wireless transmission (or cabled hookup), and allows you to maintain them without disturbing your freezer. 

Barring a third party driver being made available, you will not be able to use this tablet (or the associated screen) with a Raspberry Pi. The manufacturer provides drivers for Windows and Mac but not Linux, which is the one you'll need. 

Yes. As far as I can remember, pretty much every Pi I've ever tried to play 1920x1080 video on has worked, up to and including the very first generation boards. You can see a brief sample of the Zero playing back 1080 resolution footage from Big Buck Bunny using Kodi on the KordKutters Youtube channel. Looks fine to me, although the presenter notes a little slowdown during add-on updates - you shouldn't have this issue if you're only playing back footage. If your end goal is just 'build a Pi that plays looped video' it may be worth a look at the ready-made image provided by MP4Museum. It doesn't do much else, but it apparently does that well. 

If you really don't want to extend the temperature sensor away from the Pi, it may be possible to compensate for the effect of the CPU. This post on yaab-arduino.blogspot.co.uk outlines an attempt at this in Python, using a moving average of the readings from both the temperature and pressure sensors (the pressure sensor can also measure temperature): 

No. The Pi's 3.5mm jack is output only. If you want to record audio you'll need to use a USB or GPIO based soundcard. 

The source isn't exactly top rate (a 2013 thread from the archlinuxarm.org forums), but this seems to tally with your linked answer: 

I have an identical problem at home and, unfortunately, we're both out of luck. Not all buttons on all remotes produce a corresponding HDMI CEC signal at the TV. I diagnosed my issue using the instructions given in this Kodi forum thread by user misa on 2013-08-25 10:12: 

Keyboard input should 'just work'- you shouldn't have to do anything aside from plugging the keyboard in. Quick example, starting from a blank UWP application: XAML (Mainpage.xaml): 

I think it's unlikely that you're going to be able to persuade USB mics to provide you with the timing accuracy you need for this kind of test (although I'd be very happy to be proved wrong). Linux is not a Real Time Operating System (RTOS), and can't provide the kind of timing guarantees that you need. If you're just measuring the time of arrival of impulse noises (claps) you might be able to make use of something like this Sparkfun sound detector (cheaper versions are available on Ebay), hooked up to the Pi's GPIO pins. That board should spit out a simple binary 0 or 1 indicating the presence of sound. I think you should be able to achieve more reliable timing using that approach and a library such as pigpio. If you just can't achieve the reliability you need on a Pi it would be worth considering switching to something along the lines of an Arduino. There's less overhead to get in the way of accuracy. 

Yes, but you'll probably have to take the cable apart to say for sure. The Micro-USB Cables and Connectors Specification / Revision 1.01 is the relevant spec document. Things which are out of spec may cause problems. Among the more common issues to check for are: 

The Github page for the library you're using includes an example on how to pipe audio from a USB sound card (you don't indicate in your question what interface you're using) into the FM application: 

No. There is no way to connect the camera board's CSI output to the GPIO pins that will leave you with a functional camera. 

That's described as 'A python and shell interface for the Raspberry Pi camera module', and should get you up and running. At this point you can log in to your OpenELEC instance over SSH and run both and from the terminal. In the event that you need to launch or from the OpenELEC interface, rather than from an SSH session, you can use the Advanced Launcher add-on. It's worth noting that Advanced Launcher is usually used with game emulators, so there are a couple of weird/irrelevant options in there. There's a good walkthrough of two different approaches to installing the launcher add-on here at misapuntesde.com. I've just tested the shorter approach and everything went fine. You'll need an SSH connection to get the necessary files. 

This approach leaves you with some additional responsibilities (implement random shuffle, listen for/respond to track ending signals, etc.), but I think it offers more options for fine grained control over a running mpg123 instance than is afforded by the remote option. There's a full list of available commands on the documentation page. 

The Pi 3 comes loaded with a Bluetooth 4.1 module. It should work fine. I'm going to put my psychic hat on and presume that you're reading this tutorial on Adafruit. That looks to have been written to be as widely applicable as possible, and to sell large quantities of Adafruit's own USB Bluetooth module, which is heavily linked throughout. Because only the Pi 3 has built-in Bluetooth it's likely just easier to provide universal instructions that work on every Pi. 

There isn't, unfortunately, a pre-made skip forward/back option for this interface, but it's not particularly difficult to bang together something workable. Mpg123 requires you to use a collection index to select which track in the playlist to play. Here I've created a playlist file () with 3 entries (1.mp3, 2.mp3, 3.mp3). Using the command I'm telling it to load and play the track at the corresponding playlist position: 

Per my comments below the question, if you would like to create a network between your Raspberry Pi 3 and a laptop which has no ethernet socket you can try: 

That's the new undervoltage symbol. Your Pi's power supply is marginal or insufficient for its requirements. From the raspberrypi.org blog page: 

I believe the tape is useful for manufacturing using a vacuum based pick and place machine. The machine can't pick the parts up if they're full of holes. Removing it shouldn't do any harm. 

Sounds like you're trying to build a crossover? You can't, to the best of my knowledge, stack multiple HiFiBerry DACs for more outputs. Their help pages have an outline of which pins are used for what. Personally, I'd go for an outboard crossover unit of some kind. It'll cost more, but stand a higher chance of success when you're already fighting against the Pi's limited capabilities and godawful audio output. 

[Edit - this answer is wrong per the comments and my explanation below. I did track down several other instances on SE of an identical approach, which are also presumably wrong. It may be helpful to leave this here to prevent others making the same mistake.] Matt from raspberrypispy.co.uk posted a simple tutorial using a Pi, a Hall sensor and Python. The tutorial includes a link to his Python code. The code's a little long to post in full, but the gist of it is: 

More information on this will be available as and when the units start arriving with purchasers and we get a clearer picture of overclocking capabilities and such. To the best of my knowledge the figures from the benchmarking done by the pimoroni.com blog are accurate: 

The order of the options passed to raspistill is non-trivial - you should always finish with your output file location, not with an option. In this case, swapping the preview timer option with the output location worked: Original/non-working: 

I'd agree with Ghanima's comment that Raspbian is as sensible an option as any. The magic word for your application is 'kiosk'. There's no shortage of existing projects to poach from. I'd suggest a small amount of Python and a relay to control power to your display. If your Pi is reasonably well secured away from prying fingers and you outfit it with a WiFi dongle you can access it over SSH secured with a username and password to tweak as necessary. 

I'm presuming that WS2818 is a typo. For the most part your setup sounds fine. The only thing I'd change would be the connection between the LED strip and the Pi. WS281[x] chips, strictly speaking, need a 5V control signal to work properly. You might be able to control one or two LEDs at 3.3V (I've had mixed results), but I'd be very surprised if you could do a metre. You should use something like a 3.3V to 5V logic level converter. 

I'd be inclined towards Flask for this sort of thing. I had very limited Python experience (coming from a C# background) before I started playing with it, and got on just fine. 

Per tlhIngan's answer, Bluetooth is probably the worst of those options for this application. Limited range and limited clients will likely lead to frustration. I'd argue for WiFi. While ZigBee's cheap, it's not quite as cheap as the ESP8266 WiFi module, which you can pick up for around £1/unit. The ESP-01 modules are tiny, low power, and easily programmable using either Arduino code or javascript. WiFi saturation is unlikely to impact performance for this application, given the miniscule amounts of data being sent back and forth. 

I've never used one but they describe the module as being 'capable of 2592 x 1944 pixel static images, and also supports 1080p30, 720p60 and 640x480p60/90 video'. I think it's likely that similar modules are available on eBay if you're prepared to do some research. 

If you can live with only serving one request at a time and don't care too much about security you can press ahead and open your Pi up to the big bad world. I would recommend, in the strongest possible terms, that you don't do this and use a recognised server package such as Apache. It'll work better in the long run and should give you much more control over what's happening with your site(s). The deployment documentation has a list of viable options and accompanying instructions. 

There are many existing 3D models of Raspberry Pis available for free at grabcad.com. Your question implies that you already have access to some modelling software, so it should be fairly trivial to pull the necessary dimensions from these models. The following is a quickly-grabbed selection that look about right - when using GrabCad models it's always a good idea to, at a minimum, check the comments regarding the model's accuracy. I've come across one or two that are nearly, but not exactly right. Pi A Pi B Pi A+ Pi B+ Pi 2 Pi Compute Module Pi Zero Pi Camera