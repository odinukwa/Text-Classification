When you type you are ssh'ing to the Pi with your current user account as the user id. So whatever your mac user is (you can use the command at the terminal command prompt if you are curious), that is the user you are attempting to connect with. My guess is that your pi doesn't know that user. If you want to specify the user with ssh you use the form , so in your case that would be . If you are ever trying to ssh through a different port (e.g. port mapping through your firewall), then you would add -p port. E.g. 

Remember, cron will run as you, so use sudo in the cron command if you need to do something requiring access. Hope that helps. 

The issue is in the configuration of your ftp server. Ftp servers have their own umask value used for any incoming file. With an ftp server like proftpd, this can be set per directory. The ftp daemon runs on your machine and waits for an incoming connection from your ftp client (e.g. your windows machine). Then it accepts the file / commands, and writes the incoming file to the specified directory. When it writes that file it does not know about the permissions that exist on the machine that is sending the file. For security reasons it also does not use the default permissions on the incoming directory. Instead, you configure it to use a specific set of permissions for any files being written to the local machine. For security reasons, ftp servers generally won't let you make incoming files executable. Not sure which ftp server you are running on your Pi. These instructions apply to proftpd. First install ftpd: 

Instead of email, how about using watchdog? That way when you have an issue, if it hands the pi, it should reboot automatically. You can actually have it test the file directly. See my post here regarding how to set up watchdog. Do not let it launch right after boot, put in some sleep time as explained in the post. 

If you have successfully used putty to log in (user = pi, password = raspberry), then you are already in raspbian. And that means that you already know the IP address of your pi. If you are looking for a GUI then @dastaan 's comment is correct, but you will first have to log into the command line via putty and install / enable vnc - look here for a guide. If you have not successfully logged in via putty the you have a different issue, made more or less complex depending on whether you are planning on using wifi or a cable to connect the pi to you home network. If you are going to use wifi, realistically you'll need a monitor and keyboard so you can boot the pi up into the console and use the command line to set up wifi (and vnc server for that matter). There are many guides out there, just google "set up raspberry pi wifi command line". If you are using a wired connection but can't figure out how to ssh using putty, then your issue is probably that you don't know the IP. You can use a smartphone app like fing (I love that app) to find out what IP has been assigned to your pi. Or you can hook the pi up to a monitor and look at the boot messages, which include the assigned IP address (looks like xxx.xxx.xxx.xxx). Then use putty to ssh to that ip address and follow the vnc guide mentioned above to install vnc server. Very important, you should have installed raspbian, not NOOBS. If you installed NOOBS you still need to install raspbian, which is done by hooking a keyboard and monitor to the pi and walking through the install instructions. Hope that helps. Let me know if you have questions. 

I think you are confusing things here. Creating an access point is a networking setup, it's not about publishing services on your local network. Hostapd will create an access point which is like a router but generally just extends WIFI for an existing network. If you do want an access point, you will need two connections for your pi. One for the network you are hosting, which is controlled by hostapd, and another for your connection to the internet. hostapd "bridges" the two connections, passing packets from one device to the other. You can find a very basic overview of the difference between routers, hubs, switches and access points here. I believe what you want is simply to set up your pi as a server to accept commands from your android device, not an access point. In this setup, you would connect your pi to your internal network normally. Then you would publish services (e.g. a web server like apache). Take a look at OpenHab for some good examples. OpenHab also has an android app that is already working, and there are plug-ins for lots of common smart devices. There is also a guide for setting it up on a pi. You are going to want to get familiar with some networking topics. In order for you to access your pi from outside your home network you will probably have to configure your router to forward the ports that OpenHab is listening on, and you will want to set up some kind of dynamic DNS. I use no-ip as it's free, but there are many great services available on the web. Hope that helps! 

Not sure what you mean by a private IP, but generally speaking I think the service that you want is dynamic DNS (DDNS). There is client for the Pi for most providers. Google "dynamic DNS". What they do is give you a friendly URL (e.g. johndoe.dnsdynamic.com) and they manage the IP mapping. So the client runs on the Pi, "pings" the provider every once in a while. The provider detects the IP the ping is coming from and specifies that as the public IP. However, using a MIFI presents another issue. Depending on the MIFI, you will have to open up the necessary ports or put your Pi into the DMZ (not recommended). I'm not sure that is supported by most MIFI's, at least not the ones I have seen. The second option is to set up a VPN, as you mentioned. I'm not as familiar with this option, but you want something where you tunnel to a web-based host, and then you connect from your local machine to that web-based host. Otherwise you face the same issue with the MIFI and opening ports. The last option (and maybe the best / easiest) would be to use a remote control type of tool such as NTR, TeamViewer, LogMeIn, etc. Not sure which ones have a linux client, and you'd need to run desktop, but they will all do the job even with a MIFI in the mix. 

Please no comments on my comments / lack thereof. This wasn't meant for public consumption. I'm also not a programmer, so excuse the poor programming. Minimal things you need to change: 

There are many posts that address this. Here is a link to get you started. Here is a python program that will do what you ask. VERY IMPORTANT - don't use more multiprocessing such as children of workers, queues, etc because the call to terminate will mess up garbage collection and will cause you problems over time. 

For starters, try installing watchdog (sudo apt-get install watchdog). In /etc/watchdog.conf uncomment the ping and set it up to ping your gateway. That should at least help you not have to go and unplug the machine manually although it does not help with the root cause. Note on watchdog - I would start watchdog manually using a cron script that sleeps for 30-45 seconds before launching watchdog. This will prevent you from getting into an endless reboot loop. Here's my watchdog.conf: 

I have a script that I use for that purpose using sftp. It's below. You'll probably need to change some things but it should work fine as long as you have not changed the default file name formats. It also deletes the files after they have been moved. I run it daily at midnight using cron. It moves everything that's not from the current day. This way it cleans up after itself if you miss a few days, and it doesn't mess with files that may be in the process of writing. You'll need to enable sftp on your mac. Go into System Preferences -> Sharing and enable remote login. You need to know our Mac's IP address on your local network, your userid on your Mac, and your Pwd on your Mac. There is a guide here. You'll also want to log into your Mac from your Pi via ssh at least once before running the script. This will store the ssh key for you. The script will fail if you don't do this. This is not the most secure solution as your Mac's user/pwd is in clear text in the file. There are workarounds to this but it wasn't worth the trouble in my case. You'll also need to install pysftp and path.py.