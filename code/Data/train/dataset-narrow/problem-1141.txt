You don't actually need a loop because Ruby has built in functions that simplifies all this. To grab random UNIQUE numbers in range , do: 

You can see how our indents move backwards and forwards by 1 every time we hit a scope changing keyword, like , , and . If you were to draw a ling hugging the left side of our code, it would be smooth as it moved back and forth between levels, with no large jumps. Now we can easily see that the code is split in to three sections, based on the answer to the question, and it will be easier to understand and improve the code. 

You've got a solid start here, but consider a real world problem (and the common follow up question to Fizz Buzz): The customer now wants your program to also print "Bang" when the number is a multiple of 7. So, with your current process, you'd need a couple more statements (for 7, 21 and 35). Not too hard to do, and you can just copy the code you already have for the most part, so this is doable. But then a few years go by and the company gets bigger. Now, when the number is a multiple of 11, you need to print "Boom". So are you going to write out a chain of 24 statements? What if you mess up a number somewhere? Or put the conditions in the wrong order, like having the check for 15 before the check for 165? You have an unmanageable mess. The correct solution is to use a list, pairing each number requirement to its word, and build the "FizzBuzzBangBoom" string as you iterate over the list. The method to add a "word" to the string operates the same no matter what the number input is - it's just a modulo function - so you can cut down on a lot of repetition. As a challenge, try to repeat your project with less repetition (the DRY principle) and SPECIFICALLY do not have the numbers 3, 5, 7 or 11, or any multiples of them, appear in your code more than once. 

Although it doesn't appear to be in the scope of your project, ideally you would not call at the beginning of each factorial method. You would call it once, when you actually get , and THEN pass it in to the factorial function. Some last points; I recognize that this is a learning step for you, but do not use loops in ruby. They have bad side effects and you do not need them, there are plenty of ways to iterate over collections. Also the loop looks rather ugly but that's because it's the wrong tool for the job, so it's to be expected. All in all, it's pretty decent ruby! Good job on using reduce / inject, a lot of beginners don't use/comprehend what they do., however is an alias of so to have them both is kind of silly :P 

QPaysTaxes has a lot of great points, but one thing that stands out is that you are asking for the "Idiomatic" way of doing things in ruby. For fizzbuzz, that would involve a hash mapping numbers to words so you could easily and arbitrarily extend it. I would rewrite QPaysTaxes function as such to get more idiomatic ruby: 

Finally, in your and other things should arguably be instance variables () but I'm not entirely familiar with how sets things up so this might be more trouble than it's worth. 

A final thing to consider when you get more familiar with Ruby - do not use Class variables, use Class instance variables. Class variables have wonky behaviour with inheritence. 

If you didn't know, creates a method called (in this case, ) that simply returns the instance variable (, exactly what you already have). Remember to change the places you call it from to . This use of wont' suffice for some of your other getters, as they have a bit of logic behind them that you need to state. This leads into the next point - rename all your methods to . This will keep in line with the standard. 

This should be a constant, declared in the Dinosaur class and not in the carnivorous method. Also it doesn't make a lot of sense. If means carnivorous, what does mean? I would change this to 

Now you can uncomment those extra rules or throw your own in with ease. If the method for determining replacement or not changes from being to , you only need to change a single location instead of once per rule. (This practice is called DRY, or "Don't Repeat Yourself".) I can explain the code further if you want, just leave a comment below. 

@Borsunho made some points on functional improvements, so I'll address some style points. - Folder name is already a string, so you don't need to wrap it in a string and then interpolate it. Just use . 

Lines 2, 3 and 4 are indented further than 1 and 5 because they belong to a deeper scope. Doing nothing but re-indenting your code gives us this: 

If you don't understand what this is doing just comment and I'd be happy to explain. We're taking advantage of the fact that Ruby handles collections of things incredibly gracefully. 

REALLY not needed. Now get rid of the rest of the comments too, and reword your code so that you can understand what it does without needing the comment. 

To access a*b where a >= b, the answer is in arr[a-1][b-a] To access 3*4, the answer is in row 3-1, element 4-3 = arr[3-1][4-3] = arr[2][1] = 12 To access 5*2 (= 2*5), the answer is in row 2-1, element 5-2 = arr[2-1][5-2] = arr[1][3] = 10 To access 100x100 (assuming the range goes high enough), arr[99][0] You'll need to do something slightly different if you are passing an array that isn't 1..x - in that case, first look up the index of each of the two numbers in the original array and use THEM in the arr[a-1][b-a] lookup. I suspect you'll need to subtract 1 from the indices but I haven't worked it out in my head. 

and now people can answer "yes", "yeah", "no", "nope", "y", "n" and still get the desired result. If you don't use a case statement you can still add this functionality in conditions: 

You should use to output to the console, not , unless you actually want the output to stay on the same line (useful for, say, a progress bar or a question waiting for an answer). Using automatically appends a new line if there isn't one, so each line of output gets its own line in the console and you can read it more easily. 

In our product, is a model that can have many Companies belonging to it; so some Companies are parents, some are children, and many are both. We have a helper method that has as its children all Companies that do not actually have a parent; in this way, accessing and recursively iterating over the children will touch every Company in the database. For context, 'branches' are just Companies with a special flag set (namely that they cannot have children of their own). We have a method that makes one SQL call per Company below the queried Company. This has abysmal performance on some pages, and for instance when we need to do Company validation we need to check other companies in the chain for a few different values to ensure pseudo-uniqueness (can not make the column unique). How can we improve this performance of this method? Can we cache the companies on the first call and use the in subsequent calls? Not all properties of Companies are in the database (some are computed) so I don't think we can replace the code with a (sufficiently complex) SQL query in ALL cases, but we might be able to do it for some. 

I need to open and read several files for a project. Some of them are plain text files, and I just want a standard to read from. One of them is an XML file, and I want it automatically loaded into Nokogiri in the following way: 

See a test of this here. Also I just tested it again with the option and it works beautifully as well (returning Stegosaur and Apatosaur but not T-Rex), so that's cool. That's a bit unreadable, so maybe make each option a hash like 

Your and functions call each other, but this makes you call your validate function over and over. You should rewrite it so that factorial_r_recursion only ever calls itself, because you can ensure that everything it produces is valid already. (Same with the functions) 

Returns nil when the search fails or false when the group param is not an array. If you are confident in your ability to pass in Arrays only, you can clean it up by getting rid of the call to 

You can do some nifty meta-programming to dynamically define the methods. The code below is slightly modified to show the results, you should find it trivial to change back to suit your needs. 

Your code does a whole lot of exiting. Why not replace that exit with a call to the main menu? You can't do that at the moment because your Run module doesn't have any methods in it. Aside from the , throw all of that into a or method or something so you can reuse it. 

Ruby style dictates we use 2 spaces per level of indentation. The style guide is here, if you're interested. Moreover this is needlessly wordy. You can replace the entire thing with this: 

Your current regex is WAY too forgiving. First of all, every one of your example starts with a P followed by some numbers, but you accept ANY COMBINATION of letters at the beginning. I'm assuming that isn't a valid key, so you should take steps to reject it by using hungry quantifiers as little as possible (, ). Using matches a digit between 3 and 4 times, so that will let you limit the sort of input you accept. The same goes for the 5th group - according to your examples, it's either , , or 4 digits. In Regex, that looks like this: Next, you are using alternation () to capture the different "forms" your string comes in as, but you are repeating a bunch of stuff (for example, the at the beginning). You can limit the scope of the alternation by surrounding it in brackets (). You can see this in action with the example - that whole bracket group becomes a single token that matches somewhere in a string (or doesn't). Sometimes the string ends after the 4th group (Before the L/R group), and sometimes it doesn't. Instead of using alternation to solve this, which makes the regex VERY long, you can just surround the entire regex AFTER that point in brackets with a question mark (). This makes the entire second part optional. Finally, your problem asks if there is a simple method to improve the regex. By ending it in you can match ANY length of additions to the end, assuming the all come in the form or or whatever. If you knew that there was always a max of 15 numbers added to the end, you could change that star () to a max quantifier (). If sometimes the number only has two digits, change the to , etc. See it in action here