Actually, there is a much easier way to deal with this issue: do not use pointers and dynamic memory allocation. I do not see any point in being allocated dynamically. Using an is much better(). The same holds true for the member-variable. One more thing: you should try to keep the scope of variables as narrow as possible. There is no need to declare the at the beginning of the function. You can do it just inside the for loop where it is used. The last thing: is a bad practice. It pollutes the global namespace. 

Summary: both 1. and 2. express the same idea(from different point of views): we can represent this problem as a graph problem using standard graph concepts and algorithms and separate it from words to achieve better performance and better design. 

Use more descriptive names. I have no clue what mean. What is ? Something like and would be better (well the first one is not exactly a digit, so you can come with even better names). There's no need to return from the function explicitly (sure, you can if you want to). Write proper automated tests for your code to reduce the number of bugs (your bug is very likely to get caught by tests). In fact, you can check all possible valid inputs. There're only 100 of them. There's nothing wrong in having stand-alone functions. There's no entity here, so I don't see the point of modeling this problem in terms of objects. A function from an int to its string representation is just a function. 

Error handling. It makes sense to throw an in the constructor if the denominator argument is (it is not a valid rational number so it shouldn't be treated as such). The barrier between representation and use is not about having a constructor and fields and other methods that perform different operations. The barrier is the class itself. The clients of this class can treat it as a type with a set of defined operations without any knowledge of how it is implemented internally. 

There're a few more problems with code: for instance, it crashes for (which is a valid input). You implementation is really hard to follow: it's not clear what the arguments , and stand for. They're way too generic. : What kind of index? Sure, it's a position in the original string or list. But what does it represent? It's not an arbitrary position, is it? It's the index of the element that should be changed, isn't it? Why not call it , or something like that? The same goes for : what kind of limit is it? There's too much stuff going on in the function (like choosing the next position, generating a new combination and so on). I suggest splitting into a few smaller function with meaningful names. I didn't fully understand your code, but if you need to keep a to avoid duplicated, you're doing it wrong. I don't see why you need to recursion here either. Let's go back to the algorithm: 

In general, avoid using loops when there is a standard method for doing what you need. If you are using Java 8, you can simplify the code even more by using the method of the to avoid things like: 

The method seems too big to me. Taking into account a new algorithm described in 1., I'd do it this way: 

The comments inside the method (like ) are an indicator that a piece of code this comments corresponds to should be probably factored out to a separate method (of course, it's not always the case. It is the case here, though). Once or code calls the method, there is no need for such comments anymore. The code becomes self-documented, which is a great thing as comments can become obsolete if you change the code in the future. There's no way to ensure that the piece of code followed by the comment actually swaps anything after changes are made (again, it's not a big deal for a such a small program, but it can become a serious issue if you implement a larger program using the same practices). You can get rid of magic constants (like 3 and 2) in your code by creating a constant variable for them (for instance, you can set and use it everywhere in your code. It communicates the intent more clearly and makes possible future changes easier (you need to change just one constant instead of looking for all 3's and 2's around your code). Keeping the scope of each variable as small as possible is a good practice. The declaration of loop counters outside the loop is not just unnecessary, it's also sort of misleading (as it's normally done only when the value of the counter is used outside the loop, which is not the case here). That is, the only variable you need to declare in the begging of the method is the array to hold the matrix. The loops are usually implemented this way: 

This way the code becomes much simpler: there's no need for the structure. There's no need to care about cleaning up the memory either. I'd also recommend renaming some functions and variables: for instance, is a very strange name for an iterator. , surprisingly, can return more than one suffix. You can make the trie more flexible by making the type of the alphabet a template parameter instead of using a fixed type . It'll let it work with other types of strings. 

When there're comments in the code that tell what it does, it usually indicates that the following piece of code should be a separate function with a meaningful name. I'd create a separate function that the positions of the words to be modified (and it something like ) and a separate function that checks if a word already has a label. You can make your code more readable the tuples from the list: looks better than 

The logic of the code. It looks like your algorithm is not correct. The problem statement clearly says that the process should be repeated until we get one digit, but you compute the sum of digits only twice(what if still turns out to be greater than 9?). You can use a recursive method to make your work for all possible cases(or you can keep iterating until the root is found). Modularity and separation of concerns. It is not a good practice to have one method that does everything. I'd recommend creating a separate method that computes the digit root so that the main method is responsible only for the I/O. 

To sum up, I'd recommend to make the code more modular by having a separate classes and methods for each thing that your code needs to do. 

There is no need to use the keyword in the class. All methods are , so it is thread-safe(it is guaranteed that only one thread can execute only one method at a time and all changes made by this thread are visible to other threads that execute any method of this class in the future). 

Error handling. Your code does not handle the case when a text does not represent a valid . It would be nice to have some error handling(for instance, you could show an error message in this case). For instance, this line of code: 

Now it returns in both of these cases instead of throwing an exception. But it is not the only method of this class which works improperly. An attempt to create any instance ends up with: . It the result of an incorrect implementation of the method(which always returns ). A fixed version: 

It's split into several smaller functions so that it's easier to read. A few more technical details: I used here to implement a generator. It's useful if the number of combinations is huge. Not storing them in a collection helps to save a lot of memory in this case (stack overflow is not the only possible issue: you can also just run out of space to store all combinations). Note that this implementation handles corner cases properly (like ). There're a few more things you might want to add, such as parameter validation (it makes sense to throw an exception if or either of them is negative). 

I don't see the point in using here. There's no resource clean up or any other strong reason to resort to it. It just makes the control flow more complicated. How to fix it? In the function, you can just return the value immediately in case of an error. In the function, you can run the loop with a condition . It'll make the code easier to folloow and eliminate a corner case . The error message seems too generic to me. It would be more helpful if it were more detailed (too many and missing arguments are clearly different cases). An LCM of two 's may not fit into . I'd recommend to document that your program has undefined behavior if the LCM is too large or use a wider integer type. 

It is a good practice to keep a scope of a variable as narrow as possible. There are a lot of comments in your code that tell what the code does. Instead, you should try to write a self-documenting code. You can increase modularity and clarity of your code by using separate methods for separate tasks. For instance, 

There's a simple linear solution. You don't have to check all substrings. If an substring is a palindrome and , so is . Thus, it's sufficient to check only substrings of length 2 and 3. One can do with a single pass over the input string: 

Use exceptions to handle exceptional situations. Don't just print something to the stderr and exit. For instance, if the denominator of a fraction is zero, it's reasonable to throw an IllegalArgumentException. The constructor should guarantee that a fraction is valid after the construction, but it shouldn't terminate the entire program if it's not either. Instead of parsing the input string in the method, you can create a constructor that takes a string. It makes sense because is a widely-accepted fraction representation. You code is not correct. For instance, it treats and as different fractions. It means that you method is broken. You can fix it by changing the sign of the numerator and denominator if and only if the latter is negative. Do you need getters and setters in the class? Setters make no sense to me. You can break a fraction by setting denominator to 0. It breaks the integrity of this class. It's a good practice to keep your objects immutable. Just get rid of setters, you don't use them anyway. A default constructor for a is broken. It leaves the object in an invalid state (with 0 denominator). Either fix it you get rid of it. Why do pass and to the reduce function? Setting and fields in the constructor and working with them makes more sense. This: is also broken. It's integer division. This way, . Don't use floating-point division, though. You've got the method in the class. Use it. Taking into account so many simple bugs, I have a question: did you test your code? Are you sure that it actually works? In any case, I'd recommend unit testing your code. Even simple small test cases are likely to catch many of the bugs you've got. If you want to count the number of occurrences of each fraction, you can use a instead of two nested loops. It'll make your code more efficient and readable. You'll need to override the method to use a to make it consistent with . What is the point of this code? 

One class should have one focused responsibility. Your class sorts the vector and prints the result. These operations are unrelated. There'so no need to have a class at all. It doesn't represent any entity. It's just a function, like . The map can be local variable. To keep it more similar to the standard library, I'd recommend to take two forward iterators instead of a vector. It'll be more flexible this way. 

It does the same thing as your code did, but no "unnecessary" variables are created. Computing the roots and checking if they're looks sort of confusing to me. I'd rather compute the discriminant and find complex roots if it's negative and real roots otherwise. can be simplified to . Comparing the values of boolean variable with constants is considered to be a bad practice. I also do not the point of creating local variables are , and . They are never modified, so I suggest using the method parameters directly. The fact that the output looks slightly differently ( vs ), but has the same meaning seems strange. Is it deliberate? If yes, then it's fine. But I'd rather create a constant format string (for instance, it could be ) and use the method to get rid of inconsistencies and make the code more readable. 

The time complexity is because we traverse the given string once for each pair of start and end letters, and then we use one formula that is computed in to answer each query. 

It should actually be in the first line. You can reduce the chances of making such bugs by storing a shift vector for each direction in a dict and using a shift function: 

Thread-safety is about controlling an access to a shared state. It's up to you to specify which parts of you system can be accessed from multiple threads(and how) and make decisions based on that. Do not arbitrary tag variables with the keyword. Do not arbitrary add the keyword to some methods of some classes. You are very unlikely to get it right this way. The best way to go is to get a solid understanding of the Java memory model. 

Writing anything to the standard output in constructor is a terrible idea. It has nothing to do with the string class. Logging is a separate concern. Printing the error message to is not a proper error handling method. If the allocation fails, the users of your class will never know it (they might not be sitting there looking at the screen). You should indicate the error by throwing an exception. I don't see the reason to use here. It's easier to let it throw automatically. This piece of code is even more broken: 

Nope, it is not correct. The problem is that the to_visit list can change after visiting a child of the currect node(for example, on a full graph with 3 vertices your implementation will visit the third node twice(if you run the depth-first search from the first vertex)). However, it is easy to fix it. You can just iterate over all children of the current node and run a depth-first from a child if it has not been visited yet(using an if statement inside the for loop). 

If you call this function multiple times and want to benefit from pre-compiled regular expressions, you could create a new class that compiles the expressions in its constructor and reuses them: 

To make your intent clearer, use when you need queue. Don't reinvent the wheel. Don't confuse those who read your code. Iteration over is very inefficient because it lacks memory locality. Don't use it unless you have a very good reason to. Use as a default container. Separate the words in variable's names somehow (either using camelCase or underscores). looks sort of gibberish. or looks better, doesn't it? Even if the input and output should have 1-based indexing, I'd still use 0-based indexing in computations. It's more conventional so it makes your code easier to understand (That's the main reason. Saving one element isn't a big deal). 

While doing everything in the method may work for small programs, it's not a good idea in general. Ideally, one method should do one thing. Moreover, exactly the same code that prints the matrix is used twice in your solution. It's a very good reason to create a separate method for it. In general, I would split your program into at least three separate methods: one of them would read the matrix, the other one would perform a required transformation and the last one would print the matrix to the standard output. It looks roughly like this: 

Summary Managing memory is hard. Relying on standard practices and data structures can tremendously simplify it (in this case, they're: the copy-and-swap idiom, smart pointers and standard containers). 

And the last one: do have good reasons to use this data structure? In my opinion, as long as a simple works fine, there is no need to invent any new data structures. 

There is too much stuff going on here. And the fact that you need to write comments to explain what the code does is a smell. How to improve it? Well, you can make it much more readable by decomposing it into several smaller methods: 

You can write simpler code without 's here: converts a string to an unsigned int (the last argument is the base). I think that expresses the intent more clearly than . 

It's broken if is not an int. That's not what you want. It should be . It's even better to use . . is unsigned. It makes absolutely no sense. - what if there're several values equal to ? Do you want to delete them all? That's not how a priority queue normally works. Separation of concerns Don't mix computations and logging. Efficiency