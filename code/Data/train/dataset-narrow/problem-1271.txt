Other possible changes: I didn't make any of the changes below because you said your code was working, and I don't know those programs enough to guarantee the changes are an improvement. A) I don't see why you run WinSCP via START. I believe you could simply use: 

You can use a FOR /F to parse out the command from the arguments. I would define a variable containing a delimited list of all valid commands. Then you can use simple search and replace to validate whether the user entered command is valid. Addition of a new command is as easy as adding the command to the list, and creating a labeled subroutine for the new command. I would use CALL instead of GOTO so that each routine can easily parse the arguments. The only disadvantage is CALL will double up quoted carets ( becomes ) Here is a basic framework that can easily be extended. Note that user entered will be corrupted (or expanded) because of delayed expansion. There are simple ways to get around this limitation with additional code. 

You probably want to localize any environment changes. You should initialize your variables to a known state at the beginning, otherwise you could get the wrong result. You have a lot of redundant code that can be eliminated by using a CALLed subroutine You can use the operator to conditionally execute code if the previous command failed. I find it simpler than using IF ERRORLEVEL. You can save a bit of typing by storing code in a variable to be used as a simple macro. 

I can almost guarantee it is not doing what you think. The most it can do is set the ERRORLEVEL. However, The EXIT command expects a numeric argument, but you pass . The EXIT command returns 0 if it does not receive a numeric argument. I doubt you have a variable with a name of "0", so the EXIT command sees a string literal value of , which is non-numeric. It consequently returns 0 every time. Your very next command (FINDSTR), is an external command, so it will set the ERRORLEVEL anyway. There is no need to initialize it. 2) It is generally a good idea to enclose SET assignments in quotes. This guards against poison characters, and inadvertent trailing spaces. (There are some exceptions, but it is a good rule of thumb). 3) It is generally a good idea to always enclose file paths in quotes if a portion is a variable. You never know if the variable may contain spaces or poison characters. The value normally does not have spaces, but it certainly could. 4) There is no need to delete "%temp%\rdcto.txt" when you immediately turn around and recreate it. You can simply redirect using overwrite mode () instead of append mode (). This will guarantee you start out with a fresh file each time. 5) Why do you write the value of %MailDst% using a FOR statement? You can simply echo the value directly. 

Use FOR /L to iterate a range of numbers - much faster than SET /A with GOTO loop. Use SETLOCAL to localize variables so no need to undefine them. The EnableDelayedExpansion option does just that so that you can use within a FOR loop. A minor optimization - it is faster to combine multiple math computations into one SET /A. 

6) You do not need to create an label and GOTO that label. Instead you can do either of the following: or . They are identical, and neither form requires an explicitly declared label. The only difference is that can take an optional argument specifying the returned errorlevel. 7) You should encapsulate the logic for writing an email into a subroutine that accepts the variable portion as arguments. It reduces the amount of code, and eases maintenance. 8) I've simplified your ERRORLEVEL logic by using an extra variable to store the return code. I also make use of the conditional && and || operators with FINDSTR - I find them to be more convenient then checking the ERRORLEVEL. But I didn't use them with WinSCP because the logic is a bit complex. Note that if the last command within a block raises an error, then it would cause the block to fire. That is why my :sendMail routine explicitly exits with a return code of 0 (success). Using the above principles, I would write the code as follows: 

You can write e.g.: "The implementation of {@link #save() save()} function is optional." Same holds for the JavaDoc of the method itself. 

If I understand correctly, the program counts the occurrences of some words in a file. I have the following observations: Error handling I would recommend throwing exceptions instead of/additionally to writing to cout and cerr (btw., I think if you do write to these streams, you should stick to one of them, most probably cerr). EDIT: Note, that as the constructor is written currently, we can end up having an object in an invalid state after calling it. This would be prevented by throwing an exception. Encapsulation, state of the class I suggest making setWord private, or at least protected. As it is now, one could call: 

Is this a correct implementation of the data-structure, or do you see any flaws? Is there a way to make the implementation more optimal? (E.g. is there an elegant way in to jump out of the if we encounter a bit not equal to ?) Related to the above: is there a way to make this code more idiomatic? (I.e., conforming to Clojure best practices.) Can you think of any missing tests? Or some other edge-cases which are not covered? 

So, I am asking if there is a better way, to compare two sets, providing a custom function for equality checking (in this particular case, this custom function would be ). I am thinking of something like this (pseudo-code only): 

This will return . However, is misplaced here, because it should be at position , and it is, instead, at position . To be honest, I don't really know what would be the best solution here. I can imagine the following: 

Out of scope The quality of the hash-functions used for testing is out of scope of this review. (I know there are much better ones, but for now I focused on the data-structure itself.) However, if you know a way to e.g. better organize them, and avoid repetition (but without making that global!), that would be very appreciated. The code 

Why is this last point advantageous? Because you can easily add more situations, without the need to copy-paste the gui elements (wrapping divs). Besides that, it is also possible to quickly change the gui implementation. (E.g., if you decide to have divs instead of buttons, you do not have to change every one of them.) I created a fiddle, where you can try the concept. (Unluckily, the built-in fiddle of SO is not available from tablets...) 

Background Linked lists are a well-known data structure, so I won't waste too much detail on them. Suffice to say that a linked list consists of "cells". Each cell contains some kind of value and a reference to the next cell (except the last one, which contains an empty reference). I implemented a linked list in Clojure as an exercise. The code 

Reason is to avoid accidentally breaking the if-else construct, by introducing new solutions.Consider this: 

Alternative While the recursive approach is elegant and easily understandable, it might be less convenient for very long inputs. I suggest another solution, based on the idea, that if you want all permutations, then each character can either be part, or not be part of a permutation. This gives us 2^N possible permutations, where N is the length of the input. So, you can just generate this number (2^N), and then iterate from 0 to 2^N-1, and calculate the corresponding perm. for each number. So, if the number is represented as binary digits, then 1 means that the character at the corresponding position should be part of the permutation, 0 that it should not. (If you do not need the empty perm., just start the iteration from 1, instead of 0.) With your example, 'AA2', this would work as follows: N=3, so iterate from 0 to 7 (=2^3 - 1). 0 corresponds to the empty set. 1 = 001b, so '2' is part of the permutation. 2 = 010b, so only (the second) 'A' is part of the permutation. 3 = 011b, so the perm. is A2, etc. Remarks: 

This prevents that you add more statements (accidentally indented at the level of if-else block), and think they will be executed within if-else. Validation Although not part of the original problem statement, I would recommend to extend your code with validation. I.e., make sure that hours are between 0-23 (or 1-12 in case of 12-hour format), minutes and seconds are between 0-59, and throw an exception otherwise (or print an error and exit, whichever is available in Processing). Before adding validation, it would be also interesting to experiment how your program behaves with invalid input (e.g. negative numbers, hours consisting of three digits or four, etc.) 

You are checking the primality of the same numbers several times! Extra optimization can find a divisor, not just check primality. Optimized algorithm 

The way quick sort is defined (requiring random access) it cannot be efficient for linked lists (especially immutable ones). I recommend a recursive implementation of merge sort. It will be clear and concise. It should also be relatively efficient. 

note the use or instead of . Another interesting optimization is changing the iteration in from descending to ascending. This should speedup it up considerably as it would terminate early more often: 

You are not using tail recursion in , so the compiler cannot easily turn it into iteration. It depends on the specific problem; in this case I would probably do it iteratively. Sure, is useful and convenient. 

Lisp is a multiparadigm language. is just as lispy as recursion, and, in a way, much more so (think in HOFs)! Style 

The second (recursive) version can be made tail recursive using an accumulator. This would help some compilers produce better code. 

The seems to be no reason to use lists as opposed to arrays here. I would use multidimensional arrays instead: 

You are doing fine, other than a few simple nitpicks. You are not using (which is a crazy thing to do anyway), please drop it. You should fix your indentation, it would make your code much easier to read. You probably want to divide by , not , in and you probably want to simplify the code there by dividing by instead of multiplying by the reciprocal; also is relatively expensive, so, if you were not i/o bound anyway, you might want to replace it with multiplication. Function should probably return multiple values instead of a . Global variable should be local to . Function should probably be called (it read the whole list). 

However, no such allocation happens with so there is no reason to avoid nested reduces. Note that the proverbial "sufficiently smart compiler" should be able to handle these problems (but not necessarily the quadraticity above!), so you should only worry about this if you discover it to be the performance bottleneck. Remember (SICP): 

You compute twice - this is a waste. You return instead of the improved guess, i.e., you return a worse approximation than you could. 

Algorithm Your algorith is quadratic for no good reason because and are linear in list length. I suggest that you add new elements to the beginning instead of the end of the return value in and 

Performance is probably quadratic in your implementation, so you might want to consider another approach for larger values of 1000 :-) 

Trivial Use instead of . Avoid very long lines (Emacs will indent for you). Do not use when a single without would do. Memory Use instead of when possible to avoid unnecessary consing (in your case, allocates a fresh list, so its result can be passed to ). Catastrophic Whenever you use , you are using the wrong algorithm. Optimal search is linearithmic: . Insert search is quadratic: . Your implementation is : 

Implementations The first (HOF) version can be much more efficiently rewritten in using (provided returns fresh lists): 

is unreadable. is better. is far too high precision. With such an epsilon, you might as well use instead of - the "oscillation between two adjacent floats" problem will be the same. Read up on machine epsilon. This number should actually be an argument to . Adding a line break would make the function more readable. 

This has the added benefit that the return value increases in (i.e., it returns the of your function). Alternatively, you can actually avoid constants: 

Minor Paren placement Hanging parens are an eyesore. Global var Use instead of to create global variables. Sharp-quote for functions You should do instead of . Unnecessary allocation Since your returns a fresh list, you can use instead of . Major Sum Your function is broken - it will not work on long lists, see . Here are better ways to do this: 

Doc string (no more than one, but it can be multi-line!) usually comes before the declarations. Please see Syntactic Interaction of Documentation Strings and Declarations: will define a function which has no docstring and return , while will declare a function with a docstring, returning . should be . should not be used if you know that the object is a ; use instead. There is no need to bind and in since they are used just once. is, I think, more "idiomatic" than in your case. It is clearer to use in .