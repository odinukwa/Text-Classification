The origin and position were just to position it in the middle of the screen and aren't really important here. What's important is that you perform the rotation before the scaling otherwise you'll get the result depicted above. Edit From taking a quick look at the documentation it seems to me that you should start with , apply to it, and finally apply to the result of the previous operation. I think that should be enough to figure it out. 

Instead of using use and accumulate the running total yourself in some variable. Then when you pause the game all you have to do is to stop adding the elapsed time to the variable. Here's an example: 

And it will return you the path (if any) between both cells. Question 2 The solution to your second quest seems overly obvious. Start by adding a few pairs directly in adjacent positions on purpose. Then fill the remaining gaps randomly. 

Now I'm wondering what would be the best way to get this data on the screen, using something like XNA / DirectX / OpenGL. The only solution I could think of was to create a texture with the same size as the array, write the contents of to it every frame, then render that texture in a full screen quad with the correct aspect ratio and using point texture filtering for that retro look. Is there a better way? 

You should read this tutorial on vectors for game developers at Wolfire: Linear Algebra for Game Developers Part 1 / Part 2 A vector can be seen as pointing to a specific coordinate. It can also be seen as having a direction and a magnitude (or length). A normalized vector is one that has a magnitude (or length) of exactly 1. Normalizing a vector produces a vector pointing in exactly the same direction, with a length of exactly 1. 

Tetrad covered general intersection in his post. Here I'll cover an algorithm that returns the specific points of intersection based on the formulae in this concise article. I'm matching my variable names to those in the article, so keep this diagram in mind - and probably in view too! 2 $URL$ The language is Python. You can verify your results in Wolfram Alpha by running a query to determine the intersection of two circles like this: 

You can only load content that's in your Content project. Since there isn't any file with the name "Courier New" (.ttf, or whatever) in your Content project, it's natural you'd get a File not found error. You can't just load system fonts. The example in the official Microsoft website just needed an example font name. For their situation to work, they'd need a "Courier New.ttf" (or something) in the corresponding Content project. 

It looks like they've just dumped sprites along the edges of their terrain. It's kind of like what Metroid did - a massive arsenal of edge tiles, but if you pay attention you can notice the repetition of the tiles. Acquaria's doing the same thing, except with rock sprites, and not on a grid. How to replicate it This might not be exactly how they do it, but it's one way of producing the same end result. First, get yourself a nice bunch of rock sprites like this: 

I gave it a try and rendering a using the same start and end points resulted in nothing being drawn. I found a way around it though so I'll describe it here for completeness. The trick is not to use the same start and end points, but instead to draw a line so small, that it only appears as one pixel when drawn. So, in order to choose the correct end point, I first projected the world space point into screen space, moved it right one pixel in screen space, and finally projected it back into world space. That's the end point of your line in order to make it look like a dot. Something like this: 

At load-time I would create all of the mask arrays from the alpha channel of the tile textures but only once for each type of tile. In other words, do not store this information inside each individual tile, but store it in the tileset instead. As for scanning for the correct position for the character to stand on, I would just do it the brute-force way - query the mask at the same position as your foot sensor sensor, and then move up pixel by pixel until you find a non-blocked one. Then move your character up by that same amount. Since tiles probably won't be too big, I don't think there will be much of a performance problem with this simple approach. But it's possible to simplify it in some cases Depending on the variability of your tiles it's possible that you could simplify the way you store your information a lot. For instance if your tiles always start from the bottom and don't have holes in them you could store their collision masks as a single one dimensional height map array: 

This is off topic for the site so I hope it gets moved to Stack Overflow. Your question isn't well written and I don't really understand it, but this does stand out to me: After pressing Q, you set StoreOn to true. In your "update function" however, you say this: 

returns the string from position 1 (i.e. after the first character) to its end, which in this case ends up as something like . Here's how you stop getting your error: don't do that. If you meant to just take the first digit, use: 

Error stacks go from the most recent call to the least recent, so the most recent line is what happened, and all the rest are what it happened within, what method that was called from, what method that was called from, and so on. 

You didn't say in what way it's not working (is it crashing, or taking forever?). You ought to do that. However, it strikes me as immediately absurd that your recursive flood fill has a loop. You could either write a loop to fill everything (which wouldn't be a flood fill), or you could write a recursive flood fill: 

But basically... no, you're limited to those options, and none of them are inherently 'superior' options. That said, why do you need to make a browser-based game? If you're just learning to program in a new language, make a simple program, then make a simple game, then make an actual game that could even be an independent EXE. Just because you've been developing for the web for the past two years doesn't mean you have to continue developing for the web. 

Say there are two clients connected to an authoritative game server, using input + state synchronization strategy. Client 1’s has a round-trip latency of 100ms and client 2 with 400ms latency. For now just imagine each player controls a ball that can collide and bounch off each other. 

With this method you can really only have smooth gameplay for one person. Are there better methods for smoothing out the gameplay for all players? I understand that for FPS you can easily compensate for the the bullet latency because you don't actually see the bullet. But in the case where physics collision can occur between players this becomes troublesome. Another idea that I have is spawning of a lava pit that is instant death for players. Lava pit spawning done using client side predication can instant kill the player and sync the state later, resulting in smooth gameplay for the client. But if the other player is lagging it will appear as if he is still standing in the pit (or with full prediction will kill him but he’s not actually dead). How do games handle cases like this? 

I am wondering if anyone has a better suggestion on how to handle this case? The only requirement that I prefer to keep is the tile based wall as I have a map editor that generates the map data. Also if there is a method that can be extended to sloped walls that would be even better! Thanks! 

You called parseInt with an invalid input it obviously can't turn into a number (because it isn't a number), so of course it's going to throw an exception saying it can't do that - that's exactly what's supposed to happen. Let's see what you're doing in which is the method that parseInt is called within. 

This is a simple operation of vector difference. In XNA you don't even need to create a specific method for it - vectors already support subtraction. If you want the velocity of Body B from the perspective of Body A, you subtract Body A's velocity from Body B. So in C# with XNA, using your example: 

Because it's a game. You can do stuff like that in games. When's the last time you saw someone do a double jump in real life? Or heal fully from half a dozen bullet wounds in the space of ten seconds? Or be shot to within an inch of death, only to touch a medkit and be perfectly healthy again? It's not realistic. It doesn't have to be. It's a game. You can do unrealistic things. It just has to be fun. 

Yes, of course it's possible. You can do just as much with C# as you can do with any other language (which is just about anything). Most programming languages you find will be Turing complete, which effectively means you can always do with one what you can do with another. The only real difference is the way you can approach those problems with the given language, and what libraries are available. Since C# and the .NET framework have a tremendous variety of libraries available, there are not many limits there. 

Question I have just started working with Lidgren and networking for the first time, and I've come to the realisation that it is possible to run both the server and the client within the same process. Is this practice discouraged for any reason? Context The reason I'm asking is because I theorized that this concept might allow me to treat both singleplayer and multiplayer modes as one and the same, which would be very helpful. Following my line of thought, this is the distribution I had in mind: 

From this you can see that the vector that is being transformed is actually and the difference from your code is that you're doing: 

Then on your code, I'd recommend creating a class to encapsulate the sampling calculations. This class should know how to load the cube map texture, and given a ray it should be able to know in which face and in what position to sample. In my implementation I found it easier to store each of the six faces in separate texture objects, and branch based on the direction of the ray: 

You were using methods such as and to do this incremental sort of writing. As far as I know you can't write to an this way, but coupled with a object (which you can reuse) it's easy to get a similar behavior: 

So no matter where you move the stick around, it will still match the following regular expression: Regular expressions also let you perform the conditional behavior you mentioned. For instance (made up recipe), if you wanted a pickaxe made of iron or stone to give the same result, i.e: 

There are no "tileset systems." The only generic solution games pick up is how tilesets work on a basic level. Here's how tilesets work: 

C# and Java are not "basically the same". A lot of basics are just similar, and it's not a coincidence: C# was influenced by Java and they were both influenced by C++. Whilst this means you'd already recognise a lot of stuff, it doesn't mean you suddenly know C#. 

My XNA game is component-oriented, and has various components for position, physics representation, rendering, etc, all of which extend a base class. The player and enemies also have controllers which are currently defined in C#. I'd like to turn them into Python scripts via IronPython (a .NET implementation of Python). My problem is that I'm not sure how to interact with those scripts. The examples in Embedding IronPython in a C# Application suggest I'd have to create something like a Script component which compiles a Python script and calls the controller's Update method via Python - essentially, it'd be a wrapper class for C# to interface with Python. I feel that I'm missing something in my research. There must be a way to load up a script, instantiate a Python object (either in the Python script or in C#) and then then have a direct reference to that Python object in my C# code. Is there a way to work with an IronPython object directly, or is a wrapper required?