Summary: A short summary of the issue I am seeing before I launch into the details: I am trying to use wlan0 on my RP3b for wireless comms in a RP3 mesh network (batman-adv). Using a fresh install of Raspbian – Jessie, I am able to change the wlan0 interface mode to ad-hoc and if the ESSID is its default of “off/any”, I am able to set the CELL ID (AP) to any ID I want. I use iwconfig to do this. However if I define ESSID to “my-mesh” for example, then the CELL ID gets changed automatically and I am unable to change it back to the ID I want it to be. What I am trying to do long term: The long term goal is to setup a mesh network using multiple RP3s using batman-adv. I want to also configure each RP3 to be an AP too. The intention is to solve the wifi dead spots in my house using my own mesh network. I want to be able to roam around the house and for the client (that is connected to the internet via the AP and mesh) to seamlessly hand over to the nearest AP when appropriate. After reading countless articles on this topic, I decided to try batman-adv and follow this guideline as it is well written as seems straight forward: how to configure batman-adv As ever, things are never straight forwards as my two RP3s cannot join the defined mesh network because I am unable to set the ad-hoc CELL IDs to the same value. What I am seeing at the minute: So after many attempts at solving this problem, I decided to go back to grass roots, forget the mesh for the moment and try and work out what the problem is on a single RP3. So using a fresh install of Raspbian – Jessie and following a reboot: pi@raspberrypi:~ $ ifconfig eth0 Link encap:Ethernet HWaddr b8:27:eb:d2:c5:83 inet addr:192.168.0.79 Bcast:192.168.0.255 Mask:255.255.255.0 inet6 addr: fe80::bcc5:f949:7b72:592c/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:9318 errors:0 dropped:0 overruns:0 frame:0 TX packets:5489 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:9953717 (9.4 MiB) TX bytes:883874 (863.1 KiB) lo (ignore) wlan0 Link encap:Ethernet HWaddr b8:27:eb:87:90:d6 inet6 addr: fe80::ee57:4cb4:85bd:f61a/64 Scope:Link UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) eth0 is connected to my home gateway (access to the internet), wlan0 is currently unconfigured. pi@raspberrypi:~ $ iwconfig lo no wireless extensions. wlan0 IEEE 802.11 ESSID:off/any Mode:Managed Access Point: Not-Associated Tx-Power=31 dBm Retry short limit:7 RTS thr:off Fragment thr:off Power Management:on eth0 no wireless extensions. Changing wlan0 mode and defining the Cell ID: pi@raspberrypi:~ $ sudo iwconfig wlan0 mode ad-hoc pi@raspberrypi:~ $ sudo iwconfig wlan0 ap 02:11:87:12:34:56 pi@raspberrypi:~ $ iwconfig lo no wireless extensions. wlan0 IEEE 802.11 ESSID:off/any Mode:Ad-Hoc Frequency:2.412 GHz Cell: 02:11:87:12:34:56 Tx-Power=31 dBm Retry short limit:7 RTS thr:off Fragment thr:off Power Management:on eth0 no wireless extensions. All good so far. However in order for a mesh network to be created, from what I understand the ESSID needs to be defined so that on all RP3s that form part of the mesh share a common: ESSID, CELL ID and password. Now when I try and set the ESSID, the CELL ID changes automatically: pi@raspberrypi:~ $ sudo iwconfig wlan0 essid "my-mesh" pi@raspberrypi:~ $ iwconfig lo no wireless extensions. wlan0 IEEE 802.11 ESSID:"my-mesh" Mode:Ad-Hoc Frequency:2.412 GHz Cell: FA:0A:C8:56:BD:4E Tx-Power=31 dBm Retry short limit:7 RTS thr:off Fragment thr:off Power Management:on eth0 no wireless extensions. and whatever I try and do, I am unable to change the CELL ID to what I want/need it to be for my mesh network: pi@raspberrypi:~ $ sudo iwconfig wlan0 ap 02:11:87:12:34:56 pi@raspberrypi:~ $ iwconfig lo no wireless extensions. wlan0 IEEE 802.11 ESSID:"my-mesh" Mode:Ad-Hoc Frequency:2.412 GHz Cell: FA:0A:C8:56:BD:4E Tx-Power=31 dBm Retry short limit:7 RTS thr:off Fragment thr:off Power Management:on eth0 no wireless extensions. I am hoping that I am making a silly mistake or have forgotten something obvious. Is anyone able to offer any guidance please? I am getting quite frustrated by this. Is there a daemon in the backgorund that is changing the CELL ID? My setup: Board = RP3b v1.2 (I have two of these) OS – Raspbian Jessie, 4.9.35-v7+ For initial configuration purposes, I am using eth0 connected to my gateway, and intend using the onboard wifi interface wlan0 for mesh comms (bat0) I will plug in an additional usb wifi dongle later to act as my AP, but I want to get the basics working first before I do so Thanks in advance for any help you can offer 

Command Breakdown: says to run the following command on startup. says to run the following command in the background and name the Hangoutbot. The rest of the command is the python command that will run your python code. 

Explanation: USB sound cards are registered as card 1 on Raspbian Jessie. On Wheezy they would be registered as card -2 by default and editing would change that. I do not know if this next step is necessary but without it my card wouldn't work. Create and edit the file by using the command and change it so that it only reads this: 

Scroll down to , and then the second option is . Type in what you want the new hostname to be, and it will change upon the next boot. 3. You can edit with and change this line: 

My RPi2 boots fine, but after some time, which can be anywhere between 15 minutes and 6 hours, it crashes, leaving both the ACT and PWR leds on. My wifi card's led is either off or stuck after the crash. Also, the crash only seems to occur while I am not using the Pi, it has never happened while I was using SSH. : 

and are no longer included in the Raspbian repositories since Jessie was released. was previously used in an RPi Foundation tutorial here to compile a timelapse video. I've seen that can be used to do the same thing, and it is included in Raspbian Jessie, but what command should I use for that? My folder of stills looks like this: 

Telling me that the camera is not enabled. I have seen that this error also occurs when no camera is connected. So, I connected the camera to my Pi 3 to see if it was broken, but it worked fine on there. Is there any reason I am seeing this error? What do I need to do to fix it? EDIT: I very monotonously checked every connection on the camera's cable with a multimeter and they all were fine. 

If surround sound directly from alsa is what you need, I suggest taking a look at this article: $URL$ The article also covers JACK. 

You would have to run this script using because it needs root privileges to mount disks. would work fine. Unfortunately there is no way to avoid an infinite loop here that I know of, but checking instead of might be easier because it does not require the disk to be mounted. No matter where the disk is automounted, the device will always show up in and assuming it is the first drive put into the Pi. 

If you had any form of audio sensors/microphones under the corners of the table, you might be able to pick up some parameters that were unambiguously a bounce (length of sound pulse, frequency components via FFT, but probably not amplitude as a smash will be very different to clipping the net and dropping gently). The reasons for attaching them to the table are: Keep them out of the way; enhance sensitivity to the bounce rather than ambient noise. For location you'd need to triangulate using timing data. The speed of sound in wood is ~10x that in air, so to get around 10cm accuracy you need 3µs timing precision. Given the number of sensors and the speed requirements you're not going to do that on a Pi alone . There are DSP ICs out there, some of which have development boards available but that could get expensive and difficult. Position sensing is best done by camera, but perhaps an audio trigger would let you know when a bounce occured, as this would be hard to pick up from a single camera looking down from aboce, as would be required to give a nice position indicator. 

You need to connect pin 14 of the ATX supply to ground (e.g. pin 3) for it to come on. You could do this with a simple transistor, but I'd use an opto-isolator as you're worried about coupling noise (also in case you misconnect the ATX end). See for example this answer. You can get them to run directly off 3.3V, or that need an external resistor. 

is probably your problem. I suspect you mean . If you're testing in the evening you'd never trigger the nightlight setting with your conditional. 

If we assume a stable system, not connected to any network, and fully backed up, what damage can cutting the power do? Obviously it's a hassle to restore an image of the card, but a fairly minor hassle. Could the card be bricked (buying a new card is a minor expense but a more significant hassle)? Could the Pi itself be damaged? I'm going to be building a Pi+touchscreen into a piece of equipment, which will have a swicth that can cut all power, and I don't trust my users (starting with myself). 

Maybe. Pin 1 of the header (on all models I believe, but do check yours) provides 3.3V. It doesn't give much current (it's rated to 50mA but more may be available in practice, according to people who have looked at the components. I have successfully run two different micro water pumps (RS M100, RS M400 off this line (via a gertboard) for several days on end (while using HDMI and USB keyboard/mouse). I'm probably pushing it too hard but I haven't noticed the regulator getting warm or any misbehaviour. NB: I'm using a Pi 2, which has a switching regulator circuit; some earlier models used a linear regulator chip which would get hot under load. The limit for the 3V3 supply is no longer as clear as it was, but is likely to be higher. (official forums) As regards back EMF -- if you have another pump in the circuit it's probably a bad idea with the M100 pump I've linked. The M400 is brushless with its own control electronics - so won't act as a dynamo in the same way. I would assume that when we prime the pump by pulling water through, we spin the motor; this has't caused any problem with either pump. For longer term use I intend to put a TO220 (through-hole) LD1117 voltage regulator on a piece of stripboard, run off the Pi's 5V supply (2A in my case) and run the pump off that. If you want to switch it, use something designed for the job such as the open collector relay drivers used on the Gertboard (ULN2803A). 

If you want to exit that screen without killing it, hit CTRL+A+D. (All three keys at the same time.) 

Based on the type of flashing of the green (ACT) LED, you can figure out what is wrong (or at least what ballpark it's in) by looking at this page. Too long didn't read version: Green LED: ACT LED ------ Red LED: PWR LED Simple Issues 

I am currently using both NTP and an RTC on multiple Raspberry Pis and I can say they both work great. 

I am using a TTL to USB cable with my Raspberry Pi and I would like to forward that UART signal over the internet, or just over my own network via a usb to wifi chip of some sort. How would I go about doing this? What port would it be over? How would I access it via Macbook? Yes, I am aware of ssh this is for debugging when my Pi does not boot far enough to turn on wifi. Originally posted on Hardware Recommendations 

If you have an old RCA cable you can strip the wire and solder the two wires directly onto the two pins like so: 

I want to power my Pi Zero from the header pins, pin 2 and pin 6 specifically. I know that my Pi Zero can consume up to 120mA, and my power supply can provide up to 500mA. I've heard that the 3.3v rail on the header can output up to 50mA, but I doubt this is related to how much the 5v rail can be supplied. So my question: 

Turn the Pi over and look for the square solder point. That is pin 1. Pin 1 is the pin closest to the PWR led. 

You can try resizing the partition manually. See the elinux docs for this. Basically, you write a new partition table manually with: 

There have been no comments (at least from what I've seen) on the sd card slot of the Pi other than that it is a friction slot (like the Pi Zero), instead of a spring lock. It's safe to assume that the bus is still limited to 20Mb/s. I wouldn't worry about getting a UHS-3 card. The Pi 3's features are listed here. You can see the spring lock here: (on the Pi 2) 

This is the more widely used solution, as with a USB sound card you can use a microphone. You can pick one up for less than $5 on eBay and Amazon. 

The Model 2 B would probably be your best option, since it's higher processing speed and more RAM would decrease the latency on the video stream and possible allow for higher framerates/quality. 

I'd approach this as a pure hardware problem -- log the current coming from the power supply. To do that you need an ammeter with either logging or output (USB/serial) capability. You could either run the logging code on the Pi itself or another unit (the ammeter itself, another Pi or a PC) for more accuracy as running extra code for logging will itself consume power. Most modern bench meters have some form of digital output, though many need drivers that aren't available for Linux/ARM. Voltage loggers are more common and you may be able to log the voltage drop across a shunt resistor on the power input. 

You'll presumably need a USB TV tuner that works under linux as a first step. I suggest that a good point to start your reading would be around MythTV (an open source digital video recorder), who say the Pi2 can do it: $URL$ I'm no MythTV expert, but I know it needs both a frontend and a backend to do what you want. The backend is often run on a more powerful PC, but here's a blog post saying it can run on a Pi: $URL$ Do note though, that this will be a bit of a project to get working. 

I'm designing a system that will power a 2B using an OKI-78SR-5/1.5. It's a switching regulator, pin-for-pin compatible with the classic 7805 linear regulator. I'll be using a 15V PSU (for a motor) and once connected it will stay connected. So after some fairly basic testing I'm just planning on being careful to connect it the right way round. This only does 1.5A, but do you really need more than that on the Pi PCB? If you've got further significant 5V power requirements I'd be very tempted to run them separately -- I've crashed a Pi a few times by connecting a not-very-big capacitor to the 5V line using the official 2A PSU, so inrush currents are something to be wary of. They happen fast enough that no reasonable fuse could blow/trip fast enough to prevent a dip in voltage for a big enough surge load so are hard to protect against. Even though I'm guilty of it, I don't recommend plugging anything in while powered up. I'm not sure what current the PCB traces and headers are rated for, but for large 5V loads you may reach the limit. So there are two reasons to separate the 5V supplies to the Pi and other hardware, even if it's not a situation where isolation is required. One decent 5V supply could even feed both the Pi and the accessories, but I'd run independent cables back to the power supply with capacitors at the power supply output and the Pi input.