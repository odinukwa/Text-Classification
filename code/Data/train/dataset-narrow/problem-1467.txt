Apart from that, the is the right tool for the job. It creates an atomic compare-and-set operation that makes it thread safe. 

Separated sums You have both and , but there's no need for both. You can have one sum accumulator and use it in each side. Simplifying the doubled digits The algorithm requires doubles that are larger than 9 to be reduced by 9. Your code is: 

Note that, by convention, using hungarian notation in go is not good code-style. You should not suffix pointer variables with . A pointer to an int containing the number of T-Shirts is still and not OK, so the above code changes the flag handling to be Var-based, and it reads easier, and removes all pointer references later. I would also add flags for the starting date, and number of days to simulate. Washing Day Your washingday function is a good idea, but you are doing string processing in places where the library has better options to offer. Note that has constantes for the days-of-week, and those constants are declared as a type, and that type has a function available: $URL$ - what this means is that you can avoid the string-conversions in the function. I personally would probably use the option too to print the days. Actually, I would remove the println from the function because it is making the function do too much - (computation and presentation). I would have your function as: 

should be: for(char c : strChars){ if(c == ' ') { numSpaces++; } } Comments Comment unusual loops - your second for-loop is an odd one, and it often helps the reader if you comment why a loop is non-sequential (or even if you just make sure they are aware of it). multiple indexes Have you considered having a separate index for each position in the array - the position of the source character, and the position of where to insert it? 

Using volatile is no longer a recommended way of handling memory access. A much better way would be to use an . It has increment and decrement methods to help. Additionally, you still have race condition in your method even though it is synchronized.... you could have a situation where the nThreads changes (up or down) during execution of the playSound method because the Runnable is running in a different method. To avoid the race condition, just pull the nThreads in to a local variable once and reference that. As for your performance problem, it is here: 

The 'input' in the last column has because otherwise it is too small. The input area unfortunately extends past the border though, so I have had to add a manual padding of 7 px to the right side of the td to make it work. This seems counter-intuitive the use of read-only input members allows the data to be shown, and scrolled-through, if needed, but is it the 'right way'? 

This is approximately how I would have written your function, given the above... I have compared it with yours using some input values to test with. 

Using multiple calls for each star is very inefficient. Print is a slow command, and it also makes what is a relatively simple process (printing a line of stars) become a more complicated loop. A more efficient way to output the triangle would be to use one per line. An even better way would be for one println for the whole puzzle, but that has a potential issue of the value is large. A real trick here would be to build up one String value for the longest line, and then just print substrings for the shorter ones. Note, using is a clever way to manipulate the substring, but combining it with a loop from to makes it even easier to understand. Additionally, putting the code in to its own method, instead of the main method, makes the code more reusable. 

Note how the above is changed to use a Writer instead of an OutputStream..... Using an OutputStream for text data is a broken model.... Readers and Writers for text, and Streams for binary. That's a good segway in to the non-gui code.... The Core engine The TextareaOutputStream made me realize that all of your methods are stream based, except for some parts that are buried in the ReviewPreparer. The PrintStream code should all be replaced with a StringBuilder..... you are limited to the size of a CR post anyway, and you are accumulating the data in to a TextArea... it's not like you will run out of memory. This is also an interesting segway to the CountingOutputStream. There is no need for that either.... you are not using it to count the file sizes, but the actual post length. This should be measured in characters, not bytes.... so, it's a broken class. Get rid of it. So, get rid of the PrintStream as well. PrintStream is a synchronized class, and is much, much slower than StringBuilder. Appending the data to StringBuilder also means you can get the character-length from the StringBuilder instead of the byte-length from the CountingOutputStream. One final observation....... inside the method you do: 

Junit Testing Testing a main method is not something I have seen before. Interesting. On the other hand, in this case, why? You should be testing the method and the method. You are not testing directly at all, but relying on main to do that test work for you. also, re-assigning the System.out is a really bad idea. If the test does fail, you don't complete the re-assign. Also, it is not thread-safe, and leaving System.out as null is not exactly friendly..... :( StringBuilder usage Others have suggested there is no reason for the null-check on the get-message. I agree, there is no reason/way for the getMessage() to return null... and, why are you calling it twice? You should just kill the null-check. getters Why do you have an instance getter that retrieves a static field? This is broken. The method is private, and it returns a static constant field. The method should not exist at all, and all references to should be replaced with 

Error Handling You should include error handling always in bash scripts. RSync issues, etc. rsync builds up a list of files to transfer, calculates the smallets dataset that needs to be migrated to accomplish the transfer, then it does the copy. If files change between when the calculation is done, and the transfer is done, it gives different errors/warnings. This is what is happening with you, I believe. Performance Depending on the rsync options, it can take a while to both build the copy-list, and do the copy. Even though it may be inconvenient, you probably cannot beat rsync for performance. Check each of your options to ensure they are the best. Kill those options that you don't need. 

So a fair amount of Java8 is new to me, including the Stream API, which is, in essence, why this review is useful to me too. Bear with me... Readability You say "my main concern is readability". Now that I have spent some time looking in to what you are doing, what you are using, and reading up on some documentation, the answer is: yes! The code does look strange, but that is only because the language structures are new. You are using them right, conforming to what few 'standards' there are... and it is fine. General RestrictedGenerator 

Titles like that are an poor choice for code review, and as a moderator, we actively change titles like that to reflect what the code does, and not what the question asker sees as being the problems in the code. Unfortunately, when I read your code, to try to see what it does, all I could think of was goofers... it took me a few moments to understand that the code was meant to be "go offers". camelCase to the rescue... 

Taking the changed/alternate specification in to consideration, you are allowed to 'skip' values to get the increasing sequences. The right algorithm for this problem is to use recursion. Now, because you are skipping things, there are a lot of potential combinations of 'winning' sequences.... as a result, you cannot safely store them all in memory. The right solution to that problem is to use an iterator. Here is your problem worked out with a relatively small memory footprint, and an iterator used to report the actual sequences..... There is room for optimization still in the recursion, and, it may be worth adopting the iterative approach of the iterator instead of the recursion.... your call. Having both examples will give you something to think about. 

Note, we use the set-based handling in python. Convert the alphabet to a set, and then get the difference between the password set, and the alphabet. With that, if there are any characters left, then the password is not a match (there are characters in the password that are not in the alphabet). Additionally, I found that your readFile method does not do decent end-of-line handling, so I had to create a file without a line-terminator to make the code work... is this intended? 

Searching for all the labels is a waste of time/resources. You only ever need a label if the validation fails on an entry, and only then should you locate the matching label for the failed validation. That way, when all the fields validate, then no labels need to be searched at all. Additionally, I would (personal preference) prefer to have a strict name-based set of values that need validation. Searching for those fields that match a pattern in the is something that may lead to issues further down the road. Still, if you want to use patterns for finding the entry fields, at least limit the search to values which are entry fields.... you have no validation that checks to ensure that there's not some other node that has an 'id' starting with 'product-'. Also, you assume that the labels for the entry fields are in the same order as the fields. This is dangerous. When it comes down to it, if it were me reviewing the code, I would think: Sure, it does the standard stuff OK, but it does not have any robustness. 

With that, there's no arrays, and the extension is the last part (or the whole filename if there are no '.' values in the file.... you need to check for that case too. There's also the possibility that a file may end with a '.', leaving an empty-value extension.... you need to check that too. inotify Currently you have a number of problems with inotify: 

Note, taking the pointer at the initialization of the and brings those in to pointer-space as well. You are missing a bunch of documentation on the exported methods, types and constants ;-) All told, I would expect your program to look like: 

Then, when the person enters a month, you can subtract 1, and index it back in to the above array, and get rid of all the if's: 

Note that newline is part of the pattern, so the pattern will match whitespace padded breaks containing at least two newlines. Also, a pattern for replacing all whitespace with a single space, is: 

This way we can store each result, instead of just counting it. There are a few things to go through here. Product This class looks awkward: 

The above things should all be resolved..... Alternative Create a class that generates the names for you. Consider this class: 

In your Java 8 version, you are significantly overcomplicating it. Let's take a look at the basic question... maximum beauty is accomplished when the most common character has the largest score, the next most common has the next highest score, and so on, descending. Technically, there is no reason to know which character is the most common, just how many times it appears.... This is a trick. This can easily be accomplished by using a simple array of integers, we will call . In to this array, we record how many times each letter appears. Then, we sort the array to find out which letter is most common, and so on. There's a neat trick, that if we sort the counts in an ascending order, then the most common character count will be the last member of the array, which is index 25.... and the next most common count will be at index 24.... So, we can multiply the count, by the , to get the score for that character. In Java8, this can easily be accomplished using some regex to throw out meaningless characters, and then some simple math and a sort to do the rest. 

Note that I ended up with and because is a reserved word. Hmmm... I think I will re-recommend implementing the interface, and rename to be , and to be .... Then, an abstract implementation that does everything except handle what to do in the event that the pool is depleted. 

Let's work through some of the simpler issues, like code redundancy, and some helper-functions in the core library that help a lot, and will make your code simpler. Double-checking else When you have an either-or check in an if-condition, there's no need to double-check the side of things. you check for odd-positioned digits, which implies every other digit is even-positioned... This code: 

Why is that text introduction necessary? Well, for a start, your code does not tell us what is. It could be a time-since-epoch, it could be seconds-since-start-of-day, it could be anything. I had to struggle through WTF moments to understand why was necessary. How was I supposed to know that was already a Number, and not a String, or some other object, like a Date. I had to understand that the ParseInt was important not because the input was a String, but because it was a floating-point number and you wanted just the integral part. OK, so, having done the hard work of understanding how your function works, and what the inputs and outputs are, this is how I would write it.... ... but first, the bugs in your code. 

Sometimes (actually, normally), simpler is better. I'm going to present a different way of doing this that's really simple, if you understand the tricks, then I'm going to explain what makes it better. One of the reasons I am doing it this way is because your code is hard to follow.... simply because there's so much. I suspect that when you see a different way of doing things a penny will "drop". Here's the alternative: 

Then, with the TimedEvents set up, you can schedule them in a loop, counting down to the target time..... 

This also changes the logic slightly because empty lines will return empty-string, instead of null. Additionally, your code will match from whereas my code will consider the leading space to be a separator (and not part of the first word), and will match the empty string from In other words, I disagree with some of the handling you have with edge cases. I would handle the edge cases in a different way in the stream too: