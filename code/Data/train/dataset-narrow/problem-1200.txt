Or could be called on an array after converting the nodeList to an array via Array.from() (but beware of Browser compatibilty on that) 

Scope of Variables Unless is used outside of the code in your post (which would be grounds for making it off-topic), then you should declare it as local to the function using (or if you want it to have block scope. The same is true for and . That way those variables won't be global, which could cause confusion if you did use to declare a variable inside a function but not before that. For more information on that topic, see the section Keep your scopes close and your scope even closer on this page. Accessing DOM elements multiple times via DOM lookups are slow. It is wise to cache them once in a variable and then refer to the variable when needed. This is also mentioned in the aforementioned article under the section Cache DOM Lookups Those lookups could be added above the function (possibly assigned in a DOM ready function like jQuery's , though it is argued that isn't necessary with modern browsers): 

Presuming there should be curly braces around the update lines as well, that code can be abstracted to another method as well: 

Notice that the shift IDs are no longer present inside the sub-array. After seeing the next section, it should be clear that those arenâ€™t needed anymore. That way, the check to see if the shift IDs exist in the array of overlapping shifts becomes simpler by utilizing array_key_exists(): 

Avoid the looping Even simpler would be to push all items with the spread operator, since Array.push() can accept a variable number of elements: 

While your code specifically handles single digit numbers, it is a good habit to always pass that radix. As recommended by MDN, pass the radix - presumably for base-10 numbers. 

Bearing in mind I am not an expert VueJS user and have only been working with it on small projects in the past year, I can't really think of anything... If you really wanted you could consider using slots somehow, or an Event bus if the components became more separated but that might not be nessary since everything is contained in the main RoyalGameOfUR component. If I think of anything else, I will surely update this answer. 

But if that last block is all that jQuery is being used for, you might consider replacing it with vanilla Javascript. For more information about evaluating jQuery's value, see You might not need jQuery. This jQuery code: 

See a demonstration of the matching here in this playground example. Useless variable In your method there is a variable that gets incremented each time. If you needed the count of each line, the variable (from the statement) could be used instead (and added 1 to)... 

Then that value will be available for injection in the controller (this example uses the implicit format: 

Move table row generation code into function One can create a function to return the HTML for each table row and use functional programming techniques like array_map() to get an array of table rows and use implode() to join them together. Note also here we are using Heredoc syntax, as mdfst13 recommends, so double- and single-quotes can be used in-line without the need for escaping. And there may need to be some re-working to reference correctly - if you are working with a class definition, that could be moved to a instance/member variable and then have the function be a method in the class that can access that variable. 

Additionally, instead of checking gift partners with and comparing the length, you could possibly use Array.every() 

See how well that works with the statement from your code in this playground example. In the browser console, there should be an error: 

Mixing markup with display logic This is just a minor point and likely not something to worry about but some might argue that having the markup control logic (e.g. on the Next Step buttons) might be considered tight coupling, but perhaps that is just the idiomatic way for those modals to be laid out. 

Excessive CSS rules for headers There is a CSS style for all headers (i.e. ) but I don't see any , or tags. Unless you plan to add those tags, the selector could be simplified. Optionally, a class name could be added to those header tags (e.g. ) but then the HTML would have to be altered just to simplify a selector. Another option is using SASS or LESS (refer to this answer). 

My solution was to "create an array with the start time being the key and the value being an array with the end time and the start time, though if we find that the start time exists in the array as the end time for another element, we update that existing element." 

I would define a mapping (similar to the second option in Valentin's answer) that is similar to a 2-dimensional associative array. This can be achieved in Javascript using objects. 

So in the argument will refer to the current instance. Replace with and then any place was previously used to access the div element, refer to . Also, call and on `this, since we will be converting those to methods as well (see below). 

Then you don't need to add an additional function for the triangle. See a demonstration below. Note that I updated the method to utilize instead of a hard-coded value (like Matt Fletcher mentioned in a comment on your SO question, and also did in the jsbin example he made and linked in another comment). 

Additionally, given the last example of Equivalent constructs, the while loop could be rewritten as a for loop as well: 

Or if you want to use a double-quoted string literal for the query then the variable could be parsed without needing to end and restart the string literal: 

Sanitizing data I must admit actually haven't dealt with sanitizing data much via JavaScript but I have found various techniques: 

Though some question whether libraries like lodash and underscore are really needed anymore. For a discussion on that, check out this article. 

Yes- as others have pointed out in comments, it seems to be somewhat poorly written. Not only is it difficult to read (as evidenced by your question here), but it isn't as efficient as it could be- each variable (e.g. , ) is an array -and each sequential array grows in size! This is quite wasteful - see this playground example for an illustration. If there are 26 fields per row, that means 376 elements* across 26 arrays. Storing each value as a string (or cast numbers to integer/float values) would dramatically decrease the amount of memory used. While the memory would likely be reclaimed between iterations, it would still make quite a difference. 

The performance difference will likely be negligible... This SO answer has a link to this relevant jsPerf test. One might be able to also simplify the function by converting it to an arrow function (like was used on the callback to ). 

That way it doesn't need to be re-assigned (and cleared after evaluating the neighbors) in every iteration (and the initial line can be removed from the start of ). 

Notice how the buttons don't need to worry about which function gets called - just that it contains the name (either prev or *next) as well as a class name. Using that HTML, we could add an event delegate to listen for clicks on the element that contains the page links and look for the class name "pageLink". This is especially helpful when there are numerous elements on the page that all need to have a function bound to an event. This may not be the best place for it, but my initial attempt is to add the delegate (i.e. a click handler, using EventTarget.addEventListener() for the click event) in the componentDidMount method on the linksContainer element... 

Other suggestion I would advise you to use an event delegate - instead of adding a click handler to each square, add a single click handler for the board and check the target of the event. This can simplify the event registration on elements greatly. 

Since it already uses regular expressions (e.g. ), a capturing group could be added with the two cases for tag names: (i.e. or ): combined with an OR operator (i.e. ), and refer to that value using a back-reference (i.e. for the first captured group) when adding the nonce attribute (in the replacement string parameter). See a demonstration of this in the snippet below (should be portable to NodeJS). 

Again I don't know of any principles this violates, but I would recommend using EventTarget.addEventListener() for the beforeunload event - that would allow for multiple functions to be executed during that event if such a requirement arose. 

Cache DOM lookups Even with abstracting that code into a function, it would still be performing a query on the DOM. 

That code calls and extra time (well, actually once extra for each string after separating the original string on commas), so that call can be removed inside the mapping. is an array (and implicitly converted to a string joined by commas via Array.toString()). Perhaps you intended to call on the array returned from : 

And that function can be bound to the functions for the button handlers using the Javascript function .bind() to create a partially applied function for the parameter: 

Because those are never re-assigned, it is wise to default to using the keyword until a good reason for re-assingment arises. 

BenC has provided some great pointers. I will attempt to expand one implicit change and mention a couple other possible changes. DOM-ready function change To be explicit about one thing changed in BenC's answer, was changed to because the documentation for states: 

For the most part I would say Yes. However I do notice that the convert functions create a local variable (e.g. ) and then if the input value isn't valid, an empty string is returned. One could argue that the valid input check should come before declaring the local variable, lest memory be wasted (though in a small SPA like this it will likely be negligible).