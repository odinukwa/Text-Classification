making the variable obsolete. And if you don't need to print the error locally then no do/catch is needed at all: 

prints a message before stopping execution of the program, which can be helpful to locate the programming error. Otherwise you could shorten the "forced" version to 

Note also that the variable is not needed. But this computes the absolute values in each recursion step. Euclid's algorithm works with signed numbers as well, you can take the absolute value once, as the final step: 

which returns only "Red" without this fix. Apart from that, your code looks correct, but there are some possible improvements. 

line is extremely long and should be split into several lines. The correct way to check for success or failure of Cocoa (Touch) methods is documented in "Handling Error Objects Returned From Methods" in the "Error Handling Programming Guide": 

Your program should check if the input number \$ n \$ is zero, otherwise it will run into an infinite loop in that case. 

As another small optization, only 2 and all odd numbers are used as trial divisors. Performance comparison: 

The next step is to make the function generic. There is nothing which is special to colors or strings, so you can simply replace by a generic type : 

The correct result would be 3037000490, since $$ \sqrt{9223371982334239233} \approx 3037000490.9999996957524364127605120353 $$ (computed with PARI/GP). The following implementation uses the ideas from DarthGizka's answer to the above mentioned question to implement a "correct" integer square root function in Swift 4: 

Here you access the underlying instance variable directly and not via its accessor method. It should be 

On my computer this reduced the time to compute the results for \$ b = 1270, \ldots, 1286 \$ from 130 to 101 seconds. 

First note that your is computed property, not a stored property. It is computed using the and methods. Extensions cannot add stored properties to a type. Your current implementation crashes if the connection state is retrieved without having been set before: 

This makes no sense here because you don't want to access any properties of the returned objects. On the contrary, only the managed object ID is needed to delete objects and no properties need to be fetched at all, so this should be replaced by 

seems a bit too verbose to me. It is clear from the class name that the object is some "exhibit", so I would shorten that too 

The Swift standard library does not have a built-in method to access the n'th character of a string. It is tempting to fill that gap with a custom extension like you did, but the problem is that 

For further performance improvement, note that the strings consist of lowercase letters only, i.e. there are only 26 possible characters. Therefore you can use a fixed-size array instead to count the number of occurrences of each letter in the strings. Array subscripting is much faster than dictionary lookups. In order to compute a number (from 0 to 25) from each lowercase letter, it is more convenient to enumerate the of the string. This leads to the following implementation: 

without the need to check for an empty dictionary value. Some more suggestions: Reading a list of integers occurs at two places in the program, that justifies a separate function: 

since all primes less than have already been found. This reduced the execution time of my test (code below) from 2.26 sec to 1.17 sec. A possible further improvement is to treat the only even prime separately and then handle only odd numbers: 

The key point is that your method uses three nested loops, which is not necessary because only two of the variables a, b, c can be chosen freely and the last is determined by \$ a+b+c = \text{sum} \$. From the condition a < b < c one can also restrict the possible ranges. If we start with a in the outermost loop then $$ \text{sum} = a + b + c \ge a + (a + 1) + (a + 2) = 3 \, a + 3 \implies a \le (\text{sum} - 3)/3 $$ and for b we have $$ \text{sum} = a + b + c \ge a + b + (b + 1) = a + 2 \, b + 1 \implies b \le (\text{sum} - 1 - a)/2 \quad . $$ So your function would be 

Both can more easily determined if all scores are stored in an array. Since you are working with Objective-C, I would suggest to take advantage of the classes and methods that the Foundation framework provides. First create an of all player scores. Objective-C collections can only contain objects, therefore the integers have to be boxed into with : 

Now let's try to make the date comparison simpler and more efficient. Your code requires 4 calls to a format parsing method in each iteration. Generally, if you are interested in the numerical values of the date components (such as year and month number) then using 

Your code computes the sum of two "large numbers" in an integer array and then converts that array back to a string. In the next step the string is converted to an integer array again for the next addition. It would be more effective to use only integer arrays for all intermediate results, and convert only the final sum back to a string. Then would look like this: 

That might also increase the performance because the runtime can allocate the target array with the required size, instead of re-sizing it repeatedly. There are two methods with identical parameters: 

In addition, you can save memory by overwriting the elements in the given array directly. If a different element is found then it is copied directly to its new position. At the end of the loop, surplus elements are removed: 

If \$ n \$ is even then \$ n/2 \$ and \$ n+1 \$ are relative prime, and if \$ n \$ is odd then \$ n \$ and \$ (n+1)/2 \$ are relative prime. This leads to the following implementation 

is misleading: Variables cannot be uninitialized in Swift. This is ensured by the compiler and one of the major design goals in Swift. Finally your method: Using as return type seems quite strange to me, would be appropriate. And I would use a computed property instead, similar to the property of Swift's sequence types. Modifying inside the method temporarily is a bad idea and I can see no reason to do so. Use a local variable instead which traverses through the linked list, and again use optional binding to check if you have hit the end of the list: 

Only one loop instead of two nested loops now! Further improvement is possible with the help of mathematics. As stated in Sum of two squares theorem, 

For even better performance, the "brute-force" approach must be replaced by a more sophisticated algorithm. For these kinds of problems, the On-Line Encyclopedia of Integer Sequences® can be a valuable resource. If you enter the first rare numbers 0, 1, 2, 4, 5, 8, 9, 10, 16, 17, 18, 20 into the search field then you'll find A003714 Fibbinary numbers, where a different definition in terms of the Fibonacci numbers is given. There is only a difference by one in the index: Your code computes 

Your program calls the method of the with a two byte array. These two bytes are stored in the stream's buffer, and the buffer is written to standard output when it is full. On macOS 10.13 the tool shows that the buffer size is 8 kB, and on my MacBook the 

Together with Daniel's suggestion to make the property non-optional, the class definition would then look like this: 

As you can see, there is a summation, but it is limited by , not by , which is a huge difference for large numbers! Now translate that to Java – I don't want to spoil the fun of finding the final solution yourself! It should not be too difficult if you know that in PARI/GP, is the "normal division", e.g. , and is the integer division with truncation, e.g. . On my MacBook the resulting Java program computed the output for in 0.157 sec. 

The task is about dynamic arrays, and using an array (instead of a dictionary, as you did) simplifies things considerably. If you start with an array of empty arrays: 

and I prefer to . But you don't need the variable at all, as this condition can be put directly into the expression. So now we have 

(The only exception are and methods where the instance variable is accessed directly because the object is not fully initialized.) 

Now for possible simplifications. Both cell classes have some properties in common, these can be defined in a common superclass: 

The reason for the final is that it is required that the statements are exhaustive. Even if we know that the function throws only s, the compiler doesn't know that. (There are exceptions but that is a different topic .) Now to your question how an error should be handled in general, and I would say: it depends. There are tree different scenarios: 

As it was already pointed out, computing the slope of the line segments (as a ) is problematic because the slope can be "infinite" for vertical segments, and because of rounding errors. My suggestion is to use a different algorithm which does not compute the slope. If the coordinates are integers then all intermediate values are integers as well and no rounding errors can occur. (I would choose the same algorithm for floating point coordinates because it does not need any special cases for vertical or nearly vertical segments.) The idea is to describe the line segment from \$(a_x, a_y) \$ to \$ (b_x, b_y) \$ in its parametric form $$ (x, y) = (a_x, a_y) + u (b_x - a_x, b_y - a_y) \, \quad \text{where } 0 \le u \le 1 \,. $$ Then the intersection of two line segments is a solution of the linear equation system $$ (b_x - a_x) u - (d_x - c_x) v = c_x - a_x \\ (b_y - a_y) u - (d_y - c_y) v = c_y - a_y $$ with \$ 0 \le u \le 1 \$ and \$ 0 \le v \le 1 \$. In the general case, the solution is given by $$ u = \frac {\Delta_u} \Delta \, , \quad v = \frac {\Delta_v} \Delta $$ with the determinants $$ \Delta = \begin{vmatrix} b_x - a_x & d_x - c_x \\ b_y - a_y & d_y - c_y \end{vmatrix} \, , \quad \Delta_u = \begin{vmatrix} c_x - a_x & d_x - c_x \\ c_y - a_y & d_y - c_y \end{vmatrix} \, , \quad \Delta_v = \begin{vmatrix} c_x - a_x & b_x - a_x \\ c_y - a_y & b_y - a_y \end{vmatrix} $$ If \$ \Delta = 0\$ then the line segments are parallel. Otherwise there is a unique solution \$u, v \$ to the linear equation system, and it easy to check if the solutions fall in the range \$ [0, 1] \$ without actually performing the division. This leads to the following simple function: 

A better algorithm Your function solves the "Subset sum problem" with “brute force,” i.e. by (recursively) trying all possible combinations. This problem can be efficiently solved with "dynamic programming", as described in the Wikipedia article. But this problem can be solved even simpler: 

But actually this loop is not needed at all: In the j-loop, remember the index where the lowest element has been found, and then set to a "large" number directly: 

The and of are optionals, so there is no need to conditionally unwrap the given parameters. You can assign them directly: 

because that contains the main logic, then mention some other points, and finally present an alternative solution. 

All your logging function take a as the first argument, with a default value of the current date. Unless there is a special reason why a caller should pass a custom date, you can remove that argument and compute the date inside the logging function: 

Generally your Swift code looks very good to me, and I could not detect something totally "unswifty". There are some things which can improved or simplified. vs You have defined as which is OK if you intend to pass references to a "Piece Table instances" around. In that case you can define instances as a constant (): 

First the class: You have defined as a variable and optional, but actually node elements are cannot be and are never mutated once a node has been been pushed on the stack. You probably did that because you create "empty" nodes first and then call the method to set the element and next pointer. Another reason is that you use nodes "without an element", but I'll come back to that later. I would suggest to make a constant and non-optional and replace the method by an method: 

You also have to decide what to do if reading the JSON data fails. Just logging the error is not sufficient because then the program will crash later. 

The first element in the union need not be an array, and casting to is not necessary (the array automatically becomes a pointer to the first element when passed as a function argument). But the easiest method to extract a 64-bit integer from the digest would be to use the inline function 

On my computer, these changes reduced the time from 0.032 to 0.017 seconds. Now profiling showed that much of the time is spent in the function. The following version is significantly faster: