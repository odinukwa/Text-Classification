Now for my LogOn and my Register they are a little more to the point and easier to understand with just a cursory glace. 

since @kraskevich already mentioned making new classes I will take it one small step forward and mention something I think all beginners should know and that is creating and using unit tests. There are a few different test libraries but they test in about the same way. For beginners it is that you would do a simple 3 step process of arrange-act-assert. I'll give examples pertaining to your game in pseudo code to express my point. Arrange This is the simple act of making your class ready for a test. I'll use kraskevich's points here. He mentions making an argument parser. so lets assume you created a and a . You would arrange your test something like this 

That test runs very fast. Total time on my pc to compile and run those tests as many times I want is under 3 seconds. Understanding the green or red marks takes next to nothing to understand. Closeness to algorithm So you noticed already that there was a bug in your code. I noticed (after having re-read the wiki) page that you implement the algorithm AS WELL AS an alternative. 

and that is all the new things that I can see at this moment. You and everyone else covered the parts I wanted to talk about. 

then to implement you'd make a new class per type that you want to show a specific way. Here is an example with both. 

Each line in my assert process is where I had to run the test, watch it fail, edit the NumberFormatter, and run the test to watch it pass. Final out come is this (test first) 

I'll start with the basics and work my way up. first... If you are using an editor or IDE(IntelliJ, Netbeans, Eclipse) that has the ability to re-format your code, use the format code feature. This keeps things consistent, and a little bit easier to read. Your code wasn't too bad in this regard, but IntelliJ complained about a few things. Unused methods/variables. Some IDE's can tell you if you are no using a method or a variable. Listen to it. This is especially important for fields. 6 fields are unused: x, parabComplete, frame, x1, x2, and countEquals_quadratic. 2 methods are unused: quadraticFormula, and var. You have 2 unused variables 'spaceFix' on line 312, and c on line 483. (I used the IDE to give me those, so the line numbers might be slightly different on your machine) Don't compare booleans. 11 times I see where you use == true, or == false. With proper names and some forethought you should be able to make the if statement read a bit more in English. for instance by just renaming parabola to isParabola your mind automatically thinks in terms of booleans. A quick note about your JButton array button, and your string array buttonString. I would probably restructure the majority of the code, but a quick and easy way to fix what you have it read a bit better would be to possibly to make a hashmap of so you could say if that still isn't super nice, but atleast I don't have to count the index of buttonString over and over again. There are some other nitpicking things I could do that the IDE picked up on, and some are legitimate. but more to your question at hand. How do you make things more OO. Kinda of a loaded question, but in general having a single class for an entire program screams non-oo principles. There are TONS of books, and papers, and blogs about the subject. Reading up on some of them would help tons so I'll only touch on a few things and bother me the most. SRP (Single Responsibility Principle) each object should do only 1 thing. It should do it well, and should be tested to show that it can do it well. A byproduct of a object that does one thing well is that it is easy to test. a very simple example would be taking the method getSqrt and making a class that does just that! 

L - Liskov substitution principle Possible that I don't understand this one as well as I should, but you have 1 cited class and 1 mentioned class that implement . Naming aside, just by guessing what and does they are not able to be substituted one for the other. Now if you had an interface and and make each child class of those be able to work with any different type of provider then you'd have it. D - Dependency Inversion principle Entities must depend on abstractions not on concretions. It states that the high level module must not depend on the low level module, but they should depend on abstractions. You have code that relies on , , and all things Microsoft Sql Server. What if you wanted to switch to , or , or .. etc etc. You wouldn't be able to because you are not relying on the abstraction. (hint, look at the System.Data.Common namespace..specifically ) 

If it wasn't so late I'd go back and clean it up some. But i want to point out that i can continue to add tests now that Loader class is mostly complete and the similar code in the Player file could be replaced with it. And to test if i broke anything I can just re-run my tests (which all 3 tests run in under 1 second on my computer) 

and when I run that test my test passes just fine. You might wonder how that is possible, and the reason is because of being passed in by reference and not by value. So anychanges I make to that specific instance of Box in any class will be "updated" wherever that instance is used. Hence how that test passes. How to use this? Lets extract one of your listeners into its own file. 

(sorry to you java people if doesn't stick with convention. I've been in the .NET world for too long... I would have returned new string[0] if it let me) This class is simple, direct, easy to digest and understand. When I go to start the game I know that all 13 and up year olds will be playing my game only. And if someone told me "I put 13 as my age and it said I couldn't play", or "I put 9 as my age and it let me play" I would know very quickly if that was a lie on their part, or if I introduced a bug... just run my test. If you want to put their claim to the test, just add it to the test or create a new test 

For this scenario I think I would prefer to return void, and have a public getter for marks. The reason I would prefer that is it would appear (based on the commented out code, and the graph that you show) that you want to do different things based on this specific data. On the classes that you want to use this data you would pass in an instance of . This tells people who are going to use the data that it was made specifically for this the data that was computed for . Now this isn't always the case and you'll want to weight the pro's and con's before you commit to one style or another. I caught in the code that you have "debug" code in. I have two things to say about this: 1) Create a class that shows said data. 2) other programmers might not like using the console to inspect data nor do they want to see the clutter of commented out debug code. Using an automated test framework can fix this. Java has a few different testing frameworks, but I'm not going to promote any particular one since they are similar in syntax and in reality they accomplish the same thing. These tests are a way to address both points. The first point is covered because it is a class that, typically, has "test" in its name. Other programmers will want to look for tests to know how to use the class and see what type and format the data needs to be in. With the tests isolated from production code you don't clutter up the production code with "debug" code. With that in mind here is a test I started to make and came across a potential refactoring point/bug fix 

Now for what I consider to be the cool part. Unit testing. if each can be instantiated and run independant then you could easily go to any point in the game (without having to run through it) and test that your game logic is working properly. Lets just take your age verification part in and try it. 

Well without any context I am going to go out on a limb and take a stab at this anyway. First is if you are using a database, and have the ability to check for toy ID's instead of the toy names you won't have as many checks. it would require a little more work to pass in the string, but it would be very hard to change in the future if you get new toy names. IDs are a way of future proofing. One trick of refactoring is to look at code that does the same thing and pulling it out into its own method. This is how I see your code working out. 

In my commented I suggested a class that could do what you want it to do out of the box. However sometimes having a custom piece of code to show things in a better way is the goal. I can see this going in two different ways. One is to use a variation of the Visitor pattern and a list, and the other is to use a dictionary with and the key, and the class that represents how to view it as the value. The first way you could make the interface one of two ways. 

A tip I learned from C# winforms programs is to have the entry point do as little as possible to get the program up and running. I believe it should be a core fundamental to all high level concept classes. is no exception, in fact it is at the highest level of your program and therefor should do nothing more than do the smallest things to get your program started. An example of what I have in mind would be more like this. 

you put all sorts of work in the . One bit of work you do is check if a file is present and sets some text. One of the driving forces for using MVVM pattern is claimed testability. Well using codebehind has potential to still have well tested code. (just most frequently you'll see examples that show no testing, or testing ability). So what if you had a class that return a boolean value, and a success method? That is testable. Consider this class 

(Note that I did this in Notepad++ so syntax might not be 100% as it is for example only) Now with your stats. Take a step back and consider what it means to put in a getter and setter in a player for his stats. If Conan levels up and has an increase in stats you're giving yourself multiple ways of increasing his stats. You could new up a set of stats and set that. You could increase the stats manually on each property. The problem with multiple ways of doing something is that it allows for subtle bugs that can't be covered in tests. Lets say for instance you want to have fireworks go off when Conan goes up a level. You would put in a listener for when the level changes, but what if you new up all that? The level would technically not have changed and therefor the fireworks never go off. Now Conan destroys your monitor because you didn't give him due reverence. Consider the next 3 methods. The first two are how a person could increase Conan's level, and the third is a potential way that you could implement. Which one gives the least amount of reasons to change? 

I'm not much of a web programmer, but I am comfortable with C#. So all of what I have to say is going to be based on styling. As I had posted earlier in a comment to you was to clear out any unused white spaces. It gives the impression that you don't care if there are too many extra white spaces. The next thing that I want to talk about is your flow of thought. Although you are consistent with how you do it, it is not the most logical. This is your code 

I create a new instance of a box, and pass it in immediatly to BoxChanger. BoxChanger is this very simple classes: 

when I change degrees to private the compiler will now show me a few places where degrees is used. One in particular that stands out is in 

In my comment I mentioned that this frame looks like a demo of what you are trying to achieve. After diving into the code though I feel compelled to mention a few things that will make what you are trying to do hopefully easier. First thing is to use methods to help make clear what you are trying to do from a higher level. Here is a small idea that I've been playing with 

There are other ways as well but that should encapsulate your work some and make it easier to find where a mistake is. Because of the nature of your work on this it won't be super easy to test that everything is visually pleasing, but the code should be encapsulated enough to make it easy to adjust what you need adjusted. 

Quick note about what I did. I created a new project with the same name as the project I'm testing and added a to it. I then used NuGet to get NUnit. You don't have to follow those exact steps if you prefer a different test framework. If you've never heard of a test framework I highly suggest looking into it as it lets you test your code in isolation and (if done correctly) is fast. Those 3 tests take a grand total of 12 milliseconds to run. This tells us two things. One is that your method (what does PLO stand for even???) which is the same as my . Is not the source of your slowness. Even if I were to go crazy with generating a bunch more test data for that to work with I really don't think the problem is there.And this is what the code looks like now. 

After reading some of the comments and looking at a few things I think the underlying question is still unanswered. I'll break this answer up into 2 sections. One unit testing, and two smaller code. Unit testing is TONS easier to do with switching to MVVM. The view model already needs to be public, as well as all the properties. As you progress in your learning of how MVVM works you'll start to see that there is ALMOST nothing that you can't test. For instance you can fire your s in a unit test and assert that the state is all correct. Since I can't see much of your control I will go off of what I can see. Lets say that you have some validation in place that won't let you export until you have the export file name and export location set. You could test manually.. or you can write your test something like this