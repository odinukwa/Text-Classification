I agree with Sean Middleditch, that your approach should be changed for many reasons. Here's a couple of ideas you should consider: 

If I'm not mistaken, the player's position in your implementation is represented by 4 numbers: GridX, GridY, TileX and TileY. That's a way to do it, and it's completely fine, as long as you don't screw something up with the indexes (which will give you ArrayIndexOutOfBoundsException). 1 . First, whatever happens (the player moves, etc.) just make sure that: 0 <= GridX < Grid.Length 0 <= GridY < Grid[GridX].Length 0 <= TileX < Grid[GridX][GridY].Tiles.Length 0 <= TileY < Grid[GridX][GridY].Tiles[TileX].Length 2 . Only load a Grid, if any of its Tiles are about to become visible. 

Black means a wall, white means empty space. A,B,C and D are the elements of your array, e.g. [i,j], [i+1,j], [i,j+1] and [i+1,j+1]. The red dot shows where a polygon point must be created. So go through the whole array, collect the points in a list (there will be many duplicate points, just don't add them or remove them later). Pay extra attention to the area near the boundaries of the array! 

Read an online tutorial on the basics of collision detection. There are dozens of good articles, just do a search. Start with rectangle and circle collisions in 2D. Try to implement the stuff you've read in these tutorials. Once it's up and running, start playing with it, to see how it "feels", what are the caveats etc. Once you see what should be improved in the collision detection you implemented, you can do the necessary research. Some examples keywords might be polygon collision, pixel-perfect collision, Verlet collision etc. Then if you still think you need to know more about collision detection, to make your simulation (almost) perfect, then you should look for some books to read. 

An interface can have properties. I would use an abstract base class for the skills instead of an interface. This way you don't have to implement most of the basic functionalities multiple times. 

Each and every Tower and Creature instance has a property . If a buff tower affects a creature / other tower, it adds (or updates) an item in the list. In each update, you calculate which buff towers affect which creatures / towers. This way, you fill the list of every such entity. Then you use the list to calculate the accumulated bonuses, which will affect the actual mechanics of the entity. You might not need to do this in every update: For towers affected by buff towers, you only calculate this when a tower is placed / destroyed / upgraded. 

What Jamornh suggests is a good solution, but might be problematic if you already have most of the content finished. What I do in my game engine, is that I have a property in my class. This stores the location of the sprites rotation center, relative to the upper left corner of the sprite. A similar property could store the coordinates of the center of your character's head, or center-of-gravity. When switching between the character's sprites (during an animation, for example), you can translate the sprite by taking this point into consideration. 

The method will (in the default template) have the line in it. That will call the methods of all your s. If you have content that must be loaded before some other tries to access it, then you can simply load it in the method, before calling However, I'm still unsure why you need to access the loaded content from other components before the - cycle starts. 

The simple answer is: you'll have to learn both concepts and tools. First, you should learn the very basics of game mechanics and game design. Then you'll be able to decide, which direction would you like to go next. Keep in mind, that tools won't do any good without knowledge of the concept. To use your example: if a graphic designer doesn't realize, that the sprites he has to make are going to be rotated randomly in the game, then he might screw up the shading. If he doesn't know that the sprites need to have transparency, he might end up creating them with colored backrounds, or just simply save them in BMP or JPEG. So the question is really: how much time should I spend learning concepts and tools, versus creating something marketable. And there's no good answer for that. It depends on your goals and a million other circumstances. If you want to produce new apps every 3 months, then learn about Unity or some other similar tool. If you want to get a bit deeper, then learn and use XNA. If you want to write your own engine, then learn C++ and DirectX or OpenGL. My personal recommendation is to spend 1/3 of your time on learning about a concept, 1/3 of your time designing and planning, and 1/3 of your time implementing. These numbers aren't based on any scientific research however. Once you really get into it though, you'll feel which areas you need (or like) to spend more time on. 

I've made a game similar to Pardus as part of my diploma project. It has a tile-based world just like you described: hundreds of sectors (=continents), each sector is a 2D map with ~1000 tiles. There are different tile types (empty space, nebula, energy fields, asteroids etc.), there can be buildings, resources, players or monsters on each tile. Here's the schema of my 'tile' table and all the tables that are linked to a tile in some way: 

An idea itself rarely worths anything, unless you have at least a design plan that covers most aspects of the game. Your idea will leak anyways - and as long as only family and friends hear about it, you have nothing to fear. I mean, how many game development team leaders do you have in your family? What you should have though, is some license to protect your source code and other assets. Look up GPL, and the various open source licenses, see how they work, how they're written. You can copy and modify these licenses, just make sure to consult a lawyer if you want a customized license. As for an NDA, I think you can write (copy) your own from an job contract, or similar example which can be found online. Just make sure it covers everything you want to protect, and that two witnesses also sign it. 

If it's going to be an online game with constant communication between the server and the client, then relational database on the server side is the way to go. In SQL, for example, you can have the following tables: 

I assume there's gonna be some kind of "save game" mechanic in your game. In this case, the simplest solution is to include in the player's saved game file a list of the cards the player already unlocked. Unfortunately I'm not familiar with the plist data structure, so I'll just provide an example in xml: 

Create two fairly large textures: one for the grass, one for the ground below. These textures should be roughly as large as the screen, or larger if the game engine and the hardware allow it. The texture should also look seamless when tiled. As you generate the level (the curve of the grass), you should also generate two masks: one for the band of grass (mask A), and one for the ground (mask B). Your final screen will look like this: 

It's possible that you're not being consistent with whether faces are drawn clockwise or counterclockwise, meaning that some of the faces are "backwards," that is, facing away from the camera. If you have backface culling enabled or any of various lighting setups, those faces will not be rendered or will appear black. 

It is possible. There was a nice feature in XNA pre-4.0 called ClipPlanes. There are several good tutorials on how to use them, I'd recommend this one: Riemers XNA Tutorial - Clip planes Now the problem is, ClipPlanes have been removed from XNA 4.0. Developers are supposed to implement it using shaders. I've found the following piece of code to do exactly this: 

Your description is a bit vague, and you pasted way too much code... but I think the problem lies in the method: You increase the value of multiple times in an update if your character is running or 'hitting'. Either make sure you call the method only once in an update, or just don't use the same variable () for all calls. 

I recommend defining an interface for all of these object types (ICollidable, for example), that contains the following method: 

Let player-owned servers (POS) store the tiles and manage the game states. The game client (GC) should only communicate with the CS when logging in, and when the player is looking at the POS list. POS's should regularly communicate with the CS, to: 

Option 1. A 2D or 3D velocity vector's X component is exactly the velocity in the X plane. Option 2. If you can't access the Vector.X property's value (again, I'm not sure how Kismet works), then just multiply the original velocity vector with a new Vector(1,0), where 1 is the X component and Y is 0. This is gonna give you the velocity in the X plane as a vector. 

Simplex noise is pretty much the standard in this scenario. If it seems too complex for you, you have two options: 1. Find the time and put some effort into understanding it, 2. Look for an existing implementation and adjust it to your needs. I would really suggest the first one, but I can understand that it seems overwhelmingly difficult at first glance. So let's talk about option 2. There's a project on code.google.com: simplexnoise project The noise generation itself is in the Noise.cs file. Indeed, it looks complex. There's a test application also (see Form1.cs), which shows you how to use the class to generate an output in real-time. Since there is no existing solution for your exact needs (biomes, cities etc.), you should play with this test application, poking it, to see what happens if you change certain constants. I'd suggest even creating multiple layers of noise, applying them over each other, adding filters and so on. This way you could simulate environmental variables that are independent from each other (for example, terrain elevation vs. population density). I know from my own example that learning while 'playing' is very effective. You will eventually learn how this whole noise thing works, and you will get a clearer idea of how to implement it in your own game.