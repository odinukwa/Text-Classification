No. The Raspberry Pi is powered at 5 V. Using it as a power source for a heating element with 1.8 kW would require it to cope with a current of about 360 A - about the 110-fold of what is advisable and definitely in the range of the impossible. The only way to do this would be to have a power source which is being controlled (but not powered) by the Raspberry Pi. However, I would strongly advise to start with something more simple. 1.8 kW is a lot of power - you could easily burn down your house or inflict serious (possibly lethal) damage on people. On top of that, no insurance would cover that.. 

Why don't you use the one recommended on the product page of your LCD? That way you minimize the probability of further incompatibilities.. Update: The difference between the driver boards recommended by Mark Smith and me are their interfaces. TFP401 must be connected to the Raspberry Pi via HDMI and (!) USB, RA8875 needs a GPIO connection using the SPI interface. Furthermore, RA8875 cannot be stascked upon the Pi directly as the GPIO ports' layout is not the same. 

The PiTFT does not use all GPIO pins, the 40 pin connector is merely for physical stability and ease of use. Some PiTFTs even have another 40 pin GPIO connector in order to easily allow for more GPIO peripherals. You might want to get one of those. Using DSI instead of the GPIO would be hard, as you would have to write your own drivers (and might need custom made driver boards as well). The Raspberry Pi Foundation allowed some insight on these issues when they introduced their 7" display. 

Well there are other OS's available to the raspberry pi on the ROM site which require or can allow better use for other languages, but the main reason why python is preferred for use on the raspberry pi is because it is a lab-on-a-chip where its more for educational use than anything where we all know python is a fairly easy language to pickup. But in saying that you can find libraries which enable functionality and books on how to use other languages on the raspberry pi like c/c++ for example. 

I've been doing a fair amount of research in regards to installing opencv on to a raspberrian distro, but the problem is that there is far too many different methods to installing it and truth be told, im very new in regards to the linux system (Primary Windows User), i do understand how to use basic functionality and install basic programs like geany, but when it comes to something like opencv i am very unsure which way is the proper and effective way of installing opencv, or if anyone knows a fairly straight foward image (coding) editor would be well appricated to let me know. as a side note im using the on board raspberry pi camera, could anyone recomend a C++ lib that is as useful as the python counterpart picamera as i have written up a python version of my desired project, but i would like to write it in C++ to actually see the speed, and effectiveness of each language (and for personal experience) Running a type B rev 2 board Thankyou for your time. 

(I know this is probably the most overkilled question but) I've designed a pretty heavy code/script in python, which yes would of been better implemented on c, but in saying that short of over clocking I would rather prefer to allow as much memory for the actual code to access as possible, I know I can kill startx which makes my code slightly faster access resources, but are there any other stock applications that I can kill on the raspbian image that could aid in a better performance output eg Xorg? 

From now on, the RTC will keep the time and resynchronize the RPi's system time automatically on startup or manually by entering 

After connecting the hardware components, one needs to set up a communication inferace between the MCP79410 and the RPi via I2C (can be activated via sudo raspi-config and therein "7 Advanced Options" -> "A7 I2C" -> "Yes" ). To do so, one should check their availability first: or, for older RPis, should return 

I was trying to set up a MCP79410 real time clock (RTC) and had to search quite a bit until I found a way to integrate the RTC's time signal into my Raspbian Jessie: Apparently, even there, some things changed over the last updates of Raspbian and there does not seem to be a huge crowd using this particular chip (as opposed to, e.g. the DS1307). I specifically wanted to connect a MCP79410 already hooked up to an ABS07 quartz crystal and a HU2032-LF battery to my Raspbbery Pi Model 3B running Raspbian Jessie 4.4.38-V7+ #938. The implementation should be as easy as possible and simply provide me with a correct system time even if the RPi is disconnected from the internet. 

Well, the way you wrote your script, it does everything sequentially - one line after another. However, there are ways to execute commands parallely using python on a Raspberry Pi, whether it's a zero, a 3b or something else. The keywords you are looking for are threads and sub-processes (both links are for Python2.7, but you'll find the Python3 documentation on the same webpage). Both are fairly similar in implementation and results for most purposes. 

to unmount a USB drive. In python, you could insert that command into the os.system()-method. The easiest - though not most elegant way - to include that into your python script would be to mount the drive as first command in your while-loop and to unmount it as the last command in your while-loop: 

The Linux security structure is fairly robust, as most commands implemented are on a user level and to move to sudo (admin level) usually requires a password, assuming you keep the RPI up to date and maybe use a strong password, and make sure you do some research on some basic firewalls (if you are really worried), including VPN tunnels if you are worried about being monitored (I suggest looking up tor on the RPI on ada fruit forums) you should be fine, but if this is for a commercial network i'd strongly suggest purchasing either a hardware router firewall or looking into differing hardware security options as corporations are more prone to hack attacks then the average homeowner. Hope this helps mate and take it easy :) 

If I had more rep i'd ask more questions to help better understand what has happened, but its plausible that you may have a broken pi, sorry mate. Hope everything works out. 

Essentially if you are using RPI.gpio lib which it looks like you are, (and written in python too) I used to use this lib but sometimes commands didn't correctly setup the pwm and often caused problems due to system access, essentially I could suggest you use pigpio ( $URL$ as it is a nice and easily usable lib on python, and it has extensive documentation included with it. The problem using TCP with RPI.gpio too is that as noted before sometimes the pwm doesn't actually reach the servo/motor where as pigpio uses a listener to make sure that the servo/motor receives a smooth signal. If you have any questions please yell, hope this sheds some light on your problem. 

I just realised it was due to the os being on your USB (facepalm), the key to your problem is how the RPI accesses and uses the data stored on a USB and SD card, the main reason why the SD card is used over a USB is due to the higher speeds information is passed at and how it has more data pins than a USB: SD: $URL$ $URL$ USB: $URL$ $URL$ RPI board uses: $URL$ The point I'm trying to get to is that while sd cards corrupt easier than a usb, their number of data pins and polling speed is far greater and faster than a usb, and in the getting started with the raspberry pi a simple but important note is that an sd class higher than 3-4 is required for smooth operation on the raspberry pi (I usually use class 10) but as noted in the book if any class lower than 3 is used expect the RPI to lag, or not function as desired. Hope this helps mate 

In order to set up a MCP79410 real time clock (RTC, see manual), one needs to start by connecting it to one's RPi and a quartz crystal. The following is supposed to be a rough sketch on how to connect the pins to point one in the right direction - in practice, one might need capacitors to smooth signals or resitors to pull-up the SCL- and SDA-interface, depending for example on the battery and quartz crystal used. 

If I understand it correctly, your PWM-frequency is 100Hz and your duty cycle is 20%. This would mean, that your LED is on for 1s/100*0.2 = 2ms and off for about 1s/100*0.8 = 8ms (and so on). Are you sure you can see that? Maybe you should start with 

In order to use the newly established connection to provide one's RPi with a time signal, one needs to comment out the lines 

As I pointed out in the comments, inserting an empty SD card into a Raspberry Pi and trying to access that SD card via USB or LAN from a different computer is not going to work. The Raspberry Pi is a computer of its own and you wouldn't be able to access a hard drive in a regular computer with no operating system either. What you'll have to do is set up the SD card befort inserting it into a Raspberry Pi. There are several ways of setting up a Raspberry Pi SD card, but all of them start with inserting the SD card into a computer using a SD card reader (many notebooks have them built in). That way, you'll be able to access the card like a regular flash drive. Once you have access to the SD card, the easiest way to start is by downloading NOOBS and putting it on your SD card (you can follow this tutorial by the official Raspberry Pi Foundation). Once you have done this, you can insert the SD card into your Raspberry Pi and start it for the first time (if you use NOOBS, you need to attatch a display). To access it remotely (e.g. from a different computer in the same network), you can use SSH (following this tutorial, again provided by the official Raspberry Pi Foundation).