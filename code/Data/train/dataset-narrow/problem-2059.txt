plus the default checks if exists and if so adds it at the front. is intended precisely for "specific to my system" overrides, and for "this user only" overrides, so a symlink in any of them should work. Alternatively you could put (or maybe if it's structured that way) in your prior to . 

means your server cert has expired, not your CA cert. Issue a new server cert -- for the same privatekey if you like, and definitely for the same DN -- and use that. The whole reason to have/use a CA is so that you can issue child (server and client) certs whenever needed, without the hassle of manually distributing them, only distributing the one CA cert. 

You suggest the filenames are consecutive numbers 1 to 1170, but say there are 1760 total. There are not 1760 integers in the range 1 to 1170. Assuming you do want 1 to 1170, in numeric order: 

For OpenSSL Ubuntu as described on its man page reads from AND but writes symlinks with the subjhash.num names needed by OpenSSL to and a combined file in so the latter two should be used with and/or respectively. apparently uses the OpenSSL default, which in this build is , but depending on which Ubuntu, OpenSSL may be old enough to have the bug that commandline does NOT use the default automatically. For Chrome I can't help; I don't use Chrome on Ubuntu. Left CW in case someone else can. Although I do know once you get the CA trusted, recent Chrome also requires your server cert (in PKI terms, End Entity = EE = not CA) have a SAN extension (SubjectAlternateNames) with the correct name(s), which neither of the others do (for now), and you don't indicate if/how you did that. (expanded:) rfc 2818 for HTTPS and the CABforum standards have for over a decade required server certs to contain valid SAN, and by now all or nearly all clients use SAN when present, but to my knowledge so far Chrome is the only client that requires SAN be present. 

Be careful to distinguish between blobs and hashes. The public key blob used by OpenSSH, and also PuTTY, is the same for a given key regardless of the hash(es) used. The key blob is stored in base64 by OpenSSH in its files as applicable, partly because it makes it easier to copy these files and values with techniques like cut-and-paste and (especially older) email that might not handle 'binary' aka '8-bit' data. The 'fingerprint' displayed by OpenSSH (by default, unless you ask for ) used to be MD5(blob) displayed in hex, and now is SHA256(blob) displayed in base64. PuTTY followed OpenSSH's original lead but (as of 0.67) not the update. You can request an enhancement following the instructions in the manual and duplicated at $URL$ . Or it's open source; you can do the change yourself, and submit it back to them (see B.5 just after B.4). The 'fingerprint' code is currently in one place in and two in , but I see on the website the next release will include ecdsa and ed25519 keys, which presumably means at least one and maybe several new place(s) to create a fingerprint. To be consistent als allow base64 of a hash (not just of a blob as now) in in . That's easy if you change to SHA256-b64 unconditionally and never do MD5-hex; for a submission or feature usable by other people this probably has to be configurable and/or interactive, either of which looks a good bit harder. For Windows, I can see one very clunky workaround. Use to connect to the host and accept the new key, putting it in the registry. (If there was an old key, save it first.) Get the new key from the registry (in pieces), build the blob, hash and base64 it and display for confirmation. If not confirmed, delete the key from the registry (and restore any prior one). For Unix, a slightly less clunky way is to use with to accept the new key and put the base64 blob in , or use to get the base64 blob directly. Then base64-decode, hash, base64-encode (the hash) and display; if bad after forced accept, delete the bad entry from ; if good after , add the good entry. OpenSSL can conveniently do both bits of the calculation: 

Your question is ambiguous and the answers are quite different. Protocol. The supported-curves extension in the ClientHello message specifies the curves (standard/named, or 'explicit' GF(2^k) or GF(p)) the client is willing to have the server use. If it specifies more than one, the server can choose any of them; if it specifies one, that's the only one the server can use. If the server does not support the or any specified curve, the negotiation cannot select any EC suite, and unless other suites are supported by and acceptable to both ends the negotiation fails. OpenSSL client to any server through 1.0.1 always sends this extension to allow all named curves (in rfc4492) and no explicit curves. Except RedHat (AFAIK still?) nobbles its OpenSSL builds to P-256, P-384 and P-521 only. 1.0.2 adds new API calls to control this extension, see $URL$ . So either code and build your client program against 1.0.2* and not on RedHat, or get whoever maintains your client program to do so. Any client to OpenSSL server for ECDHE. OpenSSL server through 1.0.1 can be configured in advance of handshake, either for all connections sharing an SSL_CTX or for each SSL connection separately, with ECDHE "temporary parameters" which is (are?) the curve. Only the configured curve is used for key-exchange. For ECDHE-ECDSA the publickey in the cert used (with its matching privatekey) to authenticate, can use a different curve; that key and curve was chosen before the cert was issued and "approved" by the CA and can't be changed now, whereas the "temporary" ECDHE choice is made by the server code or configuration. If either the "temp" curve, or the cert curve when the cert is ECC, is not in the list allowed by the client, then ECDHE or ECDHE-ECDSA can't be negotiated. Instead of configuring in advance, the server can set a callback invoked by OpenSSL library to choose the ECDHE curve (or key) for a particular handshake. This should choose a curve acceptable to the client, unless that is unacceptable to the server. Again for ECDHE-ECDSA, the curve in the cert for authentication may be different, was already chosen before issue and can't be changed, and if not acceptable to the client can't be negotiated. Finally new in 1.0.2 there is an option for OpenSSL to automatically choose an ECDHE curve acceptable to the client while "matching" the strength of the authentication. In server for static ECDH the curve (and key) used for key-exchange is the one in the cert, which as above was chosen before the cert was issued and cannot be changed. If this curve is not acceptable to the client, ECDH can't be negotiated. 

(Found researching something else. I don't know if security, or even SO, would be better.) In release 1.0.2 (only) there are new for this. I've seen no doc in any release yet, but it apparently is in "master" (i.e. the development "trunk") on the website at $URL$ so presumably it will be in future releases. In earlier versions you can set a verify callback, or just check the result chain, and reject any cert or chain using MD5, or RSA<=1024, or ECC using curves suspected of NSA backdoors, or anything else you dislike, such as CA policy that says "we hate cats". 

in its normal interactive-session mode forwards all characters (except its escape, usually ) to the remote host, including . (Anything at the far end of a SSH/TCP/IP connection is 'remote' for this purpose, even localhost/loopback or virtual-LAN.) If you have a 'long' (propagation delay) and/or 'fat' (bandwidth) pipe -- and loopback is definitely fat -- the amount of data that can be in-flight to you before the remote host receives and acts on is probably more than a VT100 can buffer, since it was designed back in the days when connection was an actual piece of wire less than 50' for RS-232, or a direct-modulation one-bit-at-a-time modem like 103 or 212A. If you use with arguments to run a command on the remote host (not an interactive session) then the terminal handling (and ) remains in the local OS, which should respond fast enough. Obviously this constrains the interaction you can do with the remote host(s). By default it also does SSH overhead (keyexchange and authentication) for each command, which can be costlier and slower, but with non-ancient versions you can set up a master process with which shares the transport (and transport setup cost) over multiple worker processes. The only other solution I see is to not run remote things that produce too much output too fast; for example, pipe things into or or similar, maybe even with LINES set to less than 24. Or write large output to a temp file and browse it with or similar. 

In addition to the passive attack that lets (bad) people know what your users are reading, HTTP allows active attack where someone intercepts or diverts the traffic and alters it. For example, assume you have friends who trust your judgement about food, and the proprietor of Joe's Diner sets up a fake server so that when someone requests a page from your site instead of the 'Hello World' you actually wrote they instead see 'Joe's Diner is really great, I've personally checked it out and you should eat there every day!'. In fact Joe is a crook and his food is contaminated, so your friends get sick and die. When their families look at their browser caches and see the advice from your website killed their loved ones they may be peeved at you. 

However, I would expect Safari to give a specific indication of the problem, not just return to a previous page. I can't help you with that part, but hopefully someone else can. 

Windows CMD doesn't trim unquoted whitespace the way Unix shells usually do; you set an envvar whose name is "HOME " -- that is, H O M E SPACE -- to the value " .\HOME" . Remove both spaces, and also make sure there are no trailing spaces after the value (which can't be determined from your Q because they have no visual effect). 

When the text to be appended/inserted is more than one line, every line except the last must end with backslash-newline instead of the normal newline: 

First, use uppercase as and ; is an error. Second, put all JVM options, including and and so on, BEFORE if you use that, or otherwise before the main-class name. Any arguments after the run-jar or main-class are passed to the Java program, not interpreted by the JVM. PS: I assume/hope you have 64-bit java (and hardware) if you want 4G. 

Since I'd already started playing, another option. I simplified the formatting, you can adjust that. Instead of trying to use %1,2,3... directly, copies them to X1,2,3... 

The message tells you why there is no exception button: because (FF thinks) the site uses HSTS, which means it does not want connections that aren't secure, and Firefox honors that request. But: $URL$ includes google.pl (and google.com.pl!) on the supposedly shared preload list but my FF (ESR38.4 Windows) apparently does not have this entry (and has a much smaller list overall) according to my profile's SiteSecurityServiceState.txt . And when I connect to addresses in the three different ranges I get for www.google.pl from my ISP's DNS, Level3, and the delegated and apparently authoritative ns[12].google.com, respectively 63.117.14.184 74.125.226.191 173.194.123.87 -- which are the same address ranges I get for www.google.com -- I get (valid) replies with no STS -- and with certificates as expected under Google Internet Authority G2, which chains to GeoTrust and conditionally Equifax which are both trusted by all my browsers and clients. But google likes to send people from different countries/regions to different DNS and different servers, so you may be connecting somewhere different from me correctly -- or incorrectly, due to an attack or possibly mistake. I'd suggest you first check that your Firefox's truststore "Authorities" contains "GeoTrust Global CA" (fingerprint DE:28:F4:A4:FF:E5:B9:2F:A3:C5:03:D1:A3:49:A7:F9:96:2A:82:12) and/or "Equifax Secure CA" (D2:32:09:AD:23:D3:14:23:21:74:E4:0D:7F:9D:62:13:97:86:63:3A); and if so look at the cert chain(s?) in your other browser (assuming the same network connection) and see what you are actually getting and what root(s) it(they) chain to. If you're on Windows (you didn't say) one possibility is your traffic is intercepted by an AV or proxy that has a fake root in the Windows cert store, used by both IE and Chrome but not Firefox. ADDED: to check Firefox truststore on the Tools menu choose item Options then category Advanced and click the View Certificates button. If you don't have menu bar displayed, hit ALT briefly; or just do ALT+T, O. On the Certificate Manager window, choose Authorities tab. The entries are not all in alphabetical order, but the ones you want (GeoTrust and Equifax) are. For a particular entry, doubleclick (or select and click View button) and it displays a bunch of information with the fingerprints (currently SHA256 and SHA1) at the bottom. To check the cert chain on another browser (that does connect) depends on the browser. For IE 9-11 (I no longer have older to check) click the padlock at the right of the address bar then the View Certificates link, then Certification Path tab. Or on the View menu choose Security Report then View Certificates etc. I don't have Edge. For Chrome click the padlock at the left of the address bar, then the Connection tab, then Certificate Information link, then Certification Path tab. Reading path from the bottom up it should have some name involving google (exact one doesn't matter right now), then , then either at the top or next to the top and at the top. If not, give details about what you do have.