Why 6 questions? Most schools cover a range of student years. Groups of four seems to be quite common. If a question is used from year to year it is possible that last year's students can provide answers to this year's students. With multiple questions available this can be reduced, but not eliminated completely, unless there are more questions than years in the school's coverage. Giving the same, exactly, test again later creates the possibility that the previous version is archived on the Internet somewhere - people will do almost anything, and students are no exception. Randomizing which question in the question bank to include on a test makes each test unique and any archived test will have limited value for the current one. If the bank has 6 versions available and you disqualify the last 2 used and the school does have 4 years worth of students, then the randomly selected question will have only a 25% chance of being seen by anyone currently in the student body, and the value of retaining previous answers goes way down for past and future students. 

will cause more students to stumble, and not necessarily later. The emptiness might make apprehending the statement block concept more difficult than it already is. I'm also not so sure you should even divert into the infinite loop of at all. If you do use the LED-alertButton combination you presented in the question, modify it to respond as a toggle rather than a one-shot that turns on and then appears to ignore all future button presses. The program might loop forever, but it will look to the students like it turns on the LED and then stops responding. 

One technique we use is to work and present in groups. We give them guidance that different members of the team have different strengths and they all do not need to present. Some of the team can research, some create the presentation material and some can present. Those who are not presenting do not have to leave their classroom seat. Alternatively the time can be divided and each can have a small number of minutes and they can share the presentations. This way the less confident can play their strengths. I am an advocate of students with special needs, and in my experience they are less uncommon in computing classes than one might imagine, particularly in higher education. (Big Bang Theory citation perhaps). One should also see the "Imitation Game" to note how Alan Turing was portrayed; certainly "on the spectrum" in my view. This means a class can have some shy and reserved students but also some at the more extreme end with more extreme or radical responses public speaking situations. Some may be diagnosed but, in my experience, many have not yet been diagnosed and have managed to hide in the crowd so far. We have some very social phobic students, and the method of starting with group presentations allows them to participate without triggering their fear factors. We also find they end up contributing a bit more than they expected by the time of the final assessment, and over a period of a three year degree programme we can find ways for them to overcome or work with their particular issues. One of the ways we might use to help them present is to have the more senior students make their own videos, which can just be screen captures with voiceover (but often much more). We also find this eases them into making good presentational material. They then present by playing part of their video and just adding minor interjections and perhaps answering questions instead of the full blown "stand-up and talk". In conclusion, I wanted to illustrate that extreme social phobia is not unknown in our subject and we should be prepared to cope with it with innovative and inclusive techniques. I am wary that these problems can be solved by a single teacher in a single class just getting the shy ones to be brave, so wanted to speak up! 

I believe that using the term "contract" is hurting more than helping. Most students in that age-range have no personal experience with contracts, so the term is too abstract or remote. Secondly, using contract to "define" the rules for using an interface is likely to lead to a circular definition when you define what a contract is. To increase comprehension for the students it is better to use something they already understand in explaining new concepts. Using an analogy for how in the class declaration relates to the you could try using a survey form as an example. A fill-in-the-blank survey has no right or wrong answers, only questions that need an answer, but the answer has to be the right kind. A question about favorite color should not be answered with "scuba diving". If the form has five questions, and only four are answered, it is incomplete and thrown out as unusable, and no credit is given for doing it. In declaration is the same way. It lists the methods, their return types and their parameters, but they are blank methods that don't do anything. When the class declaration that interface it has to fill in all the blanks and how they are filled in has to match how the interface declared them, the same return type and the same number and type of parameters. Once they have a grasp on the rules for using interfaces you can use interfaces to explain what a contract is, and how using an interface is part of fulfilling a contract. 

My attitude to this question (which I have often been asked) is radically different to the other answers. I've been involved in recruitment and selection of students for Computer Science degree programs for over 30 years (in one way and another). Parents, potential applicants and their teachers often ask "what feature of an applicants profile indicates their potential..?", which is quite similar to your question. They expect me to say something about their coding skills, or even computer gaming aptitude. No; we rarely look at that. To me there are other very good indicators of a mind set that is successful at Computing and will enjoy it. The classic indicator is Mathematics, but on its own it is a poor discriminator. I found that better indicators were musicianship and modern languages. Being fluent at more than one language and having skills at sight reading music and playing that instrument with others can be an indicator that they may excel at Computing. This combined with enjoying the structure of non-computer games (board games or Role-Playing) also are positive signs. As also noted, puzzle and problem solving is also a good sign. Why do I think this is so? It is the issue of reading a coded notation at speed, as one does in music, develops the mind to handle computer code as another form of instruction notation. The combining this with manual dexterity, as in performance also helps. Understanding that the music notation expresses the communication of the desire from one human to another is so similar to the function of computer code. This analogue also applies to other modern languages; someone who has to translate between languages appreciates the difficulty in expressing meaning in a different notation for others to act on. Why non-computer games? It is because of the reading and understanding of the rules that is required to understand the play. If they can absorb and mentally model the multi-tome rule sets to some of these games then they can read and mentally model large enough chunks of computer code to be successful. I could add more detailed analysis, but I will leave it at that for now. 

The lesson looks pretty good to me. First, the last part, extending the lesson to show how the power of class is harnessed in the backend. Don't. 1) The students are presumed to already understand the OOP involved, and how the concept works. 2) Give them the remaining time, as you've indicated, to work on the project assigned. 3) Allowing them to explore what they learned, and maybe get a second sense about the power hiding under the hood will make them more receptive, and more curious, about that power, and its source. So, make that a separate lesson for the next class period. The only thing I can think of to make it possibly better, is to add some structure, or expectations, to the assignment. Possibly present a limited set of GUI templates to reproduce, allowing the students to pick the one they like to implement. Possibly add some constraints, such as that it must include 2 previously undiscussed objects from the library 

For starters, since it's primarily AP students that your question focuses on, homework will become a standard of life soon, and adjusting to the demands of that now can't hurt. Specifically, in the US, at the college and university level you can expect that every hour of class time is expected to be accompanied by three hours of study time outside of class. That's why 12 credit hours, in most places, is considered as a "full-time" class load. Admittedly, some courses may require less, and others more, which can also vary by student. Yet, the average will still come out to around 36 hours of out-of-class study time for 12 hours of in-class time. In the early portion of the term, homework assignments need not be coding-based work. Rather, they can be assignments that are based on the textbook, and lectures, that are designed as reflection for students. Reading assignments to be discussed at the beginning of the next class, or questions asked at the end of class that will be quizzed in the next session. After the first quarter of the term, or there about, coding assignments should become the norm. During the week, relatively small sections should be expected, with the Friday assignment being a larger work. The amount of thought, if not work, involved should increase as the term progresses. If the assignments are chosen such that there are three or four "projects" for one assignment, design most to be reinforcement of two sessions prior, and only one, or at most two, that cover the "new" material. The material from two sessions prior is the foundation that should be available, and that they have had an additional class session to raise questions, and see how it was built upon in the last session. Therefore, they should have less confusion about that material and only need to "do the work" for the assignment. The one assignment that does cover the new material can be discussed at the opening of the next class session, and the students should be encouraged to try discovering for themselves, from the textbook, class notes, or Google, how to resolve what they don't understand in doing that assignment. If, however, you are going to make yourself available via email after school hours, you should still have "office hours" during which you will be open to emails, and able to respond, and outside of which you will not respond. AS an example, from 5pm to 7pm you will accept emails, and reply by 7:30pm, or sooner. Anything received prior to 5pm will not be handled until then, and anything received after 7pm will be "collected" and addressed in class the next day. On weekends, and holidays, you could have longer hours, or multiple windows of time available. All students should be learning the material from class. They should also be learning how to "think" for themselves as well. Those in AP classes, in any discipline, should be able to think independently even more so. 

It was requested ad-hoc for no specified reason Critical/frequent problems originating from a certain module or modules too often It was scheduled It was requested by the dev 

edit: Emphasis on code-reviews. Gilles brings up some good points when taking into consideration more in-depth criticism of code in the form of code-audits. These steps above are not the steps I would take for a code-audit. In regards to the main difference between the two and how to interact with people, I would say it has more to do with understanding the core intent of the code and figuring out where it falls short and coming up with more elegant solutions. For example, someone might accidentally re-invent something from C++11's library to help sort something from their class. In a code-review, I would mention this and advise you to remove it and replace it, but in an audit, I would tell you to fix it and remove the redundant code, because of the conversation's scope and the relationship's connotation. If I'm auditing your code, it's usually because of one of these reasons: 

It's usually #4 and if you're playing with some fast and loose code cowboys, #2. So, in both of those scenarios you're basically the mentor/master and less of a peer. You're not there for the thumbs up/down, you're there to take charge and in some cases, teach. edit 2: Expanding on code audits and analysis as well as quality, I feel the living legend John Carmack does a good job describing it: 

Although other answers have mentioned aspects of testing language skills for non-native speakers and other reasons why language focussed questions cause problems I felt the case for students with alternate needs in Computer Science specifically needs addressing. I have much experience in working with and teaching Computer Science to students with various alternate needs. In my experience students with dyslexia, dyspraxia and other specific learning disabilities are not uncommon in computer science classes. I could go even further and say they are quite common in computer science classes. I expect to find that as many as 20% of an undergraduate computer science class has these characteristics, even if they have not been diagnosed. Dyslexia is a condition where language cognition is lagging behind other measures of intelligence and cognition. In other words these are very capable and bright students who have physical conditions that impair their processing of language. To discriminate against some of the best students in a class and artificially inhibit their progress because of a condition they were born with seems bade educational practice. You should certainly reflect on your testing methodologies. Learning vocabulary and technical terms is an important part of learning but it has to be assessed in an appropriate and non-discriminatory way. 

Although you may think mine is a less than serious answer, the best example I have seen for the use of a smart-board in computer science is in a video from De Pauw University, when they implement a time machine to explain program code debugging. I just love it, and show it to my students every year! 

A few desks I've found online. Fairly basic version, with enough room for standard keyboard and monitor: 

Not only will we tell students that, we should have that on the door lintel of every classroom and lecture hall where programming is taught. 

Since your students are getting the beginning of Boolean from you, you have the advantage of being able to lay the proper groundwork to work within. To begin with, hopefully, you will be stressing the point that Boolean logic is two-state. You can use the word binary if you choose, as long as they are not predisposed to think binary = computer, since while Boolean logic is handy for computers to deal with, it is not just for computers. To connect the symbols, meanings and math together, make it explicit, and demonstrate. Start with the concept that is the same as nothing and is the same as something. "I have an apple in my hand" is if you have no apples in your hand, even if you have an orange, or a pencil. The same statement is if you do have an apple in your hand. It is not, however, more if you have two apples, or twenty apples, in your hand, however, it is still just . Zero, as a number, represents nothing as well - zero apples is no apples. Therefore, it makes sense (dare I say it is logical?) to use the number to represent . Using the previous demonstrative phrase, it only takes one apple to make the statement , and at least one is something. Five is also something, but that would leave out everything from one to four as maybe, and Boolean logic has no , so that creates a problem. If some starts at one then there is not need for a . Using for something, and therefore , gives two symbols to use instead of the words and , which can get quite long to write in a very short while. The next step is to introduce the symbols for and . Here I will, marginally, disagree with how and why your are using center dot for . I am not opposed to that usage, only the reasoning behind the choice. The students have not had algebra yet, so it seems a safer choice than . You can tell the students you have chosen for because it is what they are most likely to encounter later. They should also be told that it can also be written as , and that both can also be used for multiplication ins algebra. The same way that means for this class, and will mean in mathematics (and in rectangular coordinates). Likewise using for in your class, while it will mean addition in mathematics. Rather than shelter them now, only to create confusion later, deal with the reality that we only have so many different symbols we can use, and many times they will have different meanings in different places, and knowing when, and when not, to use as is part of learning about Boolean logic. We need to toss in one more symbol here as well. Replacing the word with the symbol (or symbol of your choice) also comes in real handy. Since the students have not had algebra the next step might be difficult. Connecting the Boolean operators with the mathematical functions. Connecting the addition to first, because it is easier to apprehend, you can give the samples , , and . Rewrite them in symbols as , and . The first two will be obvious, make sense, and get no questions. The third will start them thinking and should get some questions about "why not ?" Return to the apples: zero apples made the statement false while any apples, one, two, or a dozen, made the statement true. So, any number other than zero is true. You can call it part of being a two-state system - either it is zero, or it is other than zero. Therefore, the last of the three samples can be expanded to: 

Although there are many good answers, some aspects of this problem have been overlooked. There are other categories of students who put too much effort in memorising every detail, and they could not be classified as overmotivated. I have professional experience of working with both groups. The first you should consider are those on the Autistic Spectrum. I find that in Computer Science this group is often more highly representative than in other academic subject areas. Students on the Autistic Spectrum would have difficulty separating relevant facts and details from the minutiae. They may also have a degree of obsessive interest in the detail of the subject and memorise detail for its own sake. Another group of students who may do this are those that are completely lost or disengaged. They may not have been paying attention in class and their solution to getting grades is to mindlessly try to store everything by rote, without regard to its relevance or purpose. My anecdote on this comes from when I taught a course on computer programming for Arts and Social Science students. Very few of them wanted to be there; the class was large (many hundreds), but passing credits was a requirement of their degree program. In order to reach out to them I used many paradigms of programming that I felt they could relate to. I explained that programs were like cooking recipes or knitting patterns. To illustrate this my slides (and notes) including cuttings from recipes and knitting patterns I picked up at home. The result was that many students memorised both the recipe and knitting pattern, but still could not explain what a computer program actually was. I still grin at it today, as the recipe was Ken Hom's Chicken in Paper. I still wonder why they thought that memorising that would help them pass the computing paper. If you do not have experience in recognising or teaching students on the Autistic Spectrum but you teach computer science, I think you would find further reading or training in this area may be helpful to you.