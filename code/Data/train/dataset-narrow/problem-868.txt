This is a really awesome pattern for building complex object in larger system and in tests. You could even reuse the builder and call create twice. Or change only one property and call create again. 

(Maybe the should be a ?) As I said in the comments, get rid of all comments without new informations for the reader. You could also move your switch into a separate method with a nice name to reduce the length of your main method. And the crop and resize_only part are also suitable for a private method. (This methods would also be very easily to test in PHPUnit; just a bunch of numbers and no real images required.) 

Why should an object know about a database (in an OOP sense)? I'm definitely no friend of the Singleton pattern, but a database is in most projects a valid use case. 

is in general a really weak test. Maybe you want to test anything in the session or the history etc. Testing is usually also not enough. What if your return code is buggy. You need to test the operation itself and not only the return code. 

My (Disclaimer: opinion-based from a German point of view) main issue here, are the non-english identifier. Of course I can guess some, but a minimized version would be as readable and unsuitable for an detailed review as this code. Always code in english, you never know who will need to read your code. In addition to that, it is actually up to you, if you prefer a clarifying variable, if it is only used once in the next line, or not. There is no global valid recommendation. 

All the other guys are in general right, so I will skip this part. If you just want to reduce code duplication and as a side effect increase testability and readability please have a look at the following code. I guess there is no doubt, that you would benefit from an object containing the , and as they somehow belong together. 

If you want to return the first item without a brand you have to add the condition to your second if. Otherwise you use the last suitable item. 

I recommend splitting your model (the database operation) from your view (the localization of your message). Depending if you prefer a return code or a exception flow your code could look like: 

Your code might not be OO but Service Oriented as you are injecting the database(-service) to your objects. 

I.e. will contain a array with all your answers to question 1. The sorting of the answers can be moved to SQL query, also if you don't need all fields you can restrict this in the SQL and don't need to take care of this in your PHP. 

I would prefer a return value instead of an Exception for winning. Think about using an for your direction instead of . Maybe you want to even use this in a broader sense than left vs. right, but N,W,E,S,SW,NW,NE,SE to also address the diagonal (e.g. horizontal=1/verticial=0 for NORTH, horizontal=+1/verticial=-0 for SOUTHWEST etc.) and iterate thru the tokens in that direction. Let's think about in detail and identify the noise adding no information to method: 

Let's start with 3. I think the most important improvement would be a separation of the program logic from the layout stuff. This will also support you in creating unit tests. (In addition to that, the separate class is working fine for me.) I added some comments to minor changes in the code. Main.java 

First of all, better names than columnX would be nice. I guess the indentation is a copying-issue, otherwise this would be the next optimization. Furthermore I have the feeling that mixing the && and the || in your condition without parenthesis is not what you want to do? 

Since Java 7 you can omit the second and use the diamond operator Simplification could be written as: 

Please check your naming conventions. I'm not sure from which language you are coming, but Java is usually using no under_scores but camelCase for variable and method names. Especially if you pick one notation don't switch in between of a single program ( vs. ). It is also a common pattern to start the method names with the verb. On the other hand, classes are usually nouns (?) and are never written in all-caps (). All-caps words are usually constants (). Although naming seems to be only a minor issue, it requires a lot of effort for the reader to understand your code, if she is used to a common pattern for a specific language. RoToRa mentioned already not to run any premature optimization. Usually any optimization will lead to worse readability. E.g. understanding requires reading the whole method (left=1|0|-1?). The meaning of is obvious. 

The parameter in your method is "useless". I think in your application you will have no benefit from defining the capacity of the StringBuilder, it just reduces the readability of your code. In case you ever need an other millisecond, come back to this place. Nevertheless, padding strings can also be done with following common and shorter method: 

should be and in new classes you might want to use namespaces instead of underscores in your class names. See PSR-0 As non of your is optional and there are only 5 I would recommend the use real method parameters instead of this array. Otherwise some validation and documentation of this array is missing. Furthermore you could refactor your ifs to real guard conditions and skip the else branch. This makes the code more readable and you get rid of a indentation level. There are also no braces on one-line-ifs. Edit Sample for guard conditions 

As Jason stated checking for ".." is a good idea. If there are only a limited number of path where the pdfs are located on the server, I would even prefer matching against this set. Nevertheless, you might also want to invert your ifs to get rid of the nesting and use guard conditions. 

As you can't type hint the content of an array, you might also want to replace by and append new rules to the existing ones, instead setting the array of rules. 

In case you want to add more fields, you shouldn't use the but a separate method. See (Effective Java, Second Edition, Item 10) for more details. 

For explaining the Singleton pattern the ABC naming is confusing. Just come up with some real name, e.g. Database, Logger etc. Something that might need access to a common config. Instead of the config, you might want to add some mock code to init the database connection or get the logging directory. Please keep in mind that Java classes usually are starting with a capital letter. The static instance variable is usually called only . In which context do you want to explain the pattern. Maybe we find a more suitable example? Check $URL$ for a nice explanation and some examples and drawbacks. Please be aware that a Singleton might seem to help you sometimes in production code, but it definitely makes your life harder in testing your code. See "Dependency Injection" for an alternate approach. 

How to improve the overall code quality? I don't know much about C#, but I guess your analyzer is complaining mainly about the length of your method and its cyclomatic complexity. Try to split it in multiple well named methods and use guard conditions to reduce the nesting level of your s. Maybe you could also use the ternary operator instead of the in your first to extract the common part of the branches. But this is an highly discussed topic. How can I make it more extendable or maintainable? There is no real use in making something extensible, that you never plan to extend. So if you don't know possible (useful) extension points, you shouldn't desperately try to find some. You can refactor it later when you need it. Maintainable is in general achieved by readable code and a good test base. If you are not afraid of breaking something, you can do everything with your code easily. Will employing some specific Design Pattern here would have mad more sense? Actually I would say, you applied the Strategy pattern here already. This is more or less the default use case, having an interface and change the path finding algorithm. (Maybe building the graph should be splitt from traversing) 

My first impression: too verbose. Usually I'm the one that get complains for too long method/variable names, because I really like this style, but I would try to omit some letters here, e.g. 

Please keep in mind that some corner cases where undefined in you initial program and I tried not to add any new functionality. 2.) I'm not sure if it is good practice or even best practice, but at least it is common practice. 1.) Somebody else need to answer this part. 4.) The usage of final all over the project or not is more a religions discussion. It's the same with visibility. There are valid reasons to restrict possible changes to a minimum and there are other valid case to keep it as open as possible. Declaring variables final is in general intended to prevent changing them by accident. Short and clean methods will also address this issue and seeing all over the place, makes the code not more readable from my point of view. 

It was not easy, but the first step for improving your code is to split the layout from the logic: layout.php 

Translating this to exception is up to the reader :) Actually I even would prefer to give the code to my template and let it handle the localization: 

PHP is already a template engine Just write a wrapper around a call and your template system is ready to use and more flexible than anything you could write. 

Maybe you should just stay with . According to the link above it seems to be faster, but at least it is easier to read. 

Do get this into an abstract method in your model class you have to extract every information related to your concrete class into abstracts methods. Just as a draft: 

First of all, I'm no python guy and I always favor readability over one-liners. If this happens regularly I would implement a get method which will return the default value not only for missing keys, but also for empty (or what ever required) values. In addition to that you maybe should have a look at the method that is generating your dictionary. Maybe you can just unify the message parameter at the place you store it and so you don't have to take care of this later? 

Now you have a separate file for the representation of your data and one for the calculation. The first file is now only a simple template without any business logic. In the words of the Model-View-Controller paradigm this is the view. The model and the controller are now combined in your content.php. In a second step you would split the content.php into two files. One is getting the data from your database (model) and the other is connecting the data from the database with then view (controller). Unfortunately I have no time to continue this at this point. But after you have splitted this file we should concentrate on some conceptual details. But this will be far easier than now, if the responsibility are divided into this three files. 

WKS is right, first of all you should split your layout from your logic and your logic from your database query. (see Model-View-Controller-Pattern) Lets start with your model (Model.php): (actually you could split it in a model for each entity/database table) 

Put your code into a method. So you get rid of the temporary variable, its cleaner and you can leave your method with a return as soon as you find the first true. (A break to leave the loop will have the same effect.) In addition to that I'm a big friend of guard conditions. Invert to , so you have one nesting level less. 

The big advantage is that you can put a configuration file in your project and define the log level of every logger independently. 

If this don't need to be , just inline the one usage. Your variables is telling everything in that place. Unused code and are not used. If there is no code missing in your question, just delete it. is redundant and can be inlined. (to be continued after you completed your code) 

If you have the feeling your classes are too big, you are usually right. Of course there are always different approaches how you could split classes and your idea seems to be reasonable. So you will have some plain Value Objects (the User), some UserRepository class for getting/updating the data in the database and some kind of UserAccessCheck/PermissionManager/... class for checking the actual user rights. In case you store your permission also in the database, you can of course extract a PermissionRepository to collect all the SQL statements in one location and don't mix your level of abstractions. To sum this up, the decision is up to you. A class with 4 properties, some Getters and 4 can...()-methods might be suitable in one scenario and splitting it up into 5 classes might be suitable in an other scenario. In general "good" (tm) developer tend to make there code more general/abstract than necessary and wasting there time or there clients money in premature optimization. "Bad" (tm) developer will never feel the need to split a class. Find the right way in between.