As explained above, whether or not the table is in 3NF (or more importantly BCNF) is orthogonal to how many candidate keys it contains. 

For those last two relationships the verb has isn't very descriptive, but that was how the requirements were phrased. The entity has an attribute, so why wouldn't these be attributes? I discussed earlier why I would choose to make location an entity type. For dependent, the choice is more clear as its clear each employee has many dependents and so it must be broken out into its own entity. Once this is done we could make the leap to improve the verb. Perhaps something like employee cares for dependent and department operates at location. Now we are in a position to create the diagram. Here is what I have: 

The pattern you are describing is often called a "parts explosion" or "bill of materials." It is part of the graphs and trees portion in the study of data structures. The essence of the solution is to realize that any given "product" can be made up of other "products." The design is then a network structure where there is a table that has a row for each product - whether it is made up of other products or not, and then a table that has a row for each product that is made up of other products and each corresponding product that is a component of that product. In your case, each product has a price. So you would have something like this 

Similarly, in relational algebra we know that natural join is associative and thus know that A join B join C can be executed in any order. These properties and laws create the power to re-write query formulations and be guaranteed to get the same results. The book Applied Mathematics for Database Professionals provides significant detail on the various re-write rules you can use to precisely formulate the same query in different ways. In a perfect world any formulation producing the same result would have the same performance. A modern optimizer, while an amazing piece of software, isn't perfect however. Thus if you have formulated a query one way and are getting poor performance, you have the skills to formulate it a different way and know it has the same semantics. Another practical advantage to this is in the specification of database constraints. First, understanding the relational algebra enables you to determine the simplest way to formulate the constraint. Second, by formulating the constraint in formal logic, you can immediately clarify any ambiguity in intent from the business subject matter experts who formulated the business rule in loose English and avoid bugs. It was Leonardo da Vinci who said: 

Conclusion So are relations closed under the operation of outer join (full, left, or right)? I guess it depends on how that operator is implemented. I would say yes if you do consider a relation to still be a relation even with markers for the missing values of the attributes of un-matched tuples. Or yes if you don't consider a relation to still be a relation even with markers for missing values but can substitute default values for the missing attributes values. But if you don't consider a relation to still be a relation even with markers for missing values, and your DBMS implements SQL NULLs, and you can't or don't substitute values for the SQL supplied NULLs in the outer join, then no, relations are not closed under that outer join. Two relations went in, but a relation did not come out. 

Both of these are not technically correct. Regarding person_id on the Account table, since the relationship is one person to many accounts, the same person_id will be in the account table for each account that person holds. It would look like this: 

Each department has a name, an unique number, keep track of the start date when the employee began managing the dept projects, each of which has a name, unique number, store each employee’s name, SSN, address, salary, sex, and DOB. keep track of the number of hours per week that an employee works for each project. keep each dependent’s first name sex, DOB, and relationship to the employee. 

Referential Integrity can no longer be enforced by the DBMS. Query expression is now more complex. Surrogate keys of a single numeric type are required for all the parents, even if that isn't the best choice for a given parent. You cannot show the relationships visually on an ERD. Instead, you now just have table boxes with no lines as there are no enforceable relationships. 

I highlighted the nouns in a bright green, and the verbs in a bright pink. Now notice there is one noun - supervisor - that is highlighted in a darker green. We'll ignore that for now. Comparing what I found to what you placed on your ERD we are on the same page! The only difference is that I also highlighted location. I can see why this was left off of your ERD as its not clearly an entity. You could just as easily think of it as an attribute - which is a common property or characteristic that all entities in an entity type share - of the department and the project and that is how you modeled it. The reason I elevated it to an entity type is this: 

There is no way to allow for two technicians with the same name and still prevent duplicate technician's from being entered without always providing an additional characteristic that will differentiate them to the DBMS as part of a unique constraint. The DBMS does not reflect reality but instead only what you have asserted to it about reality. It cannot determine if two technician's are really the same technician. Instead it can only determine if the data entered is consistent with the constraints declared to it. Therefore, if you want to be able to enter two people with the same name you must provide additional characteristics (columns) that you require upon entry so that the DBMS can check their values against existing values and differentiate. You are thinking along the right lines - adding phone number or email. But to do so those columns must become required. Short of doing this there is really no other way. 

Note I can't find any attributes for location. This would be a red flag to go back to the business to get some additional information about locations! Then list the relationships and their attributes: 

This is a great question that shows the importance of breaking down n-ary relationships based on the business rules contained in them and is a good example of the application of forth normal form which deals with multi-value dependencies (MVD). The following business rules exist: 

Then if you insert a new step - say between UUID3 and UUID4, you perform more of a linked list operation which will update UUID3|UUID1's NextId to UUID5 and then just insert the new UUID5 with a NextId of UUID4. This will reduce the UPDATEs to 1 in most cases, but it will make querying the process more difficult as now you have to walk the list from top to bottom to list out step by step. You need to decide which process you want to favor - inserting and updating or retrieving. If you favor retrieval (which you might if changes are infrequent and reporting is frequent, and the lists are short), then go with your original design. If you favor insert and update (which you might if changes are happening all the time and reporting is infrequent, or lists are really really long), then go with the linked list approach. I hope this helps. Interested in what other solutions the community might come up with as I'd love to broaden my knowledge around this!