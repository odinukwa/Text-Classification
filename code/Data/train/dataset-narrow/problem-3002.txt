I am not advocating teaching pointers to explain 0-indexing (see mine and others answers on your other question for how to do that). However if we have good reason to teach pointers, here is a tip that helped me when I was learning. I have also shared these ideas with other pupils, and they started to make progress. I find code involving pointers confusing: is it a pointer, or is it the real thing. To help me with this I adopted a little bit of Hungarian notation (I don't generality advocate Hungarian notation in strongly typed languages, but for pointers it is a great help. Prerequisite It is important to ensure that all variables and routines have good names: 

He also extends on Darwin (it is not random, there is a lot of order. Therefore the probability of it happening by chance is better than you would think). The 15 properties are: 

Summary Not all IDEs are the same. Not all editors are the same. You will have to look closely at your editor, IDE, to see if the IDE provides anything more, and does not make things too much more complex. 

As requested, I'm expanding my comment into an answer. This is going to echo a lot of what I said in this answer, so you might also check that out for some background motivation. Version control systems are tools that are designed to solve specific problems. They're great for stuff like: 

I agree with most of the other answers, but I wanted to add another way to look at it: I think one of the biggest downsides of using spreadsheets to introduce programming is that it reinforces a lot of stereotypes about programming, which turns off a lot of people who might otherwise have been interested in the subject. If the first day of my first programming course was "okay, now open up Excel..." my eyes would have glazed over and I would have thought "maybe this programming stuff isn't for me after all..." Programming is more than just ones and zeroes or staring at spreadsheets. There's a craft to it, if not an art, and it opens up a ton of possibilities for expressing yourself, communicating ideas, and accomplishing your goals. I think that's the stuff you should be highlighting in your first course. And since you're working with students from diverse backgrounds and of under-represented groups in computer science, I think you should be very aware of the effect your class has on their interest. At the risk of repeating an answer I've given before, I'd like to point you to Processing, which I think is perfect for the type of class you're teaching. See these other questions for more info: 

I often see people mixing up files and filename in variable naming. It will result in mixed up thinking. I think it is important to come up with clear names. I like to start with giving them lots of code. They then read the code, analyse, modify. In my code I use clear names. We discuss naming, and how this affects readability. Also to discuss with class: I have included some questions about some statement. Use your discretion as when to ask them. I am not suggesting you ask them in a sequence as presented. When you call a subroutine it takes a thing or a name of a thing. e.g. takes a string [or the name of a string]. Is `/dev/null' a string? Why is it not a string? Is it the name of a string? Why is it not the name of a string? When you define a subroutine it takes a name of a thing. Why does it not take a thing, why only a name of a thing? Is that a name of a thing? 

Note I have intentionally included some examples that may not fit in ether, and some that an arguably do. 

I find the "box" aspect is far more important than the named aspect. Maybe it's personal bias. However, we can combine the two: it's a named box. So you can say "Go look in the 'object color' box." If you're working with pure data (no objects), it may be effective to set up a white board, and mask off a few "boxes." Each box gets a name like "number of chores done today." Concepts like "Add 1 to the number of chores done today" start to become really meaningful that way! And it just so happens that the word for these spaces on the whiteboard is "box," which is similar to the 3d boxes you might put objects in. Even better, it puts her in an excellent position to deal with the nuanced behavior of reference mechanics when she gets there. If you're used to thinking of variables as spaces on a whiteboard, writing references to objects, like referencing the members of your family by name, is easier. For many people, the jump to reference mechanics is a real struggle because they got used to the idea of "x is my bear, that's in a box on the shelf" rather than "x is a variable referencing my bear. Y also references the same bear." (I personally have struggled to help people with reference mechanics because it forces them to unlearn whatever models they used up to that point, and unlearning is hard) You can even use different color markers for references and data. That starts to get them used to the idea that there is some fundamental difference between the word "dad" and a reference to Golo Roden. 

I reject a lot of the assumptions implicit in the question. Computer science isn't just for geeky or "smart" students. And I don't think it's fair to say that students in other classes are "more expressive, outspoken and creative." Computer science is full of art, creativity, and expressiveness. It's a teacher's job to show that to students and encourage every student to try it out. I advise you to work on your own assumptions first. If the teacher thinks that computer science is not for creative students, then what hope do the students have? Things to consider: 

Like many things in programming, pseudocode and flow charts are both tools that a programmer uses to accomplish their overall goals. It doesn't make a ton of sense to ask which tool is better overall. A carpenter doesn't ask, "which one is better: a hammer or a saw?" The answer is that they're different tools, used for different jobs. In my experience, here's how I'd use each: 

The "semantic exactness" part is the real beauty of the peanut butter jelly sandwich challenge, imho. One of the hardest things to do in computer science is take things that humans "just do" and break them down into individual steps. If they continue exploring CS, your students will eventually have to ask questions like "how would I sort a stack of index cards with numbers written on them?", and their initial reaction will be "I don't know, I just do it!". The peanut butter jelly sandwich challenge teaches them to dig a little deeper than that first reaction, and to start breaking things down into smaller steps. And the fun part is that no matter how exact students make their instructions, you can always find a way to get it wrong. Anyway, back to your actual question: I would propose a three-part lesson: 

I have just written myself a web-mark server, to store book marks to my website. I got fed up with the proprietary ones, and decided to make one of my own (probably could have found a ready made one with a Free Software Licence). It used Couchdb. This involves writing code in Java-script (the manual says that the server side code can also be written in python, I chose JavaScript, so it would help be learn it), but because it provides the framework, you write lots of small functions. You will also end up learning about the no-sql db couchdb, http, and client side web design (html, css, Java-Script). I used jquery and knockout.js on the client side. First things first Because I did not follow a tutorial, I ended up looking stuff up as I went. This would probably be to effort-full, if it was your first language, as you would be looking up everything, and not know what to look up (how can you look up how to do a foreach in java-script, if you have not yet heard of a foreach. Therefore it would be beneficial to find a tutorial to do first, then work on a project. You can also work on an existing project. There are many Free Software (Open Source) project that you could help with. It is much easier to contribute to an existing project, that to start from scratch. If you want you can contribute to my bookmark project. (If you do work on someone else's project, and it if for an assessment, then ensure that you tell the assessor what bits you worked on). Learning two languages at a time may make things confusing, and make it take longer to learn. However research into natural languages shows that, for babies and infants, learning two or more languages at a time has a positive long term affect. Though it does slow externally measurable performance at first. For these children the languages are in different contexts, one for each parent, or one at home / one at school. I would suggest that you focus on one language, until you get sufficiently skilled. Python seems to be widely used as a teaching language (1st scratch, then python). JavaScript has may pitfalls. A good language to learn Object Oriented is Eiffel. However you could learn, non-OO first (OO just adds to structured, most modern languages are structured or structured+OO). Therefore, if you have not used scratch, then have a play with it, then start on python. Other project Ideas â€” python 

It's almost impossible to convey a sense of wonder when they don't appreciate what they have. My personal favorite approach is to point out that the Apollo Guidance Computer (AGC), which sent us to the moon, was a 2Mhz processor with 2k of RAM. The original Game Boy had a 4MHz processor and 8k of RAM. The old game boy was more powerful than the AGC! Well, almost. The AGC did have triple redundancy on all circuits, so you would have to duct tape 3 Game Boys together if you really wanted to compete with it! And, of course, a modern cellphone chuggs along at 1800Mhz! I find it helps to first appreciate just how blindingly powerful and fast computers actually are. Then we can talk about where they came from. One of the calculations I did a while back was comparing the speed of a cache hit versus going out to memory to get the information. It turns out, due to serendipity, that the difference in speed between a L1 cache hit and a round trip to memory is actually the same speed difference as that of a Cheetah at full sprint vs. the top speed of a snail. No joke! Of course, that doesn't help if you don't have a sense of how fast either of those are, so let's compare them both to something we can appreciate: how long it takes to load a web page. There's a latency associated with going across the world over fiber optics. It turns out that your round trip ping time from America to Europe (the absolute bare minimum portion of loading a web page) can be put on this scale between cheetahs and snails. This web page access proceeds at the speed of the San Andreas fault slowly opening in California! Yes. On this scale of speeds, California actually starts sinking into the ocean! 

Each of these steps can be further broken down, but hopefully you can see that these bite-sized chunks are a little more manageable. It's easier to google "C++ create text area" than it is to google "C++ create shell from scratch". 

I stil think this is basically a duplicate of this question: Good datasets for intro CS courses? You're asking for a database of interesting data. The other question is asking about interesting data. The only thing you need to do to get from the answers in that question to the answers to your question is to write a little bit of processing code that outputs the data in a format that's compatible with a database. In other words, you're going to have to massage the data. This might require writing a program that calls an API to get data, and then outputs that data to files or more basic files or something. Then the students would take those files and work with them to create their databases. I think as soon as you accept the fact that you're going to have to massage the data, you'll open yourself up to a lot of cool data sets. I think restricting yourself to data that's already in the exact format you need is very limiting, and isn't how things work in the real world. In the real world, data is always in the wrong format. You always have to convert it to something you can use. Stop looking for data in the format you want it in. Start looking for interesting data, and then figure out how to get it in the format you want it in. 

Preference is for Free Software, that is software with freedoms, not with zero price (I do not introduce proprietary software into my school). 

The book has the philosophy that exceptions are only used for program bugs. variance, invariance, preconditions, and post conditions. Everything else should be checked traditionally. You will be surprised at how much simpler this makes things. You hardly ever see or use a catch clause. The philosophy makes it easy to get things right: if you forget to check an input, or have an out by one error, then the program will tell you that you have a bug, and tell you where it is. 

I think it is very important to start by discovering what the student wants. What do they think computer science is. It is usually not the same as what we think it is, and sometime a long way off, that they should be doing a different course, or an adapted course. Therefore find out what your student is planning to use there computer science for. What job they may want to do, and why. What their interests are. Focus on them as a person, not on their disability. Then look to see what problem caused by their lack of sight, need solving. 

Version control is most effective in an environment where at least one user understands it quite well. As long as you have one individual on the team that understands how to recover from a messy situation, everyone else can comfortably learn as they go. However, if one does not have such a knowledgeable individual, there may be no clear way to recover from the sorts of situations that VCS is supposed to help you with. For example, if I'm not on your team, and you come across a "Tree conflict" in Subversion, it's unlikely that anyone has bookmarked the StackExchange answer that lists each tree conflict and the series of commands which resolve it. Instead, "Tree conflict" quickly becomes "wipe out your repository and do it again." In a commercial setting, there are typically senior developers or team leads who are actively monitoring the state of the repositories and can guide you down your path. In an academic setting, one is not so lucky. If I were to introduce VCS to a curriculum, I would use it in the context of group projects, and I would want to make sure the VCS tools are actively maintained and used. This may call for extra effort on my part, or that of a TA (which may not be an acceptable cost). I'd say 95% of the value of VCS becomes apparent when one is working on a team, rather than on their own. 

Even better: have students run through these scenarios live. Have them typing commands and pushing buttons instead of just listening to you. This should be information that they can actually use, not just theory that they'll forget as soon as they leave the classroom. Don't spend an hour talking about theory. If students have never seen version control before, then they don't need to know how Git stores changes. They need to know how to setup a repo. On the other hand, don't spend an hour telling them about all the different things Git can do. If you throw a hundred different commands at them, they'll remember zero of them. Instead, introduce specific problems (that the students have already seen in their own coding), and show the solution to those problems. Have students work through those solutions and practice the commands right away. 

The second approach would let you know who is working on what, without making students call attention to themselves for being slower than their classmates. 

I don't know why you need to treat this as a separate thing. Include it in the "mini-reference" that you give them on the first day.