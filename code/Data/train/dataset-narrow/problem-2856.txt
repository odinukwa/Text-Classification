XACT, FMOD, and Wwise are also really useful for footsteps, you can create a "Footstep" sound cue, which has a bank of different footsteps. It will select one at random, adjust its pitch randomly (within a limit). The bottom line with these tools, is that your sound designer probably knows what sounds better than you do, so let them define the behavior in an abstract way, so then you only have to adjust some predefined parameters to get the desired effect. 

This isn't as common as it once was. Commonly you would get the Yahoo Toolbar or the Gator Toolbar bundled with an application that you wanted to install. These programs typically sucked up a lot of resources, or introduced vulnerabilities that compromised the security of user's computers. If the software you are requesting the user to install has a valid reason for being there, and you are up front about why you want it installed, users may check out the software out of curiosity. Honesty is key. Download any games by Zynga or Atari or EA and similarly large companies on a mobile device. They will frequently show you popups asking you to download other software. Update Pulling up Qqwy's comment into the answer because it's important for Travis to readr: 

From your question, it sounds as though you have no problem designin/acquiring sound effects, and just need to understand implementation approaches. 

To answer your question, JRuby is probably going to be your most flexible option. An alternative is ruby-processing, but of course that's geared more toward constructing visualizations than efficient game systems. Is 3D a requirement? A lot more options open up to you without it such as Rubygame, Chingu, Gosu, etc. 

I don't believe there's a feasible way to implement location features in a mobile game without a data plan. Foursquare's SMS system only allows you to nominally check in. They don't award points unless they can verify you were there by a phone with a data plan with their app installed. SMS systems are not hard to implement: use Twilio. Using their API, you can respond to and SMS via a HTTP requests. When you sign up, you get a reasonable amount of free credit to get started on development. Services like this are how a lot of companies are implementing their SMS features. It's super simple. If it doesn't matter that much to you that a user could tell you they've been all sorts of places (you could probably do some server-side checking, eg. probably impossible to visit the Grand Canyon and the Taj Mahal in the same day), then the SMS bit is easy. Somehow triangulating on their position via SMS or phone calls sounds impossible unless you are best buddies with executives at a telecom or something. 

I'm a little confused as to what you mean by incubator. Are you talking about an incubator like Tech Stars or Y Combinator in which you bring in teams and help them with the development process? If that's the case, wouldn't the decision for which engine to use generally be left to the people running the individual projects? You may decide to focus on Unity and UDK, sure. But what about when someone comes in wanting to make a purely 2D game, and they've already developed a large code base on top of something totally unfamiliar to you like SDL or Monocle. I'd say you'd be better served diving into a project using whatever tool makes sense at the time and building your general knowledge so that you can help future teams that come through. The only other type of organization that I can think of as an incubator would be a sort of collective, where you work on projects and provide a way for people to come in and get experience working on a game. Then your concern about choosing an engine would make a little bit more sense. Even still, you would have to factor in the skills and professional goals of your first batch of team members. What languages and libraries are your programmers familiar with? Do you have programmers? If you have all pixel artists then forget about UDK or Unity, look at something 2D like SDL, SFML, or even Flash with Flixel, FlashPunk, or the standard Flash graphics api. Since you say your background is in web development, maybe think about a design with multiplayer, or at least something that would require or benefit from storing player statistics in an online database so they could be publicly viewable through a web interface. A group that I worked with initially started writing 2D games in C++ with SFML. Later we switched to as3 and Flixel to reduce development time. Then we decided to give XNA a shot since a lot of our artists were primarily 3d modelers and animators and wanted to be able to hone and showcase their skills in that area. Unfortunately that project ended up going nowhere because it was chaotically managed and blew up in scope. That's another thing to consider, you probably don't want to start off the bat with the kind of project that UDK would be useful for. 

This question needs more lambdas. Note this is from a WIP, so there's some unused and implied-but-unimplemented features. Where you see the add your . I realize this is for a Gamepad and you're using a keyboard, but the grouping principle, or at least the notion of the action map still applies. This is probably overkill, but lots of fun! Setup function that maps the controls: 

If each skill is its own class, and each skill extends the Skill class, then that leads me to think you should have a field in the Mob class. Assuming you need to instantiate the skill for purposes of state management (like cooldowns and other things), then this Vector. would contain objects which are-a Skill. To search for a specific skill, it could be useful to give Skill a property called Name which is overridden by subclasses of Skill. Then you can search through a mob's Vector. looking at the name of each skill until you find the one you're looking for. A more robust solution would be to analyze your gameplay such that you don't even need to subclass Skill, and you could create entirely new skills by setting the properties of the skill class accordingly. 

Confirm the dynamic range of samples from getWaveData() Write each sample to a file as a string, then using somethign like Python or Octave (any tool that can read floats from a file, put them in some kind of vector, and then send that to the soundcard automatically) read your samples in and aurally confirm that FMOD itself is correct. Confirm your quantization step Having confirmed that sounds good, take the same data and read it into a C++ program that does the 16 bit quantization and again writes each sample out to a file as readable text. Now you can read that file in with Python, convert each int you read to a short in raw string format, and write that out to a sound file using the wave module. Play it back in your media player to confirm that it sounds good. 

If you're a C++/object-oriented kinda guy, you might find SFML easier to work with. It's very similar to SDL, except that is has an OO interface. It's not as widespread as SDL, but still has quite a large following. As for tutorials, since you're experienced with C++ you can probably get away with reading tutorials aimed at other engines and languages and apply the high level concepts, referencing your API and its help forums for specific issues you encounter along the way. 

Babycastles, the indie game arcade in NYC, is starting an initiative to help people setup similar venues. The software bundle they use for their cabinets is on GitHub: $URL$ It's still early in development, but it manages restarting games and generates AutoHotKey scripts. Since it was use for their exhibitions, it's setup to maintain just one game at a time. If you're looking to provide a Steam-like game selector for arcade machines, you might want to consider contributing to expanding these tools to add that functionality. The Babycastles site is redirecting to the Mozilla anti-SOPA page right now, but they post a lot of info on the Facebook page, and their Tumblr and Twitter accounts. Another project to look at is Winnitron. The way it works is they maintain a central database of games and high score tables, and anybody can build their own cabinet and request authorization. Then your own Winnitron will automatically download new games and update existing ones. They have a standard mapping of keys to the joystick and two buttons, and have a nice screen for selecting installed games to play. It's not really available for personal use, but if you'd like to setup a kiosk in a public location you can email them to get specs and the launcher software. 

It sounds like you're a beginner, and are concerned with investing time in a tool and not getting any transferrable skills out of it. The most valuable thing that Unity3d is teaching you isn't C#. It's teaching you how to work with a 3D game engine. Working with vectors, thinking about your asset pipeline, and how to translate input from a player into interesting transformations on screen that they can then use to accomplish some goal you set forth for them. Don't concern yourself with code reuse. I'm still working off of the assumption that you're a beginner, so you likely won't have enough code to justify being serious about code reuse, and having to re-implement some feature or translate it from C# to another language is good for you. Switching languages/toolsets as you evolve as a game developer opens your mind to new ways of doing things, earns you greater understanding of past problems you've already solved, and enables you to evaluate the quality of your future ideas for solutions to problems. 

You'll probably get a framerate dip if there's a ton of sounds starting up in one frame. If it really becomes a performance problem, consider staggering their playback across frames. Players' ears won't notice the difference, and you give the CPU some extra milliseconds to start mixing the samples. Rough crappy example that uses SoundEffect: 

It sounds like you're biting off more than you can chew. Try breaking this game down into something simpler. Build individual aspects of it into smaller games, then as you learn more you will be able to assemble the bits and pieces you've learned on the way into something bigger. 

The "main implementation" of OpenGL is whatever your OS or graphics card vendor provides. For Windows display adapter drivers it's generally OpenGL 3.3 (or at least that's what I got when I updated my driver today). For Mac, it's OpenGL 2.1, or 3.2 if you're on Lion. For iOS it's OpenGL ES 2.0. For Android, it's mostly OpenGL ES 2.0. GLUT is not an OpenGL implementation. It exists alongside OpenGL and acts as a cross-platform windowing library. It's also kind of old. Freeglut is a little more up to date, but it seems as though people are recommending GLFW as a more modern and featureful alternative. For Mac, I'd recommend installing GLFW via Homebrew, MacPorts, or Fink. Or if you'd rather just go with GLUT, version 3.7 is included on Mac. You just need to include it via instead of since Apple bundles GLUT and OpenGL as frameworks. You can also create windows and OpenGL contexts with SDL and SFML. If you're running on Mac, freeglut only works under X11. I don't think it's worth trying to get freeglut working with it. I just spent the last couple of days trying to get Nicol Bolas' tutorials to run on Mac, but by the time I was done #ifdef'ing things out, I realized that the shader code is all different versions as well, and I'm not yet ready to understand how to translate that between older and newer versions. Maybe it'll work on Lion if you fiddle enough with it, but I can't back that up. There's also the "Unofficial OpenGL SDK" which is a bunch of helper libraries (including freeglut, glfw and some asset loaders [note: the version of GLFW bundled with this doesn't cleanly compile on Mac out of the box]). Everything but freeglut and GLFW compile fine on Mac with some header tweaks. To install GLFW on Mac, just use Homebrew. If you're on Windows, the unofficial OpenGL SDK is actually pretty nice. I'd recommend it. I'm currently working through the aforementioned tutorials with it. I have yet to try OpenGL out on a Linux distribution.