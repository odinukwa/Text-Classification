This may or may not apply, but we would detect a difference between jumping/landing and falling so we knew when to swap to a falling animation, do damage for falling too long (not too far ;)) and the like. It was pretty much done by tracking how long a object was without a reference point. Anything on the ground, or any other object, had a reference to what it was standing on.. Not standing on anything? Then you were in the air, and after 1-2 seconds, you were 'falling' instead of gracefully landing :) 

The format that you load into your game engine should be specific to your game engine, and by specific I mean optimized for your target performance. What you will likely want to do, if you want to support multiple model formats, is to have a processing tool that will convert the different formats into the one for your engine. This is the start of an asset pipeline :) 

Every component should know by some unique id which object/entity it is a part of. I am not an advocate of using an Entity class to bind the pieces together. I do however know that people do do it that way. I honestly thing OOP is just such a line of thought for developers that its hard to get rid of them. The best argument I ever heard was the first one I ever heard however. If you have a central object you always wonder what should be in a component and what should be in the central object. Just avoiding having to ask that question all the time and come up with an answer was good enough of a reason for me to give up the 'Entity' object and link all components together by an ID. Remember to not think like a player in this instance. If you are a player you are looking on the screen and seeing an object that represents your player. On the display you can see how much health you have, how close to the lava you are, and that big giant rock about to smack you in the head. But to the game engine, to show your character it doesn't care what your health is, if that lava is close enough to cause you damage or strain or that the rock is now hitting you. For rendering a character all it needs is the mesh and texture data, positional information.. things specifically for rendering. The reason not to have separate classes for each entity is that you get alot of over lap of code.. Everything is like to have collision and health and a graphical representation and an action for it to go off and do, etc. The ways to solve having to write that over and over again is to either have trees to inherit functionality from or component systems so you can reuse the sub sections to build a larger object. I personally go with component simply because of ease of maintenance and update. I have been in the situation too many times where complex and ever growing inheritance trees make things annoying to deal with. (Might also be why I can let go of the Entity so easily.) The large builder class is like going back two steps, before there was inheritance at all so it all had to be in the giant FactoryThatMakesMeObjects class so I would have to say Really stay away from them. Having a PhysicsComponentFactory makes sense to me, something that deals with creating, maintain and updating all the physic components for the game. I am a bit confused as to why, in C#, a simple GetType() is not giving you enough Run Time Type Information. If you were using C++ then I would suggest using a template that would create a static pointer to RTTI for the templated parameter.. It would give you a nice static pointer uniquely identifying it as that type, great for comparison and going up the tree to see if you are a child for some base type.. but I would think the very nicely done internal reflection capabilities of C# would solve that for you. Taking RTTI into a component system and you should also be ideally keeping like components within their own groups. So you are not mixing the component that tracks what an object uses to render itself with the object that tracks its health, its gear, its physics.. any bound AI to the object, a motion object.. etc.. They may all be linked together by an ID but they have nothing else to do with each other so should not be in the same list.. there should never be a need for a large LinkedList_AllTheComponentsInMyGame.. But a LinkedList_PhysicsComponents, LinkedList_RenderableComponents and so on. All else failing, in a component system here is a potential way that you could determine what an entity is when it collides with another entity so some action can be taken. 

Since they are also integers you could use a switch statement if you wanted as well (assuming the patterns are exclusive of each other). If this is not a matrix of Off and On values then let me know and I will try and update my answer. Hope this helps. 

This type of programming is generally used, if available, to give AI Agents their 'personalities'. Using the different values that are avaialble you can try and breed the 'best' stats for an agent to survive and thrive within the world but it is not something actively done during game play for one very good reason. Its a game. You can have the computer learn to constantly defeat the player, but who is going to play a game that you can only lose at? The point is to present a challenge, and using genetic algorithms you can try and find combinations of AI to play in certain ways to represent easy, medium and hard settings. Or, for example in RTS games, play styles like a the rusher or the turtler. These algorithms are more applied to developers looking to tune their game as opposed to being actively used in the games after launch. If you read the Game Programming Gem books you can find articles in them that give examples of how these are used for RTS games to help balance AI out. 

If this is not an online tracked competitive type game: Let em hack away man. You can spend way too much energy on things like this when people who will play the game, will just play the game. Those who want to hack it will never really want to play it, they just want to hack it. If it is an online competitive type game: All you have to do is store the hashes on a server some where with their login information. If the hash from their save file is not valid, then their game is not valid.. Start over, or revert, or whatever :) This is fairly basic but there again, we are talking about games, not bank accounts and such.. And always remember.. hobbyist or professional gamer developer, there are Hundreds of people out there who are going to try and hack your games. Put in enough effort to try and preserve the enjoyment of the game for those who are going to play by the game's rules, and thats about it.