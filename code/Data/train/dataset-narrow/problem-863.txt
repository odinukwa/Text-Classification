Here you really have to be consistent with your choice. There is no reason why a statement brings benefit to your code, as you are iterating arrays and not an object. It makes the code less readable if such unexpected twists are added. Subtopic variable scoping The use of the keyword in JavaScript and it's scope has been confusing since the dawn of JavaScript. It is important to know that in JavaScript, defined variables are not block scoped, but they are function scoped variables, as this small snippet demonstrates 

It returns it's own promise, and uses the . In case the result is returned (or another error is thrown), the is called and the promise gets handled by either resolve or reject. In case the interval occurs, the promise gets rejected, and the is also called. Note that if you run the test (at least the es6 one), you can see the time it took before the timeout occured, and it will not run longer. Neither does the then method of the fetch still execute. It is true however that your httprequest will still be open, but I don't think that should be such a huge problem, as it will not interact with your own code anymore. It is still important though to handle the catch of the fetch and pipe it through, so that the interval gets cleared, but that you also get notified of the other errors that might have occured during the request. 

This you could extract to an own function if you like (I don't think I would need it when I check if I know understood your code correctly at the end of the response) 

Ofcourse, as Vogel612 metnioned in the comments, this is not the most optimized way. I just presented it as a way that it contains less code, and that it is separated in single utility functions. The code from coderodde is ofcourse lots better. Instead of deleting my answer, I will simply add 1 more version how you could do it by using ES6 and classes 

I think one of the most common errors in today times, is for example handling potential errors, as you try to do here: 

more about plugin creation for jQuery can be learned here Currently, I believe your method takes a bit to much control, and as a user of the slider function, I cannot really do a lot. I can only start the slider, I do not have any actions available to me where I could stop the slider (eg: ) or decide how fast it should slide, and though you offer the it is completely unused at the moment. There is also no way to interact with the slider from a different place in your code, to for example show a specific slide on the click of a button. So I think your plugin is to much in control. 

There are excellent suggestions in the above text, and I'd echo most of them. The key element in writing better code, though, is to understand the goal of your source code. This might be a bit above your level, but think about it this way: Why do we write source code in higher level languages? Why does a language support upper and lower case? Why does a language have support for white space? Why does a language have support for comments? The truth is, the java compiler doesn't care about most of those things (mixed-case aside). The reason we write in higher level languages is to make it easier for someone else (who may be you!) to understand what was INTENDED by the software. Source code is for HUMAN BEINGS to read and write. So my advice is to make the source code as clear, easy to read, and easy to understand as you possibly can. As h.j.k. said above, you should camel-case method and variable names, and Pascal-case type/class names. Why? Because it's the convention that's used by programmers all over the planet. It makes it easier for other people to read software you've written, if you follow the convention/style that they're used to reading. Same rules regarding white-space, such as indentation. Matching up braces to find the blocks that are under an if/then/else is nobody's idea of a good time. Make it easy for them to find where the blocks end. I would differ with h.j.k. on one point, though, and that's the use of multiple return statements in your Answer() method. I can certainly see his point; his way of thinking reduces the number of lines in the method, and makes it easier to see at a glance what is being returned by the method. These are all admirable goals. However, in non-trivial software, I much prefer to see a single return statement at the bottom of the routine, because it means that I can set a single breakpoint at the return, and I can see what the function is returning in the debugger. This is a big help when developing/maintaining software written by multiple people over multiple years. I also prefer that the local variable being returned is initialized to some known-good initial value. This guarantees the return value from the function will always be set to SOMETHING. That's one thing you're not doing currently. You're depending on the global variable to be zero, and not explicitly setting the TheAnswer to any value. What happens if the user enters an operator that's not a */+-? This is becoming long winded, so I'll try show you what I think it should look like. DO NOT TURN THIS IN AS YOUR HOMEWORK. It will be very obvious to your teacher that you didn't write it. I'm not going to fix the variable declarations and such, only attempt to show you how other programmers write software. Trust me, there's a ton more I could do to this, but I'm not fixing any of the errors you might have. You're asking the right questions, and I'm glad to see you want to do better. An ancient book regarding this very topic was called "Professional Pascal" by Henry Ledgard. Don't let the Pascal in the title fool you; it's about writing professional grade software, in any language. Professional Pascal (Google Books) I hope this helps. -john 

You also define some variables only inside the for loops and although in most languages that would be fine, in JavaScript 5 they don't belong inside the for loops. ES6 really made huge improvements by adding the block scoped keywords and , so if you would have the chance to use them now, I would really suggest you do so. So as a rule of thumb, keep all definitions on the top of your function, or where you define the first variable. Extract similar code to functions Code duplication is one of the most annoying things in a code base that you could have. Even if you know your code perfectly, still changes to certain parts of your algorithm could be forgotten if you copied the code to other parts. One piece of code that could definitely be extracted into a function, would be this beautiful block of duplication 

Suggested rewrite ES6 If your code base is not to large, or if you are willing to put the time in for refactoring, I would suggest you wrap fetch with your own function, like in the following code sample. You know that will return a , so create your own version of , which you could then export if necessary, and redirect your files that point to the functionality to your own implementation. 

This would now be an abstract class (ie: a class that cannot be instantiated), from which the method has to be implemented still. Also note, that this change means that all methods now changed from modifier to the modifier In the implementing classes you can then implement something like: 

According to your specification, a keyword is defined by a name + a number. It can ofcourse be that eg: would be followed by a number, if that would be the case, I think you could add a comment to the array why these appear to be different as specified. Variable naming I think, in general your code is quite confusing to read. You seem to be using rather unusual names for your variables, some examples: 

I guess if you just want to validate, you could write something like the following, though i'm not sure if that really answers your question. 

This only gives you an idea from how you could reformat your code using this pattern. The last piece of code can then also be rewritten like: