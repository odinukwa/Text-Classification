Any specific reason you're using 258 x 258 pixels heightmap/texture? Two rows and columns of pixels possibly force the graphics card into making the texture up to four times as big as necessary which might as well cause those black lines, since it might not be able to handle textures that aren't the power of two for their width/height. The unused pixels might be filled with some other color (like black), which could then cause them to bleed into their neighbours when upscaled. 

There's no best approach, because it always depends on the actual use case and your overall architecture. Using IDs or GUIDs won't necessarily be easier to use or replace. Just remember that you'll have to copy and use those as well. Especially GUIDs are typically rather long and hard to remember without copypasting. Same can be true for raw numbers of some kind. As such, "talking" names are probably the best approach, even if this involves some more writing or replacing. What you can do, is using some fixed length identifier. For example, you could use 4 alphanumeric characters to identify everything. This also has the added advantage, that you'll be able to easily cast the ID (string) to an integer (just keep byte order differences in mind) and compare it the fast way. This could also be extended to the file name as well, so you won't have to refer to full paths either. For example, if I use "NMY1" for my first enemy, it's data would be stored in the file "NMY1.dat", with the texture sitting in "NMY1.png", script code in "NMY1.lua", etc. Another thing would be modability: If you want users to be able to easily mod your game, try to avoid overoptimizing it. I.e. prefer talking names over abbreviations, don't use raw IDs or GUIDs and use something easier to read/understand/copy instead, even if that means you might have to update lots of references as well. If your data gets too complex to easily update/check, write tools to do it for you (and to verify integrity as well) or rethink your approach. 

There are many different approaches to this. This also depends whether you always want to fill all your rooms or just a few of them. Here's one possible approach not using all available rooms. 

Maybe I'm missing something right now (bare with me; it's late in the night). Essentially you'll just need two tiny steps here to get from world space to screen space (i.e. from world coordinates to screen coordinates): 

This is probably the easiest way to do it - not overcomplicating it at all. However, I'd work with constants rather than variables (assuming those are available in your chosen language). 

You probably had some problem in your code, because basically collision detection can always be resolution independent, so it won't matter whether your tiles are 8x8 or 1024x1024. The following would be just one possible workflow to achieve this. Note that I didn't care for strict casting etc. so there might be cases where you'd have to cast an to go get the needed precision or where you'd have to cast a to to get the modulo operator to work. Determine the tile where to check for a collision. How you'll have to do this really depends on your coordinate system. It could be as easy as rounding down your coordinates: 

In this example would be the horizontal coordinate, would be the coordinate facing to the back or the player and would be the height above ground. By multiplying you're essentially changing the camera's angel, while using an orthogonal projection (since there's no perspective correction/depth). You could as well use the following transformations for : 

That's exactly the reason for using polymorphism. If done right, your system will automatically call the apropriate member, without forcing casts or any special handling. Have a look at the virtual keyword. Another short example: 

Is localization important for a game? Yes! (No matter tha actual platform or amount of text). Is it a must-have feature? Definitely not. This might be different for some platforms, but I don't know any forcing you to provide translations â€“ neither Google, Amazon, nor Apple. 

I don't really know what you're actually drawing, but you should start with some simple culling. In essence, don't draw stuff you can't see anyway. This can be a bit tricky in 3D and it's partially done by the graphics card anyway, but it will still have to try to draw things, which will still cause work to be done. Also try to avoid creating new objects in your drawing code, unless they're really small/primitive. I assume this is supposed to become some kind of minecraft like block landscape. 

Again coming back to Secret of Mana, this was used rather well to let characters perform simple emotes, e.g. while talking: Nodding, refusing, etc. 

Thanks to double buffering, this isn't as noticeable as you might think (i.e. there's no flickering). So what you'd have to do is the following: 

Of course you can do more complicated things than just adding and (like calculating some hash). Just keep in mind that the result should be different, even if you change or only. 

There's nothing wrong with this code and it's running perfectly fine. Also, based on framerates and the number of updates per second, this will be as smooth as it can get. However, as you lower the rendering framerate, you might suddenly notice stuttering, even if you're rendering at 60 FPS. For simplicity, let's assume your game updates its state 60 times per second and your rendering is limited to 60 FPS as well (slowing the loop down to this rate, either through vertical synchronization or by being busy doing the actual rendering). So you've got a ball that is moving at 1 pixel per update. That means, in a perfect world, it should move 60 pixels per second, one pixel per frame. So theoretically, every 16.67 ms the ball moves by 1 pixel. As long as this is true, the animation will appear as smooth. However, let's assume in one iteration your accumulated time is only 16.60 ms. This means there won't be any update. The result: The ball won't move for one frame (since no update happened). The next frame there might be two updates happening at once (since the accumulated time is now 34.03 ms) and now the ball moves by two pixels between frames. Things like this might appear as some kind of "micro-stuttering". This can be hard to notice, but depending on your actual game layout it might be pretty obviousy. Can you fight it? Yes, but it's a bit tedious based on how your draw/update your game. You'll have to keep the previous screen's state (just taking a screen capture won't be enough; this isn't about blending two images). In our example, you always keep the position of the ball during the last calculated frame. To determine the actual position for drawing, you'd then use something like this: 

Usually, you can't really separate window and input handling properly (when using events rather than polling the status). IMO this is perfectly valid and not a part of bad design (reimplementing everything twice would be). I've just made a quick "sketch". It's been ages since I did UML, so might include mistakes - but it should get the idea across: