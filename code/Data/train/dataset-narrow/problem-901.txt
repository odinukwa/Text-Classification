You should create a helper extension or function for such lines, it's pretty ugly to repeat it so many times. Even two times is already too many. 

You should use names that precisely describe what a method is doing. This one is not just getting file content. It changes it! This is not clear for anyone that would use it. Instead you should call it because this is what it does or rather should. Currently it does not only changes the applincation name but also reads the file. Then the does everything else like creating paths and saving and replacing the file. All this should be separated. You should read about the SRP - Single Responsibility Principle - it's the first step to maintainable and testable code. After applying all the suggestions you code could look like this. You have now not just two but four methods. Each of them doing only a small part of the job. Should you need to adjust something then you most likely need to do it in one place which is the goal. Notice also that is not lazy by using the so we call to actually execute it get the results. 

I wonder why did you write this method? You can replace it with that, strangely enough, you already use in another place and even the exact same overload: 

Where the is now also abstracted by an interface and can be faked for testing or exachnged for another navigator later: 

And for testing purposes I use a which allows me to specify any date-time I want. E.g. it could be a fixed timestamp or some other predictable generator. 

The implementation of the extension changed slightly too because it now has the new parameter. Without it the couldn't cancel other tasks because the fuse would not pass any messages through. 

Another unecessarily long line. A dictionary implements the interface. If we change the type of the property to 

One of the APIs that makes it so useful is the method that is like a for but without copying anything. but 

There is actaully another solution that utilizes the extension. This means you first select all reviews with at least two users but remove those where the restaurant does not have at least three reviews. This requires to write a new that I find is an overkill for this but on the other hand the clearly tells what kind of results we don't want to have. Anyway, the alternative solution: 

The is a very helpful feature. But creating those strings is an extremely tedious task. I wanted to make it a no-brainer so that I can create them quickly and at the same time make sure that all of them are formatted the same way so I created the following tools. 

so why not use regex for this and split on every occurance of . You then trim each word and filter the empty results out. Then you group each word igrnoring its case, sort the groups by count in a descending order and create strings. 

So the method runs and the result is correct. But has it actually created a new user and add it to the repository? How about this operation? 

ASP.NET should take care of it not you. Your job is to just give it some data that should be turned into a response. It is not the right place to decide about the format of the response or even serializing it by yourself. 

RestClient I reduces the main interface to just one method for invoking http-methods. Details are hidden by the that provides the required flexibility. 

If you have more setting groups then just add interfaces for them too and implement them in the same way. 

I don't think it's a bad practice at all. What you did is called encapsulation. It enables you to exchange the underlying configuration provider (currently the ) to something else without breaking your application because it doesn't rely directly on it. It's also called the Dependency Inversion Principle the higher module (your application) relies on an abstraction (your ) and not on the low level module (). Usually it's build upon abstract types (or interfaces) but a lite version of this could be your settings layer. 

Everything else you can track with the . I added a new property that is nullable and empty if a notification couldn't be sent. 

I don't see much value in this method. Clearing an empty album does not make any harm so I would allow doing this anytime. 

because of the not clear intention I had a hard time understanding this short code. The descriptions says something else then the implementation. 

How does this make sure the target does not exist? It counts existing paths so put it a new method and call it . You should also craete a constant for the magic . 

This is such a mess that you can throw all these tests away and first rewrite the code completely then write new tests. 

GetLargestWholeSize This should be an extension method as it actually provides additional functionality to the that goes beyond the normal unit conversion. SizeScale.None I don't think a value without a unit makes any sense. The parameter of the should be of nullable type rather then none. Better then would be but the parameter should still be nullable and undefined should cause an exception instead of a silent conversion to another type. 

To me it looks fine. Just some minor adjustments: I think it would look even nicer if you defined constants for the magic numbers. 

If what you have posted is really only a part of something bigger then there is a much larger problem then this three nested loops and you should address this issue first. 

IEnumerable With your current implemetation you could remove the method and further simplify the repository by implementing the interface for this class. DocumentFactory This class should only know how to create documents. It can have methods for creating many different types but nothing else. 

Inheritance If you want to do it with inheritance then the new service should be derived from the legacy service that is derived from an abstract base service. The overridable method should then be called . The base service just calles the core method: 

This has the advantage that you can provide any to the decorator and test the new logic independently. You can easily create a test-service to fake the legacy one. 

There are methods that scream louder for improvement that the three you mentioned. For example these: 

I modified your so that it uses the base class constructor and passes it the actual connection. The unity documentation states that: 

wouldn't be necessary as you could specify the validation rules via the method. They would be better encapsulated and directly related to the property they validate rather then being a part of a large method responsible for validationg several properties. 

It's so hard to parallelize this becasue has a hardcoded database dependency that it shouldn't. In fact it should get it via a parameter like does. But not only this, it should also recieve the owner via a parameter. The very simple version of it should just do the job of setting the owner, nothing else, no database creations, not looping etc: 

ColumnDelimiter & RowDelimiter If these two properties cannot be null you should requrie them via the constructor instead of checking them in the method. Also if the user can change them later then you should check the values in the property setter instead of throwing exeptions later and causing astonishment why isn't this working. 

There are a couple of severe issues with your code so it won't work the way you think it would and you will also loose a lot of useful information. 

You can use the extension to group the emails by validation result. To access the collection you use either or . With this approach you can split the invalid/valid email handling. You also should put the very long pattern in a constant. 

The next method is the . Internally it uses but tries to parse the input as as long as necessary. There's no need for an extra variable with C# 7. 

The final extensions are implemented in this class that for each and type generates, compiles and caches an expression (with some help of other classes). 

Why and ? Because I assumed the windows coordinate system. Alternatively you can use the from the namespace. And an example: 

This will be a very short answer because I will just suggest you an alternative method to filter the properties. I guess you use json.net for serialization. If so, you could write your own contract resolver and actually super easy filter the properties. Here's an example from the documentation where only properties that start with an are serialized: 

I think creating such objects is generally a good idea and I often do it myself but they have to offer me some advantages over using a primitive. In case of this code I don't see them and the examples you linked give bad advices. 

Your code could e.g. parse the query string into a dictionary which is much easier to use then always run through the entire string (worst case scenario) with . Parse it once and reuse the results. I would, I'm lazy - but lazy is a good thing - it makes you write DRY code. 

You should not need the second call to . Without parameters it should already trigger an update to all properties. 

I don't want to update the value. I just want to set a new one via the property. The object tracking it should be able to figure out what's going on which leads me to the next point: 

You can then put the message there and just throw it without writing the message every time. You should avoid throwing the . 

Public mutable fields are generally a bad practice. You should use properties (if possible read-only) (immutable objects are easier to debug): 

I don't think it's such a good idea to rely on the result order of your stored procedure. You assume that the first row is always adds and the second row is deletes. I find it'd be better if you included this in the result themself and then created a dictionary based on the value in that specific column.