For the most part, the code above is a simple copy/paste of your code, with some restructuring, and variable names no longer have the qualifier. So, with the above code, we can have: 

The problem with your while loop is that you are using instead of .... you are assigning the values to the variable inside the loop, and it is successful, thus accepts all characters...... 

is a fantastic commandline tool that validates and reformats your XML to be consistent. I recommend it to anyone using XML that has access to Linux 

Your current solution is actually pretty good, conceptually. There's nothing wrong with the variable. I am not sure why you want to remove it. The loop is logically a good solution, but there's a better way than that, though (better because you can make the system do it for you....). 

which runs the function on all the input values, and returns the accumulated string results. What's nice is that I can now create other functions to test performance, for example and call: 

That is a 36 megapixel image, and it takes 7.0 seconds to process. The transformation of those pixels takes 1.3 seconds at a rate of 37.2ms per megapixel. A small file on the other hand, looks like: 

What does the above code do? It converts the long input value to a string without any spaces. It uses the and from that, it subtracts the full number of blocks that have to be padded. So, the following table gives the 'input' and 'end' result: 

Concept You have called this a "Longest Increasing Subsequence" problem, but it's not, is it? It's counting all possible sequences of a specific length, not just the longest. As a result, I think you may have confused yourself in a few ways.... Naming Your variable and method names are ... horrible. Variables should always be useful names, and, while and are referenced in the problem specification, S is not. Additionally, upper-case names are not encouraged... so you should have and instead. The method name is also off, it should be , and where does the in LCIS come from? Standards Your code compiles OK (with a warning about the missing return in the main method) with basic C compiler. This makes me think you intend to use C99 which compiles it without warnings. But, in C99, you should declare your variables where they are used, not at the beginning of the blocks. For example, you should declare inside the for-loop. Globals Globals are to be avoided. Algorithm Your concept of memoization is good, but I am not convinced the recursion is doing what you think it does. I am not convinced the memoization is used at all effectively. Frankly, I struggled to follow your algorithm, in part because does not tell me much about what is being memoized... I started hacking your code, and ended up restructuring it as a set of nested loops. The resulting complexity is somewhere around \$O(n^3)\$, which sounds really bad, but, for the problem given I am not sure can be improved on... A large part of the complexity is in the determination of the paths, not the combinatorics required to compute the count. I am likely wrong here somewhere, but my performance of the resulting code is more than good enough to be in the right ballpark... So, I use memoization as well, the system I use is, for each node, starting from the last, to record the number of increasing paths, and how long they are, to the end of the sequence. The last node, for example, can be the last node in the sequence, and thus has a count of 1 in path-length 0 (0 because I zero-base the path length - 0 really means "there is 1 path starting from this node where this node is the last member too"). With that system, I can then work backwards through the sequence, and simply add up the paths that have the right length. The critical method looks like: 

in the side of the program. This is because if the number was it would have gone to the first block. Then in general, looking at the logic, I can't help but think there's a trick you are missing: 

The split there, is "split on all sequences that do not contain digits" Java8 may help (with an added filter to remove empty values, not in the loop above), with: 

There's a big change in there from a code-style perspective. Java generics by convention have just a single-letter token. I have chosen the names for State, for Move, and for Agent. I was tempted to make the A a for Player. Your call. A single-letter token makes it easier to see where there's a generic template in place. It also makes the declaration more concise. Before I explain the declaration, here's the Agent interface: 

(Note, there's something important in there, I use and not . Using primitives in Java when you can is almost always a better idea for performance than using the full Object version, like ). So, the above system begs forgiveness when the data is broken.... what about prevalidating the number...? The code is basically copied from the Javadoc: 

The is also a problem. It should be declared inside the function.... but really, you don't want goroutines here anyway. Promise. The up-down-left-right slice could also be simplified a bunch too without the routines. No need for the closures and shadow-copies, and so on. Instead of the map, I would consider having a boolean 2-D slice that matches the same dimensions as the input data (screw the memory footprint, worst-case memory footprint is probably less than worst-case memory for the map anyway) All told, I would reduce the code to something like: 

This will need to be a little bit of a history lesson, and tutorial..... History In the good old days, Java server programmers would have one Server Socket that listened for connections, and for each incoming connection, would create a thread to handle it. The threads would block, waiting for IO from the socket, and that's OK, but not great: 

In an actual implementation, the will sort the data. My particular interest is in the second stage of the process, the . This intrigues me, and is what I have studied, and reduced to an \$O(n)\$ operation. There's a "simple" function you can apply to each index in the vector, and determine, from that where each value should go. The new location of any index value is given by: 

when, in fact, nothing in those lines of any consequence changed..... By not adding the braces when you created the code, you have made the maintainability of the code much more difficult, because each maintenance requires a lot more effort, and a lot more confusion when trying to identify code progression. What saved you 2 seconds when you wrote the code, is going to create 5 minutes of effort later for every single person who investigates why you changed lines of code, that you did not actually change.... and those 'unchanged' but different lines are the most complicated parts of the code... By not adding the braces, you are essentially saying, "My 2-seconds saved is worth more than the hours? of time that someone else has to consume understanding revisions of my code). Now, if that is not enough, whenever work is done, bugs can be introduced, and the amount of bugs is typically proportional to the complication and effort required to implement a change.... By making changes to your code more difficult, you are increasing the amount of bugs that result from your laziness, because other people need to correct both the code, and your laziness in the future. Note here is the diff for adding in a count of the number of FizzBuzz's using your code: 

The above solution will have close to an \$O(n)\$ time complexity, because, the worst case is a 2-times iteration through the data. 

This loop now returns the value at which the expression fails.... and we can use that in our main loop as follows: 

I played around with this problem, and specifically targetted an overflow-safe solution, so that will work. This is the code I have. Note that I use a class, which allows me to keep a state, and then add to the state. On my computer the test for returns in less than 2.5 seconds. I do not know if this is a good result, or not. Also, I compared my results with a naive implementation for relatively small values. Make of this what you will: 

Note, I have changed the parameter to simple instead of . Putting it all together, I have your code running as (without the additional char as a constructor to the Enum...): 

Concept Review There are a number of purpose built tools to do this job already. The one that comes to mind first is 'shred'. shred is installed by default on all Redhat and Ubuntu systems (in coreutils package on both systems). It is also installed on my RaspberryPi, so, it is ubiquitous. Shred does similar things to what your script does, but it will be faster, and more secure, presumably. Running: 

Your recursion is doing far too much, and it can be simplified a lot. Additionally, you are creating a lot of Data instances, when a simpler mechanism would be to call it a and reuse that single node for all values.... 

The above regular expression looks for a word-boundary that is followed by a character (where "a character" is a letter, digit, or underscore). Then, you have a sequence of sentence parts that need captialization, and it can be streamed easily: 

All values up to are smaller or equal to . Your code makes some sense to me now. Note, the algorithm you use to partition the data is a little unconventional... though I can't see a real problem with it. A conventional approach would have a left and right index that progress from the ends, and then swap values from each side, and meet in the middle somewhere. Your approach is OK, though. Putting it together With these changes, putting it all together, you will need to change the calling routines: 

In this case, I would consider using a CTE to contain the columns you are interested in. This saves having to declare the variables, and also saves the inserts, etc. The basic concept is the same as your second query though... 

the top value shows that the sum of factors for 284 is 220, and the sum of factors for 220, is 284. Taking the first value, we know the sum of factors, and we take all the values that sum to that (in this case, just 284), and check whether 284 happens to be the sum of some other value's factors. Then we check to see whether one of those other values is 220. 

Note, there is no actual instance in there, all just paths.... Also, there is no Watcher in there. There is no need to create the Watcher in the constructor, it is only used in the method, so use it there. In your method, the try/catch is good, but I would add a finally: 

Now, all your logic is isolated in to methods. All you need to do now is reduce the code duplication. The Date Picker is an obvious candidate. Both the start and end pickers use the same code, but with a different target . You should extract that code in to a separate method that passes in the target active selector as a parameter. 

A huge amount of that code is 'garbage', afraid to say. You already have all the basic pet data stored in the class... so there is no need to duplicate it all in each pet type class (Dog/Cat, etc.). For example, your class should remove all the duplication in then simply be: 

You pass in the file-name "test.txt" when you call the , and that becomes the parameter. But, you don't use that at all, your actual file-open is: . Use the ! You re-seed the generator each time you call the transform method. You only need to do that once. Seed it in your method, or even as an function instead. 

That would be a neat solution, where you have a bunch of rules that you know apply to the messages of a particular type, and that you can then just apply whichever ones are appropriate. That would be the most efficient at use-time too. How would you implement that? Using some pre-processing, of course, and a new class. This preprocessing is key, and the features you should look for here are: 

About Exceptions In general, exceptions should never be part of the anticipated program flow. Using exceptions to test conditions in the data, is wrong. On the other hand, that is not what you are doing. You are taking an anchor/link from an HTML document, and I would expect that to always be a well-formed URL. Additionally, a poorly-formed URL in the supplied context is not a program fault either, so propagating an exception is not useful. You will need to handle it somewhere else if you do. My only suggestion is that you should be logging it somewhere... don't you need to know that you have HTML pages with broken links? Concerns You have some programming problems.... I am unable to tell if it is serious, it may be fine depending on your circumstances... consider: 

Note that I have a concern about the output here. are you sure the last byte should be , and not (i.e. shifted two bits to the left?). Just checking... different algorithms expect different things.... 

I strongly recommend that you read through the Concurrency tutorials to see how it is applied. Java8 In Java8, a 'simple' function can be declared to process a file, and then the various files/urls can be streamed in parallel through that function, returning a success status. Using internal concurrency you can update a progress thread too. Something like: 

This is never going to generate the value 29... It is a common mistake to make when using which is to forget that returns a value from (inclusive) to (EXCLUSIVE). In other words, it will never generate and you will thus never get the value . The right approach is: 

The code looks nicer this way, but requires scanning each table three times (which I think will be better than the potentially thousands of times it may have to happen with your query...... I have put together an sqlfiddle for this 

Your code here is hard to follow because your code style and format are inconvenient. Structures like this: 

When you test the root, you will determine that both sides have the same height, yet, the tree is far from balanced. 

Note that there is no actual table there needed to get the badge source, metal, and name. It is all virtual. Additionally, the data is all stored in columns. This is convenient for the next stage. Reduced manipulations and case statements The second phase of the operation combines the user badge data, with the above rankings. Regular and Tag badges need to be handled slightly differently. There's no way to avoid that, but the classification of the badges is simplified significantly by processing data in categorized rows, instead of in columns. Let me explain: the report requires that each badge is accounted for in 3 groupings, the badge source (regular or tag), the metal (bronze, silver, gold), and then finally in a total badge count. Instead of fussing with copying data between columns based on case statements, it is actually easier to just select the data three different ways, and create different rows for each group.