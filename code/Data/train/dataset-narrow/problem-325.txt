These addresses are nowhere in the internet routing tables, so if you would send a packet with a destination in these ranges on the backbone of the internet, they will simply get dropped. This is because millions of people use the same addresses. These addresses need to be translated to something useful for the internet. This is where Network Address Translation comes in: We have two computers: 

Link-state and distance vector aren't actual routing protocols, but types of routing protocol. Since different environments have different requirements, there are different routing protocols. The protocol internet routing works on (BGP) is a distance vector protocol, because it is extremely scalable. Also, you don't want to be dependant on the link state information from other companies to route your traffic. You basically only want to know if they can get the traffic towards the destination and if they are closer to the destination than yourself and the other systems you are connected to. 

The definition is correct. On layer 3, IP addresses are used to identify machines throughout different networks. Basically you can think of it like this: 

In this picture, when PC0 sends a packer to PC1, it will send a packet with source IP address 192.168.1.10 (it's own) and destination address 192.168.2.20 (PC2's address). PC1 knows that PC2 is not on the local network, so it will hand this packet off to his default gateway, Router2. It does this by sending this IP packet with source MAC address his own MAC address and destination MAC address the address of Router2. Router2 will look up where to reach 192.168.2.20, which is through Router0. Router will replace the MAC addresses (source MAC: Router2, destination MAC Router0), but not change the IP addresses. Router0 will forward the packet the packet to Router1 in the same way as Router2 did. Finally, Router1 knows that the packet is local for him. So he forwards on the packet, which will end up having: 

A 'normal' GRE tunnel is a used as a point-to-point connection. A /30 (or even /31) would be a better use of your subnet space. There also exist multipoint GRE tunnels, such as DMVPN. Here you can have multiple tunnel endpoints connected to one tunnel interface. In that case, you will want a bigger subnet. 

Which interfaces did you link in GNS3? Usually the em interfaces are used. You won't have unit 0 defined by default. Move your interfaces from me0 to em0 on the respective devices. This is assuming that your GNS3 links are setup to map em0 on both devices as a connected link. set interface em0 unit 0 family inet address x.x.x.x/x Usually with Junos Olive\GNS3 you will not use ME0... the only interfaces that should be used are emX or fxpX depending on what kind of emulated interface you're using. Ideally if you use Intel Pro MT series then emX interfaces will appear. If you have no active interfaces or routes then no table will exist, default Junos behaviour. 

Beacon frames contain timestamps which the client uses to update its clock. Technically it does know when a beacon arrives due to this. A client is expected to wake up and listen to a minimum of one beacon when the listening time is up. HTH. 

RSTP needs backwards compatibility with STP switches. Thus Discarding state merges Disabled, Blocking, Listening into one. Ideally if running a complete RSTP topology then discarding becomes practically unneeded due to the explanation below. In STP BPDU will only be sent from root bridge > down, therefore non-root bridges would only forward on BPDUs that are received from the root-bridge via their root port. Therefore topology change will mean a longer convergence time as the TCN has to be propagated to the root bridge first then from the root bridge out to all remaining bridges in the switching domain. For STP Hello(2 secs), max age timer (10 x hello time, by default 20s), then 15s each for Listening and Learning. If no timers are touched for STP and you haven't enabled any add-on features like backbonefast or uplinkfast then you can be looking at ~50s for convergence time. In RSTP all switches can send BPDUs every hello time period not just the root bridge, the BPDUs carry up to date information. This enables faster convergence as the switch that determines the failure can advise the rest of the switching domain(bridge) of the TCN(Topology Change Notification) immediately. As the failure detection time becomes 3 x hello timer. Therefore if the hello timers are left at the default of 2 secs, detection of a failure can happen within ~6 secs. RSTP also has two additional port states: Alternate port : Technically in discarding state but is allocated as a alternate best path to the root-bridge. If the current root port fails the alternate port will take over. Backup port : This port is allocated as a redundant designated port. If there is already a designated port forwarding for that segment then this port will remain backup until it is needed. Technically this port is in discard state until needed. One more point RSTP marks edge ports as ports connected to end devices (No BPDUs expected on this port). This enables STP 'portfast' features to ensure the host port comes up as quickly as possible to avoid dropping DHCP packets etc. These are the main differences - Hope this helps. 

If you are talking to a machine on a different network, you only need to know the IP address. If you are communicating with a machine on your local network segment, you need to know the IP address and the MAC address. 

(For the following I will ignore any DNS lookups or layer two action, since that isn't the relevant part for the NAT story.) Any TCP connection is a tuple of four parts: 

I looked this up in the Cisco documentation and I tested this in IOS 15.3. The smallest reoccurrence for kron is 1 minute. I tried setting a lower value, but decimal points were not accepted. 

NB: For the reflection to happen, the RR does not have to be able to route to the destined networks. All calculations and validation of what goes into the routing table, will be done at each router individually. 

Basically, the logic is as follows: For level 1: flood all the connected and redistributed routes you know to all the level 1 neighbors in this area. Set default route to any routers with level 2 capability you know. For level 2: Import all routes from level 1 routers you know, flood to all level 2 neighbors in any area. (Please note that you need routers that are both level 1 and 2 to make the translations) Every router floods any packets they receive to their neighbors according to those two rules. The information in these packets are in the format Type,Length,Value (TLV). Using TLV's means the following: 

Every router needs to know where to route their packets. The N900 will send ping packets to the load balancing router with an IP address 'closest' to that router, so 192.168.20.X. The load balancing router knows how to route this, because it is directly connected. Your PC will send it's packets with a source IP address of 192.168.10.10. If the load balancing router is only configured with a default towards the Huawei routers, it will send any reply to your computer to the Huawei routers. It will never reach your computer. What you need to do, is make sure that both the load balancing router and the Huawei's know where to route 192.168.10.0/24. They only need to know the next hop, So for the Huawei's, the 192.168.10.0/24 should point towards the 192.168.30.X address of the load balancing router. The Load Balancing router in turn needs a route for the same subnet to the 192.168.20.X address of the N900. Note that the only reason to give the Huawei's a route for 192.168.20.0/24, is if you wanted them to be able to reach something on that network. They don't need to know this subnet to reach the computers. 

1) Yes the Primary vlan is the entity that homes the shared subnet for community and isolated vlans. Why would each switch have their own Primary vlan address? (Is your switch management vlan the same vlan as the Primary vlan?) Thus I imagine your core switch is performing MLS(Multi-Layer Switching) and homes the Primary Vlan SVI? 2) You don't need to define three different isolated vlans. The purpose of the isolated vlan is to only allow communication between an isolated port and promiscuous port. By definition the isolated host will not be able to communicate with any other type of port other than the promiscuous port. Just trunk one isolated vlan through the pvlan domain and utilize it. Another note is that a Primary Vlan can be associated with at most one isolated vlan and many community vlans. Likewise a Promiscuous port can only served one primary vlan, one isolated vlan and many community vlans. 3) Why do you need to trunk the vlans through to your fortinet firewall? If it isn't absolutely necessary I'd turn this into a routed link between the core switch and the fortinet. If your core switch is L3 capable. 4) Just use a Promiscuous-PVlan trunk for the link to devices that don't support PVLAN or protected ports. This will ensure secondary vlan tagged frames are rewritten with the primary vlan tag when crossing the trunk. Although if you make 3) happen then this may not be necessary anymore AIUI. HTH. Feel free to ask for clarification. 

Without a screenshot we can only make an assumption. One thing I will point out is that vlan 1 is the native vlan by default on a trunk port. The native vlan is used to send untagged traffic via a trunk. Perhaps this is what the CLI is displaying. 

You're likely emulating using the wrong NICs. If the correct NICs are used the ge interfaces should appear in 'show interfaces terse'. Configuring them is one thing... but having them actually present within the virtualized device is entirely different. If you're using virtualbox to run the vSRX image then try - paravirtualized network (virtio-net) NIC. I believe that should help. 

R1 knows routes from R2 (Direct) and R5 (Direct) R2 knows routes of R1 (Direct), R3 (Direct), R4 (Reflected by R3) and R5 (Reflected by R1 and R3) R3 knows routes of R2 (Direct) and R4 (Direct) R4 knows routes of R3 (Direct) and R5 (Direct) R5 knows routes of R1 (Direct), R2 (Reflected by R1) and R4 (Direct) 

ISIS works quite differently than most of the protocols you know. In the original OSI networking, ISIS would make adjacencies with it's neighbors, and tell them about the adresses of any ES it knows. IS means intermediate system, so besically a router. ES means end system, so any host. ISIS has different logic with different levels of routing. The levels used in ISIS are*: 

When a computer asks for a webpage, it wil first select a random unused portnumber from the random range (1024-65535). Let's pick . Then the following sequence will happen: Computer send it's packet with: source IP , source port , destination IP , destination port . The packets arrive at the webserver, it sees it's own IP and port , so it knows this is a request for a webpage. The webserver then sends the webpage back in packets with Source IP , Source port 80, destination IP , destination port . The computer recieves these packets, and knows wich requested webpage it was, because of the portnumber . These port combinations are often written as such: and . Now, the number of computers on the internet far outnumbers the number of IPv4 addresses available. To preserve address space, a set of private address ranges was introduced, that can be freely used for address sharing. These rangese are referred to as RFC1918 and are the following: 

ISIS, just like OSPF, runs a Dijkstra Algorithm to find the shortest path. All information for this algorithm is contained in the TLV's. L2 Communication with neighbors is done in two ways: -When connected to a shared segment, use the Layer 2 protocol of that segment to communicate. This is done to be able to traverse switches that might not be able to speak the OSI layer 2 protocol CLNS. -When connected to a point to point network, communication on Layer 2 is CLNS. This doesn't mean that there is no L3 communication. ISIS routers still need a layer 3 address. Since we are talking OSI, and not IP, the address is slightly different. In this case, the address is called a Network Entity Title (NET), which is one address for the entire system (so not one per interface). The NET has many forms, but for most ISIS adjacencies, works as follows: . It doesn't really matter what you use as identifier, but say we have router 192.0.2.5 in area 52, we could make the NET 49.0052.1920.0000.2005.00 Since the addresses are in HEX you prefer 49.0052.0000.B00B.0000.00 (The addresses are hexadecimal). *) There are other levels in OSI routing, but those aren't significant for the current operation of ISIS A short illustration of routing