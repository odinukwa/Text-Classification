Make an class that can operate on it's own, you tell it what to do, what the inputs are, and you can call methods on it that give you output. One candidate for refactoring is the input file, this should be an input argument. Another point is that you request user input inside your processing, the user input should be asked beforehand and also be an input parameter. The prediction which gets printed while processing, should be an output. 

The explicit is ugly, but neccessary to not result in type casting, which is even more ugly, it is a limitation of the current type interference. It might be only an issue in IDE's and the javac compiler might actually compile it though. The usage of is pretty bloated, but our most reasonable option, besides creating a class ourselves and using . This will hopefully be easier if Java 9 includes tuples (which logically include pairs) as more or less first-class citizens. In the whole method we end up storing all the entries in memory once, with the , I am pretty sure there are ways around that, but not worth the effort here, only optimize this if it becomes a real bottleneck. I was hoping to use the method when processing the results, however this is not possible with the requirement that you want to have a counter. Again, more possibilities open up in Java 9 when we hopefully have s and tuples. 

The argument should be checked for possibility of being null, with preferably , which will throw a if the argument is null. I would strongly recommend to leave one white space before and after every and . I would only use one statement to check the length, and report back the given input, thus the string. The same holds for the last place where the exception is being thrown, I would echo back what was. 

First off, let me say that this article pretty much changed how I program, for the better. Until I read this article, I was a spaghetti programming master --- if there were awards for crappiest, least organized, and impossible to read programming, I would have been world champion. But that article taught me to utilize classes (mind-blowing, I know), rather than just copy/paste the same logic around to the necessary pages. With that in mind, I modeled my application (described below) on the examples found in that article. I highly recommend that article for anyone else who's looking to make the jump from newb coding via facerolling on the keyboard to newb coding with some thought behind it. I've been simultaneously building upon and maintaining this web application for a year now, and I feel that while the layered approach has helped me to stay more organized, I'm not utilizing very much (if any) extra power from having layers. In my web application Project, I have a folder I created called Classes. The structure looks like this: 

The TextBox1 in Processing.aspx is where the progress update goes. Now let me just point out the dirty trick and the part I don't like right now. In Processing.aspx, there is a meta tag to refresh the page once per second. How it works (summary): When the process starts, a Session variable called ["Running"] is set to true. When the process ends, Session["Running"] is set to false. And since Processing.aspx refreshes once per second, what happens is it saves the current contents of TextBox1.Text to another Session variable called ["TextBoxContent"]. And then the Page_Load method for Processing.aspx fills the TextBox back up with the previous content, and adds a period. So the output will begin simply looking like "Process Starting", but after 10 seconds it will look like "Process Starting.........." (one period per second). How it works (details): The process begins in DatabaseChecker.aspx's Execute button: 

Now we have the , and here we decide to collect it into a . Here we continue with your old logic of having a counter attached to it. 

Then one more additional thing about the onparsing the integers. I suppose you can take several views on this. You should only do it this way if it is an exceptional situation, which seems to be correct here. Yet, for performance reasons, you might want to simply check whether , etc. is a number and only then try to parse it. 

I'd like to get a review on all aspects. The class for example has been refactored a few times to incorporate new constraints and I am intending that the refactorings do not leave their marks on the source code. 

Your code and Java 8 usage looks fine in general to me. I do see an issue with the class, it looks like you are intending it to be an immutable class, if so, then you should also enforce it. You need to ensure that the and fields can never be changed, you can do this by adding to them. Your code currently seems to be safe, but it is not. I can extend and offer a method there to change the and fields, which violates the assumed variant of that those fields in are immutable. Simply changing it to the following will do: 

The code is not intended to work with the and classes just yet, I have only included those classes such that the code is complete. The code is also available in my GitHub project. 

Now we should refactor the methods to not lead to duplicatd code. I do not know which Java version you are using, but considering this seems like a toy project, I am assuming it is safe to introduce you to Java 8, which will make your life considerably easier. Strangely I have just noticed that does not compile on Java 8 (not sure if it did on your version, I doubt it), there are two ways around this: 

As you can see, my web application is broken up into different layers which makes organization a breeze. But, I feel that currently I'm not utilizing the power of layers --- the logic layer does nothing at all but just forward the calls to the DB layer. I think part of my problem is that I simply don't know what I CAN do that is useful. Currently my system works and my goals are achieved. Some people might say, "then what's the problem?" And while that makes me happy (it means I've done my job with some degree of success, horray), I want to know more advanced techniques. In the article I originally linked to above, it uses the example of checking roles in the logic layer. In my case, I don't need to do that. We're checking roles pretty much on every action the user takes at the page level. If I can't figure out something else useful to do at the logic layer, I am thinking about cutting out the logic layer all together, since all it does is forward calls anyway. This would eliminate some .cs files and make it even easier to navigate/maintain. Ideas, thoughts? What can I do better? What has worked for you? Are there any things related to layered web applications that you know now that you wish you knew when you first started? 

Once again, very abbreviated here. I am aware of auto-implemented properties in C#, I just chose to manually implement them. Upon Object instantiation, I set everything to null. It is easier to check for null than to check for "empty" or "zero" values, in my opinion. This way when it comes time to validate an object before saving it to a database, it's very black and white --- if any field that does not allow nulls in the database is found to be null, throw an error, else continue on to save. Next up, here's what a Manager (Logic) class looks like: 

Note that this also initializes to zero here instead of in the constructor. Use a single constructor and call the other constructor to avoid code duplication: 

Last week I started learning Haskell, and since I have some experience with Brainfuck already, I decided it would be a great idea to implement an interactive Brainfuck interpreter in Haskell. I'll first list the code and then add some remarks on it. Main.hs 

In the game Factorio there are string-encoded representations of blueprints that I wish to decode. The implementation according to their wiki is the following: 

When an item succeeds to 7, it can be converted to a "32DR crystal", which can be sold. When an item fails, it will produce 1~15 Dazzling Ores and a Level 100 Chip. If the upgrade that failed was from 6 to 7, it will produce 2 Level 100 Chips. Upon failure the item is lost. To increase upgrade success, you can add 500 Shiny Crystals from upgrade from 4 to 5 onwards, which will double your success chance. My goal is to calculate the most profitable method (possibly negative profit, also called loss) given the price of the 29 DR item. Implementation-wise, I have decided for now to let it run on the console for ease of use and with a few variable parameters hard-coded. they resemble the price/value of an item in the game and that, because it is dependent upon players, may vary from day to day. It's just for personal use, so I do not think it is bad to recompile it every day. In the future I want to support multiple types of items and goals (upgrade levels) though, where the following details are variable: 

What I want to improve: Basically, everything. This whole thing feels like a really makeshift house of cards. In particular, I don't like that the page has to update once per second, particularly because the Windows mouse icon changes to loading and not loading cursors very fast. If the user knows the system and knows what's going on, then yeah big deal I guess, we can just deal with it because we know what's going on. But I think to the average user, the behavior is jarring, it feels like something might be wrong or something. Hopefully I've made it clear what I'm trying to achieve overall, so I'm open to other ideas about how to go about it. 

The .aspx portion is very simple. DatabaseChecker.aspx simply has a button to begin the process, and it has Processing embedded as an iframe. The result looks like this: 

The above is extremely abbreviated (for example, ClientManagement actually has about 20 Objects, 20 Managers, and 20 DBs), and there are other base folders like EmployeeManagement, InventoryManagement, etc. Each "Management" base folder corresponds to a schema in the database, so that for example, in my SQL Server database, I have [myDatabase].[ClientManagement].[Clients]. Each class in the Objects folder looks something like: 

As you can see, most of the calls to the manager/logic class are simply forwarded to the DB class. This is where I feel I could use improvement by actually doing something useful in the Manager class, I just don't know what. The Validate() method is a last resort check. There is already validation checking in each page's code behind. There really is no apparent way that you could ever reach the Validate() method in the Manager class, but it's there anyway because you never know. I've purposely chosen to have it throw a hard exception, because if somehow the user reaches that point, something is seriously wrong somewhere and needs to be addressed immediately. A DB/DataAccess class looks like this: