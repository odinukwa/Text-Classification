Algorithmic considerations Instead of doing a backwards search from a random comma, I would rather change the algorithm to doing forward searches and picking id's, values or list of values. Changing into forwarding searching algorithm would also allow for proper handling of commas and escaping of quotes and similar. Some things you should look for when doing a proper search: 

Addendum on accuracy In a comment you state that you want accuracy, and as such want to calculate more. There is a balance between doing 2.5 millions steps, and 3000 steps, which is related to the speed of the various objects and distance. The further away the less impact they have on each other. Another point regarding accuracy is that you claim to use the earth as your reference point, whilst your code doesn't actually do that, and here is why: 

On the bright side, your code is nicely indented, and you are pretty consistent with bracing style, and other stylistic elements. And it does what it is supposed to do! Alternate algorithm In the comments I suggested to use split and join, which has been commented upon by another answer afterwards. In the answer by janos, it's suggested to keep as is, but here is a faster alternative where you only traverse the text once, whilst building the result string. Code follows: 

Unneccessary complexity When reviewing your original problem statement, you need to calculate points of words starting with either a vowel or a consonant. You don't need to actually now the words. Combining this with knowledge from previous section that at a given position, \$k\$, in the text you can generate \$N-k\$ words, the total complexity reduces quite nicely to a method like the following: 

I was able to reduce the run time of your code to a few seconds (2 seconds on my computer) by changing the type of from a to an immutable . You were correct that was the major bottleneck in your code. This is a bottleneck because checking that an item exists in a means inspecting every item in the until we find it or reach the end of the . Fortunately we can use a (which under the hood is supported by the class) and reduce the search time for objects from linear to effectively constant. Notice that in the code below I simply applied the method to your function converting the returned to a . 

Hmm I'm not sure what the requirements for 'python koans' are, but if you are getting counted off for the conditional, here are two alternatives: 

My current assumption is that the string returned by is going to look something like If this is the case then you can try the following function: 

Below are some of the changes I would make to your code. In my opinion one of the nice aspects of Scala is that it gives you all sorts of ways to reduce the amount of work your mind has to do in order to decipher code. As an example, one of the first things I did was declare a type that is equivalent to . I then just substitued where necessary and the code (to my mind) became more readable. The choice of was arbitrary on my part, you could if you wanted use instead. Along these lines I shortened all of you variable and value names. As the program is set up right now you don't need to pass in a array, but I left it in anyway. As you mentioned this is a homework assignment so I'll leave a bit of mystery as to why this is. And really you don't need the and the . Next note that is equivalent to . And finally (for now) checkout how I initialized and . If you still would like to use your function you should look into the method called . Cheers. 

Which would pop values from the end as long as they're not returning a falsy value, which would work in my current case. However as I tend to want generic solutions (not directly asked for in the question), I found this alternate solution which would allow for the default values to be real default values, and not only . 

Here is an alternate version for finding the multiple of \$N\$ which looks like a binary. It doesn't depend on a prebuilt table of binary looking decimals, but generates these on the fly. This is done using a counter from 1 through 4096, which is converted to a binary string1, before that binary string is converted back to a . This newly formed binary looking decimal is then used in the modulo operator testing. 

This would allow you to simplify your logic in the badly name to use and so on. Now you have a function with might be useful elsewhere, even though still pretty simple. As a general principle if you see repeating blocks of code you can: 

First of all I, for one, do not think your code is self-explanatory. I've read it quite a few times, and if I do understand the code you've written, but I still fail to properly understand your logic. In other words, your code would benefit greatly from some test cases, with proper explanations around them. Even a link to which algorithm you are attempting to implement would be better. So here are some other stylistic and code review items: 

Code Legibility Many of the values and functions in your program have non-descriptive names. If you plan on only sharing this code with your colleagues who have familiarity with the domain, similar algorithms, and the mathematics behind it all then there may be no need to be descriptive. However, it is also easy to cite whatever source you got this from at the top of the code so that future users can have a frame of reference. 

Overall I'd say your off to a great start. Here are some of the changes I would consider making to your code: Formating Output When printing strings that encapsulate values/variables you have two (idiomatic) choices in Scala. Option one is to use string interpolation: 

Below I've written up an implementation of a recursive bubble sort that addresses the main concerns you mentioned. The areas your code can be improved matches what you instinctively pointed out in your bullet points. Whenever you use a or in Scala remember that it is in fact a linked list and so accessing an element takes linear time. This could add a significant number of operations to an implementation of bubble sort that utilizes a . As a substitute I used an which offers constant time access to elements. It is also worth mentioning that the container is mutable in Scala even if it is declared as a . We can kill two birds with one stone by rewriting the while loop as a recursive procedure. The two birds are and and our trusty stone is . 

Here I've also renamed the class to , as it seemed kind of strange to use the class to stuff... I've also removed some temporary variables to avoid clutter. I also added a second constructor allowing for providing a different to the constructor. This way you could change the entire functionality of the encode/decode by providing a different properties file. Code is untested as I don't have access to do the resources thingy using my online java compiler, but you'll get the gist of the idea. PS! Using the try-with-resources as Vogel612 exemplifies in his answer, is most likely a better, more up to date way to do the properties reading. 

All in all your code reads rather nicely, and there are just minor adjustments regarding style. After those comments, I'd also like to take the opportunity to propose a better algorithm for finding these palindromes. 

If you're using Python 2.x, I would also consider using if is somewhat large, to avoid creating that array in-memory. This is better handled by default in Python3. In the suggested code I read the file twice in order to get the number of words. This would in a lot of cases be better than reading the entire file into memory, and reading is usually cheap. If not an exact number of words is needed, I would estimate this number by taking the file size, and dividing by the average word length. Finally, I've also created the to return a boolean regarding the membership, as this allows for other uses rather than just presenting a text. Hopefully you'll see the benefit of packaging this into a class. This implementation should allow for a much smaller memory footprint, and it would also easier allow for multiple filter to be used in parallel by instantiating multiple filter simultaneously if that should be wanted. 

Lists vs. Arrays The Scala version of your code ran surprisingly slower because you used a . In Scala you can think of a as a traditional linked-list. s don't provide random access to their contents. That is, accessing an object at index n requires O(n) time. This really slowed down your code because you index into in both your inner and outer for-loop. To fix this problem you can simply use a different data structure like an . 

We use a list comprehension to build the list. The benefit being that later on when building up we no longer have to call on . 

For Euler problem number 17 there is no reason to utilize . At a high level using implies that there are missing values in the domain/codomain of your function. To put it another way, as long as we can trust that will produce an ordered sequence of integers from to we can drop the use of and just focus on the logic of the problem. It is rare as a programmer that we get such an explicit definition of what our program input will be, so we may as well take advantage when we can :) The advantage in this case is being able to not use and thus allowing our code to be much more concise. Below I've coded up a solution to 17. I partially obfuscated the code in case you (or whomever might be reading this) didn't want a direct answer to the question. I can give proper variable and function names if you'd like me to. 

To summarize, your script does implement a function to play rock, paper or scissors, but it is, in my opinion, too condensed and should be expanded upon rather than simplified any more. 

And if you want the output sorted, you could use . This uses the, to me, more intuitive method to build the final IP-address, and this can be customized if you are so inclined. The code use to induce uniqueness, for format the IP-address, simple integer arithmetic to add the offset, statement to proper handle opening and closing of file, and to join the final list before writing. 

Secondly I would make the functions actually return values and not printing them directly. In your case I would probably make the function return a triplet of where the index is used for offsetting the next run. 

And corresponding in the definition: and then your view will be simpler and will contain no logic at all: 

First of all you seem to have made a working game, and there is a certain game logic. But your overall coding style and data structures needs updating. If you haven't done so already, I would strongly suggest reading PEP8. Actually your style isn't really bad, but the entire game is crippled by no use of vertical spacing. You have mostly good names, albeit some of them are a little short, but you need to add some vertical space in there. And you need to add a little comments here and there. I suggest the follwing for adding vertical space: 

that you are immediately throwing away because you aren't assigning it to a variable. In other words you should only use a list comprehension for building a list, not for calling a method that is doing work elsewhere. An alternative implementation is as you might expect a nested for loop: 

In Scala the pattern is an expression, which means we can use it to return a value (similar to Java's or C++'s ternary operator). You don't have to change much in order to take advantage of this: 

From the POV of operations performed they're unequivalent. is defined from the result of a pattern match that discards the tail of the list. as you know is the result of the invocation of the method. (I suppose it could be the case that the compiler is smart enough to translate a pattern match on a list that only takes the head of the list into an invocation of the head method, but lets just ignore that for now :^) And a final example: 

As Illya has mentioned Regex alone cannot solve this problem. Instead, we must employ some type of stack-like data structure to give our program memory of past characters. The first three lines of the main function are just a cheap way to replace blockers with a single character. A better solution would be to tokenize so that this isn't necessary. 

Style When you declare a type of a function, value, or variable, add a space between the and the type. 

Note that in the first case clause you can replace with any arbitrary constant that you want to match against. In the second case clause simply means match against the wildcard, that is, can have any value or type and the block will get evaluated. As a general Scala tip I'd recommend learning about the many other ways in which pattern matching can be used to create concise code. There are a couple of other places in your code where you could apply pattern matching, but I'll leave those to you as an exercise :) 

I kind of prefer building the array, as that allows me easily to change output variants. But you could also opt for using directly, which would eliminate the need for the entire table. I did however removing the original and included that directly in the foreach, as I try to keep intermediary variables to a minimum. PS! Depending on font settings and encoding elsewhere, you could consider calling in addition before using in the URL. 

When timed (without the statements), this ran about 33% faster than the original. It does kind of reuse the random numbers slightly, but it shouldn't affect the overall randomness too much, I think. Other possible factors Just for the fun of it, I also tried exchanging the with a loop, but that only had a minor effect for the larger number of runs. NB! If you was using Python 2.x, there would most likely be a massive effect out of changing into . The could be eliminated, and the could be moved into the block. This also, has little to no effect in my tests. Lastly, using various python implementation will also effect timings. Using PyPy, IPython, C-Python(?), or other variations could change the time usage. I've used $URL$ which reports the following on : 

Return at first fail The easiest way to handle this, is to make your own , which in addition to the normal parameters has a flag variable initiated within , where the local variant never executes the if the flag variable is set. This removes the possibility for changing the error code, and re-executing the after failing. Skip later executions An alternate version I've used in production code for a company is to have code which essentially behaves like the following: