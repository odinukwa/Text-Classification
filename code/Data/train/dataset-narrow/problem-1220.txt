According to C# naming convention you should use PascalCase for constants (unless you are mirroring some external API which uses different naming convention). So It should be , etc. Also you might want to use instead of strings: 

If you manually specify all the test cases as in your example above, then I don't really see the advantage of passing multiple pairs to your method. Personally I find this version a bit easier to read: 

You do not pass this value through views. There is no reason to make your views responsible for creating view models. For example this: 

Also, what instantly raises red flags is the sheer amount of various tions, tions of tions, dictionaries of tions, etc. gathered in one place. I mean come on 

Alternatively, introduce a flag. Set it every time collection is modified by //etc. methods and check it before yielding each element. 

You don't need to implement pattern if you have no unmanaged resources to dispose. Unless you get paid per line of code, that is :) You should not dispose objects you did not create (unless you implement a wrapper). In your case, you should not dispose reset event in class, since you did not create it there. Instead, you should use 

I think you should either use or , but not both. Also aren't you already catching all errors in your implementation? Another advice: do not discard the callstack, when you log. Otherwise, how are you going to find the source of exception? 5) Don't use Task.Factory.StartNew without specifying TaskScheduler. 6) I don't quite like API. I would expect it to behave the same way most other observables do: it should automatically start inner timer when first subscriber arrives and it should automatically stop timer when last subscriber disconnects. Having to manually call looks inconvenient (although I imagine some functionality might actually be useful). 7) Whether or not uses multiple threads should be an implementation detail of method. This logic should not reside in static factory methods, IMHO. Or you might even want to abstract it out into separate component. 8) I would name static methods or something. Otherwise it is not very obvious, what they actually do. 9) This does not look very precise as far as timers are concerned: 

I just wanted to add, that for large buffers (or or other similar methods) will give a way better performance, than element-by-element copying. Also this: 

I think its better to use . This way your thread will wake up on cancellation instead of sleeping for 10 ms. 

has inconsistent behavior. Sometimes it creates new elements, and sometimes it does not. This can produce all sorts of weird side effects associated with shallow cloning. Modifications that are done to transformed tree in some cases will affect the initial tree. To avoid that you will have to do deep cloning during transformation. However, if initial tree is always discarded after transformation, then it does not matter, I guess. 

Those delegates inside methods are cool and everything, but I think you are overusing them a bit. For example, compare this: 

Do you need the reference in outer scope? I doubt it. After all, you already pass this same reference as parameter, so you should already have it. Also pay attention to . When you dispose it in block - you dispose the underlying stream as well. Accessing it later on will lead to exceptions. No, you should not, if all you do is writing to the given stream. implies, that you will assign a new value to passed reference parameter (meaning you will call at some point or something). Which is not the case apparently. It depends on use cases. I guess the best approach is to create multiple methods to cover them all. For example you can create another method, which would accept (file path) instead of a . And another, which would accept a . 

Reduce nesting in your loop to avoid arrow code. This can be done by using // statements or by extracting logic to separate method or entity. Depending on how often you receive messages and on how much time takes, you might want to release before calling . You might want to wait for process to exit before returning form your method. This will ensure, that everything went smoothly, and there is no process left hanging somewhere due to some error in your code. If signature is not set in stone, you should probably replace strings with complex object: 

I agree with t3chb0t's comments, this sounds like a bad idea. You assume too much about what functionality you are going to need and what other containers are like. 1) Some containers require you to release components. 2) Some can (should) be disposed. 3) Some can (should) be configured via configuration files. 4) Some containers can be nested. 5) Some containers allow new registrations after first resolution, some do not. 6) Some, like say , have a concept of "installers", where you do not call method directly, but use a custom implementation, which does the registration. And this list goes on and on. There are different component lifestyle models, different dependency resolution policies, different extension points, different... everything. Yes you have successfully abstracted out 4 most basic methods that pretty much every container has. But what next? You might think otherwise now, but sooner or later, you will need to use a custom factory for this component or specify a dependency for that component. And what will you do then? Will you create your own custom registration API, that you will then map to the API of underlying container? And then rewrite the entire mapping, when you do change the container? Well, that sounds bizarre to me. TLDR: Just use containers the way they are supposed to be used. Not as a static service locator, but as a composition engine: isolate your registration logic and call method once to resolve a composition root. If you would ever want to change the container - yes you would have to rewrite your registration. Will it take some time? Yes, due to how different containers are. Is it harder than rewriting a wrapper, once registration logic become a bit more complex? God, no. 

use . This will reduce the number of fields and assignments. I dont see an issue with . Repeated code should be dealt with by extracting common logic to the base class (?). I'm not sure (state entering object) makes much sense. Shouldn't object enter state and not vice versa? 

Yes, you should use instead to coerce your Level property (what you are trying to do is not "validation" strictly speaking). 

I have a personal vendetta against , so I can't judge it objectively and I won't. :) What bothers me though, is your use of reflection. Why do you even need it? All DI containers I've worked with (Autofac is not one of those) had a way to do both: specify a default implementation of an interface and register a wrapper that would resolve a collection. So you should be able to register: 

Well, in my opinion transaction should definitely NOT be responsible for getting a list of itself... Not only it makes little sense from domain perspective but it also violates SRP. Another major concern is that this design clearly encourages having classes with lots of hidden static dependencies. This problem alone is good enough reason to avoid it. 

You use to create a button, instead of using an actual class with custom template. Because of this you'll have to manually manage all the interactions, which are already implemented in regular (, , , their interaction with property and keyboard, etc.). So i suggest you use an actual button. Well, your storyboards are clearly copy-pasted. :) Why don't you move them to resources? 

The rest you can do with regular LINQ operations. Want to get a Fibonacci sequence for ? Just call : 

Your implementation looks really complicated and (more importantly) error-prone. To be honest: i stared at your code for ten minutes and i still failed to follow the workflow. And it should not be that way. I mean, parsing a csv file in simple case is a three liner: 

The general issue with your code is that your client and server implementations reside in your control's code-behind. It is always a good idea to separate business logic from UI. This is copy-paste: 

or something along those lines. Or you can use -based or -based api instead just for the kicks. But the point is: 

Just stick to one or the other, so reader does not have to look for deeper meaning to all this. :) is unusual in C#. You should use for constants instead: . I think you should extract constants to separate class, so you can easily serialize it later on and tweak those values without re-compilation. You can call it or something. You can move filePath and timer interval there as well. You shouldn't use nested classes to build class hierarchy. I'd say, that if nested class is larger than 50 lines - it probably deserves to be moved to dedicated file. Default encoding may vary depending on your users' environments. Since you are using a shared file, you have to specify encoding explicitly when writing and reading, to make sure that all the users are using the same encoding. does too much: it opens the stream AND it parses the entries. Split it into two methods and replace with proper return value. Nobody likes using . :) I think method is the wrong method to override. I mean writing logic does not change, its fixed: you take a bunch of entries, and you write them one by one. What changes is which entries you have to write. So instead of abstract you should have . Your class is tightly coupled with class which is a sign of bad design. should have a single responsibility: writing entries to file. It should not manage timer or update cache of parent component. IMHO, you should remove reference from constructor.