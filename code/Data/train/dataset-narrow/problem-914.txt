Outside of that, I find your code incredibly difficult to read, and while some of that might have to do with following style conventions in Wordpress (which really bad IMO), you should at least indent you code and place comments properly (i.e. not prepending comment on code lines). 

Here I have shown a theoretical class/object where you could encapsulate your logic related to: current localization being requested, localization to be served, outputting localization info to browser, etc. 

Typically localization might be achieved through storing localization in configuration files (perhaps in JSON) which would be deployed along with the application. The appropriate config would be loaded into memory based on localization setting such that main app code code just references a string identifier. This would be in contrast to your approach of loading all translations into javascript variables in memory, which could get memory intensive if you have a large number of strings. So you might take a look at a plug-in like this which takes this general approach. 

I question the whole persistence model. Rather than explore ways to write code to work around what looks to be a bad data storage model, I would think about how you can best persist the data in an appropriate manner such that it can be read into your application without an intervening layer of regex-based data mapping. 

Given your starting array, which appears to be a field-value map, I find it odd that you want to go with question-mark-style query parameters instead of named placeholders. You might find named placeholders more useful should you ever need to do some debugging around your queries. This can also simplify your SQL preparation. For example, one might typically build field and/or parameter strings directly from an input array like you have shown. You can then also work directly with such an array when executing the prepared statement. For example in PDO: 

In general, your data is structured very poorly for your filtering use cases. Having to iterate an entire array of users every time you want to apply a filter (and then having some of those filter methods further iterate nested data structures) will become a very slow process once you have a large number of data objects that you want to filter (not to mention also apply multiple filters towards). It is also unclear how your filtering logic support AND vs. OR across the filtering criteria, so not sure how flexible/extensible what you have really is. Finally, the approach you take on chaining the filters might need to be something you think about optimizing at some point. If you have fields that are unique, like login presumably is, these would almost seem to need different filter treatment than trying to iterate through all users making this comparison. These sorts of filters should be binary in the sense that the match will either return exactly one item or no items if the match isn't fulfilled. So, this is not so much a filter as it is an indexed lookup. This ties back to my concern about your data structure. If you have unique fields, you should be able to perform an O(1) lookup to determine if that object with that unique value exists, not have to perform an O(n) iteration across all objects to look for this unique value. 

Consider not giving feedback to user as to whether an existing username or email address is present. You are giving a potential attacker valuable information here. Many consider it best practice to give more generic "unable to create user account"-type messaging for this reason. 

Does your method really need to be public? Is there context in which you are expecting callers to invoke this method outside of password verification? 

I think it strange to have a controller and model class name that is so similar. That could be really confusing. Consider and (singular since you are only representing a single user here right?) 

By passing in callbacks, you give yourself flexibility to define different DOM interactions all triggered by hooks on steps in the ajax request process. You can define the hooks in your class for different parts in the process - request initiation, request failed, request success, DOM insertion, etc. You would have the constructor potentially fully replace or extend default configurations that are stored on the class statically. The constructor could also store all the callbacks on the object instance. Since you are using jQuery, you might consider for this purpose. 

Assuming that you have a unique index on the field, I would just go directly to performing an insert, but looking for insert failure on duplicate index value. I would then apply increment and try to re-insert. Why have two queries in your happy (no duplicate) path when you only need one? My guess is that the number of cases where you need to make 3+ queries to successfully insert a record into the database will be extremely low vs. having to perform 2 queries every time you want to do an insert. 

Typical comments for all fields - - Hard to read this code. Lines are too long. Too much output manipulation happening here. - Should you even call if there is no error for this field? - Why have check on value to be populated here? By this point in the code you should already know exactly what values you are will be populated into these inputs, whether they be blank values or values derived from POST input. You should also have already prepared the strings for output. 

Why require the caller to call this method? The caller is not passing any information to the router class at all, so I don't see why all the activity is just not happening in the constructor when the class is instantiated. 3) All of your code is very "happy path" oriented. You just assume everything is going to work and you do a generally poor job of dealing with executional failures in your code. For example: 

I would agree with discussion in comments that this should be looked at as a stop-gap solution only, as the real answer here is to change the HTML source, or better yet, the CSS styling for the desired 's such that you don't need these 's at all. If you truly want to wrap every like this, why is this not just: 

Don't echo out code-level error messages to the end user. Log the errors, but give meaningful display message to user in HTML. 

Both of these seem horribly inefficient, but I guess that is what you get if you are forced to use recursion to solve this problem. In either case you don't validate input. What if you don't get an integer value passed in the first place? Your solution doesn't handle negative integers correctly - why would this always return false? Your solution is really odd in that it unnecessarily uses recursion. If you are going to use modulus, you have no need to recurse at all. You know true or false directly after this operation and decrementing two from the number and recursing isn't going to change the outcome. It's just going to take more time until you finally get to value < 0. I might have something more like the suggested solution, but with some input validation added: 

I guess this is similar to my earlier thoughts around request/response objects. I think your framework is currently quite naive around aspects of reading and setting HTTP headers, something that can be critical when trying to build a RESTful API framework. What you will likely find is that there might need to be quite a bit of logic around this, such that building these separate classes becomes mandatory in order to encapsulate this logic and not have it scattered throughout the other classes in your framework. Again you may want to look at your favorite framework(s) for inspiration in this area. 

You could also simplify here and just eliminate this https check if you simply build your URL string like with no protocol shown. This would mimic current behavior of simply continuing current protocol. You might consider adding parameter to force http vs. https if you ever need to move between the two protocols. 

in within this function context will have everything you need to know to perform a validation. From it you can reference the current value for the field, the type of validation rule that should be applied, and of course the element itself should you need to modify it (not discussed here). Inside your validation method is where you should hold the logic on how validations occur, not outside of it, otherwise, why have the function at all? Now for the validation method... At it's simplest this method needs to: determine input value, determine validation to apply, and return validation result. That could look something like this: 

With all the intermediate methods calls being abstracted away inside the class. By the way, all your method names should start with lowercase letter. 

I honestly don't see what value you are getting from this class. It looks like you are trying to build an object relational mapper and a database connection management class without really doing either successfully. I don't understand the desire to make this overarching class that can perform all database insert and update actions. You are making your code much more complex and obfuscated by trying to have one class that can interact with different records representing different objects (i.e. database tables) in your systems. For example, what if you changed the schema on one of your tables to or remove a column. Rather than making a similar change in a single class associated with that table, you now have to search all around your codebase looking for all places where this more general class is used in order to determine if that particular usage is impacted by the table change. This is very much a concern for application maintenance. You also have a very simply use case here. What happens when you need to do things like insert timestamps on your table records (a very common operation) and deal with more field types than the ones you have considered here? You well continue to have to branch you code to handle more and more edge cases, adding complexity. There is absolutely nothing wrong with having specific database model implementations for each table/object type in your application. This makes it much clearer to the developer as to what the expected fields and behaviors are for each individual object, as opposed to them having to go review a database schema to understand what fields are available. I would suggest an alternate approach to the object relational mapping functionality you are trying to achieve. You might start with an abstract DBModel class that can be inherited by individual classes specific to each table. This abstract class can require that each inheriting class implement their own logic for CRUD operations. Perhaps that abstract class looks something like this. 

Why would your main application class ( as currently named) live in a directory? Don't confuse main application functionality with models used within the application. 

Consider renaming your file input fields to (note that array notation). That will allow you to access all your values like an array, allowing you to simplify your code. I will also take the addvantage of the fact that binds the a variable to a parameter not a value, meaning you don't need to rewrite these lines of code repeatedly. For example, 

I am not understanding what value you are gaining in defining a closure here in your constructor. The closure being applied will never change, so it might as well be traditional static code. I also question the general value of this factory as constructed. It looks like you are trying to implement a singleton, but did not really do it properly, so there is really nothing to prevent calling code from instantiating lots of different factory objects and thus lots of DB connections. I also very much question this being a factory to instantiate objects that need PDO objects. I would think that most classes in a complex application might need dependencies beyond just a PDO object, so can this class only instantiate a subset of the overall classes in your application? It looks like what you are really after is a dependency injection container. I would suggest you look into common PHP DI containers like Pimple or PHP-DI to deliver this functionality. 

Rather than recursion (which seems unnecessary) we use to perform the same logic of incrementally building the string. This might not be optimal from a performance standpoint vs. simply parsing bits of the original input string into a results array but my guess is parsing the original string would be an micro-optimization at the trade-off of code simplicity. 

You put your javascript smack dab in the middle of your HTML view and in global scope. It probably should have, at a minimum, been in a document ready ready block or IIFE, ideally in a separate file to demonstrate that you know how to decouple view from logic. In a real world application you would likely have components of this sort defined at a framework level, decoupled from page view. 

Why is defined in constructor? Your code is actually improper in that you are overriding the constructor inappropriately, with PHP not failing here only because you are not type hinting your parameters. If the parent class gets passed a config as first argument to its constructor, this inheriting class should as well. You might also consider making a config class that you can pass around. Ideally your constructor should look like: 

This code above is actually not too far off from how one might write a jQuery plug-in, which might be a nice avenue to pursue. Now to the code on the page. You would need to implement something like the following: 

The handler is only called if there are no other ajax requests currently in progress, so if there is already something in progress, the handler will never be fired. Th handler will only be called when a request completed and there are no other outstanding requests. So, theoretically, if you have ajax requests being fired every second, the loading icon could remain on your screen in perpetuity. If you are looking at building a heavily ajax-driven UI, it might not be too wise to rely on the global ajax functionality for this reason, as you have to then concern yourself with interaction of different ajax requests and how they may impact the user experience. From a UX standpoint, I would find it odd that you only want to display the loading icon until after 2 seconds have passed. This seems like a really long time to wait to give the user some feedback that something is happening in response to some action they have taken. There is no reason to have your global variable at all. It would be preferable instead to work with jQuery queue functionality to give explicit control over how the animations are sequenced. For example: 

Note here that even the case for inheritance might be weak as mentioned previously, as once you begin to normalize the property and method names across the different vote classes above, you can get to the point as shown above, where the only difference between the two classes is the database table they are pointing at. 

If you want multiple classes to be non-clonable or non-serializable consider putting magic methods that throw exceptions as noted above into traits and simply use these traits from all classes needing these behaviors instead of re-implementing these methods across every class. The same could actually be done for singleton behavior as well, though, I would encourage you to break out of this way of thinking about singleton.