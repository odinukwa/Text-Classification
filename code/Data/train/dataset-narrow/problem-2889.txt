Don't make confusing mechanics. That may sound flippant, but strongly consider this. Just as you don't write overly confusing code, you should not write mechanics that are innately confusing. The first step in getting players to learn quickly is to not confuse them in the first place. Find out what it is about your mechanics that they are finding confusing and fix that. Then, once you have a quality set of mechanics, you can start working on how to introduce players to your game. 

It's inefficient. If performance matters, you're going to want to sidestep it. It's not very good. Take the GLShaderManager for example. It either loads the shaders or returns 0. If there is a compiler/linker error, it gives no information on this. Yes, it writes the log to stderr, but not everyone has stderr piped to somewhere that is visible. Exceptions are rather harder to ignore. 

... so? The data structures, taken from your example XML, would consume (with no attempts at compression: 

Yes, C# has the same problems as C++. But it also has a lot more. For example, take this statement from Shawn Hawgraves: 

This function makes reference to a set of global tables that I use to give each face a distinct background color, a distinct sphere color, and to position the sphere (in camera-space) properly for that face. The salient points for are these. As a general rule, unless I have certain knowledge that state is set, I set that state. I set the viewport each time I call . I set the projection matrix each time. Those are superfluous; I could have set them back in before the loop that calls , just as I do with the current FBO and depth renderbuffer. But I also clear the buffers, which is different for each face (since each face has a different color). 

That presupposes that you're actually trying to get that achievement. Most people that get this achievement play AI matches in order to practice and get better at the game. Your overall question really depends on what you want achievements to do. They can have many functions, and not all achievements need to do the same things. Design Feedback It is really important to understand this: achievements were invented for game designers, not players. Oh, they have useful psychological effects, but they're really just tools for knowing what someone is doing with the game. Take Civilization V's Steam Achievements. There are a number of achievements that are basically, "Beat the game with character X." By monitoring these achievements, Civ V's developers can know which characters are popular and which are not. That's why a lot of games have achievements that are basically, "Got this far in the game." They're used to tell how far players progress on average. If you find that most of your players stop 30% of the way through the game, you may want to check to see what happened between your 30% achievement and your 50% achievement. Not all of your achievements should be for game design achievements. But some certainly should be. Grinding Rewards Like the StarCraft II example you gave, sometimes you just want to give players an award for doing something that isn't itself particularly interesting. This shows how dedicated the player in question is at mastering the game. For a game like SC2, these could be considered rights of passage along your progress as a skilled player. These generally don't encourage grinding. They're rewards, not encouragement. It's a way of saying, "You played our game a lot. Here you go." Some OCD players may actively try to achieve them, but that's not what they're for. They don't really encourage replay; they reward replay that you would have done anyway. Behavior Encouragement This one is mostly for multiplayer games. It can have positive and negative consequences, depending on how well you design them. Team Fortress 2 has quite a few achievements that reward playing in a certain way. Some of them work well. An achievement for backstabbing a certain number of characters helps to encourage proper play of the Spy class. Some don't, such as the one that encourages Medics to stop doing their job and go attack people with their pathetic weapons, leaving their teammates to die and lose the match! So... yeah. Make sure that if you're trying to encourage behavior, you don't promote negative or abborant behavior. Behavior achievements should encourage play that helps the game. These generally don't help the replay value. They're there mainly to point the user in the right way of playing the game, and reward them for doing so. Challenge Rewards Challenge rewards are essentially you giving the player something to strive to. They should be difficult to achieve. These do promote replay value, depending on the kind of challenge. However, it only promotes replay among players who like the particular challenge in question. You need to design these with a firm understanding of what is easy and what is hard in your game. Also, you need to know what is possible in the game. And most of all, what your players will find enjoyable. Civ V's set of achievements has quite a few of these. The most famous of which is probably the One City Challenge. Accidental Awards These are mostly failed Challenge Rewards. The developers thought something might be a challenge, but the circumstances that might bring it about are either completely out of the player's control, or so unlikely to work that the only way it would happen is by dumb luck. So when making Challenge Rewards, make sure not to go so far that the player really has no control of when they would even get the chance to pull it off. Awesomeness Rewards A particular intersection of "Behavior Encouragment" and "Challenge Rewards." These recognize that there is some particularly difficult but cool that someone could do. You want people to try it, and you want to reward them for pulling it off. Not all Challenge rewards require awesome behavior. But Awesomeness Rewards are probably the most coveted kind, because getting them is both hard and awesome. A great example is the TF2 achievement "Be Efficient" A Sniper kills 3 people without missing a shot. It's hard to make that happen, but when you finally pull it off, you feel like a boss. Again, you have the potential issue of encouraging improper behavior. So you make sure that the awesome thing is something that benefits the team and doesn't work against good play. Consolation Prizes The consolation prize is an achievement given because the player screwed up. A lot. It's not designed to encourage behavior, since the behavior it would "encourage" already has plenty of negative stigma on it (like for example, dying a lot). It's mostly a way to point out that fail happened. To you. Obviously, these don't encourage replay value. 

You can attempt to create a context with the compatibility profile. However, you aren't guaranteed to be able to succeed. As a practical matter, all Windows and Linux drivers will provide compatibility profile support. OSX does not. But then again, OSX doesn't support OpenGL 4.x either, so you can't use it either way. 

In OpenGL terms, a "Framebuffer" is an object that holds references to images which can be used as render targets. "Framebuffer Objects" are user-created framebuffers who's image references come from images you explicitly allocate (as different from the "Default Framebuffer", who's images come from the OpenGL context). Framebuffers are not the sources of images; they only hold references to existing images, like pointers. There is no "image object" in OpenGL. There are objects that contain one or more images. FBOs can therefore take their images from one of these objects. The object can be a texture or a renderbuffer. Textures can have one or more images (array levels, mipmap layers, cubemap faces), while renderbuffers only have a single image. It sounds like you just want a renderbuffer or two for your color and depth/stencil images. 

Generally speaking, you don't. What you're talking about is a general kind of puzzle that I would describe as a "combination lock". There's some interface for the user to enter a combination, but the number of entries is too vast to brute-force for the user. So instead, the user actually solves the clues needed to solve the puzzle. Myst and its ilk thrive on such kinds of puzzles. The solution to the Mechanical Age in Myst I was a combination of 4 "digits", with each "digit" having between 8 and 10 different images. For a human, that's far too much to even consider brute-forcing. Your problem is that you're not designing these puzzles for humans; you're designing them for machines. Your design goal is to make them unable to be brute-forced by a modern computer. See, the Myst designers choose 4 digits rather than 5, 6, 20, etc, because 4 is a small number. It's small enough that you could quickly jot down the values you find on the age, then bring them to the place to enter it. The number of digits was choose for a similar reason. In total, you have a puzzle that has enough entropy to make brute force hard, but the scope is small enough to make remembering/copying the symbols easy. If you are designing a puzzle that's hard for a computer to brute force, then you will have to create an interface that a human will find tedious to enter, even if they know the solution. Take your idea. Boiled down, what you have is a 10-digit code, with 500 different possible values for each digit. Now maybe the user won't have collected all 500 before they know the solution. But they're still carrying around a satchel of 300-400 different things (which presumably have no other in-game function). When they go through the various clues to figure out what the right ones are, they will have to sort through hundreds of choices. Even if you tell them outright which ones to use (the way Myst puzzles tend to do), they still have to search through their satchel to fish them out. 10 times. That's not an interesting puzzle anymore. Or rather, whatever interest the puzzle may have generated is sabotaged by having to go through a great deal of tedium to tell the game the puzzle has been solved. Remember: coming up with the solution to the puzzle is what people find interesting. Everything the user has to do after finding the solution is just dragging things out. If I spend 2 hours solving a puzzle, and then have to spend 15 minutes poking through a UI just to let the computer know I solved it, that's a problem. Here's an example of a puzzle that had high entropy in Myst: the fireplace puzzle. You have to enter what is effectively a long binary number. It's a big pain to copy the pattern from the book, walk 5 feet, and then type it all in. How much entropy does it provide? It's a binary matrix with 8 columns and 6 rows, which makes it 48-bits. The average smartphone can probably crack that. And remember: this is a puzzle that has reached the level of being tedious, since pretty much nobody likes it. Admittedly, it's not actually a "puzzle"; at one point in the game, you're just told which pattern to enter. But there is perhaps some chance for hope. Riven presents to you the Fire Marble puzzle. It's a 25x25 grid of locations. And you have to put 5 colored gems (from a set of 6; one of the tricks to the puzzle is knowing that 1 of them is superfluous) into 5 specific locations in the grid. I'm no expert on determining the number of possible solutions for this scenario. However, when I computed 125 choose 5 to get an idea of what a similar reverse problem would be (choose 5 of 125 balls), an unordered choice represents an entropy only in the hundreds of millions. An ordered choice breaks a billion. But that's even less than the 48-bit encryption from before. It's nothing extraordinary. I know those aren't the right calculations for the puzzle. But as order-of-magnitude estimates, even if you added a couple more zeros onto them, it seems clear that the entropy on this puzzle is probably not cryptographically secure. And that's the best Myst ever got, entropy-wise. Not only that, Riven bent over backwards to justify having that many gird squares. Plus, they made it easy for you to jot down the solution. See, the grid is subdivided into 5x5 blocks of 5x5 locations (5 is an arc-number for Riven. It's literally written into the world). So you don't need to carry around a 25x25 grid; just 5 separate 5x5's with each one specifying which of the larger sectors it is. So I don't believe that it's possible for you to come up with a puzzle that has cryptographically secure entropy, without being tedious to enter that solution or for the user to generate it to begin with. Or both.