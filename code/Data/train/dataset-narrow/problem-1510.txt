If you can allow fetch to load potentially before promises are available, then you could use the fact that fetch presumably can't exist without promises in a native browser environment (because fetch returns a promise) and could use this shortcut: 

Here are two different ways of doing this, one using repeated calls to and one using repeated calls with a regex to . The regex solution requires the pattern argument to be a regex compatible string or an actual RegExp object with the flag on it. The option should be much faster than what you have since it avoids repeated operations and as a library function should be faster than your own variation. The regex option is a lot more flexible since you can search for phrases that match a regular expression. 

I have discovered, with thanks to you each, that it is better to call the display method within the DataAccess.ReadMethod() than to pass strings, Here's what I think i should do: 

I'm looking for a way to simplify this code, because I could develop more overloads for I made the string and int both of class so that in each overloaded function, the catch block could return the same value. The problem is I need, if possible, no overloads of . The function overloads are both identical, except for the type of delegate they are passed. Is there some kind of variable that would encompass any delegate that can be executed? 

I also have a helper static class that provides some functions to make some tasks easier. 4 CRUD FUNCTIONS 

Correct (produces the desired result) Reliable (always produces the desired result) Robust (handles errors appropriately and is not brittle when things change around it) Readable and Maintainable (try working on someone else's code or even working on your own code 3 years after you wrote it) Appropriate Performance (most code does not need to be optimized for performance) 

Your object would be simpler if it was a object because you can avoid all the stuff and just use methods like , , etc... It also has built in iterator instead of your manual iteration. 

Your implementation is taking and mapping it to which is not exactly the same thing. An exception or return of a rejected promise in in your implementation will hit the , but in , it will not hit , so I think your is not correctly imitating the behavior in some circumstances. Here's my implementation that should more closely mimic : 

I am asking this for coding style. I have a program class that calls a function(of a data access class) that reads from a table (using entity framework by the way), and I'm preparing to write the . Is it better to pass the function a 2d string array , reading each field and each row, and put it in the 's out parameter to return to the main program and have the main program display it? or just repeatedly call the and in the main program print each record out individually to the console? I imagine that my will look something like this: 

I also have a class called ServiceManager, which checks to see if the SQL Server (SQLEXPRESS) service is running on the local machine. 

There are problems with your readFile and writeFile functions. These functions are asynchronous. As such, the callbacks you pass to and to are called some time in the future, long after and have already returned and finished executing. As such, the return value you have in those callbacks just returns back into the bowels of the file I/O sub-system and does not go back to any of your code. So, as you have the code written, you have these problems: 

You could also consider making the max length be a non-enumerable property of the array so you don't have to pass it to every time. 

Make sure the pushMax function is not enumerable so people who iterate arrays with won't see the pushMax property. Ensure the array stays below max length even if it was previously above max Return the new length of the array, the same as : 

As you may have noticed in the code directly above, I use the DbResult class as a return type to carry the status message and bool back to the main program. I think this does not make sense since DbResult is a class created for returning results from trying to perform operations on the Database, not the SQL Server checkup. I could create a new class called ServiceResult, which does the exact same thing as DbResult, but that would be duplicating code. see example below: 

This is used in my DataAccess class, which has several methods whose return type is DbResult. They use LINQ and the Entity Framework. UPDATE Here is the entire DataAccess as of right now: 

I have a console application that I'm trying to make with minimal redundant code. I have 4 functions, Create, Read, Update, and Delete. 

You don't need to use since the data is already in an array. If you just process each file as it is read, you can avoid the iteration entirely. You can avoid some temporary variables. You should declare all local variables with , or as appropriate. 

Note also that if you want a rejected promise to just get returned as a rejection, you don't have to it locally in an function. If you one of the promises you are using on rejects, that will just reject the promise that your function returns with that error. If you wanted to catch the error locally and do something about it, then you would use try/catch: 

FYI, jQuery will also measure the natural width of any DOM element for you so you could also have a span that is styled with the right font that you insert this text into and then ask jQuery what it's width is. jQuery will temporarily make it position absolute (so it will layout to it's natural width) and then let the browser tell you how wide it is. This would be much, much more accurate than what you are doing. Letting jQuery measure it for you would look like this: