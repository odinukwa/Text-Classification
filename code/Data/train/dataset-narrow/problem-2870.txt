It's really only the creation of an object out of thin air that violates natural law, since it's the position at which the object is created that generates GPE. All forces are entropic, which is to say (in a tremendous simplification of terms) that they cause systems to evolve toward a resting state. The more starting energy the bigger the forces, and the faster (usually) the final state is reached. It's actually change in force, the gravitational attraction between one thing and another which popped into existence, that "generates" energy. Energy would be conserved in such a system if, say, you could only create 5 objects, and they eventually reached a final position where they orbited each other or landed, the energy would end up being retained as angular momentum. We could explain away rounding errors (which should be in favor of energy loss) as universal entropy. =P 

That is right idea for reading/writing images but you'll want to get your "ImageLoader" class from a library, which will then give you a regular bitmap in memory to work with. The layout of that bitmap class is going to depend on the library you use. To see why, or what you need to handle if you want to write your own, see the W3C PNG Specification. 

Note the complete lack of references to entities in this loop! The update and draw methods are really the only two special cases you need, and we only tolerate draw being separate as an optimization in the face of system limitations (it's generally better to try and group draw calls, and draw doesn't need to be called every pass) - it's not architecturally ideal. If each component has a reference to its parent entity, it can talk to the other components on its parent entity and there's no need to pass the entity as an argument to its update method. There's no need to have special methods for each component either, since that could just be wrapped into a uniform set of method declarations: 

It's probably the first of those. It looks like you're attempting to procedurally generate it, so you'll want to check on how you're ordering your vertices in the triangle list and how you're coming up with UV values. 

The fundamental reason why projects are successful (in terms of funding or completion) is this understanding and management of risk. You post concept art to demonstrate competence. You talk about the writing to capture people's interest and imagination, to show that the story is well written. You give examples of past projects to show that you're capable of commitment. If you can't take a good hard look at your project and tell me the most likely reasons it could fail and how you're addressing them, you haven't put enough thought into it for me to give you money for it. Once you can address all the risks, ideally with evidence but a passionate explanation can go a long way too, that's when you know you have enough to go ahead with a financing campaign. As an exercise to find out what's important to your project, you can examine similar but failed campaigns on crowd funding sites to see what risks they failed to address adequately. Especially helpful are the ones that look really polished, but didn't come anywhere near their funding needs. 

It's isometric. How can you tell? When things get bigger the closer they are to your point of view, that's "perspective," because your perspective matters in the view. When things appear to be the same size no matter how you move the view around, that's "isometric" (Greek for "equal measure"). Since the objects at the bottom (what should be the near edge) of the screen are the same size as objects at the top (what should be the far edge), we know it's isometric. If this were 3D and we were looking at models, we would use Perspective and Orthographic projection, respectively, which are two mathematical models of how we map coordinates in 3D space onto a 2D surface for display. 

You'll have to load your scene as normal, so that your menu objects and scene objects are in the same area. You'll then use culling to separate out which camera displays what objects. So you'll want to use two cameras - one for GUI objects and another for everything else. 

The return value of ShowDialog is set by altering the value of Form.DialogResult. To ensure that the correct result is set, override the form's OnClosing invocator or hook its Closing event and set it there. 

The more general idea is transformation, which includes a frame of reference and typically rotation. The frame of reference with respect to position could be another object ie. 10 feet above earth's surface at lat X, long Y, or it could be implied to be the world origin (0,0,0). For rotation, we usually use a canonical rotation that is the result of whatever format, say, a model is in, and then the rotation is implied to be offset from that. Unity actually takes frame of reference from parented objects, such that each item has a local position that is offset from its parent objects. For example, a driver's position is local to their car, and thus the world position of the driver is relative to the car's rotation and position. This is an important concept because position at any given time can depend on attached objects' current rotation and position. An especially complex example: Local Cluster -> Galactic Center -> Sun -> Earth -> Car -> Driver -> Driver's Hat -> Spider on Hat With this scale of simulation, we need to know the driver's hat's position relative to the driver, the position of the driver relative to the car, the rotation and position of the car relative to earth, the location and rotation of the earth, and so on. Of course, unless you're working on something like Kerbal Space Program, this amount of parenting is unnecessary. Most often we use this to attach clothes and props to bodies and bodies to vehicles. 

...each beat will be found at milliseconds, where is the n-th beat. You then need to tweak your score thresholds. Here are a few as an example: 

You then run all these tests in a separate mode and take note of which ones fail, or you can use an external project that links in your code to run all the methods. Most Unit testing APIs like NUnit provide decorations so their test engines can automatically extract, run, and gather results from your tests. Check out "Unit Tests By The Book" part 1 and part 2 on the Unity Blog. 

The most important thing, and the one I think causes most game projects to fail, is not understanding feasibility. To put it another way: The Risks section of your business plan, Kickstarter, or whatever, is the most important part. Maybe not to everyone, but to you and your team, and especially to the people who can market your project to their audience. You need to really understand your risks and address those if you want people to invest in your project and address those directly. Otherwise there's no point in having any of those things. If you know or can find a project manager, they can help with this. Here are some example considerations: