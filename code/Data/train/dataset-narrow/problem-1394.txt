Other than this, your code looks good. You use prepared statements, so it's secure, and your style is consistent and easy to read. I would probably write as as it's more readable, but otherwise everything looks good. 

Comments I always appreciate method level JavaDoc comments, to get a small overview of what a method does, what arguments it accepts, and what it returns. It makes it a lot easier to see what's going on. Misc 

Your function seems to do too much. Handling input from three relatively different forms in one function isn't a very good idea. If you extract the handling of the forms functionality, your code would be a bit cleaner: 

Reviewing code not written by you is off-topic, so I'll be brief about that. But yes, you are right with all your questions. There is a lot of duplication in that code (the duplicate arrays might be explained by them wanting to sort the exact same array each time, instead of one that has already been changed by another sort function; in that case, a function would avoid duplication), the formatting is pretty bad (unnecessary newlines, no paragraphs, no indentation, lack of spaces, etc), multiple statements on one line, and so on. 

URL Structure The URL structure is hardcoded in the //etc fields, which doesn't seem like a good idea. It is confusing, and it means that and are responsible for how the actual remote call looks, instead of having it all in one place. This means that in case the call ever changes, you have to change your code in two completely different classes. So what I would do is move the strings into the class. You don't specify if you have control over how the API works, but if you do, change it. Sensitive data should not be submitted via GET, as URLs are frequently logged (client- as well as server-side), while POST data is mostly not logged. Exception Handling Your exception handling could be improved. Just catching and printing is rarely the best choice. It's not user friendly, it's not development friendly (the stacktrace is swallowed), and it's not good for reusability. It also takes away any control the calling class would have if you just threw the exceptions. What if it doesn't want to print? And what if it doesn't want to continue? Eg seems like a good reason not to continue, except if specifically order to do so (you could add a flag to for this). Misc 

The main reason I would prefer this approach is that it follows the MVC approach (separating the code by model (), view (), and controller ()). This seems a lot more flexible (with your approach, I even have problems extracting the main method to its own class, for example). Misc 

These functions do widely different things (replace stuff in a generic string, handle HTML, handle colors, ...), so there are probably better places for them then a generic class. A class like this would grow quite large if you handle all functions like this. for example doesn't really have anything to do with strings, and is something else entirely. 

Note that the injection takes place into a JavaScript context, which is worse than injections into HTML context because browser filters have a hard time catching it (if you try the payload with eg chrome, it will execute, while would not). Standard HTML-encoding would solve your problem, but OWASP recommends escaping to prevent XSS in a JS context. Misc 

You have to decide if it's more readable. It's certainly less complex (and mistakes/typos are easier to catch), but it might take away some clarity. Misc 

Yes, it's safe (against SQL injection; if you give users complete control over table and column names, they may read data you do not want them to read). But I would worry about performance a bit. For each query you want to perform, you actually have to perform 4 queries now. The looks to be the most expensive - it fetches all items in the table -, but is luckily also completely unnecessary. You use prepared statements for the id, which is enough. If you do want an additional layer of security, you could additionally filter your input (for example, you know that ids can only be integers). You could use an input class like this for example. For the table and column check, this is a bit more difficult. Ideally, tables and columns should not be user supplied. But I have seen both in practice, so as defense in depth, it's not a bad idea to filter this at this level. I could think of two possible performance improvements: 

Error Messages Going by the names, this seems to be an online shop or similar software with actual customers. In that case, error messages should be factual and non-insulting. You cannot know if this was an attacker, or someone who might just have made a mistake. Handling Errors Contrary to your comment, catching an exception, printing the message, and then continuing the script as if nothing happened is not handling an error. If you cannot recover from it, redirect to a custom error page or similar. Style Use correct indentation. This is really important and improves readability of your code a lot. Request Types Be consistent with your request types. Right now, you are checking , but retrieving . So an attacker could post the value and get around your checks (which isn't that bad because you are using prepared statements, but still). Return Early You can reduce if nesting by returning early: 

Security Curl Set POST I don't think that there is a problem with passing user input to as post field (something like http header splitting is not possible, and it doesn't even seem possibly to add additional post fields, or to overwrite existing ones). Important information via GET It's not a good idea to send anything confidential via GET. GET requests can be cached, they can be stored in the browser history, they show up in server logs, and so on. Use POST instead. SQL injection isn't controlled by you, so you shouldn't trust it, the same probably goes for . Never put variable data directly into an SQL query, use prepared statements instead. CURLOPT_SSL_VERIFYPEER If you disable this setting, you weaken the security of SSL. Yes, you still encrypt even if is false, but you would also accept the key of a man in the middle instead of the key from the server, so an attacker could still read the communication. Here is the warning from the documentation: 

Missing Functionality As I know hangman, the letters that were guessed are written down. You should also save them and print them out each time, otherwise the user has to remember this. Bug If I play a game, lose, and then print out all words, the hangman board is printed as well. Game Loop Use a game loop instead of your repeated calls to . Your approach is hard to grasp, especially since you not only call from , but also from and . It would look something like this: 

Object Oriented I wouldn't call your code object oriented. And yes, using in too many places can be a hint that you are not using OOP correctly. But your program is so small and specific that this isn't really a bad thing. If you actually have some extension in mind, a different approach might be better, but right now, I would leave it as it is. But for example, lets say you plan to write a program in the future which prints every odd Fibonacci number, or every Fibonacci number dividable by 3. With your code, this might be harder to do. If your approach was like this: 

I prefer your method, because it's a lot clearer. But I would turn the if around (first check the input, then the normal action): 

Your questions seem to have been answered (use jQuery), so here are a couple of small points regarding readability: 

As is always false, you are doing some unnecessary loops in your program. The quickest way to fix it would be to just add after assigning in the inner loop. And then the assignment to could just be . But you could also get rid of the var altogether and to it like this: 

Now it's pretty clear when what is happening (of course, you have a lot more function calls, but the code clarity should be worth it). Security You are open to directory traversal via . In your case, that isn't all that bad, but it should still be fixed. What can happen is: 

I already posted something about the general concept and OOP, but I also have some comments on the concrete code: displayWhoWon You have 

Now the code is a lot more readable, and because it is in separate functions, you could profile it to find bottle necks, and then improve on those. Another added benefit of separate functions (apart from the readability, reusability, and profiling) is that you can test them separately. 

When you fixed the issues mentioned in the answers here you should post a follow-up question which contains a bit more code. Right now, I can only guess how might work (where does the data come from? how does model store it? how does insert actually work with real data?). 

Most of those things would deserve their own class. At least three new classes would already be helpful: for reading/writing, zipping/unzipping, and handling of directories. Methods Your methods do too many things as well (a method should really only do one thing). Take your method as example: It's 80 lines long (as a rule of thumb: if it doesn't fit on your screen, it's probably too long), and it does multiple things. Even your comment states this: It creates the SQL, it writes it to a file, and it zips the file. But even if you extract those functionalities, your method to create the SQL would still be too long. I would create a function which is responsible for creating the SQL for inserting data into one table. That way, at least your code is separated from the rest of the method. Details Early Return I'll take your function as example. You ask a lot here, and this leads to very deep nesting. It's very confusing to read, and it will lead to bugs quickly. Instead of using your approach, it's better to just return as soon as you get an error (if there was an error, you are not doing anything else anyways). So your code would look something like this: 

Usability As I mentioned in my comment, you just exclude way too many names (even for a test program; I would at least add a comment in the code). Personally, I would accept any input, do a length check (it should not be empty, and it should fit into the database), and that's it (for further input validation - if it's needed - I would use a web application firewall, or something similar to filter all input). It will be really frustrating for users if they cannot enter their name, and thus have to make up a name. Security I don't see the use of your security integer. It's hard to see what it's meaning is from the outside (if you really want this, use an enum), and it's not really needed. 

Without your code, it's not that much more to write, and it is a lot clearer what is actually happening. Improving your approach Now, I'm not generally a fan of wrapping/extending PDO like this, but you can improve your methods to make it a bit more usable. First of, documentation. It is completely unclear from the outside how to use your code. This can also easily lead to security issues, as and should not be user-supplied. Secondly, it's really not needed that a user passes themselves. It makes your method harder to use, it doesn't provide any additional functionality for a user, and as said above, it can easily lead to vulnerabilities. Thirdly, as mentioned, use exceptions instead of error strings. A better method signature might be this: 

This seems a bit complex for relatively little benefit. Personally, from these two choices, I would go with the approach for simplicity and slightly improved performance. But I do see your point about the default value, and the readability of the array structure. If you actually do have a lot of parameters which have a default value, your approach might have merit. But since you are going through the trouble of updating legacy code anyways, you could also think about choosing a different approach and create an class. It would also result in readable code, and you could add input filters, increasing your security. The structure is really a matter of preference, but it might look something like this: 

I would either define these strings as static fields (), and then use them from outside the class, or do it how PHP does it for eg by using to create a global variable (I would actually prefer the first approach). Still, good documentation would still be nice, I would add an example case to the PHPDoc (the current isn't helpful at all). Misc 

Yes, it is. You should never put any variables directly into SQL statements. Even if you think that the variables may possibly be safe, it's just really bad practice, and you will mess it up sooner or later. In your case, an attacker could use the profile fields, which would very likely lead to SQL injection (this depends a bit on the input filter for the profile fields, but I would be surprised if it caught all injections, and you should definitely not rely on it). 

I don't mean the code inside the function, just the function definition and the function call. General Approach You already mentioned that this is probably not the best approach, so I'm not going to say too much about it. Generally, I would probably go with an iterative solution as most of the time they are easier to understand and faster as well. An example of an iterative approach might look like this: 

I wouldn't do it this way, because it does seem confusing. And not just because you are using truthiness (which I really wouldn't do, because it's hard to understand and just screams for bugs). It takes a while to see what happens when there is no POST value, what happens if a categories doesn't exist, etc. You don't need multiple checks either though, just move all the code that belongs to category-doesnt-exists and category-exists into one block. If you also extract some code to functions, your code might look something like this: 

I don't think so. This doesn't seem like performance sensitive code. Even if you added a couple of branch instructions, it shouldn't lag (not now, and not with future extensions to the code either), so there is no reason to avoid them (except to see if you can do it). The lack of branch instructions isn't the only reason that your code is extremely hard to read though. Your variable names and your formatting are also making your code hard to read, and thus hard to maintain. There are tools which can minify your JavaScript and CSS for you (and they will do a better job than you will), so there is no reason for doing it that way, you can follow proper formatting rules (this goes for the JavaScript, CSS, and HTML): 

OOP Your internal class doesn't have any state itself, but uses the fields of the enclosing class, which is quite confusing. could just as well be removed and its methods made part of . It's also rarely needed that a class has a field storing an instance of the class itself (linked lists would be an example where this makes sense). If I remove the field from your code and call all the methods directly, it still seems to work perfectly. I don't want to do a complete redesign of your code, but if you do want to use classes, classes such as and might be more useful. Error Handling Your code doesn't handle invalid input very well. As I had no idea what valid input looks like, I tried a couple of things: