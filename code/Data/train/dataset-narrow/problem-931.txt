After months of going back and forth, I broke down and ended up returning IResult or IResult< T > from all commands/queries. The IResult looks like this: 

This way, I don't have to handle any exceptions to change the flow of the code except when a truly exceptional thing happens. It is caught like this in the top level exception decorator handler: 

Validation The validation decorator will run validation on multiple threads (if you want) and async will not block. I didn't use expressions since a lot of times validation involves multiple properties and has a lot of overhead. The BrokenRule() parameter is the "Relation" and it can be used to tie the rule somewhere on the UI. 

Validation uses ?. here so that the second part isn't run if there is no rule. .NET Core changed the way translations work, so I had to IoC inject a reference to them now, which is why you see that. CreateCommandRepository 

I've created a "framework" or more of a library for a CQS implementation with a few decorators. Using ASP.NET Core for the front end, I wanted an opinion about how this looks/feels. I changed the default mvc approach and created a Features folder that stores both the Views and Controllers in the same folder. Then each command/query ends up being in its own folder in the implementation. I have the following decorators: Exception/Logging, Retry, Cache, Cache Invalidation, Validation, and Permission. Any input at all is welcomed! This will be along post, but it'll be an interesting read, in my opinion. :) First, CQS = Command Query Separation. Essentially, queries return data and do not modify state and commands modify state but return no data. There is a gray area here where you need to run a command but then return the data (i.e. Queues, Stacks). Thus, i Created a "CommandQuery" for those scenarios where just a command won't be good enough. CQS normally has ICommandHandler<> and IQueryHandler<> interfaces to support decorators. Decorators are classes that can add functionality to these classes without changing them. i.e. The calls are chained. They implement the same interface, but I use SimpleInjector to make those classes run before/after the actual implementation. All code becomes narrow and easy to maintain. Also, you can add more decorators to all commands/queries with one line of code. I tried to follow SOLID through all the layers here with the intention that every piece of code will be unit testable at a high level. The problems being solved inside may end up more difficult than that, but I digress. :) (My mock implementation deals with Digimon World 2... Don't ask) :) Controller 

With this code, you filter your list over and over for each rule you encounter, which seems sub-optimal to say the least. I'd rather construct a single rule, which gets applied to the list once. Here, you can use the Predicate combination via "and" as this is basically what you do with chained filtering. Something along the lines of: 

Is this better than the loop: I don't personally think so. My advice: stick to your loop or revise your data structures to better support this approach. 

Hmm... the generalFizzBuzz method is a mix of business logic and output, I think this should rather be separeted. Thus, I'd rather have a business logic conversion number, which converts a given number to test to the output string: 

This basically boils down to a grouping problem: you have an input list and want to group it by date, which yields a per-date list of a given length (1 to number of departments). Then, these list's contents get added to a collector list chosen by the list's size, i.e. add all contents of list with size 1 to collector 1, add all contents of lists with size 2 to collector 2, and so on. Using the stream API, you already have the grouping, the rest is a little footwork: 

Version 1: Basically OK, but the copying of elements to another list is unnecessary. Have a look at on how to create lists from a given index range. Additionally, you should change the return statement to so that the recursion does not take place if result is already false. (Look up short-circuiting in logical statements.) Version 2: NO. It is much better not to copy the elements and use indexes into the unmodified structure, but here you recurse for every element in the list, i.e. the recursion depth equals the list size. This is a total no-go, as it will definitely blow your stack if we are talking about serious data sizes. Nevertheless, explore the option of using indexes (maybe a start-index AND an end-index) into the given structure some more and combine it to a divide and conquer-approach as in your first solution. Happy coding! 

If you don't mind me asking, any reason you want to register the DbContext directly? I know .NET Core seems to want you to do that, but I don't like IoC containers deciding when to leave open or close my DB connections. Insetead, I'd just do IFooDbContextFactory and have that use a "CreateAsync" method. This factory can take your IAppSettings or IDbContextSettings or something to get the connection string. Then you can call the provider async just fine and in your specific code you'd just do: 

My "repository" is a little different. The repository here is above the database technology being used. That way, if you want to change from EF to a webservice or something, you can change that implementation easily without affecting the handler above. Mapper 

I have the complete opposite view. Every query is specific to its use case. Today it may be true that you can call the other query but if someone changes its output then your query could be impacted. Maybe the other query gets a permission added to it that yours doesn't have. It is far better to simply build and return exactly what you need and no more. You may be thinking that you aren't reusing any code this way and you would be right. If two UI had the same data on it why would you have two? 

Instead of shuffling the byte array around all the time, I'd rather create an additional Frame constructor, which operates on the byte array, performs the deserialization and sets all internal variables to the values from that byte array. Then, you'd just parse the answer into an object and use the object for all later references: 

You can use the new utilities in the comparator class. Unfortunately you'll have to help the compiler a bit with the generic type induction. Assuming, that the value class is "Whatever", this can be done like this: 

Volatile won't do anything here, as this basically only affects the reference to the map, not the contents of the map. As for ConcurrentHashMap (as opposed to explicit synchronizing I suppose): this depends. If you want to make absolutely sure that no digest is ever computed twice, stick to your approach. If you just want general concurrency, but can accept that eventually in race-conditions, digest is called twice for the same input (sidenote: I suppose digest is deterministic, so that two calls with the same input yield the same result), you may simply repace the map with a ConcurrentHashMap and the whole method with: 

You failed to solve the "try to do this in one pass" part, as you iterate through the list once to find the total size and a second time to find the nth element from the start. The algorithmic idea is, to use two pointers into the list: 

If you know the queries you affect, you just have to give it the query type and it'll take care of the rest. I made it async in case it took some IO to figure out all the types. Decorators The most important decorator I wanted to show was the exception handling one that is at the top of the chain: 

Edit The last point here is that Exceptions actually are pretty slow. When I throw an exception, it ends up taking around 150 ms to get the result back. When I switched to not throwing an exception, it would get around 25ms response for the exact same check/data. That is 6 times slower! Thus, avoiding exceptions seems like a really good thing to do! :) 

I also work on an e-commerce platform that has tons of data in it. What I've found is that if you have more than a very basic query, write the query yourself. EF speeds up saving records and very basic selects, but as soon as you start doing something a bit complicated, EF will spit out thousands of lines of SQL for something you could have done yourself in 100. You are better off just trying to create the SQL for it and use Dapper or just create an object that you can map directly back to from the query. Use context.Database.SqlQuery(sql, parameters).ToList() and you'll be able to get exactly what you need. Though, naturally, it is going to be way more work on your part since you have to do all the joins manually and type that out, but if you need it to perform, then I would really recommend just typing it out. I've had calls go from 60 seconds down to < 4 by just doing it myself instead of relying on EF. 

Edit: As an afterthought: why do you waste so much code with null-checks anyway? This is a technical interface, so whoever calls this, should simply not send you invalid requests. Therefore, in real life, I'd simply add the condition "values must not be null" to the interface contract (if possible), then do a single validity check at the beginning of the method, and reject with status code "bad request" if there are nulls in the data. 

That is exactly what Sonar says: "... from which an application should not attempt to recover". Thus, if you catch Exception and NOT Error, yes, this will effectively terminate your scheduler and probably impact the DataStore. BUT: as Errors indicate a severity, where the VM probably won't be working reliably anyway (also see $URL$ this is exactly the thing to do: terminate the program, bail out, call the admin. When you continue working under error conditions, the result is generally somewhat undefined. Better avoid this. 

You mix business logic with UI code. Normally, you'd go for separation of concerns and move the conversion functions into a separate class which is used by the UI, but does not belong to the UI. Running a separate thread: how long does the conversion take? 1 ms? 2? I really doubt that the overhead of thread-creation is necessary here. (Though it may indeed serve as an excercise!) Binary to ascii validation: if the amount of bits does not match, you overwrite the user input? Thus, if I, the user, make a little mistake, type 319 bits instead of 320, you actually force me to start over? /me pissed user :-) 

That way, the rest of those scenarios are being handled by the other decorators so returning an IResult doesn't become cumbersome. At the UI level, I created a ResponseMediator instead that returned IActionResult items. This will handle the IResult and return the appropriate data/status code. i.e. (ICqsMediator is what IMediator used to be) 

All my queries/commands/command queries end up returning IResult because I found throwing exceptions is really expensive. Thus, this lets me deal with any issues. IResult is returned by Command and doesn't return any info about the actual call, so it doesn't violate CQS. Query returns IResult< T > that stores the data. I'll show an example here of the Create Command through the layers. CommandQuery 

Since we can route the different verbs to different classes, we can focus on only 1 method at a time per class. I'm using Mediators everywhere so the code looks the same across all classes. I thought this was really the Service Locator anti-pattern, but it isn't because you still know the mediator dependency. I also use async through the entire call stack because Task.CompletedTask, if needed, has very little overhead and not blocking threads is the way to go. ResponseMediator 

I like the Factory. I called it Create() instead of MasterDbContext. :) After that, I'd like to talk about it a bit. I used to try to do things like this too since it felt like that is what I was reading all over the place. However, EF by itself already is a Unit of Work with Repositories (DbSet) built in. Thus, creating another one over the top doesn't add anything at best and takes away features at worst. If you are looking for something a little different, read up on CQS (Command Query Separation). With this style, you can go directly against the DbContext inside a command or query specifically and select back out what you need. Each command/query is specific to the business problem at hand. You could even swap EF out for Dapper if you wanted to for certain queries. If this doesn't really help you out at all, let me know and I can delete this answer. Edit: One thing I would mention is that you create some sort of interface that represents a user. You can use IoC to link that to some class in the UI that pulls it from the User.Identity if you need to. That way, you aren't passing the UserId/UserName into the method declaration but instead are using IoC to get that information. 

Then, the actual call of the logic is simple and clean, no matter whether you use a loop or a stream: 

OK, the data-structure looks a little wierd here, because your list consists of map-entries, but this was the main work. If you print this result, you already get (format added manually): 

You check whether the index of the tab equals the position. If this is the case, use the selected icon, otherwise use the unselected one: 

Funny how nowbody seems to know the class... I agree with the previous answers, that try-with-resources is a good thing to do, but to perform the task in a real simple way, use : 

Then, for the methods themselves. Basically you always do some outer loop checking projects != null, then an inner loop checking versions != null. If you can live with a different message order (errors first), I suggest you create a preprocessing method first, which will sanitize the input and emit the according warnings. Something along the lines of (attn: untested editor-only code) 

Regarding the method: you could at least eliminate the repeated call to s.length() for every loop operation: 

Or going back to principles: separation of concerns: load the window, return the controller is enough for a single method. Init data seems not to belong in there. 

The main question here is in the understanding of the business context: do you want the date of operation as an external parameter (I tell you now that I will have a withdrawal next Tuesday) or always as "now"? If it is always "now", create it internally like you do right now. If you want to test the result of "new Date()" to equal a given predefined value, you could either use Powermockito to mock the new operator on Date, or inject a date factory which you can mock. Apart from that, there are two problems with your naming which make understanding the code quite hard: 

ICommandQueryRetry will cause this to retry general exceptions up to 3 times before failing. For caching, you just add a different interfaces (a few different ones for different timeframes) and it takes care of it for you. 

There are specific scenarios in my logic where I can easily not throw an exception and have the above layers just check those boolean flags to determine what to show the end user. If a real exception occurs, I can put that on the ErrorMessage property and pull it from there. Looking at CQS, I realized that returning an IResult with this for a command is okay because it isn't returning any information about the actual process. Either it succeeded (IsSuccessful = true) or something bad occurred, meaning I need to show something bad happened to the end user and the command never ran, anyway. I created some helper methods for creating results so coder's don't really care. The only thing that gets added to the main implementation is: 

I find if you do this in chunks together (all these classes, minus the controller) are all in the same folder as they are all related, that coding the mapping by hand isn't that big of a deal. Though, I made this generic so you could setup your own that just used AutoMapper or whatever instead. Invalidate Cache 

If you are still reading and your eyes haven't glazed over yet, what are your thoughts? Is this too much? Thanks! 

These throw NullPointerException if the respective parameter is null. This is the clearest way to tell your user that this was unexpected. (If you use some kind of validation framework like javax.validation, you might even annotate the parameters as @NotNull). Furthermore, I recommend IllegalArgumentException for illegal types instead of returning null. DRY Then, you repeat yourself with the check - you could refactor that into a variable. switch String comparisons can be done via a switch statement. To be case-insensitive, you can switch over of the string and use lowercase constants. delegate to specific methods Last advice: move the concrete object creation to specific methods for objects, and simply call the sub-method from the main method. Putting it all together 

First look, I'd change the if-chain in getNeighborNodes by defining directions, their offsets, and taking the same actions in a loop for all directions. Along the lines of: 

The most important problem I have with your code is, that it totally fails to achieve the goal you set yourself. This is not dynamic at all. Basically, you take the "normal" method body and put it into a lambda, but this lambda now is a complex function, which contains all of the business logic. Dynamically, you'd need a collection (probably list for being ordered) of lambdas, which each check a single input value and return an appropriate string representation (i.e. "fizz" or "buzz" or "whatever" or the empty string) and a method to apply this complete list on a single input, accumulate the results and perform the final check whether to output that string or the integer itself. Thus, start out with something like: