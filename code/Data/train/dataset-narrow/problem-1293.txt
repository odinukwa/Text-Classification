One way to make it easier to follow is to construct your merged documents result separately from your input (above code is not tested). Construct a dictionary to easily get the document to append to, based on type. It also ensures a fast operation. For each document from the input, append its pages in the dictionary: 

If I understood correctly what you are trying to achieve (concatenating objects for owners), I think one way is to actually process all the data on SQL Server. Setup: 

Things that just pop up in my mind when seeing the code (more of the architecture and robustness rather than language constructs): 1) Harcoding path to ini file The path might have a meaning in your development environment, but it will mean nothing in a test or production environment. I would set it in an included file and use it from there. Something like: 

Usage in markup: It is very concise, as I want notification to look homogeneously across the entire application. Customization is possible through methods exposed by the factory: 

One way is to have a function that returns a table composed of two s, corresponding to each of your s: 

Question: Can any of the above be improved in terms of architecture? Performance-wise, the initial Excel package creation and other initializations may take even 2 seconds, but after that, getting changes usually takes 100 ms (send changes, process + get changes back in browser). There will be only a small number of users to access this functionality (maximum 20 concurrent users), so I do not expect any performance issues. 

Eager load is recommended to avoid separate queries generated when Chart object properties are required (less SQL verbosity, significantly faster for large collections). will automatically map properties having the same (and type, if type is different and no implicit conversion can be done, it will throw an exception) and not ignored ( attribute). 

Update, make the name of a It turns out the name of a can be a consisting of characters for which is . Changes needed for that: Change to 

A similar change can be made to Removed unnecessary use of In the function , the argument type is . The in that type has no benefits. I would change it to: 

I understand that you have some concerns about using containers from the standard library. However, it's OK to use of member function templates described below since they don't involve use of standard library containers in the interface of the member functions. Here's how I see to look like: 

Other suggestions: Add functions instead of This may be a matter of stylistic preference but I think it is better to use: 

PS I am not suggesting as a function name. It just illustrates the concept. Avoid multiple statements in one line The line 

Make functions still smaller You have functions that accept input, process the input, and display the result of processing the input. You can separate the first part the last part into separate functions. That will make your code easier to follow and maintain. For example, can be: 

Change physical layout of the classes The section of a class are most important to users. Hence, I recommend the section listed first. If we could, we could completely hide the section from the users. Hence, I recommend the section to be listed last. 

You have class templates with the above enum as template parameters. You have specializations that use the enums. You have user defined suffix operators that depend on the enums. If you want to add to that list, you'll have to search for all the places where these units are used, go through every one of those files, and add another function, another value, another clause that deals with the new unit. These are very intrusive changes, and will most likely introduce bugs. You shouldn't have to modify existing working code to add new type/enum to the code base. My suggestion 

However, logic for the dates is unclear for me, even after reading operator precedence (AND takes precedence over OR and BETWEEN). It is strongly recommended to use parenthesis when using multiple operators with close precedence. 6) Set based logic WHILE and other looping constructs are intruders in T-SQL language. They will usually behave (much) poorer than set based approaches. So, your WHILE can be converted into something this: 

Complexity should be as all dictionary operations are done in . If your documents were copied from some other data structure to your response, I think it is better to construct the dictionary from that data structure and obtain from the merged data. Otherwise, you have to use a loop to remove documents already merged (somewhat more convoluted than version). 

I have used properties, a more generic list type (IList<>) and put a more C#ish capitalization (Pascal case). 2) Proper disposal of disposable objects implements and should also included in a using block (as its close friends and ). Also, in order to shorten things a bit, C# allows usage of to replace the actual data type: 

So, error on saving changes will have consumed the sequence numbers and thus you obtain gaps. On the database side, this thread approaches the generation of gapless incrementing identifier, but I am also thinking about generating identifiers within the application layer and restoring the value on save failure: 

2) Variable declaration closer to usage C++ allows you to declare your variables anywhere before they are actually used and it is a good idea to be as close as possible. The first part of your program may look like this: 

Your models project should contain only functionality related to data models such as: data models themselves, data context, repositories. Provided code does a simple thing: gets a model based on its identifier, so this can be included in a Repository. E.g: 

Create a base class called . Create sub-types , , and . Make sure has the necessary virtual member functions that are needed for supporting the high level functionality. Implement , , and in separate files. When the need for adding comes, it will be a very simple process. Create a class that captures the quantity part and the length unit part. Remove altogether. Make a regular class, not a class template. 

Inconsistent naming convention All of your functions are consistently named except . That should be changed to to be consistent. Inconsistent physical layout All of your functions are declared and defined before except which is defined after . I would recommend putting the definitions of all the helper function before or all of them after . Having some of them before and some of them after is inconsistent. Personally, I prefer the declarations of all the functions to be at the top of the file irrespective of whether they are defined before or after . Names of functions This maybe a personal preference, but I think function names that start with a verb seem better than those that start with a noun. Use instead of Use instead of already starts with a verb. Using s for user choices Instead of using magic numbers like and , I would recommend using s. That will make the code more readable. 

And move the logic of getting the ordered rank value from the input rank to a helper function. In the function, use a instead of an logic. 

you allow multiplication of matrices that don't result in a square matrix. However, if you multiply the following matrices with just that change, 

You get automatic memory cleanup. In your posted code, you don't have a user defined destructor. As a result, you have a memory leak. By using s, the default destructor provided by the compiler will take care of releasing memory used by the s. It is easier to iterate over the array. You can replace the following block: 

Besides 's suggestion and based on 's comment, it makes sense to log more detailed information. This can be provided using a formatted exception string or using a logging library. The second option has the advantage that can be customized to log only some levels (e.g. one usually wants less verbosity on production). The code using NLog (but this can be replaced with any other library or a custom one) would look like this: 

A possible approach is to put all the repositories in a UnitOfWork class, so that multiple changes can be done in a single unit of work (transaction). Something like this: 

4) Defensive set If by any chance, the select for year returns more that one year, set statement will fail. You might consider assigning with and/or using , just to be sure it does not fail (however, it may return an incorrect value). 

It has been a while after toying with the notification factory and directive. Now I had to actually use it in several dozens places in a real Web Application. Doing so, I realized how much code must be replicated in controllers and markup. In order to avoid this, I tried to keep markup and controller code as simple as possible: The factory: A factory creates a "class" that takes care of the dirty details of setting visibility, type, text and so on. 

However, keep in mind that your function will be called for each row returned from (clearly visible in profiler, estimated/actual plan does not show function calls, if I remember correctly), so performance might be affected. Also, * should be avoided since it can lead to performance problems (selecting all columns may inhibit indexes usage) and also may also lead to unexpected results (changing table structure without procedure recompilation, means that * does not actually brings you all the columns). If possible, please provide code from - maybe it can be rewritten to be more set based. 

It's not clear to me what you are trying to do here. I think you should change the type of from type to and have just one line to increment its value. This is how I see the loop. 

Since you are dealing with only integral numbers as input from users, I would create a helper function to get input from users. 

I'll leave the implementation of as a detail. Avoid I would recommend using an overload of . That makes usable with all kinds of objects. It also makes the task of outputting objects of the class more idiomatic. 

After seeing your code the first time, something didn't feel right. I couldn't quite put my fingers on the problem. However, after going over the code a few times, I came up with a few things that can be changed to improve the code. Using the right nomenclature I think the nomenclature is wrong. Metre, kilometer, and mile are better thought of as units of distance instead of being distances. 12 metres is a distance but metre is not. Your use of distance and quantity is not quite right. Distance is a quantity + a length unit. When we say distance from point A to point B is 5 kilometres, 5 is the quantity and kilometre is the length unit. Design of the and various classes It occurred to me that your design violates The Open/Closed Principle. You have the following that's the lynchpin of your entire program. 

Use a better name than I would prefer to use something like or . Update The functions will be problem when is . If you like to use the functions for all types, it will be better to change to a different function, such as . 

In addition to the points raised by other answers ... You seem to have the wrong types in and functions. I think you meant to use , not . 

Generally, it is easier to think your program logic top-down than bottom up (doing little things and merging usually requires more skill): 

4. Simpler and more natural iteration Your logic is fine, however a chess board is 8 x 8 and a natural way to iterate is by rows and columns, rather than tile by tile. 

Besides great performance improvement due to 's suggestion, the code can also be improved. I have put comments to indicate changes: 

I am not familiar with Autofac (I am a Ninject fan), but I expect similar concepts and implementations, so I have a few ideas: 1) data models serialization I see attributes in your data models, which leads to serialization (?). As far as I know, directly serializing EF data models is not a good idea because it might lead to circular references caused by navigation properties (which crashes the serialization). One way is to define some service models that are obtained from data models. Mapping can be done quite easy using a auto mapping library such as AutoMapper. 2) Repository implementation can be extended with some useful functions 

Also, table is not required anymore and the whole block is slimier. 7) Proper data types suggests that Sales_Closing_Date is not a DATE (maybe a or ). If possible, use the most appropriate data type to avoid explicit or implicit (silently occurring in queries) casts. 8) Comments It's a matter of taste, but I like comments written as normal text, not using CAPS 

This solution should be easier to understand, but uses extra memory for the result. This can be overcome, by reusing the same documents: 

An alternative to this approach is to have custom map these properties when transferring data model -> view model and vice-versa (so, this also supports data persistence, not just data fetch). Actual mapping As already suggested, AutoMapper was specially designed for this kind of chores. Its usage is simple as: setup the mapping: (this is deprecated in the last version, as described here (and also mentioned by the compiler, if last NuGet package is referenced))