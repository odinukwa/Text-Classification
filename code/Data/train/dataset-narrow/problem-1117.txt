Put a blank line below your last . Also, where are , and from? They sound like your own support modules rather than part of a third-party package, in which case the imports should go after pymongo, rather than before, per PEP 8. 

In your second loop, you use four lines to swap two list elements. This can be more idiomatically done in one line using tuple assignment: 

Second, you could inherit from the stdlib one and add the missing functionality. If you want to add directly to timedelta this way as well, you would also have to override and to turn any object they are about to return into your extended . I was going to suggest monkey patching as another option (this being one limited context where it does seem worth it), but it turns out you can't ( and use ). I only recommend adding the strict compatibility things this way. The idea is to set it up so that if you stop supporting 2.6 down the track, you can delete this code without having to adjust anything else, except maybe some imports. in particular ought to stay separate, especially because it fairly specifically enforces/assumes your local policy ("serialised dates will be in one of these two formats"). 

On Naming + On TypeScript And Types I strongly recommend making the function result type explicit. When I see the method, I expect it to return something. However, the return type is . That causes immediate confusion: is it a misleading name or is the code missing a return statement? 

Nano variable names are evil. What is ? An error? An exception? An event? To figure that out I need to look at a place where the function is being invoked. That's mental burden. Same applies to , , and ... If you are in VS Code or any other smart editor, it's a matter of hitting F2 and renaming it. Names and are particularly unfortunate since they are meant to be symmetric to/consistent with and . Thus, should be ! Also, I could not decipher what the prefix means in both of these variables. Just spell things out: , , , , , . 

Translate dates into a sortable representation (one time). Use . Do the sorting with . The values will be put in a lexicographical order. Translate the sorted dates back into original representation. 

The end-to-end test was not meant to be exhaustive. Unit testing can be dome much more thoroughly here. It just was not my goal (rather, to illustrate how the things work). If I had written the code as TypeScript I still would NOT mark array as . With data structure implementations I really want the internals to be directly available for observation from test â€” I'm very firm, it's fine to have internals open this way for consumption in tests. (I'm in agreement with Mark Seemann's thoughts on structural inspection not necessarily breaking encapsulation). Nevertheless, in real production code (if at all) I would add interface and use it everywhere to access the . This is to prevent the accidental undesirable data access by the consumer. 

You have a variable to capture the links on each iteration of the loop, and to accumulate them across all the pages you parse (which is only one at the moment anyway, but I'm assuming that could change later). Those names are quite confusing; it would be good to differentiate better - call them for the one that gathers all the links, and for the one that gets the links for just this page. Your function parses what I would call your 'main' data structure. Since that is a lot more than just email-related information, isn't the best name for it. The data structure that creates seems awkward for your data. If you think of people as 'records', and the information you capture about them to be 'fields', then it would make more sense to have it as a list of namedtuples, or or even a pandas dataframe if you're working with a lot of data. That way, your code to parse it is a little bit simpler: 

Your problem essentially boils down to repeatedly finding the (global) maximum of some (local) values. Python for "the maximum of some values" is , and Python for "do this iteratively on this sequence of things" is a for loop (or, in this case, a list comprehension). You want the indexes of maxima, rather than the values, but takes a argument so you can do: 

"Linearizing" the solution (i.e. getting rig of the recursive calls by using a single loop); Applying memoization, which is recording the cells which are known to be unreachable from the target cell and avoiding further visits of such cells. 

Please notice that the code above is for illustrational purposes in your specific context. Any more or less real project will use directive to iterate over some data source to construct the boxes dynamically. Something like the code below. Do not worry if you don't understand it yet. You'll get there later with a bit of practice. 

One more note. If whoever constructs the Images class can guarantee that , and , and are always set to at least empty arrays rather than , we could throw away the ugly null check in the predicate. And this 

I'm pretty sure you already see what I'm going to say. It's not a great thing to reassign a value that was provided into the arrow function by the caller. Today your code works. Tomorrow a junior developer touches it and things crash... I'd recommend to rewrite as or even as and use a locally scoped "variable" to prevent bugs. 

Note that the first condition changed from testing a length to testing a position, and that the helper function works completely in-place. This makes one copy, in the outer function. You can also change it back to an in-place sort like your original code by deleting two lines, and it will make zero copies. This is probably the best a recursive insertion sort can be. 

To optimise this type of problem, the best way is usually to rethink your strategy. You currently generate most of the possible pairs of numbers of the appropriate length, calculate their difference, and then check if the equation satisfies your constraints. As you note, that is a massive search space. Consider the following type of strategy instead: 

Note that I have modified your conditions a little, since yours seemed slightly off. The branch of your condition effectively says "if the zeroth column is "name" or the first column isn't a match, it must be a header" - I've changed it so that instead, an appropriate value in the zeroth column is a header, and a non-matching first column on is ignored. I've maintained a temporary 'headers' list, because your code is currently robust against those appearing anywhere in the file. A better way to maintain that robustness would be if you know - or, preferably, can parse from your file before now - how many variables you have data for. Then you could do away with that list and do this: 

Added to . Replaced with where applicable. Using extension method instead of an explicit static method invocation. 

This may be a bit more compressed at the cost of readability, which I provide as an option rather than recommendation: 

Therefore, if you have no special reasons, you should subscribe the least number of times. In your case, a single subscription is sufficient. You can still use separate functions to delegate them the actual work (, , ). 

Here's a related, but not quite the same exact plunkr. You can have more custom logic in the block, but frankly, I have no idea what are you trying to achieve and why is the first Http request's results are of any special interest. 

Never being good in "algorithming", I'm now trying to improve the situation a bit. An algorithm below is the attempt to home brew yet another quicksort. This time, specifically with a "last-element" pivot selection strategy. Is there anything, I can improve better here? Priorities 

Dealing with DOM competes with . Do not mix DOM accessing styles. That hurts readability. Either use jQuery everywhere, or native API everywhere. jQuery is kind of out of fashion nowadays, mainly because major browsers got much better in exposing DOM accessing APIs. Dealing with Http Again, since your code already depends on jQuery, I don't see why prefer over . Inconsistency of the code is one of the biggest issues when it comes to maintenance, especially in case of new hires. Separate Data from Logic Your mood to color scheme relationship is data that can be encapsulated in a separate place (apart from the places where it's being used). Say, you define color scheme like this: 

Sqlite objects can be access by column name - rename your variable to , and you can do, eg, `repost['permalink'], instead of having to create variables to keep track of what each one is. A more Pythonic way to manage your counter down the bottom is like this: 

is always a number - why are you calling it a 'name'? Also, there's no need to take it as an argument, since you never use its initial value in your function. 

Note that is not included in the range, and you may need to choose it with that in mind. You initialise a variable called at the top of your loop, but it's only used in one of the branches of the statement. For the same reason as above, it should go near where it's used: 

This means that if you can work out how to generate the indices of potential locally-interesting values, you can structure your program like this: 

This will reduce your search space, and also allow you to use ints everywhere, and not parse them into strings. 

avoid bare , it can mask bugs, and even cause some - eg, you might catch and ignore . instead. Consider adding a docstring to explicitly say that it tries two formats, as well as that it gives you a timezone-aware datetime. 

@demrks please take a look at the code below. It's a result of multiple refactoring iterations. While the original code does the job, I find it very hard to read. Hopefully, you agree that the improved version reads better, even though there's very little new in it. Many developers including myself believe that readability is a super important aspect of coding because it directly affects complexity, and thus correctness of the code. Here's the list of techniques I applied (in order of importance as I understand things): 

I tried to rename things and format it differently as per my understanding of readable code. I'm still struggling with a few names as you can see, but this is just to demonstrate the ideas in actions, anyway... First, and . 

Some Comments Are Fine While the following comment explains both the intent AND the implementation, it is better candidate for staying the way it is. The reason is Angular developers don't have to deal with these aspects on daily basis and a bit of context may be helpful. 

Update As @Gerrit0 suggested, is a better option than (more concise and achieves exactly the same result). 

In your loop, you have a list called which gets the same things as except its cleared for every . You don't actually use it, so you could just drop it completely. If you do want to keep track of which solutions go with which , you could change into a , and then do: 

In terms of raising the as soon is called (rather than when its result is iterated), this general pattern is likely the best. There are a couple of other points that bear mentioning, though. First, is one of the worst ways to handle a detected error (marginally better than, say, ). Make the assertion self-documenting so that if when it gets triggered sometime in the future, you have more immediate information in the stack trace about what is going on. At a minimum, include a message with the assertion: 

This is a list of lists of strings. For most of the rows, you don't seem to care about column 0 at all. Column 1 contains row labels, and corresponding to keys in your dictionary . The rest of it is numeric data, currently stored as strings. It also contains 'header' rows - you only keep one of those around, so presumably you only expect one to be in there. I'm guessing that is column labels, which a DataFrame lets you include directly in the same data structure. The only trick parsing this into a DataFrame is that it is a little easier (and, apparently, more efficient) to swap the columns and rows from how you have them currently. That will affect how it prints, and which methods you call to relabel things, but not much else. This is how I would parse it into a DataFrame: 

Notice that may be implemented in many various ways, I just used the simplest formula that came to my mind. Here's a test console app: 

DISCLAIMER: I don't think this is actually an "answer" answer. Please consider it as a side note, because your code generally looks good to me. I also admit, this answer is highly subjective compared to other my answers.. My purpose here is to provide a point of view rather than persuade that something needs to be fixed in the original code. [Non-functional] alternative In a real-life scenario, if input was huge, you might not be able to create a range array via . 

The test that almost precisely repeats the code under test indeed does not provide much value and is tautological. 

Why Abstract Class? is declared as an abstract class that has only one method. The method itself is abstract too. I don't see how is it better than an interface, since no base implementation is provided anyway (and I'm a big not believer of implementation inheritance as a way to create new types). 

The last part is your consumer component. It orchestrates objects creation and iteration. The collection of is created in rather than constructor, and it defines the number, kind, and order of the Cards. 's constructor is used to inject the dependencies and prepare a that is than passed to the s (remember, they now require it in their constructors). method is used to react to the corresponding event. In my code I assumed that we only need to iterate through the questions linearly (first to last). If that is not the case (e.g. you may need to jump from Card1 to Card3 if a specific Answer was selected), then would need to emit event with some data. For example, and . Then the answerId could be used in for implementing more complex iteration logic. 

Python provides extensive operator overloading capabilities. Use them. For example, could be called , which allows you to then check a condition like . You can then drop the line of the docstring about what the return value is - it is implied by using that operator. Even if you decide to leave it as a normal method, isn't the best name - it sounds like it should return some kind of index, rather than True or False. The reason for the argument to is that a Trie behaves like a Python dict - the strings that you store efficiently are keys, and each one has an associated value. So, you could call instead , and you can do things like . If that is useful to you, you should also implement appropriately. If it isn't, drop that argument. is also a strange name. It sounds like it should return some kind of metadata, but instead it prints some stuff to STDOUT. Printing from support classes like this is usually worth avoiding anyway - build the full string and return it instead, and rename it to , and then to print it you just have to . The docstring for it seems to be lying when it says "equivalent representations are randomly chosen from" - you have no randomness here, the closest thing is that you use dicts (whose order is arbitrary but consistent, not random); it says it isn't testable, but you do test it in your doctests for another method.