I am not sure I understand the question. What are these classes going to give me that a standard lock wouldn't? I would write that first class something like this: 

Use instead of ; it is shorter and faster in all cases I've ever bothered to test. Don't use inline, javascript doesn't have block scope (only function scope) so it is better to declare all necessary variables at the start of your functions. Cache to make code more readable. Use toString instead of a regex test for checking for the bool type simplify loop and store the upper bound in a variable instead of computing it every time Use a check on the loop. 

This implementation (whether or not you pull out the functions is irrelevant to this single use) will let you manage inheritance properly, but it does have some inefficiencies (setting radius raises the event 3 times, similar to how your implementation does). If you weren't concerned about inheritance you could simplify this by not bothering with the change event and modifying the private members outside of their own setters: 

Before I do anything else I feel compelled to clean up your spacing convert " to ' to consistantly use only one type of strings 

In these cases, you would need to do more than what you are currently doing in your method to take care of unregistering these functions (In IE7 and below). My perspective would be just to let it leak (tell the users to get a better browser). IE6 would leak until the browser is closed, IE7 would leak until the page is out of the navigation cache. In every other browser, once the DOM is detached (or the timeout occurs, or the ajax post happens, etc.) these functions are not reachable from the global scope anymore (and so they are removed in the next garbage collection cycle). Cleanup in IE Essentially what you are doing in is move the stuff you want to delete in the previous route to and then in you take care of deleting the old references. Really the only things you should care about are those properties that you cannot actually get at via variable properties once set. Whenever you do a (or similar) you would want to do something like this: 

Edit You could also return if you don't need to use with the value anywhere else. For your problem about the intiialization of the base animal line, I would recommend not to validate that it cannot be set more than once. A view model is almost like a DTO, if I decide to mess up its values, it is the problem of the code's user, you don't have to protect your VM from this. In your controller, the constructor's signature doesn't fit the controller's name, this doesn't compile. 

So we will extract this logic in a method, in order to hide to your method these ugly hardcoded values. 

Why do you keep the block if there's nothing in it? You should always use brackets when there's a bug possibility. In such a case : 

I've unit tested this code (except the builder, but it works according to the unit test that uses it, tests will come later, oops). I want to know if there's anything smelly in there or things that could be optimized. The full code can be found on $URL$ 

In Java, the convention wants that methods are written in camelCase. Which means should be and so on. The indentation is a little off with the declaration of the . Instead of this : 

This way, there's no confusion about "abe" being everywhere, heck, I don't even need to know what is inside the variable, I just need to know it is equals to the retrieved one because I used it to retrieve the account. Actually, the use of constants should be heavily considered in my first example too!! Note : The string messages, aren't necessary. The default assertion message for will be very clear that the actual value isn't equal to the expected one. And your test name shouldn't include . You know it's a test, there's the attribute juste above :) (You should take a look at @Konrad's comment about naming!) 

I was going to make this a comment to Dan's answer, but it started getting quite long (and I wanted to try and actually code it to see if I remembered how). Assuming is big and doesn't change between builds of the application (or if it does you have the ability to replace a single dll), you should build a dll containing the compiled regex representing it to get a much better search then you would if you used that linq expression. 

While these examples are pretty far out there, consider if your Queue class were complex enough that I might want to add an extension method to it and need access to internal variables in the method to do some algorithm in a way much better than possible with the available public interface. 

I felt that this code would be good as a jQuery plugin, so I went ahead and altered your code until I was satisfied. I left in some comments that are applicable to your code, but I would encourage someone else (and may do it myself still, I don't know yet) to give an actual review. 

I have made the arrays into objects so that it this is easier to edit. I doubt it makes enough of a difference to be noticeable. That is, I replaced with a structure . It may be worthwhile to change them back though. Reduce comparisons by navigating a 1 dimensional model of the map instead. When you call you can generate a set of for a given map. For the terrain_map provided and a mobility index of 0, this would be the following array: 

First of all, most (if not all) your comments are unnecessary. Your comments should explain how not why (apart from the head comments that resume the signature of the method) you do things. They're there to help your fellow developers to understand what happens, but don't forget that your code is its best documentation. Well written code won't need much comments. 

This is not a correct use of the UoW. A Unit of work "does two important things: first it maintains in-memory updates and second it sends these in-memory updates as one transaction to the database." [1] Your unit of work looks more like a Repository pattern, which takes care of hiding the implementation of the data access. In fact, the UoW should take care of the transaction part, and the Repository should take care of the data access, so at the moment both are mixed up in your class. The rest of your code looks pretty fine. 

Now, let's get real. isn't an efficient method. It's very slow. I don't have your class, which is sad because it'd be helpful at the moment. The question is, what defines the identity of a ? If the identity if defined by and (meaning that if two services have the same ID and service date, they must be the same ), you could override the and methods of the class. Then, you could use an data structure inside your class (Instead of ) to use the method, which is far faster. Since this is all hypothetical, I don't want to go in too much details. If this sounds unclear to you, I recommend reading on data structures. Each structure has pros and cons when it comes to its data. For example, the is very fast to see if it already contains an object. This is all I can do with the information that you provided. 

ignoring immutability and such (like having a getter and no setter for FlatSideArea that computes on the fly)... What you are basically implementing here is an internal usage of the INotifyPropertyChanged interface. If you are going to implement that interface, I suggest you actually do so instead of only sorta partially doing so: 

every time you call , jQuery needs to do some work in the background to figure out what you mean in the string. You can instead cache these items and not need to depend on retrieving them repeatedly being fast. In this case it doesn't make much of a difference, but eventually it will cause your page to be slower. There is too much extra junk in the way to make it apparent what is doing. A good rule of thumb is to wait a week, then if you cannot glance at a statement and know that it is both in the right place in the function and what it is doing then something is too complex. While your code is probably sensible to you right now I am willing to stake the claim that in a few weeks/months when you go to add some other functionality you would waste some time trying to figure out what this is doing. 

Without going farther I recognize this pattern as a depth first graph traversal with a little additional functionality. I would abstract that a little and see this helper function: 

Your stack is just one step away from being , which is great. I don't know if it's useful to you but usually, data structures are generics! In the initialisation, I could pass as a paramter to your 's length, which is flawed. There's a bug in your method. If I create , an will be thrown when I push something, since you start with . But in the other cases, you expand your array to make sure you don't have an exception. This might not be a bug, but you should think about this behavior. Plus, expanding your array with a length wouldn't work, since As @holroy pointed out in the comments (I'm adding it to my answer just because he/she didn't post an answer yet), you're going to throw an exception if you try to an empty stack. To counter this, I added a check before popping! If my contains : , I'm going to pop the value , and return . The expected behavior would be to return since it's the poped value. Also, instead of looping all the time to find the index to insert or pop in your stack, why don't you just keep this index as a private member of your class? You'll save useless loops and conditions. There goes the final result : 

Now, if we want to get rid of the that is a little difficult to read, and keep the fact that you alternate between a number and a letter in your code, we will try and use a instead of 2 

(unable to check correctness right now due to not sitting at my work machine, but barring any syntax errors I think that is right) Am I doing something wrong here? I think a static constructor is fine for the singleton pattern as well, but I am not 100% sure it covers all thread safety issues. I don't see how a single lock object wouldn't though. 

The controller is vulnerable to automation. If I can discover a list of user ids I could create the following html page: 

(spacing to demonstrate relationship to terrain_map) With this array you can start with any coordinate and convert it into an index in this array via a the function and back with its inverse function. Once you have that you can move up or down by adding/subtracting and left or right by adding/subtracting from the index. Since this array is a padded version of the map, you never have to worry about wrapping around because you cannot move to these fake coordinates that make up the padding. This may or may not wind up actually being faster (it depends on how big your maps actually are and how easy the set of paths were to compute in the first place). code: 

and refactor accordingly. Beyond that the only suggestion I would have is perhaps some better variable names (at least use a single naming style; if you don't already have one, use this: $URL$