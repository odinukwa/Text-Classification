Caching references to DOM objects One simple way to optimize is to identify places where you're querying the DOM for a specific element multiple times, and replace those with variable references. 

Use UTC Time to avoid timezone issues People in different timezones will see different values for the current date and hour in JavaScript even when viewing the web page simultaneously. This is determined by the user's current timezone as specified on their system. Generally, when counting down to a specific date, you want the countdown to be the same for everyone, no matter their system's timezone. You can use UTC times to retrieve, set, and compare time values against Universal Coordinated Time (which roughly corresponds to the old standard Greenwich Mean Time (GMT) but ignores daylight savings time). If you have a date object, you can call to see what time it corresponds to in UTC. You can also call all the expected getter and setter functions to retrieve or update specific components of the object, such as , , etc. I would create a variable using and then set its date components using the UTC setters. You'll then be able to compare the current date against that variable and JavaScript will be smart enough to take timezone differences into account. 

You can also change the method to be an extension method of . This will clearly state the purpose of the method if declared with a good name: 

The code is missing the class which I think is also important for the review. The cache items are added with keys and it is important for this method to return the same value for objects having the same credential values, and distinct values for instances with different credential values. Is it? Naming conventions. Class names should be PascalCase and the class violates this rule. Should be To achieve better encapsulation and seperation of concerns, (The creation of an empty credential object should be a concern for the Credentials class, which has control over the internals of itself) instead of having a field in this class, it is better to have a field (or property getter) in Credentials class. 

Reading through the code, I can say that it is well written, concurrent access in mind, and at the first sight, it can be said that it has no flaws. I especially liked these lines: 

Notice also that you had an unnecessary loop in the function which did the same thing 5 times in a row (set the inner text and attributes of the element). 

Since these are constants, a common standard is to name the variables with all capital letters; you can do that if you find it helpful, but the important thing is to be internally consistent. I would take this concept (of capturing reusable strings in variables) a step farther for the element IDs of your daily deals, and throw them into an array of objects. 

At the time of this post, arrow functions in JavaScript () are an experimental/proposed technology supported only by Firefox, with no stable specification. If you need to support IE9, IE10, IE11, Chrome, Opera, or Safari, you'll want to use the more verbose function expressions that they replace. As 200_Success noted, you'll want to encode the values returned, and also decode them when translating the encoded query string back into the original string. You can use and for this. 

That's just to give you an idea of how you could go about cleaning it up. There are other improvements you'd want to make in your final code, such as using a variable for the timeout delay, and wrapping up the relevant code sections in closures as necessary. We'd need to see the full code to identify other areas for improvement. Proof that the concept works: 

You should also check the items of the passed in collection for null references. If any of the items of the would be null, your code would fail with a null refererence exception at 

You can wrap your timers in ExecutionPlan class. Using a class for wrapping the timers have many benefits. 

To prove that it is properly working, I run a 100 concurrent threads test with random access to the operation with the same credential instance. This test revealed that, 

Then, why restricting the second method parameter to ? Let's get that as an . This way, your method can also operate on or instances 

You keep track of class instances and not bare integer values, You can re-use this class in other projects or forms (if designed & implemented correctly), You can extend this class to enrich it's functions etc.. (There are an infinite number of benefits) 

Therefore, You can simplify the exact same behaviour at least in terms of the final state as follows: 

I'm not suggesting to change to and to of course. The parameters should have descriptive names in the first place. You can consider and or similar. Possible Improvements Being consistent with code formatting is important. Consider using curly brackets, always: 

avoiding global namespace pollution Since your logic (wisely) does not depend on global variable declarations, you can avoid polluting the global namespace by wrapping all your code in an immediately executing function expression (IEFE). 

Eliminate potential logic error in return value I'm assuming the purpose of this code is to let you provide the name you want for your subsite, and the code will give you an available name based on whether the provided name already exists. It does this by appending/incrementing a suffix to the provided name whenever there is a naming collision. If this is the case, your function should return sans the prefix, not . To walk through an example briefly, let's say you want to name a subsite . The code checks and doesn't exist, so it returns which resolves to . You then go ahead and create a subsite named and everyone is happy. One month later, you come along and decide to make a subsite named . The code checks and sure enough, doesn't exist (since you created last time), so the code returns which again resolves to . Now you're going to run into a naming collision. Reduce the number of instantiated SPSite objects You are only ever dealing with a single SPSite object in this code (the parent site that you are checking for subsites). Therefore, you don't really need to create and dispose of a new SPSite object in every iteration of your loop just to grab a subsite from it. I recommend refactoring your code to instantiate the SPSite object outside of and pass it in to as a parameter, along with the name of the target subweb . 

The following is the IL generated for There seems to be full optimization by inlining , and The CIL runtime stack works only with 4 byte or 8 byte integers, even the LDC_I4_S pushes a byte as a 4 byte integer to the stack, so, there is no performance gain in changing parameter types to smaller integers, byte or short A slight improvement (may be); These methods need not to be instance members and can be defined static. Changing them to static will remove 1 push instruction to the stack (argument 0, the instance to invoke the method on) at the caller site. That's all. 100 million iterations on my 2-cpu 8 core windows 7 HP machine executes in 17-18 ms, and 8-9 ms of it seems to be the iteration (empty loop) itself. 

And here are the results of the test, which shows the method is invoked a total of 5 times for all the 100 threads. The test created 100 threads which access the method randomly within 500 ms. There is another thread for removing the item from the cache in 100 ms continuously (This is because, the cache policy doesn't seem to effectively remove the item at the exact point of time of expiration). The method lasts for a random time between 0 and 500 ms With the following results, it can be seen that the method is invoked a total of 5 times (which is the number of the cache not containing a instance for the given credentials, first one because the cache is empty, and for 4 more times because it is removed from the cache) I can't help myself thinking why the of returns when the item is added to the cache. This would have been implemented differently (as returning the added instance as ConcurrentDictionary does) 

(Since this code needs to work on IE8, it's clobbering the mouseup event instead of adding an event listener to it for the sake of brevity and performance. Add that to the list of things I feel guilty about.) 

Here are a few suggestions to start off: Understanding the Base Number conversions The base number system should be irrelevant by the time you have a number as a primitive type. It only matters when you're converting strings to numbers and vice versa. JavaScript can't tell the difference between and ; in both cases the underlying number is the binary ... the other formats are just to make it human-readable. So is functionally equivalent to ... in both cases, you're saying here's the number 30 (or if you like), please give it to me in decimal format; thus the output is always the number . The same is true when you reverse it with : both and will evaluate to . The question to ask yourself is: "Under what circumstances would an octal primitive be passed to my function?" Since JavaScript itself doesn't distinguish between octal, decimal, and binary numbers when it handles them in code, the question doesn't make sense except insofar as someone's JavaScript code could explicitly pass as a parameter. In such a case, the error would not be in your function but in the logic of the author who types and expects it to be parsed as a decimal instead of the octal number that it is. Determining the Class of an Object It's tempting to use to determine the type underlying a variable (that's what you'd expect the operator to do, after all), but its output is not always consistent. For example, will return when the underlying class is actually . On top of this, the return values of the operation are not defined in the ECMAScript specification, and could thus be different in different JavaScript implementations. Yikes! The only thing for which you should use is checking for an undefined variable, using the syntax Instead of using to determine the class of an object use . Here's the syntax for that: where is your variable. The reason we call at the end is because the function call would otherwise return when all we care about is . Semicolon Best Practices While JavaScript requires semicolons, the JavaScript parser is pretty forgiving about them: if semicolons are missing, it'll try to extrapolate the correct semicolon placement and insert them as needed. However, it's a best practice to explicitly identify the ends of lines. This not only saves the parser some work, but prevents it from making mistakes that can change the behavior of your code. Since you already have your code in jsfiddle, go ahead and click the "JSHint" button in the nav bar. It will identify lines where you excluded semicolons (such as at the end of a variable assignment) or added unnecessary ones (such as at the end of a function declaration). 

You should always check if the parameters are passed in as null. Your code would fail with a null refererence exception at if is passed as null. 

EDIT 1: You also don't have to check and assign moannie if it is passed in as euro because it already has the value euro: 

Method name is a common method name used by collection types to add a new element to the collection. An method with source as the first parameter and the items to be added as the second parameter does not make sense. and are bad names for parameters and should be changed at least to and or similar. And in Capitalization Conventions 

Yes, it seems thread safe. I run a test to prove it which I give the details at the bottom, but first are some code review comments. 

The access is synchronized to the method. OK. For the threads that call at the same time passing the same instance, after the call to , is for only the first invoking thread. OK. All other threads get the existing instance after calling and is . OK is called on one of the first threads that call , most of the time the adding thread, but sometimes on another. OK After the call to , all requesting threads get the same instance out of one by one, as returned by . OK The first thread that gets the instance calls and succeeds. OK. After the instance is removed, other threads continue to get the old instance because they have the removed instance. OK 

On thing to keep in mind is that certain inputs that you might not consider to be numbers will be considered numbers by the and functions. Potentially Unexpected Numbers: 

Like Kennebec's original answer, the code is inconsistent in its identification of different versions of browsers. For example, Internet Explorer 9 will appear as while Internet Explorer 11 (which despite forsaking the family name still wields the trident of its ancestors) will appear as . Since you have direct control over the name returned for a trident-detected version of IE, why not return "MSIE" instead of "Internet Explorer"? Super minor nitpick: you misspelled "guarantee" in the code comments. 

I recommend naming your array something other than since is also the operator for creating an instance of an object type. ($URL$ Consider a Different Data Structure Since each object in your output has a unique identifier (the date) you might be better off with a different data structure; instead of an array, you can store the data in an object that uses date strings as property hash keys. 

Right now is a string that seems to be put together solely for searching through it. That has the potential to be a big performance bottleneck. If you change it to an array, you can squeeze a bit more efficiency into your code by sorting the array and then using a binary search method to detect whether it contains the desired value. Here's an example of a binary search method.