as you are creating as a copy of ; any change to changes as well. Also, you can iterate through your unique values in instead of checking if each element is in . Sorry I could not be of more help. Let me know if anything is unclear. 

When performing a chi-squared test, one takes the square of the differences of the expected counts per bin and observed counts per bin, and divides these per-bin differences by the expected counts per bin, as seen in the formula below. 

The for-loop has the advantage that you can later change the number of output plots without changing too much of your original code (if say, you wanted to output 2 or 4 plots, or perhaps change the to something entirely different). This may or may not be relevant, but it may be nice to associate each individual plot with a specific legend label, marker style, and/or color, all of which can be handled using . This can be especially useful for overlayed plots (especially considering that your data consists of and over the same x-interval. 

I agree mostly with @200_success' answer, though for simplicity and maintainability I do suggest you to use the following, which is only possible in Java 8. It functionally does the same as @200_success' answer. The code with explanation below: 

You'll need to obtain the the backing source of a , such that you can apply operations in constant time. You can obtain a both readable and writable backing source via: 

Inspired by some older questions, I decided to create my own postfix calculator using Java 8. I'd like to have all aspects reviewed. 

In general it looks good, now going through the code to also see if it actually is good. 1. Exception messages Your exception messages should be made clearer, an example of them is at the constructor of . If or , we get echoed the value of the variable back, but no indication whatsoever to what is actually wrong with it. It would be good to see it included. Also is most likely not wanted, is it? Lastly on this point, I would prefer if you only use once, as the case is here. If it would be used multiple times, then there should be a simple check at the top of the method, to ensure the check only runs once. 2. Initialize objects as early as possible. You are initializing both and in the constructor, and not at declaration time, which looks suspicious. They do not depend on either or passed into the constructor. Hence I see no reason to initialize them late. This prevents duplicate code when adding more constructors. This also holds for in . 3. Try to use more meaningful variable names. As a reader of the code, it is very hard to get the meaning of in , after some thinking (which is a precious resource) I realised it was meant to be temporary queue, just name it then. 4. Consider factory methods. The lines: 

Since the sum changes with each iteration through your dictionary values of , I don't know of a way to pre-compute the right-side sums before-hand. This would be a little easier if you could use external modules. That said, you might see a slight speed-up if you use more comprehensions. For example, you can get via . Also, use (not ) to check zero equality and use (not ) to check . Also, you are iterating through all possible combinations. In the case of using and , you know that and . So you know that your lower bound is cut-off at 76. Those are 76 permutations that you do not need to use. You can include a statement at the lower bound since you are incrementing downward (), but I would instead use this lower bound as the starting point and iterate by incrementing upward as you may find some other way to restrict the sums in the upper limit. Lastly, the use of globals and non-descriptive variable names makes it hard to edit the code. For example, instead of , instead of , etc. Also, you can pass into . I personally prefer iterating over lists instead of dictionaries since you can use zip. I don't have a full solution for your problem, but it may help as a start. 

Changed signature in from to , as the method needs to be and in case inheriting multiple times is possible, would clash. Changed the constructor to , to fix that a test class must only have one public zero-args constructor. Added to make it have one public zero-args constructor. Added to ensure that this abstract class itself isn't being tested. 

That is all advice I can offer you right now. Please rewrite your code and post it again as a new question such that for example your Java 8 streams usage can be reviewed. Lastly I want to make it clear again that you cannot continue in this way, look at this line: 

Streamify This suggestion can be a matter of taste, but I believe a piece of code written in a functional programming variant is easier to understand than some calculations involving loops and more importantly it is less error-prone as you cannot possibly implement the method incorrectly! 

I just created the following code and am wondering whether it is logically correct (all other feedback is of course also welcome): 

I am trying to write an algorithm that can find user-specified nearest neighbors. By user-specified, I mean that the user can specify whether it's a general nearest neighbor, a forward-nearest neighbor, or a backward-nearest neighbor. The idea for this code was inspired from this SO post. While it isn't ideal to search the entire array (perhaps use searchsorted as an alternative), I want to find all occurrences of the user-specified nearest value in the given data array. While there are other techniques that can be used to achieve the same goal (such as using the cumulative sum of differences of argsorted values), I feel the code below is easier to read/understand and is likely quicker since it performs less operations that require traversing the entire data array. That said, I would like to know if there are better approaches (in terms of speed) to achieve the same output, as this code will be applied to a dataset of at least ~70,000 data points. More than the value itself, I am concerned with the indices at which the values occur. 

Where expects an argument of type . It seems to be working, the only thing I am left off wondering is: 

Now we should refactor the methods to not lead to duplicatd code. I do not know which Java version you are using, but considering this seems like a toy project, I am assuming it is safe to introduce you to Java 8, which will make your life considerably easier. Strangely I have just noticed that does not compile on Java 8 (not sure if it did on your version, I doubt it), there are two ways around this: 

Then one more additional thing about the onparsing the integers. I suppose you can take several views on this. You should only do it this way if it is an exceptional situation, which seems to be correct here. Yet, for performance reasons, you might want to simply check whether , etc. is a number and only then try to parse it. 

Can the speed and/or accuracy of this algorithm be improved? Is it proper to use centered differences at interior points and one-sided differences at the boundaries? 

One alternative method I have yet to explore is using set intersection/unions to find the same indices, though I'm not sure if that would necessarily improve performance. I posted a similar example some time ago, though I later realized the code had bugs and could have been improved upon as an example. 

This can be rewritten using a helper function (or alternatively a for-loop), which may look something like this: 

Since I could not get to compute a derivative successfully, I wrote a script to compute it manually. Running the script below will output a plot of two functions and over the interval . 

I have written a script that I believe works and covers all edge-cases. I am curious about ways to improve upon speed. While the given example below covers a multi-dimensional array of , my actual use case will be (where depends upon the number of data parameters being searched). Given individual arrays of data points, the goal is to combine them into a multi-dimensional array and find the columns in which all conditions are satisfied. If the same column of each row satisfies a given condition, the index that corresponds to that column is output; otherwise, an error is raised. I have included a small named because it has many other functions relevant in my main code, though I've only included the parts relevant to the goal in this question. 

The usage: Note that the is not complete (but working) yet, I will put convienience methods in there once I need them. 

Use diamond inference where possible, this means that for example can be written as . Code against interfaces instead of against classes. Take your again. Nowhere I see a requirement to use a here, you just want to use a list, so only constrain yourself to writing: . This allows you to change the exact type of at a later point. I see that you only loop over the , you have no special requirement to use a linked list, consider using the more or less default , which provides constant lookup times and generally performs better. In your case the performance seems to be equal as all you do is, underlying to the enhanced for-loop, use an . Consider changing from using the API to the API at some point, it offers more future-ready changes and will co√∂perate better with Java 8. Prefer a class that receives print statements over directly printing to during processing. In bigger projects this usually is a logger framework, to which you then attach writers and also file writers for logfiles. In your case you may use a simplified version of this. A is old, very old, use the nowadays standard called , with as default implementation a . Some method names/semantics may have changed, but they both serve the same purpose. Do not catch all exceptions with , you may have confused yourself here, but this catches all exceptions of type (so all), and gives the caught exception the name . But even then, catching s is not good and you should just let them fall through such that they terminate your program (or thread), so you can actually fix the issue, rather than a Cannot make prediction. message. 

However, I've heard that it is good practice to modify the bins such that the observed counts are above a threshold (typically 5, sometimes less) as a large number of bin counts below such a threshold can result in a bad fit (assuming minimized chi-squared). If the observed bin count is less than this threshold, then the bin is merged with the next bin. Assuming a distribution (such as a Gaussian) with a central peak, the next bin would be the next-right bin (i to i+1 bin) when the bins are left of the central peak while the next bin would be the next-left bin (i to i-1 bin) when the bins are to the right of the central peak. I've created an algorithm that I believe works and covers all-edge cases (assuming a single central peak). I was wondering how it could be improved in terms of speed/efficiency. I also feel like I am duplicating code using similar approaches in two while-loops; can this be averted?