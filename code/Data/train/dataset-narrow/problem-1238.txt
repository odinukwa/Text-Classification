This part works as expected in that while my thread is running I can plug in and unplug a smartcard as often and as quickly as I want without problem. What I'm struggling with is the Threading portion of it. Visual Studio screams at me for using suspend and I found a bug when using suspend in my thread so I am taking that out (in other words don't comment on that) but this is how I "open" and "enable" my smart card 

Mind you this probably isn't the best choice in names, (or even naming convention) but this does give you and idea of where to go. Making a class that can compare itself to others. We are only interested in comparing the states by their name. implementing is important for list as it is how you will search for an item pre java 8. With java 8 you can use stream and lambda's. Handy if you understand them. That is my suggestion. 

Since I'm not sure what you are asking by if you are doing it correctly I decided the quickest and easiest answer is to put your code to use. I created a method called Yates and put your code in it. I then called it 19 times in a simple for loop noted the output. (I limited my output to the first 5 numbers so it is more clear here) 

IGameView.cs You have a method called Release with the comments of Release as Releases all the resources allocated by this IGameView. This is the purpose of the interface IDisposable in the System namespace. I would recommend changing to that instead of Release. IGameController.cs You have a method called Start, but your comment says that it initializes the instance. It's not until I go GameController do we see that you do both an initialization AND a start. This is a violation of the Single Responsibility Pattern (SRP). In short it says your class should be responsible for one thing, your methods should only do one thing, and your variables should only mean one thing. It would be better to use your constructor to initialize all your variables, or to make a method in your interface called Initialize(). The context would say that you should use a method in your interface. Your method MovePaddle takes a player ID and a direction, and uses that to move the paddle. Your method Refresh is a good idea, but when I look at the implementation I feel like you lie about it's purpose a little bit. You have a GameTicker that calls it... I think it would be better if PeriodicTick had a instance of IGameController instead of the other way around, and then put the Tick to call the refresh command from IGameController. Although it does the EXACT same thing, this would make more sense to put that in the Ticker because I have to ask my self...well what does this do? I can't tell by looking at PeriodicTick. all I know is that it can be cancled. Last note about this too is that it is not a good idea to have a interface depend on a class. Rather it is always a better idea to have a Class depend on a interface. GameController.cs there are 2 instances where you have a constant defined in the code. MOVE_MODIFER being one, REFRESH_RATE being another. Nothing wrong with having these, but as your comment says it critically affects the performance of the game. Things like this should be put into a config file, or a setting that can be edited from your form. It may be a good refresh for your computer, but what about mine? how about all 4 of my computers? In General Try not to expose your variables in your classes. Expose your methods that act upon your variables. And example of this would be something like this. 

This information would have been better served in your question. But the test is simple and is simple to reproduce using , , or . The latter two being among the more popular but MSTest is built into Visual Studio. I see that you put in your "test" so that you can watch the debug screen. Well how about instead of reading the debug screen you watch the test runner screen for a green check or red x for a pass or fail? You could even copy and paste your code but you'd run into an immediate hicup. You have testable code inside a non-testable class. Solution: extract that method into its own very small class. 

So although this code is a small example it still can benefit from having a few methods sprinkled in to help clear up what you are trying to do. For instance what if you decided that you wanted to change the max and min to be entered in as a parameter to starting the program? You would have to change max and min to be equal to the int value of args[0] and args[1] although for a small example that is not a big deal, but it would be a little more simple to of had a method similar to this. 

I'm glad to see someone did a WPF calculator, and I hope that I can add to what was already stated. Before I get started: "yes this is a MVVM rant". Now that I got that out of the way, I can understand though why a person would do a code behind approach. One is that it is what a ton of people are used too (I was one of them coming from Java, then going to winforms and eventually landing on WPF) Two is that at first glance it looks to be more compact and easier to understand. So why should a person do it? Well for one is that you'll be less tempted to put FrameworkElement properties in your code. , , ...etc Why is that helpful? well if you were to write tests for your code to make sure your logic is sound you don't want to setup a window in your favorite test framework. (trust me..I tried) However if you setup your ViewModel using normal primitive properties and bind your Window to those properties you'll find it much easier to test. I can imagine my ViewModel looking sorta like this 

Since you showed us one method that is fairly easy to test and it appears to belong in the newly created I moved it there and built a test specifically around it. 

Side note The link you provided was to the wrong project, but they are right next to each other. I scanned through the website that you are learning from, and the project Address book is found in the ArrayList section but there is no reference to the ArrayList type. $URL$ "Java doc for ArrayList". Not to be harsh, but if I was the teacher I would be requesting a re-write. Using inner classes can very rarely be useful. This is not one of those cases. Entry has a proper place in the project as you use it as a data model. Making an in your Book class would be clean and to the point. The Book class itself will become very easy and clean when you switch to ArrayList. For instance if you decided to use lambdas and kept using the number to sort your entries your code would look something like this in your 

This has 2 advantages. 1 is that it is easier to understand. 2nd is that if I want to change the behavior of what happens when I am going to show the game I can do it in 1 place instead of 10 (or more if you add more Categories) Dynamic Code This is probably where you will struggle the most at. Is making code that is dynamic. Think about this scenario. You want to add more Categories to choose from? How hard is that going to be for you? I can think of it being 3 new Properties for easy, medium, and hard. 1 new button and check box plus wiring it up. 1 new check for IsCompleted..and the list goes on and on. Kind of a major pain. This is going to require a design pattern of some type. In the end it would hopefully be as simple as making a new class that extends/implements something. Then your UI would update and pickup the changes, and life would be good. That is going to be difficult though. 

in C# using lambdas is nice and easy. There are also a few shortcuts. You don't have to specify the type and if you don't plan on using the variables from the event naming them and implies that you don't care about them. this would make it short enough to inline it 

You'll notice it is 19 of the same thing. The problem with Random is that it isn't truly random sometimes, and you just ran across this. simple fix for me was to move the creation of the outside of the method now when I run it. 

I have this API to control some hardware. The API is not very well documented, but I've been able to make do with what I have. It is a API for a RFID device, but also has LED's on it that are controlled from the API. So the idea is that this is a OPOS program. The RFID device opens/claims/and enables. When it is enabled I start a thread that polls the reader to see if there is a RFID card in the field. The user has the ability to turn on and off the LED's when ever they want by using a DirectIO call. Here is the hard part. I've found that if i make concurrent calls to the API that the commands will give me back some gibberish (might be wrong word) answer. Valid messages returned are 0 to -7. We wrote a simple parser to run commands for us so we don't have to change the program it self to test for bugs.