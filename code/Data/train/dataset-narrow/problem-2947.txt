However, (the final however) if you can't make that work for you and you have limited time, then first focus on the language as given, respecting the intent of the creators of the language and teaching students how to use it well. Make sure that they understand the concepts of that language and the environment for which it is intended. But save a day or two at the end for a "beyond the horizon" look at programming. In that final wrap up session, you can talk about the limitations that were imposed by the language you've been using and some ideas (for their future study) that can be used to remove those limitations. So you close by opening another door for them. And this has much less chance of confusing them or burdening them with awkward constructs. Your students won't be happy with you if they later learn that you were using a given language badly, even if you have good intentions. You can't teach them everything they will need to know in just a few days, but you can do a few things well. KISS = Keep it simple, students. 

I have a couple of orthogonal suggestions. First, and you may have done this yourself, before you give any assignment you should create a reference implementation yourself and test it in the student's environment. If you did this, then just let it be a warning to others. This is true, actually, for any assignment, not just one that might run up agains limitations. But for the current situation, simply realize that there are several ways for the students to learn, not just through successfully building software for a problem. While you might be able to change the conditions for a future offering of the course, you need to deal with today's students. One of the most valuable educational experiences is a Retrospective of a project in which you formally explore what worked well and what needs to be changed (or should have been changed). Instead of a working program per student, a paper per student (or student group) can impart the desired learning. Students could examine the results of other students, for example, and reflect (in writing) on the relationship between the code and the outcomes. However, if you only want an answer to the stated question (how to provide for computationally intensive projects), then you need to either scale down the exercise to make it reasonable, or you need to provide adequate resources somehow. Upgrading all the laptops is probably not in the works, but you could, perhaps, provide access to a more powerful system (or systems) on which the students all work (individually or in groups). Scaling down the project might work, actually, at an undergraduate level, since the students aren't expected to build commercial quality software, but only enough so that the appropriate learning occurs. If this were a doctoral program, on the other hand, where the students are involved in serious research, then there doesn't seem to be any alternative to finding the resources - perhaps through grant writing or even begging resources from local organizations. 

is just compute a new value using x and then let x refer to the new value; This, of course is the same reference model we use in other languages (OOP, functional) for things. A variable is just a name (not a box) the name can refer to different values at different times/contexts (Buffy is me here, Buffy is you there). Different names can refer to the same object at the same time (Angel is me and also Buffy is me). Assignment does nothing more than reassign a name. Note that I recommend this mental model for beginners, and believe it has substance even for advanced programmers (e.g. me). However, at some point you do want to show the map to machine states, but that is a different issue. If I do that too early, then I ask the students to carry around two different models of computation, one based on logic and another, different one, based on machines. I prefer to keep it simple for the beginner and so try to focus on just the logical (higher level) model. But it takes some work to have a consistent model. As a general principle, I don't believe that every beginner must recapitulate the entire history of computing in the first course. Said another way, there are lots of things that I know, but it would be counterproductive to tell students. Their path needn't be my path. Finally, my comments in the earlier answer about separating concerns still holds. A virtual world can free the student from also needing to learn the issues and side effects, etc. of primitive data. Assignment can involve "interesting values" as it does in other computing models. 

Not shown here is the possibility of creating alternative world (population) geometries. For example a linear (single dimension array) is easy to do. You can also create a world as a Möbius band by "connecting" the left and right edges with reversed orientation so that a disease spreading off the left-top will spread into the right-bottom. Other connections are possible, creating such things as a torus, sphere, tube, etc. Combining that with immunity barriers can yield fairly realistic simulations. 

I'm going to focus on student's understanding recursion at a fairly deep level, rather than coding. First, to really understand recursion you need a sense of its parts. There is the base case, of course and most teachers spend time working on that, but students often miss it. But Before the process hits the base case there is a winding phase working toward the base case and after the base case is reached there is an unwinding phase in which all of the recursive "calls" unwind. In the execution of the algorithm, the winding phase is associated with the execution stack increasing in "height" and the unwinding case is associate with its subsequent shrinking. One point often missed by novices is that the winding phase has just exactly as many steps as the unwinding phase. Another point often missed by novices is that work can be done on both the winding and unwinding phases as well as in the base case. Therefore, to teach recursion you need a set of examples or exercises in which the student can examine all of these in detail. Complicating this learning is that most students learn recursion in an environment in which they have already learned to count, both upwards and downwards, and that knowledge, while useful in general, can inhibit learning about recursion if the ideas of recursion and counting (by incrementing or decrementing integers) get merged into a single idea. Therefore, I propose a sequence of active learning exercises, that don't involve coding, but in which the students play roles (stack frames, actually, though you needn't discuss that until later), and which lend themselves to immediate discussion and analysis. To do these you will want a deck of index cards on which to write instructions of the various roles. The recursions will all be "list-like" so a subset of your students will stand in front of the room in a row. Each student will have a card for the current exercise. Your role is to keep things moving so that the "execution" corresponds to that of a computer. I assume that the students are arranged "left to right" at the front, with the "base-case" person at the right furthest from you. Exercise one - Work only in the base case. This is a fairly odd example, not likely to be part of a real program, but it can be instructive. One student's instruction card says that when they are given another card they just read aloud what is on it and then pass it back to the person that gave it to them (This person is the base case). A few others (maybe zero) each have an instruction card that says that when they receive another card they just pass it to the next person in the line, though if it is passed from the left it needs to pass to the right. You have one additional card that says "All Done". You pass this card to the first person, who passes it on, and it should eventually reach the base case and be read aloud. You should then get the card passed back to you. Talk with the students about the phases (winding, unwinding, base) and how the number of times the card passed in is the same as the number passed out. Run the "simulation" more than once, with at least one "run" with only the base case. Later you can run it again with a missing base case to see the error that arises. Exercise two - Work on Winding Phase - Tail Recursion The instruction card for the base case is that when handed a card he or she should announce how many marks are on the card and then pass it back. The other student's instructions are that when passed a card "from the left" they just put a mark on it and pass it to the person on the right, but when passed a card from the right they just pass it to the left. Start the simulation by passing a blank card to the first person (who might be the base case in some "runs". The base-case person should announce the number of people prior to the base case and return the card, through the line, back to you. At some point you can talk about how this might be mapped to a while loop and avoid all of the return steps: unwinding tail recursion. As before, have an immediate discussion about what happened to make sure that the students got the points. You can discuss the fact that the number of marks on the card is like a parameter to the function, also. Exercise three: Work on the unwind phase only. The base case instruction is that when handed a card, simply hand it back. The others have instructions that say that they should simply pass on a card if they receive it from the left, but mark it if they receive it from the right and pass it left. Pass a blank card to the first person and you should get back a card with one mark for each person, but no announcements. You will need to make the announcement of the number of marks. Exercise four: Work on both winding and unwinding phases. Here the base-case instruction is that when given a card (from the left) with a certain number of ticks, just write the number of ticks on the card (perhaps on its back) and return it to the person who gave it. The other student's instruction is that when passed a card from the left just put a tick on it but when passed a card from the right find the largest number on it, double that number, write it on the card and pass it back toward the right. Pass the first person an empty card and make sure you get back the correct result. Again, a short discussion question/answer session will help solidify the ideas. While the discussion here was long, these things move quite quickly and only a few minutes are required for each exercise and its retrospective. However, expect that the students will get it wrong as you go, so your job is to be a coach to make sure it works ok and that the appropriate lessons are learned. Emphasize that the "data card" passed through exactly as many hands on the winding phase as on the unwinding phase. 

I don't think that the new UK curriculum is intended to create professional programmers, certainly not among 10 year old students. Perhaps the focus of this question here is too narrowly focused on programming rather than the more general "computing." Certainly, in today's world, where even young people carry mobile devices of exceptional computing power and whose applications can threaten their privacy, everyone need to know something about the details of this world and how a citizen should react to it - and govern it. The post here by Gypsy Spellweaver already presents a larger framework for thinking that is excellent in every regard. So let me mention another aspect that is often forgotten. I think programming at some level can be valuable to any "scholar" at any level. If you are studying $X$ then being able to write simple (we hope) scripts that let you automate some of the aspects of $X$ can be very enlightening, not as a programmer, but as a student of $X$. Replace $X$ with any field you like; music, art, philosophy, chemistry, maths.... Literature today has aspects that can only be successfully studied by examining very large data sets. Obviously the same is true of Astronomy. You don't need to be a professional Java programmer to write programs that are useful to you in your work. Even a spreadsheet can be of great use. Purpose-built (bespoke) programming languages for, say, Psychology research would be valuable to many researchers, but those researchers need at least the background to understand and modify their programs. Otherwise they need to depend on professionals even for relatively simple things. Even beyond the realm of scholarship, every citizen faces relatively small problems that they could solve with a bit of Python or, dare we say, Scheme. It also, of course, gives insight into the limitations of computing systems and, one hopes, the dangers of misuse. With the above in mind, it is probably necessary to teach programming in a different way than if you were teaching it to someone with a formal CS focus. Rather than traditional CS topics, such as searching, sorting, optimization, algorithm efficiency, etc., applications can be stressed. And they should be applications in the other fields that the students are beginning to study; their science courses, for example. This also opens the possibility of collaborations with the instructors of those other subjects which can, in itself, be a useful thing for all parties to the collaborations. The physics teacher is a good source of ideas about what physics issues might be informed with a bit of computing. Biology is an especially fruitful field since students often do field work, tallying up fish and frogs and birds, etc. Some simple programs to help them do the tallying and especially simple statistical analysis is helpful. Teachers can organize multi-year projects in which a new class carries on a study started by earlier students. It has scientific merit as well as generating learning and enthusiasm for the field. But the question is deeper than programming as I noted at the start. Every citizen needs to be able to digest what is going on in the wider world of captured data as exemplified by the current (early 2018) discussions and debate about Facebook and Cambridge Analytica and the misuse of personal data. These are big questions that require an informed citizenry. 

Introduction to Programming with Greenfoot by Michael Kölling might be what you want. Michael has a great grasp of OO and has built a great tool (Greenfoot) for beginners to explore it. The book has a number of simulations that are used to develop Java programming with OO principles integrated. The first four chapters (especially) of Karel J Robot by Bergin, Stehlik, Roberts, and Pattis also present OO principles in a simulation context, but also using a few simple design patterns. The Karel book has analogues for Python and Ruby also. Karel can be used within Greenfoot if desired or in other IDEs. There is a teacher resource for Greenfoot ($URL$ that has many projects for use within the greenfoot system. These are also simulations and show interesting objects moving and interacting on the screen (the World). New worlds can be created (inheritance) and new Actors as well. It is easy to integrate design patterns into the curriculum with these tools since the supplied software infrastructure means that the student isn't starting with an empty screen but with a well defined framework in which to develop the ideas. So, the student starts at a higher level of abstraction than the language primitives. Classes, methods, interactions, composition, delegation, etc. are natural topics that can be explored early in the student's learning. 

Of course, if you want them to learn OO style and not just build code, then you need to watch over them. There are a few ways you can do this. I'm assuming that your class is reasonably sized (say 20 or less). I'm not sure how to make it work for 80. You can use the class time as design sessions for coding. You can have students work in groups for a while and show you what they come up with. Initially you can suggest designs for sections of the project. The idea is to "nudge" teams in the desired direction, rather than to lecture on the ideal. I used to teach the Compiler Course in which a goal was also to improve OO thinking. I would review the student's code every two weeks. Student pairs (or teams) would submit printouts in a folder every two weeks. They needed to use a highlight marker to mark the changes from the previous report. It is relatively quick to go through 10 or so folders if marked up. You don't need to note every detail in these, nor do you need to grade them, but just give any needed feedback. For many groups as check mark is enough. But for some, you know you need to provide more guidance. If teams are larger (say around 5-6) I would do two things. One is that I'd appoint a "captain" who was responsible for keeping me informed (not for team management). I could discuss the periodic report with him/her. Depending on the number of students, you could have a weekly "captain's meeting" as part of class or office hours, perhaps. I also named teams with names they though clever to give them a sense of belonging. "Lions" and "Tigers" might work, or "Earth" and "Sky". I made up the names to avoid possible improper "creativity."