Once you have a picture of what you have and what you need you can start looking for solutions. If you have overlapping subnets and/or identical default gateways on multiple networks but you don't actually have overlapping host addresses I would look to use a single instance solution on a sufficiently flexible routing platform. Linux will let you assign the same address on multiple interfaces and you can then add /32 routes to send each IP address to the desired interface. If you want hosts on the overlapping subnets to talk to each other you can use proxy arp. If you do have overlapping host addresses then you probably want to use a solution involving multiple independent instances of the IP stack. Linux calls these instances "network namespaces", the big name router vendors call them "vrfs". Each network can be terminated on it's own instance of the IP stack and then NAT rules applied as neede to translate things to a non-overlapping IP space. 

It is likely that for the forseeable future your ISP will put some mechanism in place to allow IPv4-only clients on your network to access resources on the IPv4 internet. As the IPv4 crisis bites deeper ISPs will increasingly turn to mechanisms that allow them to provide you with access to resources on the IPv6 internet without giving you a dedicated public IPv4 address. Eventually I would expect such mechanisms to be phased out but likely not for a long time. There are at least five options available to the ISP for doing this. 

While this is probablly nessacery I would be wary. They will probablly get you a machine connected to the Internet somehow but they may horriblly break your client's network in the process. If/when you do call them out be careful what you let them touch. 

The machines are all on the same Ethernet network without VLANs. In this case the machines are not isolated even if they are in different subnets. IPv4 unicast traffic between different subnets will by default pass through the router where it can be filtered but broadcasts to 255.255.255.255 and IPv6 link-local traffic will pass directly between the machines. Furthermore if someone does want to send IPv4 unicast traffic bypassing the router they just need to add a second IP address to their NIC. The machines are on two physically seperate Ethernet networks connected to different ports on the router. In this case the router can reliablly control communication between the two groups of computers but maintaining two or more physically seperate networks is a PITA (and it's very likely that sooner or later some numpty will interconnect them). The machines are on seperate VLANs on the same physical Ethernet network. This gives you the best of both worlds. The router keeps control of communication between the two groups of computers but you only have to maintain a single physical infrastructure. 

Full cone, the mapping depends only on the client IP/port, the same mapping is used for all servers and return packets are allowed from anywhere. Restricted cone, the mapping depends only on the client IP/port, the same mapping is used for all servers but return packets are only allowed from servers the client has connected to outbound. Restricted port cone, the mapping depends only on the client IP/port, the same mapping is used for all servers but return packets are only allowed from server/port combinations the client has connected to outbound. Randomising symmetric, the mapping depends on the full 4-tuple, ports for outgoing connections are chosen randomly. Port-preservative symmetric, the mapping depends on the full 4-tuple but the NAT only changes the source port if it has to do so to avoid a conflict. 

Subnets are the IP stacks way of determining what hosts are "assumed to be on link". If an address is in the same subnet traffic will be sent directly, otherwise it will be sent to a router (by default). VLANs are a method for splitting a physical Ethernet network into multiple virtual Ethernet networks. If you put hosts with different subnets on the same unpartitioned Ethernet network then IPv4 unicast traffic (and possibly IPv6 global unicast traffic depending on how you set up IPv6 routing on the clients) will by default flow via the router where it can be firewalled. However. 

I expect the best approach here would be to forget using the built in NAT in virtualbox and instead set up a host only network and then use standard iptables NAT on the host. 

I am sure you could hack up a TCP/IP stack to remove arp and use a single MAC address for everything and you could make it work on a local network with only hubs and no switches or routers. Why anyone would want to do such a think I have no idea. 

That depends. Normally each host will check the desintation address for it's packets against the "network" defined by it's IP and mask. If they are within that network they get sent "directly", otherwise they do to the default gateway. So if host A is within what host B thinks is it's network and host B is within what host A thinks is it's network the ping will succeed. Further complicating matters some operating systems will try and send packets directly if no default gateway is configured or the default gateway is set to the clients own IP. IF a router is introduced and packets are sent to it it may router the packets between the hosts. If the router knowns the hosts are on the same network it may may also issue ICMP redirects to tell the clients they can talk directly. 

By that definition the line coding schemes used by modern network cards would not qualify as "modulation" (you could argue that the Manchester Encoding used by 10 megabit ethernet does count as modulating a carrier). On the other hand the schemes used by modern dialup modems wouldn't either On the other hand if we take a broader view of the term modulation as covering any scheme designed to take a signal and encode it as a waveform whose voltage and frequency characteristics suitable for a given channel then the coding schemes used by ethernet would count. In practice the term "modem" is typically used for devices used over channels that were not specifically built to carry data. That doesn't imply much at a technical level though. 

It depends what exactly you want to test. There are sites like test-ipv6.com which can check your IPv6 connectivity. If you want to check what would work in an IPv6-only world then your best bet would probablly be a VM of some sort. Of course you need to get IPv6 working on your networ before you can do that. 

When a host goes to send a packet it first looks in it's routing table. From the routing table it determines what interface to send the packet out on and the "next hop IP address". You haven't said what the subnet masks are on your host, lets assume they are both 255.255.255.0. Normally when sys1 tries to send a packet to sys2 it looks up the IP in it's routing table and decides to send it to it's default gateway. It then looks up the default gateway in it's ARP table (and makes an ARP request if needed). It doesn't try to do an arp request for sys2's IP address because it considers it to be out of network. At least on linux this behaviour can be overridden with explicit routing table entries. I don't know about other systems. 

The other approach is to have distinct "upstream" and "downstream" interfaces. Straight cables can then be used. It means you can have one set of rules for wiring things up and do not build application-specific assumptions into your cable plant. Twisted pair Ethernet takes this approach (calling the two interface types MDI and MDI-X). From time to time it was nessacery to connect two intefaces of the same type together. Maybe you were connecting directly from host to host. Maybe your hub didn't have an "uplink" port. In this case a crossover cable or adapter was needed. 

It's absoloutely possible to Jam a wifi connection in this way. There are also some sneakier ways to mess with wifi such as triggering deassociation from the AP. Note that messing with other peoples RF communications, even on your own premises may well be illegal. $URL$ 

Point 1 is certainly true for Linux NAT, I can't comment on other implementations. Point 2 is fine if the DNS server is on a different subnet from the client but if they are on the same subnet then some trickery is needed. It would be possible to have a script make the router take over the DNS server's IP address but then you have a potential IP conflict to deal with when the DNS server comes back up. Point 3 means you need to think about your routing. If there is only one path from the client machine to the internet and the same path back then you are fine. Otherwise you may have problems. Overall, while certainly possible to implement this seems like a bad idea. Far more sensible to just have two DNS servers and then set the "primary" and "secondary" DNS server settings appropriately. 

First we need to understand how packets are sent. When a host or router tries to send an IPv4 packet* it first looks up the destination in it's routing table. Based on the routing table it determines the "next hop IP address" and interface. For a machine on a local subnet the "next hop IP address" will be the IP address of the destination, otherwise it will be the IP of a gateway. What happens next depends on the interface type. Assuming it's an Ethernet or similar interface the network stack needs to determine what MAC address to send the packet to. To do that it looks in it's ARP table. If it finds a valid entry then it fills in the MAC addres and sends the packet out over the Ethernet interface. If it doesn't find a valid ARP table entry then it will begin the ARP process to try and create one. In the meantime packets destined for that next-hop IP address will be queued up until the system knows what MAC address to send them too. If the ARP process times out then any queued up packets will be rejected with a "destination host unreachable" ICMP message. Eventually entries in the ARP table time out and need to be refreshed. On hosts/routers without a default gateway you can also get a "destination host unreachable" reply generated if there is no routing table entry, so the system doesn't even know what interface to ARP on. 

464xlat, the ISP runs a NAT64 and then you locally run a NAT46. Many ISPs are likely to implement the NAT46 on their home gateway devices, but if they don't then you can implement one yourself easilly enough. I expect this is what the andriod phone you mention in a comment on Sanders answer is doing. DS-lite, an automatic tunneling based approach, usually implemented by the ISP. This is really only an option if your ISP chooses to use it. Use a conventional VPN implemented with software that allows the VPN to run over IPv6. 

So customers want logically separate Ethernet networks but physically separate networks end up being prohibitively expensive. So we need to build logically separate Ethernet networks over the top of a common physical network. VLANs provide a method for doing this but they have scalability problems. VXLAN aims to provide a more scalable solution (at the cost of substantially higher encapsulation overhead). 

It depends on how they are fragmented. If they are fragmented before encapsulation then the fragmented packets can travel seperately to the end host (though as mentioned above many firewalls will defragment them) On the other hand if the encapsulated packet is fragmented then it must be reassembled before it can be de encapsulated. 

Each router has it's own routing table. The routing tables are built by the routers based on exchanging routing information with other routers and by policies set up by the owners of the routers. The exact policies will vary between ISPs but as a general rule a shorter AS path will be preffered over a longer AS path and if the AS paths are the same length a closer exit will be preffered over a more distant exit. Google interconnect with other networks at many locations around the world. At each of these locations they advertise 8.8.8.0/24 address block. The routing rules work out such that traffic to the 8.8.8.0/24 block is usually delivered to google's network at a location close to the sender. Once inside google's network google can then route the traffic to a nearby cluster of DNS servers. 

Media or Medium reffers to the communications medium (cable, fiber, radio etc) over which communications happens. Originally Ethernet used a "Shared medium". That is something (specifically a coaxial cable) where multiple devices can transmit but only one can successfully transmit at a time. The medium access controllers primary job was to control access to the medium. It would receive a frame from the host computer, wait until the medium was free and attempt to serilaise and transmit the frame, performing backoff and retransmission if needed. It would also deserialise and usually filter incoming frames. Each medium access controller had a unique address known as a MAC address that could be used to identify the source and destination of frames.. With modern links running in full duplex mode there isn't any need for medium access control, the sender can just transmit immediately, but we still call the part of the network controller that handles serialisation, deserialisation and filtering a MAC and we still call it's address a MAC address. Such is history, it's a bit like the way we still use a floppy disk as the save icon even though hardly anyone uses floppies anymore. 

There are ways around some of these, for example you can put NAT routers behind the main NAT router to provide some isolation between lans (though at the cost of having two layers of NAT which can break some services). You may be able to buy a buisness package from your ISP that allows the first level LAN to have public IPs so each house has thir own public IP, getting a buisness package from the ISP may or may not also eliminate unfavorable terms and conditions. You can get traffic shaping routers to try and reduce the impact of the torrent traffic. 

This is usually related to buffering. The delay through a buffer depends on how full that buffer is. With a simple buffer when there is little traffic the buffer is empty. Packets get through quickly. When there is more traffic than the outgoing interface can handle the buffer fills up. When the buffer is full it starts dropping packets, typically it drops newly arrives packets, a behavious known as "tail drop". When the sender sees packet loss it backs off the speed slightly, the sender then gradually increases the speed again until it once again sees lost packet. The result of this is that the buffer immediately prior to the bottleneck ends up nearly full while other buffers end up nearly empty. I would guess that the buffer that is causing your problems is on the ISP side where the traffic passes from fixed line to wireless. So what can be done? There are a couple of things the ISP can do in principle.