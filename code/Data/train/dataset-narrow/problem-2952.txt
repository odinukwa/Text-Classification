And they see in eclipse that the last print errors in compile time. That shows them that . Next, I show them that there will also be an error if we define before the block, but the last line won't error. So they see that order of creation matters. Afterwards, I show them that creating after the block and before the last print, then there are no errors. The vast majority of the students understand the idea this way. They don't learn the stack segment of the computer at that time, but they see that order matters, and that makes learning about the stack easier for them when they learn it later in the year. 

You can use an analogy of priority queues (maybe a hospital, if it isn't too gruesome; perhaps a queue for ordering work tasks) A nurse doesn't need a patient to have some indicator that they are supposed to be treated before some other patients (these indicators are the parenthesis). There's simply a known treatment order, based on the urgency of the treatment. If all patients need equally urgent treatment, then they are treated according to the order of their appearances (the ones who "check in" first are the ones treated first). Nurses know how urgent a new patient's treatment is, and so does the compiler. For java, it goes like this: 

This year I am planning to shift from teaching Swing for graphics, to teaching JavaFX. As JavaFX ideally uses the MVC design pattern, I thought it would help students understand how to use JavaFX if they learnt about MVC. While teaching the various controls, views and goodies in JavaFX is relatively trivial and straightforward, teaching MVC isn't so simple. So I am trying to intuitively explain MVC in the context of JavaFX. What example applications in javaFX can I use to show them the MVC cycle? 

and then explain that holds info about the date and time that the line was executed. Once the students understand the very basics of the date object, ask them to print it. The difference between 

What are some advantages of incorporating algorithmic complexity in grading tests and assignments given to students? Currently, students in 11th grade at my school are required in tests to write functions that should preform some operation (usually operations on data structures like , and ). This works fairly well in terms of checking whether a student knows how to use those data structures. However, it's not uncommon to see an answer that does, eventually, preform the required operation; and yet its complexity is $O(n^3)$ (no kidding. The specific case I'm thinking of is one where the student worked with the unsorted linked list of stacks1 in 3 nested for loops). The students are required, after they write their functions, to also write the complexity of their solutions. In a quest to improve the students' thinking skills, I thought that maybe we should give bonus points if the solutions are inventive and less complex than a head on approach. This means that if a student's function is $O(n)$ for a task that a direct assault would be of $O(n^2)$, they should get more points. This can also apply to various assignments we can give them, in addition to the tests we already have (or maybe make the tests slightly easier and then add assignments). The students are in a CS major, and they have experience with java, OOP, Data structures and basic calculations of complexity for various, simple, algorithms) 

Often times, google is our best of friends (I hope). A rather simple search leads to a very informative site: $URL$ It is very thorough, and explains many use-cases for recursion. Another very handy resource is, inevitably, Stack Overflow: this question also provides some information, but it is rather specific. Instead of staying there, one can navigate to the Related Questions section, and from there choose a promising question (usually the one with the highest votes, but not always) and reading it. And so on, and so on... (recursively ). 

That's it. Doubts I spotted a few issues in the curriculum. First and foremost: Where are all the arrays? I want to include arrays, but I'm not sure where\instead of what. Teaching after arrays seems better than before, because then I can show the in the same lesson. They are essentially the same (but not 100% equivalent. Concurrent modifications is something beginners aren't ready for). So I am uncertain about the order of the subjects. Secondly: Functions. Again, why? I want to remove them from the curriculum (students learn about them in the following years anyway, as part of OOP), but this might do more damage than good. Students might want to know, after an entire year, what exactly is the meaning of the from lesson 1. Functions can explain that, but other than that, it's pointless at this stage (because they'll learn it anyway, should they major in CS). So, does the order of subjects in the curriculum, as it stands, make sense (keeping in mind that arrays are not covered at all)? Note: this question is not a duplicate of this one, simply because I already have a curriculum, and I am asking for a review of it. I'm also asking about specific aspects of my curriculum, and not general "hand wave-ish" things. 

I was recently asked to teach someone OOP and C++, to a relatively advanced level in the former and an intermediate level in the latter. After one half of a private lesson, it became clear that the student isn't good at learning in this way. Instead, I tried to give the student some links to explanations and examples (mainly so that the student could learn the remainder of that lesson's material). That proved to be so effective. For the next lesson, I won't "bother" with teaching the student. I've found a satisfactory collection of websites that cover the relevant material for the lesson, but I am at a loss on how to order them (and, indeed, the curriculum in the broader sense). This made me think of the following: There are probably many students that learn from websites and links etc. much more effectively, as opposed to learning in a classroom (mostly self-learners) So my question is how can a teacher (or student) find resources that both cover the material, provide example and exercise and are ordered in synergy? Specifically, OOP and C++ each have many subjects and points of interest that are built on one another. For complex subjects/paradigms, it is much harder to find fitting resources. So the methods (for constructing a curriculum built upon resources and websites as detailed above) I am looking for should be able to tackle such a complex combination, meant for less than 5 students. 

Give them as many opportunities to work on such abstractions At first, you have to give them the right amount of feedback on their work. 

You could show them the results with a given heuristics function, that has a single parameter which impacts how the heuristic function affects the cost estimate. As an example, 

1Technically you're just executing the code line by line like a computer, but the point of what I said doesn't change. 

While teaching OOP in a high school CS major (in java), it is important (and part of the curriculum in any case) to explain "what is the meaning of this and ?" (A question voiced by many students). The usual explanation is a technical one: 

I am trying to think of a way to demonstrate how a multi-client server works, from the aspect of the broadcast messages sent from the server in response to a message from one of the clients. I thought of making a small demonstration with cups and strings, having 4 to 5 cups on strings which are all connected to a main hub, rather than to each other. The hub is simply a closed box with holes where the other end of each line goes to, and a cup sized hole at the top. When students speak into the cup, all the students hear what was said, because it was a broadcast from the main hub. While this example sounds cool, I am not sure if it covers all1 sides of a multi-client server. What differences between a multi-client and the cup-string-hub example should I point out? (e.g. one of the differences I found is protocols, which the example doesn't exactly convey). I am talking about back-end differences, and not front-end ones. 

But what if we had more than 1 hidden layer? Now that's classified as deep learning. A short google search for "deep learning neural networks" gives this handy website. It, too, gives a brief summary of the mathematics, increasing understanding. After reading these articles and that website, you and your students should be good to go, and start gaining hands-on experience. Usually, the basic example for a deep learning algorithm is to fit a linear function to a dataset of points. Another article (again, found through google search) explains the subject with more specific information. I recommend reading it to gain greater understand of the subject. Because links sometimes go broken, it might be a good idea to download those articles (they are pdf files). Then again, they were found with straight forward google searches, so that's more reliable, especially in such a quickly evolving field. 

That's the first lesson. From here, I'll list the subjects (each one is a subject, and not a separate lesson; lessons are ignored, I only address the subjects of the curriculum) taught (the language used to teach is Java)    0. (First Lesson) introduction and simple printing of text 

A good way of doing this is showing them (via example) how important it is. A small piece of code in a lab period can be used to show them how everything falls apart if you don't test your code. Going by: Bugs are small beings, so you need to look for them with a magnifying glass. Testing is the magnifying glass. Using a piece of code that, at first glance, looks just fine. Show them that for the input it was made for (but not exclusively for that input) the code works smoothly. However, given some input (which the program should theoretically be able to handle), the code fails miserably. The key point is the should theoretically. It should, but without testing it, it might as well be that it can't. This example usually shows why it's important to do tests even where no problems should appear. Because, again, bugs are small things that create big problems. 

one knows that anything that for any object instance of a class which , we can call . This means that, unlike ing a class, means (and directly implies) that instances of the class have some functionality. Teaching it in this order gives the view of an interface being nothing more than a promise for some functionality, and how such a thing is integrated into OOP. This also avoids some of the confusion I've witnessed in cases where abstract classes are taught before interfaces. They are not the same, but understanding why it's ok for something not to have a method body (i.e. abstract methods in such a class) is clearer to students if they know interfaces. Additionally, if one teaches interfaces as a contract of functionality, then it doesn't appear as an add-on. It's a fully-fledged OOP concept with incredible usefulness. Whenever a person needs to describe just the functionality required by an unknown set of objects (and maybe of different classes), an interface is their best friend. 

Explain the basic objects inside the library: , etc. Explain the object in , and elaborate on how is heavily dependent on . All* objects in are children of objects in . Also explain the class object. Show that essentially contains (hence the fancy name) other s and that creates a GUI. Show the students a simple GUI for a chat application (no server-client, just the gui!) which composes of a , (for entering messages), (chat history) and . This step includes showing them the code. let them work for the remaining time (45 mins plus ) on creating a gui of their own, of their choosing, which can have any object they find. The GUI must have , and . Other than that, go wild. 

As usual, useful network analogies are buses: A bus leaving the central station sets out on route to its first intended stop. That's the first step. The process of the bus's route from the central station and back to it (the entire route) is a pipeline. In this analogy, latency is the time it takes the bus to get back to the central station, and throughput would be that maximum number of times a bus completed its route (in a given timeframe - maybe 1 day). The latency might lengthen due to traffic (literally ) or due to packet load - high number of passengers boarding at some stations would cause the bus to be late to the following station, and so also increasing the time it takes to complete the route. In this example, the throughput is not exactly the reciprocal of the latency. This can also convey the idea that messages can be delayed at the central station (for various reasons - compression etc.), and that counts towards the throughput but not the latency. Every busride ends exactly where it started; every bus ride starts when the respective bus route is complete (bus number 9 can't start until bus number 9 completes its route). Again, there is some degree of parallelism, because some bus lines have multiple buses going about, but let's ignore that, and focus on bus lines in small cities, or those with short routes. 

I feel it is important to know binary. Some students find it enjoyable (and some might even use it in their projects to encode and decode custom data) and those who don't simply ignore it. I think it's good to teach it because a) it gives students the notion of how computers actually work (they know it works with electricity, so 0 is low current, 1 is high current) and b) it's useful in coding, as they can use it to serialize data. Eventually, if there's time, teaching how it can be used is good, and not only what it is. 

I am preparing to teach students python, in addition to java. Usually, I test a proof of concept (POC) of my teaching with a handful of students, so as to know if my lesson plans are good (I teach the lesson to 4-6 students of varying skill and then I ask them for feedback). This time, the students were introduced to Python, after they were taught Java (They were taught OOP and basic I\O). For the POC lesson in python, the feedback I received showed the difficulty in understanding the difference between Python and Java. Python felt so different (and rightly so) to the students, and they couldn't quite understand how it works, when compared to java. They know java has the runtime environment which runs compiled code, but they don't know how python runs the code they write. This difference I'm referring to. That isn't the only difference they had difficulty with. So, in an attempt to make the introductory lesson in python to the rest of the students, I am trying to explain those differences beforehand. How can make the transition\introduction from java to python more smooth? 

and then if there was a mistake in the text, (as there is in my example), it's very easy to fix, without needing to copy-paste. As for elegance, I agree that the second option is a bit more elegant. However, it forces the code to enter the loop, and when teaching, it's far better to break an example into smaller parts, so as to allow students to understand each component separately, before they tackle the entire thing. 

Trial and error, as well as practice, are usually the best way to get students to be comfortable with anything. "All" you have to do is give them time and plenty of opportunities to use multiple layers of abstraction. They will find it difficult at first, but after a while they'll become noticeably better at it, and eventually they would be quite ok with using many levels of abstraction. They'll develop that mindset by trial and error. With all trial and error, a system of feedback is needed (to know when a trial is an error). You are their system, in the beginning. At first, you have to guide them very closely, only by giving feedback on their work. This is crucial. If you don't give feedback, then it might as well be "error and error" (in their eyes). If you give too much feedback then they might not develop the wanted mindset, or worse, they would be confused about abstraction even more, setting them back even further. So you're task is twofold: 

Push - adding a new element (bullet) to the top. Pop - remove the top element (bullet) from the stack (in the analogy, this is like shooting). Peek - looking at the first element of the stack (checking to make sure that the topmost bullet is correctly placed) Check if Empty - check if the stack is empty (in the analogy, this operation is checking if there are bullets left) (Initializing the stack - creating a new stack) 

It would really depend on the student. I would suggest that you see if it those students get better grades (compared to others that do the expected amount of work). Also, it might be worth looking out for signs of breakdowns, or anxiety (usually expressed in hurried complaints about workload). If they get better grades and don't collapse from the work, then I would think that everything is ok. However, if they don't get better grades (I'd define that as 1-2 tests that are below their average) or are showing signs of breakdowns, I'd talk to them and say that they are putting more effort than is needed (and healthy). They might protest that "I'm ok", but that might be an attempt to convince themselves. If they do this, then you should point out that the curriculum is designed in a specific way, and they are overworking. You can also advise them to put the additional effort into expanding their knowledge of other things, in addition to the "Vanilla" curriculum. This might not work with all students, but for some, it's like presenting a good opportunity.