visually this rotations are equal, but when I get angles 2) from quaternion and increment them it starts rotating in oposite direction, next frame rotation is again as 1), so there is infinite loop at this rotation (some kind of black hole;-)). What can it be? Something wrong with math? 

After some rotations and to from quaternion conversions I get negative scale from Matrix 4x4, is it possible? I need that scale to draw sprite on screen so I get sprite flipped, how to deal with this problem should I just handle negative scale in sprite drawing method. if MatrixHasNegativeScale then invert scale, draw sprite with inverted scale after m4.initWithHeadPitchRoll(0, 0, 180); I already get negative scale. or something wrong with matrix class? Edit I create transformation matrix(rotation + scale + translate) rotation around Oz by 180 and when I extract scale from it, it has negative value is it normal? 

When I started to develop my game engine, I created StateManager and BaseState class, but further I found it extremly unpractical, and removed state management completely. Now I simply use SceneManager loading, unloading scenes. Main problem was transition between states. Now, I just use substates inside scene and that's all 

I have Transform component storing it's rotation as Quaternion. Transform has set/getEulerAngles (rotation order oy, ox, oz). I want to rotate object in any direction but while testing I get jumping(glitch) objects stop rotating at specific angles. Euler angles in problem frames: 1) oy 0 ox -90 oz 0 - previous frame. 2) oy 180 ox -90 oz 180 - next frame after incrementing angle of the object. my increment looks like: 

Let's first discuss the dot product. A·B is a measure of A's component in the direction of B or vice versa; of the magnitudes of both vectors as well as their similarity in direction. Vectors pointing in the same direction have a dot product equal to the product of their lengths, perpendicular vectors have a dot product of zero. Turn the vectors even further apart, and the dot product becomes negative. Though normally defined as (x,y)·(u,v) = xu + yv, it has the property: A·B = A B cos θ, where θ is the angle between the two vectors. The sign of this product can be used to determine whether a vector B partly points in the same or opposing direction of a reference vector A, i.e. if A·B is positive, the angle is less than 90° (or greater than -90°). It doesn't tell us if the vector points left or right with respect to the reference. Below is a graphical description. Blue vectors B would yield a positive A·B, red vectors a negative. 

Only in exceptional circumstances will players notice or care about the accuracy of your physics simulation. Most games fake calculations like these, which has several advantages; fake calculations are easier to code, computationally less expensive and most importantly, they allow the behaviour of the game to be tweaked in favour of fun rather than realism. If playtesting reveals physically accurate bullet drag is less appealing than some other model, faking it becomes a deliberate design choice. If you still believe realistic drag is an important feature for your game, here's a bit of physics. The drag equation can be solved analytically, though if you should want to involve other forces on the bullet, you require numerical integration. Combining the drag equation with Newton's second law of motion, we get: m v'(t) = -½ v(t)² ρ A Cd, the solution of which is: v(t)=2 m / (ρ A Cd t + 2 m v(0)-1). This gives us the bullet's speed as a function of time, not of distance, but we can integrate v(t) over time to get the distance travelled x(t), then invert that to get the travel time as a function of distance: t(x) = 2 m(eρ A Cd x / (2 m)-1) / ( ρ A Cd v(0) ). The many symbols in this formula obscures its relatively simple exponential nature, which becomes apparent if we simplify v(t(x)), the speed the bullet has when it reaches x: v(x) = v(0) e-(ρ A Cd/ (2 m)) x. The plot below shows the bullet velocity against distance with the parameters you supplied (air density: 1.225 kg/m3; bullet radius: 11.43 mm; initial speed: 251 m/s; drag coefficient: 0.45; mass: 10 g). 

Gimbal lock is the answer, avoid using euler angles even converting to and from quaternion, use multiplication by quaternion created from angle axis. Unity3d has same problem when rotating around ox axis: 

I have a lot of minuses on this question, but I tried to use reference counting on my entities and components, and now I like this approach very very much. So if someone is interested, I stopped on using reference counting on these objects. I used this approach a bit and see now a lot of benefits and hope in future there won't be problems. 

BasicEffect is shader program. So it is resource it must be single( to save memory etc). And parameters are passed same as in function. 

Instead of using tilemaps you can use general objects transformations. Like: house01 x:151 y:150 angle:30. Also you can generate your map on the fly. In storing map as bitmap you use 32bits per pixel for example, and in the simpliest tilemap only 8bits(ASCII char). And using bitmap for map generation it's just a way for storing data. Anyway your engine will interpret data as required, so your idea is right about save/load tilemap. 

(Rotation*Vector3::Forward).Normalize() * move_speed * dt dt - time elapsed since last frame Vector3::Forward - direction to move relative to current rotation. 

I want to show user shot power in standart way (the more user holds finger on the screen the stronger is shot) 

With your Physics you subscribe to changes of your Transform component. So when transform position changed directly you Physical part also moves. And after physics simulation you can directly change Transform->position from Physics, because entities which have Physics will always have Transform. What about direct moving of objects without physical simulation, you can use Kinematic bodies most of engines provides their support. Or you can directly write your position+=velocity in any your script. Or create some BasicPhysics component and then just adjust properties. 

Wouldn't it be simpler to just use some integer state logic to drive the match comparisons? For example you could just keep track of each Tile's state and colour and do numerical comparisons instead of interrogating the actual texture of each gameObject? This has the added value of using a single Texture Atlas to store your tile textures and then just map to that Atlas as per the norm if a tile needs to change via a user mouse click. A quick comparison example for you to Ctrl-F5 (if you run it a few times you'll get a match) : 

When I implemented something similar I used a messaging system exclusively to handle the necessary communication between different entities in various systems. That way the messenger can perform the relevant required component checks while marshalling the your messages between the entities. You can think of the Events as mini SubSystems if you like. It also cleans up your systems quite a bit as well as providing a great deal of de-coupled logic, and hence less dependency chains overall etc. (contrived and untested psuedo-code disclaimer) example : 

Once thats set up you can then interrogate a tile in your move path to see if its walkable based on the terrain type, or if it's blocked by an child obstacle etc. 

You've already got most of the setup. What you could do is just control the Campfire from the other collider inside the Collision method [untested code] : 

I found it a little bit difficult to follow the entire thread of your question. However at the most basic level, in a simple FSM you could either just query the current state of your StateMachine (i.e. assuming its a singleton manager class etc : StateMachine.Instance.GetState ) and then do the necessary long-winded if or switch statement logic depending on which state is returned. Alternatively, for something a bit more loosely coupled and dynamic you could just have each relevant Class subscribe to a OnStateChanged event equivalent and react to specific states with callbacks. There isn't a right way to implement a FSM, however you can take a steer from one of the many online resources eg: $URL$ $URL$ ------ EDIT UPDATE ------ The idea is that if you're going to roll your own GameStateManager in the Unity engine, then each state would essentially have it's own methods such as Update etc. These methods would execute sequentially as per the norm. You could manage your state transitions with a State stack container. This way multiple states could be queued up and pushed into the stack, and then executed in order i.e. GameState-->MenuState-->ControlsMenuSubState etc. At the end of each frame you could then do some bookkeeping and check if it's OK to roll onto the next state i.e. pop the current state and then execute the next state object on the GameState stack. It does sound like you're overcomplicating things by coupling each class to each State of the game. The classes generally shouldn't know or care which state they're in as it's the State's job to call into other classes, not the other way around. Unity's normal Scene methodology is also suitable. You could just use Scenes to transition between major games states, and then use the Unity GUI for Overlay states such as Inventory or Menu states which need to run in the current state. All you would need is at least 1 object to maintain your meta game state between scene transitions. 

Personally, I would prefer to keep variables like 'normal' and 'center' intact for later use, but I hope this example code gets the point across. 

As far as legal issues go, the usual remarks apply. Laws are not universal, your mileage may vary etcetera, etcetera. If you are required to obtain the user's permission to publish his score, it doesn't follow you need to ask. Permission can be implied by simply playing the game, as long as the player is informed of this, for instance through your terms of service. Once again, one paragraph of legal advice is bound to cut corners all over the place. Most answers so far have been focussing on these legal issues, but from a gaming perspective, there are very few reasons to pose the question whether scores should be submitted. Obviously, the less you bug the player, the better. Interrupting gameplay to register the user's preference adds no enjoyment to your game, regardless of which option the player would click. Assuming the score should or should not be submitted is intrinsicly better than prompting, but you risk getting it wrong. By automatically submitting the high score, getting it wrong is not such a bad thing though. Players simply uninterested in competing on the leaderboard, will not be harmed by their own achievement being on there. After all, it might just as well have been someone elses. Other players may however still benefit from the score being on there, as it allows them to compete with it. The leaderboard will be more competitive and fairer; it is not limited to a non-representative selection. Moreover, showing the leaderboard with the player's name on it, might awaken his interest to compete, even if he would not have posted his score, had he been given the option. Perhaps he realises his score was far better than expected, giving a sense of reward, or quite the opposite, letting the player know there is a lot of room for improvement. Perhaps he sees he has beaten a friend, or that he has been beaten by one, inspring him to play again. All experiences he would have otherwise missed out on. Worst case scenario: the player looks at the list and doesn't care at all. A leaderboard can definitely make your game more interesting. If it does, you should probably just go ahead and get the player to participate. If it doesn't, you probably shouldn't even have one. 

You can use factory method or you can use array of objects prototype pattern (prototypes or templates, how to name them your choice) from which you create objects just copying and instantiating if required. I've seen only this two ways of problem solution, if someone suggest another one I'll be glad to see them (possibly they are better) 

I want to make my body fly at constant speed, how to make it fly at constant speed before and after collision? I set restitution of my body to 1.0 but after some direct and powerful collisions my objects begins to slow, I want it to fly same speed as before. I heard this can be done by setting liner damping of the object, I think it can prevent only from fast flying objects not slow. Thanks in advance. Edit* I can simply modify velocity of the object every frame, is it a solution? 

So you have to take care about constant physics step. Sometimes for example it can be called 2 times per rendering frame. You wrote: 

Where is the best place to show this icon on touch screen(when I use mouse it's better to show it at the mouse position): 

You must use texture coordinates instead of resizing, like draw only part of the whole texture. I don't know how it works in libgdx but it's common to use this approach. Another approach is to use texture atlas, you have in memory e.g 1024x1024 and then when you load your image you load it to atlas rectangle. 

So you're looking for a parabolic function y(x) that equals zero at two known points. Let's call those points r1 and r2, after robots 1 and 2. One solution is easily found: y(x) = ( x - r1 )( x - r2 ) On top of the robots, one of the terms in parentheses becomes zero, which, multiplied by something else, remains zero. For that reason, we can multiply the entire thing by a factor a. This stretches the parabola vertically (or flips it upside down for negative values) without changing the location of the zeroes. We manipulate a to make sure the curve passes through the vertex, defined by coordinates (xv, yv). We solve the following equation for a: y(xv) = yv a ( xv - r1 )( xv - r2 ) = yv This yields: a = yv / (( xv - r1 )( xv - r2 )) We get the function y(x) we want by multiplying our original function with the scaling factor a we just obtained: y(x) = ( x - r1 )( x - r2 ) yv / (( xv - r1 )( xv - r2 )) 

The equation works reasonably well for bullets of different sizes, shapes and masses, but not for different materials. Wood, kevlar and flesh are not fluids and the drag equation does not apply. Newton's approximation of impact depth may be of some use, but its accuracy is limited, especially for materials like kevlar, which are designed to outperform this approximation.