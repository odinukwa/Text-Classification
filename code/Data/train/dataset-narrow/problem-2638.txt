The answer to your 3 questions is subject to the laws that are applied in your country, also a trademark is a different concept if compared to a registered IP or a registered copyright, and there are also other possible options. Each country has its own law and usually its own patent office, also do not assume that a registered IP is protected worldwide, this is a political issue and can also affect your distribution strategy. 

I know this 2 products but i have never used them for production, since I have a bunch of cool shaders i would like to use them under OpenGL with GLSL but i don't know where to start. If it's not possible to convert them directly, where i can learn the Renderman syntax for the shaders? 

This isn't clear for me, if i use the drivers from the GPU manufacturer and they support OpenGL 3.0 and/or above, i can always make an OpenGL ES 2.0 application work? 

The only real thing that is different is the amount of devices, Apple just sell 1-2-3 new product each year, Android offers 1 new product every day/week. The emulator it's not buggy, it's just not intended for profiling, if you want to profile an Android application you have to do the same thing that you have done for iOS: consider the lowest profile device that match your requirements and buying it. You are supposed to have at least a basic know-how about the ARM architecture, otherwise you can make a difference between all the devices on the market, begin to outline the hardware features that are important for your application and buy that device for real testing. 

Each has its own pros/cons. You seem to me to be quite new/unexperienced to programming. I would recommend You to do some more excercises in general programming. Data structures and algorithms. Quite nice book about programming is C Programming Language, the language it is for -C- is similar to Flash. You should also try searching stackexchange for recomendations on beginners book/tutorials on programming. 

The way around it is to have/create a memory where You store information WHAT should happen and WHEN it should happen. Then memory should be checked whether time has elapsed (in WHEN) and if it did, then do that WHAT should happen. You can acomplish this in several ways: 

You have to figure out rules of communication (communication protocol). Also there is a chance, that some of javascript game libraries has methods to help You handle communication. 

This way You can have talent A unlocking B, C and D ((A, B), (A,C),(A,D)) and talent Y unlocked by X,Z and W ((X,Y),(Z,Y), (W,Y)). In imperative/procedural/object-oriented language You would do it as list/array of pairs like there: 

I want to know what options (or shaders) to set so that my OpenGL game looks like Playstation 1 game. I know it probably can not be achieved 100 % because PSX used television and television renders differently that monitor. Thanks. :) 

In the game You find id and try to match id and the condition. You need to model the conditions and actions. By objects, function pointers, XML ... Good dialogue editor will be handy too. 

Only the person, the group of people, or the activity that owns the code can change its own license. If that code is yours you can change license every time you want, decide to be payed or not, you can do what you want, but if the code it's not yours you stick with the license if you want to avoid troubles; big troubles. The owner can also refuse to accept to be payed, it's a situation like the one that you have with the patents, if you can prove that you own the code doesn't mean that you are putting it on the market for money, many many times the patent or the license is supposed to force the market or the user to stay in a confined space. The answer is no and the only way to change the license is hoping that the owner will do that. 

Well, Game engine is a generic term, Physics engine is more specific, the "problem" is that the functionalities that a game engine provides are up to the developers that have coded that particular game engine. There are very basic game engine that have no physic support or they expect you to add to it manually, and game engine that support physics and fractures in real time. Your view shouldn't be about how they work together in the first place, just look at what a game engine offers and if you need a physics engine add it to your code. There are also some engines that mimic the physic with pre-baked collision and explosions, there are several approach to this, depending on what you have, what you want to achieve and what is your target machine, you better look to the features and how they are implemented, only the name "physics engine" can't tell you what you are dealing with. 

Like in physics. Only at the moment You press and character is on the ground add upwards velocity (it is called impulse), but make character fall by gravity all the time. If You do not want character to be jumping every time it hits the ground - because You are holding - add variable which You clear after is released and set after. Pseudocode: 

You can also store it in relational database, althought it looks like it is not necessary, if You want to make this game in big You might need to make one. You then have to parse these strings/things. Or You can use some scripting language like Python or LUA or language like LISP, they all can parse and execute it for You. :) How to use these events in game loop (2) You will need these two data structures: 

You can optimize Brute force search: For each point in plane compute how big disk (for example, can be arbitrary bounds) can be placed without colision. 

Buttons (controlls) and graphics handle on browser. With javascript, there is lot of drawing libraries, well, even game libraries (craftyjs, gameQuery ...). State a current game has will be on server in a database. 

I thought You need to know how to make these events and the rest of post is about it, If You want just to store these events then use some relational database or decribe them by text and use scripting language (he will do parsing and evaluating for You). :) What You want is to recognize events happened (1) and then do some actions which are demanded by these events (print message, check for keypress...) (2). You also want to make these events happen only once (3). Basically You want to check for conditions and then schedule some behaviour. How to recognize events (1) 

By the way Collada is just XML, I would just remind you that, the default .blend format file is probably not so standard, but there are prepacked alternatives. 

I'm starting with the programmable pipeline and the shaders in C++ for OpenGL 3.0+, i would love to be able to change some settings on the fly, for example replacing a function with another function, supposing that i have a shader with an operation like 

There is this Windows Advanced Rasterization Platform on the most recent Windows platforms which i think it's what you are looking for or there are commercial solutions like Pixomatic. 

There are frameworks like FreeGLUT that give a basic input/output abilities with keyboard and mouse, but if you want more there are the Visual C++ APIs for Windows. 

There are different technologies for this, there is no standard, at least no one that i'm aware of. The multi-monitor technology from ATI is named eyefinity and it's probably the most mature technology among the ones available on the market. The eyefinity capabilities are accessible through the AMD display library SDK . Nvidia calls its multi-monitor technology nVidia Surround and there are little to none informations for the developers, there is this page that mix the surround technology with the 3D technology and i don't think that is useful at all. If you are interested in this you can try to browser and ask in the Developer Zone. 

I will use this as a generic reference, but the more i browser online docs and books, the less i understand about this. 

Communication between player and server is trough AJAX. Player side is coded in javascript, server side in PHP (or similar) + SQL. One problem is that You have to periodically ask/query (chat made by periodical query in AJAX) server whether something new happened (server can not contact You trough AJAX); there might be a way to let server contact You trough something else than polling with AJAX, but I do not know what it is. 

You start these objects when they are demanded to start in action queue. these object can be used for other things such as some other timers. In Quake these entities are used for whole game logic, I recommend You to read some material about it. 

Data is key to programming. If You desing Your data good, algorithm usually emerge from them (if You don't count some numerical algorithms, like computing determinant). 

How will change is up to Your imagination. Velocity should get smaller heigher donkey is in the air to make it look good. 

You can smooth or create some fractal details on it (usually when dimensions of array are small). Don't do collisions by hand, You might run into problems with speed, penetrations ... Use Box2D convex polygons for sidescrollers (Scorched Earth). For topdown RPG like games ODE, Havok, Newton, Bullet ... seem to have support for heightmaps, sometimes even natively. 

These steps You mention are most likely done in separate engines. It is just that simple game engines usually have them in one pass. Your sequence 

Having an application that uses shaders that have been wrote in GLSL, what is the best strategy for the distribution in the real world and for the desktop and mobile? I'm aiming to distribute this in a binary form or as plain serialized text, i would like a good suggestion on this. 

Yes, also this is a common scenario for both desktop and mobile users, with OpenGL the fixed pipeline approach is just deprecated and when using old code on modern devices you are just guessing, because any GPU maker that wants to stick with a modern OpenGL approach is not forced to support old functions and the old approach for the pipeline. These days you get OpenGL ES 2 capable devices from the low end market up to the high end, and the OpenGL ES 3 will come soon, adopting OpenGL ES 1.x is just an old and deprecated approach for the market of today. OpenGL ES 2 introduces the programmable pipeline on mobile devices discarding the old fixed-pipeline approach; probably for this reason you find it more difficult to use, but just a change of mindset and some hours passed on coding will make you change your idea about this. 

Safe? No, in theory and in practice not even the ones that you pay are safe, the fact that this images are free or not tells you nothing about their copyright and most important of all, who is the copyright holder. The real solution is more like a good suggestion: always mix and work with this textures in way that you will never use just 1 big texture alone. If you really need a complete big texture of something you better go out with your camera and take some pictures of the natures avoiding famouse places/buildings and private spaces.