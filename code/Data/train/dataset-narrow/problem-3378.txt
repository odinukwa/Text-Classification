I have a Raspberry Pi that hosts a website and it going to host an email server. I am looking for tool that is a web interface, just like a cPanel. The reason why I need this is because I constantly work on the server and I have set up extra security precautions, and it takes a long time logging in and modifying things, so I am thinking that a web interface server manager would be perfect. To sum up, my questions are... 

I am building a Smart Mirror for a school project and I need a way to give the user an interface where they can search and connect to a network. Unfortunately, my Raspberry Pi stopped working (doesn’t boot for some reason) to overcome this, I am going to code and test on my Windows laptop, then run the code on another Raspberry Pi that I will be borrowing from elsewhere. I am quite new to Python, and I want to know if there is a way to use a universal module where I can test this on Windows while knowing that it will work on a Raspberry Pi. Any help and suggestions are much appreciated, Sid. 

I am making a pascal app on my pc for use on my Raspberry Pi, I thought that coding the app on my Raspberry Pi would be inefficient. I have completed the app and now I need to test the app on my Raspberry Pi. How can I compile the project into a .elf file? I use Lazarus 1.6.4 Thanks, Sid. 

Here is what you could do: Download the Google voice library onto your computer. Then copy it to a form of removable storage, such as a desktop hard drive or memory stick. Then plug the removable storage into one of the Pi's USB ports, making sure your Raspberry Pi is sufficiently powered. You can then simply copy the information across to the Pi. Alternatively once you have downloaded your files you could use a program like FileZilla to transfer the files across to the Pi over your network. (Ideally you want your computer and Pi on the same network for this, it makes the process much easier). Dropbox or another file sharing site is an option, just be aware that you have to first upload the files from your computer to the internet. Then download the files using the Pi, depending on your internet connection speed this might be impractical. It is also going to take the longest to transfer the files out of all the options listed here. 

I too am intrigued by the notion of outputting sound out via both HDMI and analogue at the same time. After doing a bit of digging it does seem like people have experimented with it. Firstly, its not possible in OS's like XBMC because is not implemented. is the Advanced Linux Sound Architecture. Its software that allows audio software to interface with the Kernel. Which is required for sound through both HDMI and analogue at the same time. This answer gives a nice explanation of it. Here's the reason for the delay. Without getting into the detail too much here's how it works. HDMI supports both sound and video, so the sound gets outputted along with the video through HDMI. However the sound through the analogue jack is created using PWM. So the sound over HDMI and over the analogue jack take a different route through the hardware on the Pi. This is what generates the latency. This answer here explains it well, if you are after more detail. How can you reduce the latency. From what limited posts I've seen only I don't think there is a fix for it. The issue is the two audio signals take different paths, and I don't believe there is a way of combining them on the hardware level. So, you would have to use some software magic to slightly delay the transmission time of one or the other. I don't think this is really an option. The thing is I don't believe the Foundation considered the possibility of people wanting to use two audio outputs simultaneously for the same audio source. However, if you want to distinct pieces of audio to play then the latency between the two isn't really an issue so much. 

The Raspberry Pi uses 3V3 signals on its GPIO pins; a voltage level which is high enough to trigger the High State in the relay as per the specs. An Arduino (for which the same board is used) uses 5V signals on its GPIO pins and works equally fine with this board. The other circuitry on the board needs to be powered by a 5V source, for which you have correctly wired the board to the 5V power supply pin on the GPIO header. The specs you quote are not completely correct, however. The GPIO header consists of power supply pins (1x 3V3 and 2x5V), several Ground pins, as well as GPIO pins. The GPIO pins (like GPIO17 you mention) are severely limited in the current they can supply (unlike the 5V pins which can supply at least 0.5A if not more depending on the rPi model). Each pin can output a maximum of 16mA (not 50mA as you mention), with a total maximum combined current across all pins of 50mA. This is enough to drive a few LEDs, but not much more. The pins are typically used for sending signals to other devices, and your relay is a perfect example. As I mentioned, your circuit will work fine as you drew it (provided you supply a different power source to the relay terminals, the Sainsmart page says this about the Relay voltage and current it supports: 

Open the configuration file with . Go to the bottom of the file and add this line, . Exit the file with saving. Next run and edit the , to give this result: 

If one wants to purchase a Raspberry Pi, there are a number of different manufacturers from whom to buy. These include element14 and RS Electronics. Are there any significant differences between Pi's made by these manufacturers? 

The easiest thing is to image the OS onto a SD card. Then using MiniTool Partition Wizard you can very easily change the size of partitions on the SD card. There is also an option in raspi-config that will set the OS to use the whole of the SD card, if that's what your after 

I have tried setting the file system type to both ntfs and vfat, both give the error above. So what do I do to get the drive mounted? And how can I get it to automatically mount whenever the Raspberry Pi boots? 

This will give you a program that should measure the current draw of your CPU. However looking at the results, the most the Pi 2's CPU consumes is 420mA with all 4 cores under load. Once you account for USB devices, and other circuitry on the Pi, you can see where the 1.2A recommendation comes from. 

The Pi will then start recording sound from the microphone. When you have finished recording leave a gap of 6 seconds then press CTRL+X on your keyboard to close the terminal window. The file will save automatically. The part of the command determines the save location of the file and the part is the name of the file To playback the file run: 

Please do not try to drive a servo (or multiple servos) directly from a GPIO pin. You will need to put a transistor in between, and provide a separate power source for the servo, as the RPi might not be able to deliver enough power to drive the Servo (depending on the voltage used to drive it, at 3.3V the RPi only has 16mA available, at 5V this is a little less limited). You can also look at prepackaged servo driver boards - the one I linked can control tens of servos with the same board. And to answer your question: Yes, you can just connect 2 servos to the same signal, and they will do exactly the same movement. 

Have you thought about giving your contestants 4 different tags, one for each answer? That way you can bring your setup down to 1 reader, no reading conflicts, and you replicate just the cheapest component in your setup (the RFID tag) You might want to look into different RFID readers - This one from Adafruit does UART, SPI and I2C. Since all of those mechanisms are available on the Pi (and it supports 2 devices via SPI) you could put one via UART, one via I2C and 2 via SPI. The card seems to have 2 select pin headers on it as well, I'm not sure if this would allow you to set different I2C addresses, but if it does and depending on how many different addresses it supports, you might be able to plug all of those on the same I2C bus and use them this way. 

I am building a smart mirror with a raspberry pi b+, a 5 inch display and a mini WiFi dongle. I was thinking about using the MagicMirror software but this means that the user has to exit the software to connect to the internet. I was thinking about making my own software, initially I was thinking about developing an app that runs from startup written in pascal as I’m quite familiar with the language, although I’m not sure this will end easy as I don’t think that the compiled EXE file will run natively on a raspberry pi like python and I’m not sure if the I can interface networking stuff, like allowing the user to change the WiFi ssid and password to make the pi connect. So right now I’m left with few doubts... 

I have a web server on my Raspberry Pi and I use ssh. Before I port forward I want to make sure it is very secure and hackers won't be able to do anything. I have set up an ssh key from PuTTY on my computer so only my computer can access ssh without password. I want to modify it so that anybody who tries to ssh into my server without having the authorised key will be refused. Also, people with the authorised key can login but the have to enter the ssh password. I am also going to install fail2ban later on. Is this possible? Suggestions and help are warmly welcomed... Sid. 

According to this forum post over at Raspberrypi.org, you need to modify lightdm.conf (/etc/lightdm/lightdm.conf). There is an "autologin-user" parameter in that conf file that you can modify, and, paraphrasing the last poster, several other setting you need to change: 

Nothing is possible without software. I guess what you mean however is "without installing a full media center". You can just install Shairplay or the now no longer maintained ShairPort on your rPi to do the AirPlay emulation. 

The GPIO can output only 16mA (50mA total across all the GPIO pins) which is likely not enough to make your motor turn. Furthermore, the resistor will also limit the current through the motor, so the motor is not even getting the 16mA it could possibly get. You will need to use a transistor and a separate power source to make this setup work. The separate power source could be your 1.5V battery, or the 5V from the GPIO header converted down to 1.5V using a buck converter. 

I am a bit rusty on my C++ (it's been 15+ years) but I think the issue is that you didn't declare the variable as a private (or protected) member of the class. Instead it only gets a declaration (and I'm not sure that's done in the right way, my (Java-influenced) brain says you should likely do to make the correct declaration) in the DATA constructor, which means its visibility is limited to the constructor, hence the member function cannot access it. Net, what you want to do is change the class declaration to: 

My question is, is changing the value for camera.apeture actually changing the aperture of the camera? And what are the possible maximum and minimum values for the aperture? 

As @Havnar suggested if the PS3 controller is still connected to the Pi when it idles, as soon as you start pressing buttons on the PS3 controller the Pi will wake up. I can confirm this is possible as I can wake up a Pi with XBMC installed on it using an app on my phone connected to the Pi using Wi-Fi. 

To enable the server to handle files greater than 2MB a couple of tweaks need to be made. Go to and open the file . Change the value of and to something like . Which changes the maximum file size to 2GB. As an extra you can install APC PHP accelerator which might make ownCloud more responsive for larger installations. To do this run: 

I'm assuming you are using Raspbian? First things first, make sure you are powering the Pi with a decent 2A 5V power supply. Ensure the Pi has fully recognized the display by running: 

Now open a web browser on your computer and enter . You will then be prompted to create an account. Click storage & database pull down menu and add in the text box corresponding to . Then select the option in the section. You will then be asked enter the connection details of the database server, so just enter "localhost" as the host and "root" as the username, along with the password you configured when the database was pulled in along with ownCloud. Everything is now setup. To access the files on the database from your phone you can install the ownCloud app or the free ocloud app and you are good to go. 

Passive = no external power source required, i.e. all powered from the power supply of the device that contains the source signal. Passive = no transformation of the signal, i.e. the signal is just rearranged from one input pin to another output pin. 

Most common: Your power supply is underpowered. The power needs of the Pi fluctuate, and it needs more power if there are USB peripherals attached. How much depends on the peripherals themselves. During peak usage, the Pi might need more power than during startup, which can lead to brown-outs (freezes). For a model A/B/A+/B+, a 1.5A 5V supply should be enough, for a model 2 you need at least 2A 5V. Some boards, especially early boards, have a capacitor that tends to tomb-stone (where the solder joint on one side is weak and detaches after some use). The capacitor in question is C51 at the underside of the board, near the crystal marked X1. When it tombstones, you will find that USB input devices no longer work, and that the board freezes after 20-60 seconds. The resolution here is to either resolder the (super-tiny!) cap onto its pads, or put a new cap across the two legs of the crystal just above it. This technique has revived one of my model B boards in the past. 

Your problem is clearly because apt-get is trying to get amd64 packages which don't exist for the RPi (the RPi has an arm7hf architecture). You said you looked at other forums, but did you actually execute some of the troubleshooting steps from those forums? The one you've linked to deals with amd64, so if you did any of those steps you might have created an issue somewhere. Also, I just noticed that the contents of your have issues, the correct content should be: 

If you installed the OS using NOOBs check if these lines of code are present at the bottom of the config.txt file: 

I know the Raspberry Pi 2 has been released very recently, but are we likely to see a new model with more features within the next year? And is it likely the Raspberry Pi Foundation will ever produce a really powerful Pi with killer Ethernet, USB 3.0 ports, more RAM and a faster CPU? 

You are certainly not the first person to have asked about using a cooling fan with the Pi. I can understand why people think they need to actively cool their Pi. From a desktop PC user's perspective the idea of running a CPU without any cooling seems bonkers. I have extensively used various models of Pi over the past couple of years and not once I have been concerned about the Pi overheating. Firstly, the SoC which is the main chip on the board, where things like the CPU are located has a thermal limit of 85°C. This means if the Pi approaches this temperature it reduces the performance and the temperature decreases. Having used a Pi 3 in applications such as a media center, not even watching a film at 1080p could get the CPU temperature anywhere near that. Also a cooling fan is rather redundant anyway unless you plan to use heat sinks. Heat sinks allow the thermal energy to be stored up over a large surface area. This makes dissipating the heat energy far more effective than just blowing some air on the SoC. I've had a look at the case you are referring to and I'm struggling to imagine fitting even a tiny cooling fan in it. Yes you could solder it to the GPIO pads on the underside of the Pi, do I recommend it, well... It's one of those were if you have to ask it might not be a good idea. You do risk bricking your Pi in the process and I imagine you are going to void any warranties in the process. I'm also not sure if the GPIO is going to be to handle both the requirements of the case and the fan simultaneously. I suggest if you are concerned about temperatures to keep an eye on them, if they are not going anywhere near 85°C then the cooling fan is really superfluous.