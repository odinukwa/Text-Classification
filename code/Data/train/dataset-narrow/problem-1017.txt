LogSource, LogTarget These are not neccessary but they show the inherent abstraction the thread makes use of. So A LogService is of course a LogSource but it can also be a LogTarget. 

Code I looked after a solution with less if statements and more expressive artifacts. I came up with this: Introduce a class "Situation" This represents a game situation with the choice of each player: 

Encapsulate connection information Introduce a new structure that represents the information necessary to establish a connection and use it to be independent of "retreiving the data from a properties object" that provides no semantic. Variable scope You can reduce the scope of the connection information variables to "method". Once you are connected they will be present within the connection. And you never reinitialize the "conn"-variable. Extract constants You have a lot of Strings that should be extracted as constants String templates Not neccessarily objective but using template strings will have influence how you express String composition. Naming As you are currently supporting a MySQL Database I suggest to rename "Database" to "MySQLDatabase". Separate concerns of process and output If you introduce a callback or an observer mechanism you separate the console output from the real doing. You are no longer tied to a console output. You can easily change console output to log file output. Refactored code 

You should have a look at BigInteger to avoid overflows and you think about numbers exceeding the Long-Type. This will not be easy. You should not compare Integer-Values with Long-Values as you are using them within the same semantic. Harmonize the algorithm to use only one type for one purpose (in this case Long) 

Do not use Optional as a general substitute for null. In your case it is absolutly ok to not use Optional. You will have less noise in your code. Optional is a way to express, that your code should not depend on a value. As you create the value right after you determined it is not present your algorithm seems to have not an "Option" to bypass the non-existence. Your algorithm is a lazy initialization mechanism where a null check is appropriate. Everything else is noise and should be omitted. There are rare occasions to use Optional. Your result value is not optional. The using code depends on the existence of a non null value. Using Optional is misleading. My bigger concern is that hibernate initialization mechanism. As I do not know your other code I don't know if it is neccessary. But this statement is a surprise. It does some magic to your structure to return AND it is directly dependent of a concrete technology instead of an abstraction like JPA. I highly recommend to avoid such mechanisms and adress this kind of micro management architectural. But as I do not have any further code I cannot make detailed suggestions on that. 

Having the the whole construction at one place If you use the lazy getter only you do not have to care about the creation time. You are more flexible when rearranging the components 

Nevertheless: In this use case (an Mp3 Player) I would not cache any state object. They can be instantiated on demand. If you have a user of your Mp3Player who is clicking the Buttons million times a second we can talk about another solution. But overall a good first implementation. 

With this in mind it will lead to following code at the caller: ... System.out.println(askForFirstNumber.getContextMessage()); Double d = askForFirstNumber.ask(); ... The goal should be to have all console output statements in one compilation unit to be sure that you are not violating the single responsibility principle. HistoryHolder You provide a presentation method. You should separate presentation from datastructure. Suggestions 

You have a stateful model that has three states: Pausing, Running, Stopped. I would represent this with a State-pattern. For me there is too much micro-handling (isPauseRequested, !Thread.currentThread().isInterrupted()) as the concept of the model is the handling of these states. As a matter of symmetry I avoid using volatile variables. I currently heard about the concept of "single source of truth" (SSOT) as you have TWO sources that have dependencies: the lock object and the volatile variable. Even for the sake of efficiency I would use the lock object to express the "monitor" for all elements that should be handled in the monitor. (Optional as you want to follow my path) Even if some literature says something else (I know about that) I prefer synchronized methods. That has for me following reasons: First I want the developer using my objects to know about synchronization BESIDE potential documentation. Second I do not explicitly want to allow other developers using MY objects in THEIR synchronization purposes as I see this as semantically wrong. THEIR implementation should fail (mostly dead locks) because MY implementation is responsible for MY objects and using developers should not take over this responsibility. As your model is composing the elements to provide the expected functionality I would locate any synchronization mechanisms there as well. Your ResumableModel becomes the monitor. You the either make all model-method synchronized or move the lock-object to the ResumableModel. This depends on if you follow my path or not. 

The point is that there is no rule to catch and handle an exception where it occurs or as early as possible. The rule is: it has to be the semantic correct location under the assumptions of the involved methods. 

StateStopped As the state pattern has a context object (here LogService) this context object will be used as the monitor (synchronized(LogService.this)). My implementation accepts log messages put it will not notify any consumer. Calling stop() will be a NOOP. If your flavour is to throw an exception do that. Calling start() will instantiate a new thread and start it. After that the internal state is changed to be "StateRunning". 

You should have a look at your design. These new constructs may have their applications. But most of the time I see them in usage they hide design flaws. Semantical problems where obfuscated by language mechanisms. 

Serializable Omit Serializable if you do not need it or separate this concern into DTOs equals / hashcode Do NOT override hascode and equals if you provide setters. Objects may not be accessable anymore if they were added to a hashcode using structure like the HashSet after you change a value If you usecase specifies to change values in your contact. You can easily see this in this simple example: 

Hints I would have named the generic types properly. Maybe I would have divided Logging from processing with help of a listener pattern. I would have expected the input parameter to never be null, so returning null is obsolete. I would have extracted some methods to have parts of code be named. Code On a very high level view I would have expected exactly what you described what the code should do. Splitting an input in parts, processing these parts in parallel, collect the results and aggregate them. This should have been expressed in the "process"-method. 

With this information you will be able to built your where-clause dynamically through string concatenation. This will be some effort and error prone. Furthermore you are currently restricted to one conjunction. You have to decide between "and" or "or". And make sure to omit the where-clause in the whole if the queryParams are empty. The parameter will be passed to the method "QueryDatabase" as well. There you can built your "NpgsqlCommand" dynamically. This is only a suggestion to develop the code in the "right" direction. As you already asked to avoid redundancy on this way you also gain flexibility. The flexibility now ends at the level where you want to built queries with "and" and "or". If you want to do that you must have somethig like the Criteria-API in JPA (Java). But as I said I won't cover that in this answer. One other thing you should think about: db.OpenConnection(); and db.CloseConnection(); are perfect candidates be extracted to a template. (see $URL$ 

To Option B Yes you can do so. But the achieve the same with the correct hashcode equals implementation on immutable datastructures with less overhead. Logical path 

As I said, I used the state pattern to represent each state of the game. It's verbose and it's not perfect. But maybe you get an idea of the intention of this design decision. 

I like separated classes instead of inner classes they are more handy in testing I would have separated the algorithm in "generateNextPermutation()" in an additional class. I would follow the recursive nature of the problem and build a recursive structure. This is a slightly different approach. I do not exactly know how the algorithm should behave if you provide an empty list. I assume that you will have one permutation as result. So I adapted your algorithm to work with an empty array of indices. 

First of all: You got it nearly right. One thing in your implementation deviates from the standard implementation: 

If you override equals you have to override hashcode hashcode is used within hash-based datastructures to put objects into buckets If you change the value hashcode depends on AND you have put the object into a hash-based datastructure before, it is very probable that you never find this object again. Therefore values that are used to generate the hashcode must not change if you want to use the objects within hash-based datastructures. 

Writer I do not know if it is intended to close the PrinterWriter after the queue is empty. This will cause a problem when restarting the LogThread. Closed PrintWriters may not work anymore which depends on the underlying Writer that interpretes the "close()"-operation: 

The trick is to extend the capabilities of StringBuffer by "composition" to shorten the way to your goal. By the way StringBuffer is final so you cannot derive from it. StringBuffer has no method to ask "hasMoreChars". So you encapsulate "sequence.length() > 0". StringBuffer has no method to take the first X chars so you formulate "takeNextChars(amount)" with the given capabilities. The pattern used here is an unfinished "decorator pattern". As StringBuffer is final there is a little bit more work to do to finish it but I think this solution is proper to the task and can be extended without blocking. One side note: In my opinion the primary task of a developer is not to think about what you can do... the primary task is about to omit things without obstruct possibilities but meet the requirements (related to the Open-Closed-Principle). 

Documentation You should not overestimate documentation. If your variables, functions and classes are named properly and you try not to distorte reality in your model you help to avoid looking into the documention. Documentation for me is not neccessarily a problem but for me it is an indicator of poor code quality. The truth lies in the executable parts of your source code nowhere else. And those should be as understandable as possible. If you really want to produce beneficial documentation for a developer you should provide expressive tests that shows how to use your API and tell him/her about the restrictions. General notes and Parameter validation Maybe for the usecase you have to implement the provided solution may be sufficient. If you introduce new elements like brackets or whitespaces you will have to violate the Open-Closed-Principle as you do not go the general way of parsing. Your approach does not consider language extensions to be easy. You can see where your parsing is neglected as you introduce unnecessary delimitters (,) to separate each element properly. If you want to be flexible for language extension and avoid such artifice you should consider the Interpreter-pattern and the State-Pattern. Additional you should have a look at automaton theory. If you follow this path you do not need a parameter validation as you would be able to identify the exact position of the language violation during parsing. 

Solution 3 (OO) This is an solution that shows how the responsibilities are cut in the OO. I guess this is the most verbose one for the given problem. 

You have a lot of structure without any benefit as already recognized in some comments. Because you have to decide what to create with your "Type" enum it is as worth as instantiating the concrete documents directly. You really will have a benefitial factory if it is able to decide to create the correct concrete "Document" from the input string. 

My suggestion is to abstract from the sources where the elements come from. So the first responsibility will be a class that can asynchronously receive elements and output them in a sequence. Following algorithms now only need to depend on objects of this class: 

Monitor I encourage you to think about critical code fragments and restrict concurrent access to it. The critical code fragments are the following statements: 

Monitor I would start with formulating the Monitor. The Monitor is synchronizing the things of interest: 

In your comment you mentioned that "liter" may be negative. This is an allowed value but your method signature says "fillUp". So one of them is lying. You now have two possibilities: 

I suggest to extract this code into a method "getOmittedByteCount" as you already mentioned it in the method "extractEncodedText" (omittedBytes).