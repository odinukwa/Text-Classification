If the output rate (the frequency) of your software PWM is at the B+ really limited by the computational load then yes, it might be possible that a faster Pi2 would be "better". But there are many ifs and buts here. Before jumping to a new Pi2 it might be worth to profile the current code and find out why it is as slow as it is. Maybe this could be improved by honing and tweaking the algorithm. Optimization of software fell a little behind these days when upgrading hardware is cheap. 

and this LED calculator or Ohm's law we find a value of 22 Ohms. This however might not be the best idea, read below. Reducing the resistor (as stated in the question of 220 Ohm Caveats: Using the GPIO pin with a resistor this low, either by mixing something up on the breadboard or if the LED dies in a short-circuit failure mode1, carries the risk of damage the Pi's GPIO pin. So, decreasing the resistor in the current setup might make the LED light up but possibly introduces new trouble, such as overcurrenting the LED (thanks @yo' for the comment) or the Pi, i.e. if the LED shows differing behaviour, not to mention that electrical characteristics are typically temperature dependant. 

From your comments I take it that your PC is connected to the "Internet" by an ethernet cable running to your router. So if you already have a router that provides more than one LAN (Local Area Network) ethernet port - which most routers do - than you can simply connect your Pi with another ethernet cable and you're done. If the router does not provide more than one LAN port a simple switch can solve your problem. Other than that WiFi is also an option. 

For the B-type it should be possible to disable the USB-Hub (see $URL$ ) which should lead to some power savings. It's not refering to the B+ but if I am not mistaken that part of the architecture did not change. Note that the Ethernet NIC is connected to that USB hub so you'll lose network connection when disabling the hub, so you will be unable to connect to the Pi via network or USB. The only way to access the Pi is by the serial console. Script from source: 

Given that this power supply is a constant voltage source, with (5 +/- 0.25) V (the spec lists 5% voltage tolerance) it is within the specifications of the Pi. It should work. I am not sure about the high ripple of 100 mV but I would not expect too much trouble since the Pi regulates all its internal needed voltages. There's also nothing of a minimum load in the spec sheet. It lists the full range of 0 to 2.6 A so it should not be a problem to run it at lighter loads. So I will go with: Yes, that will most likely work with the Pi. 

As two previous answers already give some references for the power consumption of different models of the Pi and various load cases, I would like to add a note on the amount of energy a portable "power-bank" will have to provide over an 8 hour period. Assuming the bank can provide its power at a constant 5V level. It's really as simple as this: 

There seems to be plugins able to link the Pi's GPIO pins to kodi. That way it should be able to wire some buttons to the Pi and have some script do the language switching, e.g. see here: $URL$ Other than that the main user interface will control the Pi via HDMI-CEC and the TV's remote control. 

They are to be found on the bottom side of the PCB near the Micro USB (power in) connector (that is on the top side of course). 

While you could always set up further FAT partitions for data and nicely access those at the Pi - Windows itself is the limiting factor here. If I remember correctly and without further tools installed on the Windows machine you will only access the first FAT partition. Strange (read stupid) as it seems that Windows does not support multiple partitions on storage devices. Of course you can use the boot partition but be aware that the size is limited and the user has all the means to smash the system by deleting important files. 

As already stated in the question: since the Raspberry Pi does not have a real time clock RTC with a buffered power supply, its clock is reset to 0 after each reboot. Time is only an integer number with its reference being the time of 00:00:00 UTC on 1 January 1970 (Unix epoch). There is no way of knowing the accurate time without feeding that information from an external source, e.g. sync'ing with a NTP time server. If the time of start up is of utter importance it has to be calculated from full system log, e.g. for the log of the current boot. We know that start-up took place at , now follow the log (not necessarily manually) to the point where systemd claims . Parse the new time, parse the last old time to get the number of seconds it has been running (e.g. 15 seconds), substract, done. As always there is a little pitfall. Unfortunately it is possible that network time synchronization might try to do its work before networks are up. It then notices a jump backwards and resets the clock to the last recorded timestamp - a time more or less near the last shutdown of the Pi. But the idea to solve the problem is the same, parse the full log for , and calculate the desired time. 

This returns a list of valid attributes. It will be directly output if issued at an interactive shell or can be printed when executing a script. And some more resources to check: 

SDL/SDR are the shutdown pins, they have pull-up resistors on the board. As long as you do nothing (not pulling them down to GND) the device is enabled. 

is the shell command for Unix and Unix-like operating systems like Raspbian to list the currently set environment variables. Raspbian is in that respect nothing special but just the friendly neighbourhood Linux. 

which is probably not what you're trying to intend here. It reads more from the serial port and hiding it from the user. It should probably look more like this (though I have to admit that I am not sure where you're going with this and after all): 

The port is USB OTG. All discussions on RPi.org's blog and the fact that most vendors provide according adapter kits point that way. 

This answer provides some insight in the electrical characteristics. The input current however is something nobody usually cares about as in digital circuits we usually assume low impedance outputs and high impedance inputs. That's fairly save to assume unless one considers "strange" logic families like ECL (a current-steering logic). That however is not relevant to the Pi. GPIO Electrical Specifications (from Milliways' answer linked above) tries to give some estimates based on similar ARM based chips. Especially the Freescale MCIMX31 multimedia application processor (Table 15) lists a maximum input current for a high impedance input gate without pull-up/pull-down resistors of 1 microamp. While this is just an estimate of a "similar" chip and the real Pi's SoC might be orders of magnitude different, it at least shows that there might be an issue down that road when connecting that particular source to a GPIO pin. Proper buffering with an additional external high impedance opamp, i.e. see here, seems to be the save way to go. 

As long as the power rating of your power supply (that being the current it can provide) is high enough to power both the RPi as well as all the devices attached to the active hub (including the power needed by the hub) it is perfectly safe to operate all from one power supply. If on the other hand the necessary current is not provided by supply you may encounter problem. While breaking the hardware of the RPi that way is unlikely still a decreasing voltage of the power supply could cause a brown out of the RPi resulting in erratic behaviour and faulty I/O access, e.g. faulty write access to the SD card leading to bad blocks. 

From the picture shown on Hifiberry's site we learn that it uses the PCM5122 Audio Stereo DAC with PCM Interface and Fixed Audio Processing. We also find a RC low pass connected between "something" (traces coming from under the PCM5122 itself) and the audio out RCA connectors. R6, C8 and R3, C7 form these low passes. So the external circuitry does not block DC signals. This circuit might very well be the recommended output filter shown in the datasheet, p. 42 and where we find that: 

I think of something like a snap-in-adapter (for the lack of a better word) like a docking unit for cell phones or charging units of cordless phones. Just sit the remote control in there to allow some contact fingers make the contact to the RPi, remove it for full manual control. If you insist on the non-destructive way I would favour the solenoid/electromagnet approach as it offers at least the most simple driving circuit both in terms of software and electronical hardware albeit the mechanical fixation will be a little tricky. The driving ciruit shouldn't be much more than a simple power transistor switch per solenoid. But be aware that the inrush current of the solenoids can be pretty hefty. The power supply needs to be properly decoupled from the Pi's supply and needs to be able to provide this current. The selection of the solenoid of course needs to take proper care of the force it can exert to overcome the pressure point without damaging the control. I'd try to fix a rubber tip to the steel actuator (push rod) anyways (if only it serves the looks of the artifical hand). Good thing with solenoids is that the force could be reduced by a decreased driving voltage.