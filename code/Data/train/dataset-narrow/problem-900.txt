Since returns only non-empty lists, we can safely apply . Remarks on style I strongly suggest you to move large lambdas into their own bindings. That made the first variant of more readable and is the usual style, for example in GHC's code. Also, if you use both the results of and use , or—if you use positive numbers only or don't want the specific behaviour behind —. Don't be afraid to give something in your code a name. That makes it easier to grasp and to change later. Also, you might notice that a function is reusable. And, by the way, primes are a "hard" topic, as in: it's not easy to get proper bounds of the numbers you have to check, since you would need to know whether is already a prime, or whether is a prime, or and so on. Exercises 

You can use the same method in . Errors Your code has several errors. Some of them will prevent your code from compiling, some of them will lead to undefined behaviour. Errors during compilation Let's start with the compiler errors. Here's the part you should remember: whenenver you use a template, the compiler will only instantiate the methods if you actually use them. For example your function does not compile, since its signature uses , although it returns a : 

The important part about however is, that there is no function(*). That's what keeps pure and impure code apart. Either way, as I already said, your code is fine (except for missing type signatures). Note that you've only used "guards", though, not pattern guards, since you do not actually use a pattern in your code, just boolean expressions. (*): well, there is one, but you should only ever use it if you know completely what you're doing 

Either way, as an exercise, I suggest you to write and without . Note that Mergesort is a lot simpler to implement in Haskell. 

Now we only check whether is smaller than if it wasn't aleady greater than . An error in disguise Now we come to the part where your code is actually wrong. Sorry. Let's say your user inputs the following numbers: 

where is an appropriate function (left as an exercise). Actually, that's it. That's all that is necessary for , apart from . Well, I'm lying: the key will run out at some point. That's why you use : 

This is hard to check with your current variant. By the way your variant was completely opaque whether the left or the right list would provide the pivot element. Our new makes sure that we cannot do it wrong, and that in always exists. How does look with those changes? 

Allright, that seems to work. However, do we actually need the check? No. does that for us. So let's get rid of that: 

That brings us to naming. Lists are usually called (for es). That's just a minor nitpick, although it would make place for as the first element of the accumulator. Either way, the constraint should not be necessary. might even lead to a wrong if all other values are lesser, e.g. 

However, this does only work if the key is longer than the text. How do we write , which may take a smaller key? We use : 

That's error prone. You might change , get a phone call or get called into a meeting, and then you forgot to change the other. Instead, use or a compile-time constant instead: 

But when all your numbers are positive, you want to use since it's usually faster. Note that many modern processors do and at the same time, so using the appropriate function when you ened both results can be a boon. Back to our prime factors. Now we have the factors. But how can we get the multiplicity? We use : 

If the input pipe is broken, the JSON input will suddenly end and you have invalid JSON. Do you need to handle invalid JSON at that point? It's a non-goal, as you said. 

Note that you shouldn't copy the vector all the time (see below). Don't use for fixed size collections You're using in order to get three points into your function. That's error prone. One could use two points and end up with an exception, or four point and don't notice that they actually wanted a rectangle. Instead, use a fixed size collection. This could be , or something like 

but that's an aside. However, now is total: for any input it will produce an output. Use to find possible eta-reductions While not necessary, this could be a good time to learn about . It will report common improvements on your code. In this case, you can write as 

Other than that, well done. Keep in mind that there's a in that might be more suitable for your use case. 

And now back to As I said, it's completely fine, however the additional type signature isn't necessary, as the compiler can infer 's type in that context. We end up with: 

After all, does not return prematurely, which can be misleading to Haskell newcomers. Next, try not to shadow names like and . Let's call the arguments and instead. Furthermore, you call the value at an index . That's misleading. And is usually used as predicate, so let's call it instead. And is just the new we found with our . We end up with. 

As you can see, we got rid of the recursive calls in and the base case, since that's now handled by . We also swapped the arguments, since gives the state first. Also, since primes are odd (except for ), we've optimized the list slightly. Unfortunately, we still need to get rid of those with multiplicity. However, what if we didn't return a pair? Return factors, one by one This time, we inline the functionality of : 

can be expressed with and vice-versa. If you use both and , use to get both at the same time. You can pattern match on two elements in a list with . That way you only need a single . is . can be written with , but that might be a little bit too advanced. 

Note that I've used the properties of again, just as in Caesar. Everything is the same. Except for the modification. In , we subtract the key, and in we add it. So let us move that into another function: