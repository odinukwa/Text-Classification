programs do not really work well with start/stop/restart logic, you may have more success trying to start your program from , just don't forget to make it an executable file. 

the FAQ part where this was posted is named "Graphics" two hottest chips on the board are BCM2835 and LAN9512 (source). there are quite a lot of places on the web, where the BCM2835 is mentioned nearby 85Â°C. 

"with" will automatically close the file, so you don't have to worry about all this "you must restart after rotating the log" nonsense. also, you don't really need to store temperature and humidity every 10 seconds, unless in a very harsh environment. it might be a good idea to write three separate log files and store the values only when changed -- this might considerably reduce your file size and wear of your SD card. 

Raspberry Pi is still fed through a polyfuse, that may protect it in case of shorts or unexpected surges. there are no large currents flowing across GPIO pins, just the control signals. whatever happens to LED strip won't hurt your Pi and vice versa. if you decide to go for a longer strip or totally different appliance, you don't have to rewire RasPI power supply. 

will copy the whole SD card. I'm not sure about the naming system on the computer you use, but most likely you'll be able to find the proper partition name using command : 

your error message clearly says: "* "System not configured - see README", that means you haven't configured your build system, it has no idea what board you need built for, and details about configuration could be found in file -- read it and get enlightened. most likely the following command will do the trick: 

First up, you should profile your code, probably using cProfile: $URL$ Optimization without knowing where the time is spent is often pointless. If the problem is mainly time to write to disk, you might try capturing to a stream/buffer, and then writing the buffer to disk with a side-process, perhaps using threading or an entire separate process which you pass the data to. This article describes how to capture to a stream: $URL$ This article describes how to use threading easily with the 'threading' library: $URL$ Should be pretty easy, since you basically just want to fire off a thread to write data to a specified file each time the image capture is done... 

One thing you can do to reduce the impact on the SD card with the Pi is to use a USB stick for the root directory: There are instructions here. The SD card willstill be used at boot time, but is basically untouched during other operation; as a result, you don't get nearly as much sd card corruption. 

Set up the Pi to connect to a hotspot created by (say) an Android phone, connect your laptop as well, then ssh over the phone's local network. This is how I used my Pi headless for quite a while. Connect an ethernet cable directly between your pi and your laptop. (The Pi automatically detects if it's connected directly to a computer, and plays nice if it is!) You'll need to configure both the Pi and the laptop to use a static IP address over the ethernet network, but then you can SSH over the ethernet cable quite easily. 

Basically, it's a good idea to use proven configuration (TV, plain HDMI cable) to do the installation, and start tweaking the software settings and hardware environment later. I'd suggest you to get HDMI cable to connect your RasPi to the TV set and check if everything works as it should. usually this won't take long, so nobody will miss the TV really much. And only after you've proven your RasPi is working well you may change your configuration and try to attach it to the monitor using HDMI-to-DVI converters. 

There's absolutely no point to connect expensive and power-hungry Oregon 600, you should definitely choose BU-353-S4 (SiRF4 chipset), it's plug-and-play solution, that powers up from USB port and even has the built-in magnet for mounting on the car roof top. From the software standpoint you'll need to install , but there are plenty of tutorials on the web, so I don't delve into that. 

This definitely should not call any , just don't forget to make it executable with . Or there's more advanced "seamless" player in python available here. 

before everything else, I'd like to say that hosting anything worth hosting on raspberry pi is a silly idea, unless you don't care about your web-site at all and do not mind it going down at any random moment. otherwise, it's very easy. 1) install LAMP stack with (you already have Linux, so there's only Apache, MySQL and PHP/Python/Perl left to install), 2) configure your raspberry to have IP address visible from the outside (probably somewhere in your router settings) 3) change your domain DNS configuration to point to your raspberry IP address, 4) have fun! 

You would replace the with whatever command you use to run your jar file. (Note that it's generally good practice to put in the full path to any files in your home directory.) 

A much easier way than setting up rc.local scripts with the Pi is to use crontab. Here's a standard example of a crontab line: 

for whatever esolution you actually want. Another trick which might be helpful would be just using the "red" channel of the RGB image as a greyscale image. Your captured image should be a numpy array with a row for each of the three color channels; you can just use the first channel as a greyscale image and save yourself some data processing. 

My preferred method is to use , which is an alias for a shutdown command that also kills power usage. 

You should also be able to directly set the size of the captured image, instead of doing a resize later; this will save a good chunk of compute time. Do this by setting: 

Create a new raspbian installation on your desired new, smaller SD card. Boot into the new installation and expand the filesystem to fill the whole disk. Shutdown the pi. Now mount the new and old cards and use to copy/overwrite the filesystem on the new card with the filesystem from the old card. Finally, boot into your new system, and run to make sure that your firmware is consistent and up to date. 

I've been using to copy filesystems from one disk to another for a while now, with no hiccups. The advantage of using rsync is that it's copying the content of the filesystem, rather than doing a block-level copy of the device; as a result, it really doesn't care what size the target and source drives are, so long as the target drive has enough space to hold the data. So here's how I would do it: 

you need only 1 (one) ground pin for does not matter how many input buttons. there's absolutely no reason to use any other pin as a ground as long as you have one already used. 

The micro-USB port is designed to power the RaspberryPi using 5V wall adapters, so you'll be pretty much safe doing that. Moreover, that is the preferred way to power the RaspberryPi, widely used by millions of people around the globe, and as far as I know they haven't had any problem with that yet. Regarding the external 3.3V supply -- I'd remove it, because the board is quite capable to provide the 3.3V from the 5V you feed through the micro-USB connector. 

on the other hand, if you insist, your python script may touch the file (or update log file, or do whatever you like, that leaves a time stamp in the file system), and your cron job may check this time stamp and restart the script if the difference between the time stamp and the current time is more than few minutes. 

regarding the GPS module, please, see my comment above. BU-353 is cheap, reliable and proven to work. interfacing something else with TTL level shifters from 5V to 3V3 and back is troublesome and eventually will lead to pain and frustration, possibly including burnt unit and/or RasPi. Raspberry Pi has no output power limitations. There's a polyfuse, that limits the total current to something about 1.2A, thus, considering RasPi consumes about 0.7A, you have about 500mA to play with (~10 times what you need). Still, if you shorten the polyfuse and attach a good power supply you may easily pull the current in excess of several amperes, provided the PCB traces won't burn.