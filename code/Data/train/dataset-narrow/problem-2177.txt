decide the following language: $$L = \{ n^2 \mid n \geq 1 \}$$ (the input is initially loaded in the counter $c_1$)?. Is it still an open problem? (cf. Rich Schroeppel, "A Two counter Machine Cannot Calculate $2^N$" [1972]) 

I think that you can start (and probably end, because it's a huge list :-) with the references in the recent Charles F. Miller's paper: "Turing machines to word problems" (2013). And another recent paper that surveys the connections between group theory and theory of automata and formal languages and hase a huge (>100 entries) reference section is: Tullio Ceccherini-Silberstein, Michel Coornaert, Francesca Fiorenzi, Paul E. Schupp. Groups, graphs, languages, automata, games and second-order monadic logic. European Journal of Combinatorics, Volume 33, Issue 7, October 2012, Pages 1330-1368. Abstract: In this paper we survey some surprising connections between group theory, the theory of automata and formal languages, the theory of ends, infinite games of perfect information, and monadic second-order logic. 

Since parallel segments form an independent set in such a representation, this conjecture implies the 4CT, but perhaps is even stronger. The reference: West, Open problems. SIAM J Discrete Math Newsletter, 2(1):10-12, 1991. 

For approximate counting, the following paper (also in APPROX-RANDOM 2011) $URL$ describes the state of the art. As Anthony Labarre refers to in a comment above, there was a recent and unexpected breakthrough by Yufei Zhao showing a tight upper bound on the number of independent sets in an $n$-vertex $d$-regular graph. His proof used a very clever bijection. The extremal example, conjectured by Alon and Kahn and dating back to 1991, is simply a disjoint union of many copies of a $d$-regular complete bipartite graph. This area of research draws on many mathematical and algorithmic methods, and is an area of interest not only to theoretical computer scientists, but also to number theorists, probabilists, combinatorialists, statistical physicists, and more. These two recent papers might give you a good start, though there is a rich collection of deep and interesting papers on the topic going back decades. 

This is not a real answer to your question (I don't know much about the (2,3) machine debate); but I suggest you the paper "Small Turing machines and generalized busy beaver competition". I quickly read it some time ago, and it has a nice graph with the borderlines between the 4 types of small TMs: 

Figure: a graph $G_1$ on the left, and the equivalent $(H_1,...,H_k)\text{-free}$ graph $G'_1$ on the right (suppose that the longest cycle of the $H_i$ has length $r=15$, so every edge of $G_1$ is replaced with a path of length $l = 5$. We can also extend the negative result to Hamiltonian cycle NPC problem, indeed it is an immediate corollary to the following (original?): Theorem: for any $k \geq 3$, the Hamiltonian cycle problem remains NP-complete even if we the graph $G$ does not contain cycles of length $\leq k$. Proof We know that the Hamiltonian cycle problem is NPC even on a planar directed graph $G$ with each node $v$ satisfying: $outdeg(v) + indeg(v) \leq 3$ (Papdimitriou and Vazirani, On Two Geometric Problems Related to the Travelling Salesman Problem). We can transform the graph $G$ to an undirectde graph $G'$ simply adding a node on the incoming edge of nodes $v$ that have $indeg(v )=1$, and to the outgoing edge of nodes $v$ that have $indeg(v)=2$. Then we can replace the nodes of $G'$ with the gadget in the figure below. It is easy to see that there are only two valid traversals (zigzags) that visit each node of the gadget exactly once (red and green paths in the figure): the gadgets cannot be traversed from top-to-bottom, otherwise the horizontal (incoming or outgoing) path would be cut out. Furthermore we can place enough nodes on the vertical/horizontal segments of the gadgets, and extend the number of its zigzags, to ensure that no cycle of length $\geq k$ is possible in the gadget or in a triangle of 3 gadgets linked together. This assures that if the resulting graph $G''$ has an Hamiltonian cycle, then the original graph $G$ has also an Hamiltonian cycle (the converse is immediate by construction of the gadget). 

As a bit of unashamed self-promotion, Marthe Bonamy and I found more negative answers. In particular, Theorem 4 of $URL$ improves upon the aforementioned result of Král' and Sgall in certain cases. The examples we use are complete bipartite graphs, where we used some extremal combinatorics to analyse them. The work was motivated in part by this TCS overflow question. 

Probably there are too, too many examples to list, but one classical example (it is highlighted by Aigner and Ziegler as a "Proof from the Book") is the use by Lovász of a geometric representation to solve a problem in Shannon capacity. Though the proof was published in 1979 and solved an open question from 1956, this remains state-of-the-art. 

We can gain more space if we add a lookup-table of the most frequent 0 (non contiguous) subsequences ( 0_0, 0_0_0, ...): 

I was interested in finding the center of each zone; if you are interested in the exact length of the bridge you can use various techniques. For example: 

A simplee trick (explained here) that let you use the $\log$ approach even when you must sum probabilities. Problem: $\log(\exp(a) + \exp(b))$ can lead to an underflow, to avoid it you can use this formula: $\log(x + y) = \log(x) + \log(1.0 + \exp( \log(y) - \log(x) ) )$ Or use another approach: $\log(\exp(a) + \exp(b)) = \log( \exp(a - C) + \exp(b - C)) + C$ Setting $C = \max(a,b)$ For example: $\log(e^{-120}+e^{-121}) = \log(e^{-120}(e^0 + e^{-1}))= \log(e^0+e^{-1})-120$ 

Have student reps To address Jukka's supplementary request made in a comment to the question: Enlist two (or more) people -- one an energetic young researcher (student or post-doc) and one an engaging and extremely experienced academic (professor) -- to co-ordinate activities for early-stage researchers. The former would be responsible for planning drinks and other social events, while the latter can provide careers and research advice, perhaps in a special-purpose session of the conference or possibly at said drinks. (An optional third person could be an industrial contact.) 

Gerd Wegner in his PhD thesis (Georg-August-Universität, Göttingen, 1967) proved that any graph is the contact graph of a set of three-dimensional convex polytopes (but he credits the first unpublished proof of the result to Grünbaum). This is a short proof. 

An example could be ODD CYCLE TRANSVERSAL (OCT), the task of making an undirected graph bipartite by deleting as few vertices as possible, parametrized by the number of allowed vertex deletions (though Stefan Kratsch and Magnus Wahlström recently showed a randomized polynomial kernel for OCT) 

This is only an extended comment. A few times ago I asked (myself :-) how fast a multitape NTM that accepts a (reasonably encoded) NP-complete language can be. I came up with this idea: 3-SAT remains NP-complete even if variables are represented in unary. In particular we can convert a clause - suppose $(x_i \lor \neg x_j \lor x_k)$ - of an arbitrary 3-SAT formula $\varphi$ on $n$ variables and $m$ clauses in a sequence of characters over alphabet $\Sigma = \{ +, -, 1 \}$ in which every variable occurrence is represented in unary: $ + 1^{i} 0,- 1^{j} ,+ 1^{k} $ For example, $(x_2 \lor -x3 \lor +4)$ can be converted to: 

This is related to Travis's answer. In fact, it could be considered a stronger version. A paper by Bollob\'as and Thomason (Combinatorica, 2000) shows that in Erd\H{o}s-R\'enyi random graphs $G_{n,p}$ (with $p$ some fixed constant), every hereditary property can be approximated by what they call a basic property. Basic almost means graphs whose vertex sets are unions of $r$ classes, $s$ of which span cliques and $r-s$ of which span independent sets, but not quite. This approximation is used to characterise the size of a largest $\mathcal{P}$-set as well as the $\mathcal{P}$-chromatic number of $G_{n,p}$, where $\mathcal{P}$ is some fixed hereditary property. If $p$ permitted to vary, the behaviour is not well-understood. For more background to this and related work, there is a survey by Bollob\'as (Proceedings of the ICM 1998) which also gives an enticing conjecture along these lines but for hypergraphs. I find the deep connection between hereditary properties and Szem\'eredi's Regularity Lemma very intriguing, as it was used both here and in the Alon and Shapira result. 

From the comment above: you can use the same oracle $A$ used in: Richard Beigel, Harry Buhrman, and Lance Fortnow. 1998. NP might not be as easy as detecting unique solutions. In Proceedings of the thirtieth annual ACM symposium on Theory of computing (STOC '98). for which $P^A= \oplus P^A \neq NP^A = EXP^A$ ($EXP^A=NP^A\subseteq PSPACE^A$ also holds) 

From the comment above: you can easily prove that your problem is NP-complete. If you don't like the degenerated path solution (path of length zero) as correctly suggested by Yixin; and you also want to force that the paths are included in the Hamiltonian cycle; you can use an easy reduction from the Hamiltonian cycle problem on directed graphs (which is obviously NPC). Given a graph $G$ replace each node with a path of length two (three nodes) and mark one of its enpoint as the ingoing endpoint and the other as the outgoing endpoint. Now simply connect the endpoints of the paths according to the original graph $G$: for a directed edge $u\to v$ you will connect the outgoing endpoint of the path corresponding to $u$ to the incoming endpoint of the path corresponding to $v$. The resulting (undirected) graph has an Hamiltonian cycle (which by construction must traverse every path, because the middle node must be included) if and only if the original digraph $G$ has an Hamiltonian cycle. 

To add to Dai Le's answer, a more recent book by Dubhashi and Panconesi provides many examples of the use of probability in the analysis of algorithms. 

A limited number of tables/desks in a quiet room Problem: Not everybody will attend every session, nor will everybody be staying at the hotel to/in which the conference is nearest/held. Solution: A few tables, desks, chairs in a quiet room for undisturbed reading, writing, typing, browsing, possibly with power outlets. 

Schramm proved that every planar graph is the contact graph of some set of smooth convex objects in the plane in his PhD thesis (Princeton, 1990) using Brouwer's Fixed Point Theorem. A nice survey of this and other results related to Koebe's Theorem is in a survey by Sachs. 

In a concurrent runtime environment simple things can seem weird ... hope this can help. We have a BUILT-IN ATOMIC CAS1 having this semantic: 

$F$ needs only a limited look-ahead buffer (4 symbols) to make the rewrite and also to perform the $w+1$ operation; the internal states of $F$ embeds the internal states of $M$ so it can simulate the transition function $\sigma$; 

I think that the gap between the performance of two programming languages highly depends on the type of the problem/algorithm and how you measure such "performance". The introductory paragraph of the "The Computer Language Benchmarks Game" page is clarifying: ... When the facts are about the performance of programs, the particular way each program does a task matters a lot. Obviously when programs implement different algorithms that difference may itself be enough to explain any difference in program performance. Less obviously, even when the same program is measured with different implementations of the same programming language, the particular way that program does the task may work better with one of the language implementations than the other - but slight changes to the program might reverse that performance difference. So there has to be some flexibility allowed in the way programs implement the same algorithm, and the tasks are kept simple enough for you to check the program source code. When the facts are about a wide range of different programming languages even more flexibility has to be allowed in the way programs implement the same algorithm - after all, the point of using a different language is for the different approach that language provides. ... For example, if you look at the The Computer Language Benchmarks Game, you can see that a gap often occurs between a compiled and an interpreted language, but it is not always true: in the regex-dna test, javascript performs better ... but only because it has a powerful and "native" support for regular-expressions. It is also clear that the gap between Java and C++ has greatly reduced thanks to its JIT compilation. The theory says that different programming languages lead to execution times that differ only by a constant factor ... and the speedup theorem for Turing Machines says that constant factors are meaningless; but some efforts have been done to study computability and complexity from a programming-language point of view and the results are a little bit different. See for example: Computational Complexity via Programming Languages: Constant Factors Do Matter (A. M. Ben-Amram and Neil D. Jones) ... Using the programming language described in this paper we prove a series of hierarchy theorems ... The main theorem, for deterministic time, states that for time-constructible functions $T(n)$, there is a constant $b$ such that more decision problems can be solved in time $bT(n)$ than in time $T(n)$ ...