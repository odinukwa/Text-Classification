Note that the class name violates Microsoft's capitalization rules: "Do capitalize only the first character of acronyms with three or more characters". 

This is just begging for an ORM like NHibernate or Entity Framework. Don't even get me started on : why does this method exist? This "logic" should be in your XAML, not in your code behind. 

WRT your question, I don't see how you can parallelize it without running the risk of duplicate entries. I do wonder whether it wouldn't be easier (and increase performance) to maintain a instead of doing each time. Key of that dictionary is the , value is the . So you'd end up with something like this: 

Also: wouldn't it make sense to replace the with a ? That is: assuming the parameter isn't always unique. I wonder about the wisdom of storing 70k records in a session variable, wouldn't it make more sense to look at improving the performance of -- e.g. via a cache,... -- and simply storing the result of in the session if you expect repeated calls for the same ? 

If you're using , you're probably doing it wrong and you need to use . Your first method would then become: 

can return a , yet you never check this. Why are you even using the version, considering that the first line sorts the result of by , which would throw an exception if one of the items was . 

I cannot imagine a scenario in which the logic in your is applicable: ? If the db is down, report back that it is down and that's it. 

Each of your contains basically the same code. Don't copy-paste, instead create a method that contains this code and accepts the button as a parameter, and call that. 

Already it's a lot clearer. However, you need to comment this: because I cannot figure out easily what this logic is supposed to do. Properly naming and would help, I guess. Or even better: move it to a properly named method of its own. 

I'd change that method name too, but I'm low on inspiration now. I also don't get why you'd treat each case slightly different (i.e. checking if parsing to int doesn't throw an error, checking if the string is null or empty,...): why not treat each parameter the same? 

I'm baffled by . Why don't you have a custom class with meaningful property names? Also, in the one place where you call , you don't even do anything with what this method returns. 

I would even urge you to move that outside of this class and parse the arguments you're sending to this method before you call it, so it can become: 

I've never worked with ASP.NET MVC, so I don't know whether this is the usual way of doing things, but passing a model and then setting properties to give feedback -- e.g. -- looks really odd to me. Especially since this class doesn't have anything to do with the UI; which means you're mixing up tiers. 

Comments like are superfluous. Your code should tell me what it does, comments are used to tell me why it was implemented like this (if necessary). 

Instead of the logic, use int.TryParse(). Also, use descriptive names and avoid calling things "somethingArray", especially when they're not arrays. 

The folder name is used in at least three separate methods. If you ever decide to rename this folder you'll need to change this in three places: that's a recipe for bugs. Such things should be defined as a in a configuration class, or retrieved from a file. 

Names like , , ,... are bad names for classes; if possible change them to more descriptive names (and use PascalCase). My guess is that the entire body of your button click event handlers can be abstracted into a single method, considering that also seems to be pretty generic. Look at that method and check how it handles the various types of forms and filters. 

Most of what happens in should not be happening there, it should be happening in a separate layer. I'd suggest you look into multi-tier architecture and split up your code into at least three tiers: 

What I am unhappy with As you can guess, my main issue is with : the parameter is actually never filled in and its value is actually in a querystring parameter called . Of course, when you first enter the page there is no value and thus a default one is assigned (that way you don't end up with a blank page): 

Is there a reason you're doing this in an "outdated" technology like WinForms when WPF etc. exists? There is a strong link between data and UI in this method, which is a frequent issue with WinForms; if this was WPF you could implement MVVM to separate those concerns. 

There's no need for fairly meaningless variable names like , , , ,... And is equally bad, since it doesn't tell me what it contains. is... unexpected. or is usually used. 

I don't see why you create a in your controller, only to pass to to the ? Why not let the repository deal with all of that instead of mixing it all over the place? 

Why use when it would be far clearer to create a custom class? The next person to look at this code will first need to figure out what the and the represent, whereas if this had been a custom class they'd know the first was the URL and the second... well, I don't know what, but you get my drift. 

You assign , a name that conveys absolutely nothing, only to use that to execute . Why not do that in one line? 

What type is , and why does it return a value that isn't an ? Seems odd to me that a control that returns a value from 1 to 8 would return this in a non-numeric format. 

Those first two lines are completely superfluous; moreover if you need to get a value from a and aren't sure the key is present, you need to use .