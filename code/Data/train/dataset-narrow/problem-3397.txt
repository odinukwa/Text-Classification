Try to open the file and check if APT syntax is correct. Here is a post that may be helpful in your situation. 

By looking at your question, it seems that you are trying to gather light data from multiple Arduino boards and using Raspberry Pi as collection (and may be reporting) point. SPI specification has no set length limitations but when run a few meters apart, it is susceptible to EMI/RFI, cross-talk, slew rate issues. Assuming your Arduino boards are far apart, you need a differential pair bus like RS485, RS422, etc. To answer your question in simple words yes, you can use SPI to communicate between 3 or more Ardunino boards contingent to proximity between your nodes. Master with three independent slaves: Simple in operation but limited to the GPIO pins required for each SS. Each additional slave will require one additional Slave Select pin. 

My recommendation would be to add another layer of opto-isolation when driving the above relay. Here is how opto-isolators work. If possible, double the capacity of the relay (90A) to add scalability and over-current scenarios. There a lots of advantages of using SSR over mechanical relays. Here is an application note from IXYS that delineates the advantages of SSR over mechanical relays. I would not recommend you do it yourself unless you are licensed. Better get a licensed contractor as the voltages are lethal and one mistake would cause electrocution! 

The Raspberry Pi board operates at 3.3V internally. Although you power up the board using 5V but the GPIO voltage is 3.3V. Even if you replace the 5V relay module to 3.3V relay module, the GPIO can't provide enough current to energize the relay coil. You need an opto-isolated relay board that will take 3.3v trigger input (most opto-isolated setups do). Referring to below schematic, you would connect DGnd to Raspberry Pi Ground, IN1 to Raspberry Pi GPIO, Supply Relay voltage (12V in this case) at J9 and connect your load (bulb) at J5 (in series with your load supply voltage, same as your current module). 

My Raspbian Pi crashes to a Kernel panic when I start it up, and it suggested somewhere that an invalid cmdline.txt can cause this. What is in the cmdline.txt by default? 

The highest temperature my CPU has ever reached is 61 degrees. However the overclocking capabilities change depending on the manufacturer and batch. 

Depends how mobile you need it to be. If you don't move it too often or too far, it could be worth using 1 12v/2 6v batteries to power it and then using a 5v regulator. It would last quite a long time and you could also use a 12v solar panel to recharge it if needed. If you need to move it around quite often, you could use a 5v battery, such as this one $URL$ but they are usually more expensive and don't hold as much charge. 

I can make new files, folders and install new software but I can't download files from the internet (Using Iceweasel(Firefox) and Midori). When installing new software at some point it says something like "man.db: not enough memory". Also when starting the Pi, "[warn] Root filesystem full...warning" comes up. I use rasbian wheezy with a 16GB SD card. I always use root user. Any ideas what the problem is? df command output: 

I've only managed to overclock my Pi to 1.3 GHz, but this guy here $URL$ got it up to 2.4GHz. Is it the cooling that makes it possible to get up to that high? I couldn't overclock my Pi any more because, if I increased it more, it would crash at startup. Would cooling help with this too? Usually, it seems that you only need cooling to keep the CPU cool as overclocking heats it more then normal, but if it crashes at startup would more cooling actually help? 

Flashing the SD-Card may have un-done the changes you did. Follow the same instructions you did to get it working the first time. 

$URL$ It's 25mb and does a whole lot more then hello world. EDIT: Another important thing to note: "Tiny Core is designed to run entirely in RAM, which means that you don’t install it so much as load the disk image onto an SD card. When you’re running the operating system, everything is loaded into the computer’s memory." 

I've turned the WiFi off about five minutes ago so that explains the watchdog timer being 372 seconds. Is the value for frequency what I'm looking for? Question 1: Is using the lowest value for "when" a reasonable way to gauge roughly how long it's been since the system time has been checked against internet servers? Question 2: Does the ntp daemon make an estimate of system clock drift rate available in any way? If it's say 10 ppm or 100 ppm, is this reported somehow? Question 3: What do the characters in the first column such as '+', '*', '-', or absence thereof indicate? System: using Raspbian GNU/Linux 8 (jessie) 

I am writing a data logging python script and I would like it to find out if the system clock has been synchronized via NTP recently, and if not, to attempt to cause it to happen before proceeding. Starting from this answer, I've found that for the status 

For the next 1000 milliseconds, a transition in either direction on pin 22 will result in a call to , passing the new level and the tick number (microseconds). If I understand correctly, in pigpio one can set up one watchdog per GPIO pin, so there could in principle be many running at the same time. My question is what are these watchdogs? Are they CPU threads, or are they running in the GPIO electronics itself, or something else? Like real dogs, can they compete, conflict, or collide (say two watchdogged GPIO pins experience edges at exactly the same time), or do they get along nicely with each other? This is from and may be of some help: 

I'm trying to check on the status of the pigpiod process from within a python script. These two methods both appear to work so far. Are there any significant advantages or disadvantages of one over the other? Are these likely to be reliable ways to do this? 

What caught my eye is the "stability" measurement. I'll let it run for a while to see if it becomes non-zero, hoping it might address Question 2 below. edit 2: Looking at the question timed out, nothing received on ntpdc> loopinfo? I found the command 

Your application doesn't need denouncing as there are no mechanical contacts involved. The pulse adapter board has no mechanical contacts, relays, etc. Debouncing is only needed if you connect mechanical contacts to digital inputs. From Whatis.com - "Bouncing is the tendency of any two metal contacts in an electronic device to generate multiple signals as the contacts close or open; debouncing is any kind of hardware device or software that ensures that only a single signal will be acted upon for a single opening or closing of a contact." Here is a excellent guide on debouncing. On the other hand, your application may need signal conditioning. The pulses from the adapter bard may be of different amplitude that the PI can handle. Or the pulses may need filtering, etc. You can read more about signal conditioning here. 

For a new system you would have to create a wpa_supplicant.conf file in /boot to configure your wifi. Follow this post for a new setup. 

From your diagram, it doesn't seem that you have connected the LED to a GPIO! Here is a map of the GPIO connector: 

From Raspberry Pi Documentation: "The flow of boot begins with reading the OTP to decide on the valid boot modes enabled. By default, this is SD card boot followed by USB device boot. Subsequently, the boot ROM checks to see if the GPIO boot mode OTP bits have been programmed — one to enable GPIO boot mode and one to select the bank of GPIOs it uses to disable boot modes (low = GPIOs 22-26, high = GPIOs 39-43). This makes it possible to use a hardware switch to choose between different boot modes if there is more than one available." As per above, it doesn't seem that you need to program the OTP (One Time Programmable) bits to boot from USB. 

Connect your RxD GPIO Pin (GPIO15) to TxD pin of your USB to serial adapter. Connect TxD GPIO Pin (GPIO14) to RxD pin of your USB to serial adapter. Connect your USB to serial adapter ground to Raspberry Pi Ground (Pin 6 of GPIO connecter) Use appropriate serial terminal program (depends on your OS and choice) 

That fan has only 2 cables, a black and red, for positive and negative, which means there it is either on or off depending on if it's plugged in or not. There is no thermometer inside measuring how hot the processor is. Normal computers usually have a fan with 3-4 cables. Two for power, one for controlling the speed, and the last one tells the computer what speed the fan is currently spinning at. To turn on the fan when the processor gets hot you'd need to write a script that turns on or off a gpio pin depending on the temperature, connect that to the control input of a relay, and connect the fan's negative to the pi's negative, the pi's positive to the input of the relay, and the relay's output to the fan's positive. DO NOT connect the fan directly into the controllable GPIO pins. Also, it cannot get hot enough to cause damage to itself unless it's somewhere very hot, a lot hotter then room temperature. 

To be able to connect to your pi from anywhere outside the local network, you will need to make sure that your router is set to port-forward. To do so you will need to login to your router. If you're using Windows, open the command prompt and enter "ipconfig". Scroll up and find the ip address for the "Default Gateway", and enter this into your browser. If you're using Linux, the command is "ip addr". It should then load a login page for your router, where you will need to enter the admin username and password. I cannot give you specific instructions after this part as each router has a different interface. You will then need to search through the settings for an option that says "Port-Forwarding", which is usually a checkbox. Restart your router and you should be able to connect from outside your local network. 

I want to change the default governor on my pi from ondemand to performance. Is there a way of doing this? 

edit 1: I've taken a look at Install NTP on CentOS which turned up in a search for help trying to understand what "lithium.constan" meant, and I found the command: 

I'm using pigpio bit-banging script (download, GitHub) that interprets the pulse durations generated by the DH22 Temperature/Humidity sensor. It sets a 200 ms pigpio watchdog to the GPIO pin and attaches a callback, passing the tick count and new level. Here's a generic example: 

It turns out that this sluggishness in the pigpiod DAEMON's status is real. It's not a problem in the script. I saw this by accident while trying to stop and then restart pigpio while debugging a DHT22 script. Here's some text from the Pi's terminal. After the killall, pigpiod can not be started between and . The message: 

After disconnecting the WiFi, I captured a few responses. According to the page 22.13. Checking the Status of NTP the column labeled is "how long since last poll (in seconds)" and it increases with time as expected. But I don't understand why between 155 and 434 seconds that "jitter" changes, or between 434 and 687 seconds "delay" changes. Right now I'm classifying that as an inconsequential bug and ignoring it. To me, the value of "when" is most important 

After turning WiFi on again and letting it run for a bit, I see the following, which suggests that it's periodically checking. 

I'm trying to learn how to safely and reliably start and stop the pigipod DEOMON process from within a python script. If pigpiod happens to be running already, then this script is always successful. It stops pigpiod and then starts it again. But if pigpiod is NOT running when I run this, then MOST of the time it fails, and the standard message block that starts with "Can't connect to pigpio at localhost(8888)" appears when I try to instantiate pi = This happens even though returns , there are no exceptions, and a was executed "just to make sure". 

There are many relays availible for use with the Pi. It's very similar to a transistor, except its digital rather then analogue, once the input is at a high enough the relay will turn on its normally off output. There are 5 inputs and 2 outputs. One output is normally on, the other is normally off. In between is the input for the relay. There are 3 more inputs the other side of the board that will have GPIO pins. 2 are for VCC(+5V) and the other is the GND(-). The third pin is the input that controls the relay, changing it's state from normally on/off. You can connect the GPIO pins directly from your Pi. This is how a 1 relay board works, but if you're using a 2 relay (or more) board, it should be easy to work out. 

See this website: $URL$ Download the software, run, select the SD card drive and it will completely format everything on the SD card no matter what file system was used. 

I have created a game that only runs on a pi and I want to upload to the Pi Store, but I need to take a screenshot of the game. Anyone know some good software for taking screenshots on a pi? 

You could use the GPIO ports on the Pi and the RPi.GPIO API for Python to communicate and convert the number to binary, although this would take quite a bit of coding. Another option would be to connect the two pis' directly to each other with just 1 ethernet cable, for which you would need to configure a default, static IP address to use on each. Then you could use the socket API from Python to communicate. 

Is there a way to monitor the current CPU core voltage and overclock, similarly to CPU-Z but for the raspberry pi? This is so I can check that nothing is limiting the overvolt or overclock. 

About a year ago I installed NOOBS on an SD card, then put raspbian on the SD card using NOOBS, and it's always worked fine, however I now have a problem where whenever I boot into raspbian I get "Unable to mount root fs on unknown-block(179,2)". After looking around this seems to be due to a corrupted partition on the SD card. I hosted my website using this SD card, and I forgot to make any backups. From windows, how can I recover those files, without Linux or fsck? I'm using Windows 10, and I have a card reader and I can access NOOBS's RECOVERY partition, which doesn't appear to contain anything useful. I was using a pi 2 B. Thanks!