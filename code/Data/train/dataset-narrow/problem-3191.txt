Red line at top corner of the pi with cable facing out to red line on the "5V" side of the breakout with the cable facing back. 

By default they overwrite the modified file. If you want to copy instead, use , as in . See for more after you install -- but it is pretty simple. 

The GUI stack on GNU/Linux usually requires (at least) two drivers, one used by the kernel, and a userspace one for the X server. I think the latter one tends to be more generic, which is perhaps why there's no indication of one being installed; the kernel one handles the specifics so that a more generic, pre-installed driver can be used with X (in contrast, another question about a touchscreen here yesterday seemed to involve a generic and/or preinstalled kernel driver, but a custom X driver). The X server does not require a configuration, in which case it probes the hardware and tries to makes an appropriate decision. However, if you do provide a configuration, it will stick to that. If that configuration is wrong, it will fail. X logs various things at start up to . It is tidy about this and rolls them over, so that log contains only information from the most recent start (hence you will also find a and so on, these are for previous initializations). It also indicates going through your configuration line by line. If you shut down X and move those config files in and , you should be able to start X on the HDMI display, presuming something funny wasn't done with the kernel. At the very least, you should get a more detailed description of the problem in the . If that works, you just need a script (or two) that will symlink and unlink those configuration files depending on which display you want to use. Stupidly enough, and don't seem to have options for using alternate files. However, if it does work, you might be able to create a that covers both displays, since X does not have a problem running multiple different monitors. You could then enable or disable them and change certain parameters from within the GUI using . 

Pidora stopped being updated at least a year ago; I could go check my logs to be sure, but it was well before F20 reached EOL. I also had an x86-64 F20 system up for the duration and it was receiving updates during that time. This implies it was abandoned by the maintainers before F20 got to EOL, as does the state of their web page and the fact the Foundation stopped listing it. Pidora was the product of a university based research group. Presumably they moved on to other things and none of those involved wanted to take responsibility in their spare time. That said, it doesn't make it particularly unsafe to use, it just means you won't be getting any security updates. I believe it is, e.g., safe from heartbleed but probably not shellshock. If you are running an outward facing server, it is always a good idea to periodically check the upstream distribution site (i.e., the homepage) for relevant software to see what news they have about this kind of thing, because using a current distro doesn't guarantee anything. I'd still recommend against using it for anything at this point as it isn't being maintained. 

If everything is working ok, I don't think this is anything other than informative. Why do you think it indicates an error? Not every message spit to console at boot indicates a problem -- in fact, most of them don't. Different software may use different priorities with the system logger in order to force stuff to the screen but that does not mean it is really urgent. Of course, if stuff is not working ok, then it might be a clue as to why. You might try this: 

This presumes it doesn't require interaction, and that you don't care about watching the output. If you do, replace w/ ; you can then check that. This orphans the process so it is re-parented by init (PID 1), such that if your current ssh session terminates for whatever reason, it will keep running and you can just log back in and the process will still be doing whatever it is supposed to do. 

You might for starters use a systemd service file instead of a SysV style script, since those are supported for backward compatibility only (SysV is no longer used on most current linux distros, including Raspbian, so do not bother with online blogs etc. which reference it). This will provide you with some more fine tuned control. See in particular the Before and After clause in : 

That last step is trivial. If those sync systems provide a "no delete" option on the destination, so you can copy all the files and then delete them yourself and not worry about them being erased on the destination next time you sync, there's not a problem. 

>_< That will never, ever accomplish anything, except possibly on a Pi 2, and even then it may be sketchy unless you have actually installed the ARMv7 version of Debian, which Raspbian is not. Normal armhf debian is compiled for the ARMv7 architecture. This is NOT compatible with the A/B/A+/B+, which is why Raspbian, for the ARMv6 architecture, was necessary in the first place. Unfortunately this is a bit confusing since both of these are tagged as packages. So, take that line out of . I checked the raspbian "jessie" repos but the highest version of NM there is 0.9.10. I suggest if you want 1.0.0, build it from the source. It is not that big and should not take so long, even on the pi. The general procedure for this should be: 

"Argument zero" here refers to the name of the executable itself, i.e., would refer to a login shell (but it is still 1). This is typically done by the command if you log in locally at a console; will also do it if you log in that way. However, if you log in graphically, e.g., using a display manager, (DM) this depends on the attitude of the people who wrote the display manager, because it never starts a shell. You may never start a shell. If you do, it is probably inside a GUI terminal, and those do not use a login shell because normally you only have one for every login session, not everytime you open a terminal. Hence, some DM's will source to compensate for this. Some others, on the idea that it is not their place to do this, do not, including the default used on Raspbian. Evidently this applies to your VNC login as well. 

Which would mean implementing significant parts of an HTTP server. That is a big, big, big task -- as in thousands of person hours minimum, and not for beginners. If you want a web interface and you want it done before the end of next year, use an existing http server and write code for that. Here's three suggestions: 

FAT32 (with VFAT) -- "With VFAT" really goes without saying now, of course. While it may not be, in theory, the best performing filesystem of all time and lacks features of newer/more advanced fs types such as NTFS and ext4, it has a long history of stable support on both platforms, including VFAT extensions that allow for long names with spaces in them, unicode characters, etc. -- which is one of the basic problems confronting people using FAT filesystems and ye olde 8.3 filename format. It also allows for (depending upon block size), minimally 2 TB of storage. If you need more than that, just use a bigger block size when you format the partition (or spread your stuff across several partitions). While I'm not a Windows user, the fact that Windows does not natively support ext4 makes that, at a minimum, a hassle -- especially if you end up wanting to plug this drive into some Windows system somewhere where whatever special third party software you need isn't installed. NTFS probabably has better support under linux than ext4 has under Windows, but it is not without complications. For starters, I believe the currently predominant implementation is FUSE based. There's nothing in particular wrong with this, although it might be considered to impose some restrictions that you may or may not ever have to deal with. It should work out of the box, but in the end I am not so sure you are going to get better performance with it on the linux side than you would with the less restrictive, more flexible FAT32. Just stating the fact that there are various NTFS implementations for linux and "the currently predominant is FUSE based" I think means we are getting into potentially confusing territory for many users and "confusing territory" is the last place you want to store your data. Finally, NTFS support on linux has a spotty history in all the various implementations including corruption, absurd processor usage, etc. which may (or may not...) currently be considered a thing of the past -- but since it is proprietary technology belonging to a corporation notorious for leveraging its size to try and establish monopolies wherever possible, there is always the outside chance, since it is currently their primary fs, of it being manipulated to this end in the future. Although technically this could apply to FAT32 as well, it is much, much less likely to happen there -- e.g., MS could suddenly decide to drop support in Windows 12, but this would probably not be a wise choice for them to make as the most significant consequence would be to drive a small percentage of their user base away. It is also worth observing that (V)FAT is a requirement on the Raspberry Pi regardless of the operating system used, so you are almost guaranteed support for it will be present no matter what you do with your Pi. The requirement is because of how the SoC uses the SD card during boot (I do not know whether this covers FAT32 specifically, and technically the OS doesn't have to be able to read the first partition, but it is still a pretty safe bet). 

The default GUI file manager on LXDE (the desktop environment used by Raspbian) is PCManFM. Unfortunately while that wiki page mentions "file associations", it doesn't explain how to customize them. I don't use LXDE or PCManFM but I am fairly certain they use XDG protocols, which are open standards implemented by various DE's. An internet search for led me to this page, which seems to confirm that, although it was written almost four years ago. There's a lot of explanation of various things in there that it still valid although there is now one more location for a , . Since user preferences should take precedence it is that or which should apply; I don't have a recent non-lite jessie image at hand so you may need to check if either or both already exist. But before you bother you try ; have a look at . Geany has a system file, so the command would look something like: 

And other than the first two lines (not shown), that's all you need in that file. If it doesn't look like that, create a backup copy of the file and change it so it does. You've already confirmed the kernel 8192cu module is loaded. Apparently is the interface name, double check that with . If there's a wlan0, we're good. 

None of this can be done in parallel. You have to multiply the first two numbers to get a result, then add that to 5, so for a task like this, no matter how many cores you have available and want to use, only one will be involved with the problem at any give point in time. However, 

There is a difference between at boot and at login. This may be somewhat obscured in Raspbian if you use autologin, because right after booting finishes a login will automagically occur. Booting is something the system does when started irregardless of whether anyone is going to log in afterward. Boot services are by default owned by the superuser (), although this ownership is often switched to de-escalate privileges, making the service less of a security risk. The activities started at boot run in the background -- except for login consoles (and/or GUI logins, aka. "display managers"). Note the system can be configured to run something else in the foreground instead, but this is the norm for a multi-purpose desktop style system. Also note there does not have to be anything run in the foreground, which is the case for a headless system, with no physical HID (human interface device such as a keyboard or monitor). "Foreground" is a little subjective. In one sense it refers to the perspective of a user. In another (compatible) sense, it refers to a relationship between a parent and child process -- a foreground process will block its parent until it completes or goes into the background. Note that all processes have a parent, except for the first one, init, which is responsible for starting most processes at boot. On Raspbian init is . If the parent of a process dies, any children which survive will be adopted by init. Login is something a user does to start an individual session with the system. This may be anytime after the system has more or less finished booting.