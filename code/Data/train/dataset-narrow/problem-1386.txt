Don't use flags for this. If you can use Java 8, you can use (there are libraries with similar types for older Java versions, e.g. FunctionalJava). But there is an even better way: You can use generics in order to insure that all required fields are set. This is called the "type-safe builder pattern". The easiest implementation (an example for using "phantom types") is this: $URL$ I would recommend a slightly improved version based on the following Scala code here: $URL$ I translated this version to Java in my blog post $URL$ (sorry, it's in German). 

First, your method violates the Single Responsibility Principle: It calculates something, and it prints it out. Such coupling makes it inflexible. It's better to return a String, and letting the caller decide what to do with it. Second, you're code is way too complicated, handling all the different cases which are very dependent on the ASCII layout. Imagine next you want to support digits as well - oh my... I would suggest to do something along the lines... 

Note that for a real world application this approach is still not "OO" enough, as there is a tight coupling between the model and the user interface. Ideally you would factor out all user interactions in a separate class, which would simplify later refactoring (e.g. using Swing instead console). However, I felt that for that small example this would be probably overkill. 

Note that unnecessary comparisions will be skipped in the cp methods. [Update] Apache Commons does something similar: $URL$ 

In my opinion should contain a , not extend one. Another possible design would be to use a single call with varargs: 

Remember that is just for lists. So this code prepends every in the list with a space, concats it and than throws the very first character (the leading space) away using . 

So try to condense your logic as much as possible (as long as it stays readable). Learn about the laws of logic (e.g. de Morgan's rule). I think you could improve speed by collecting bigger chunks of output in a , instead of spitting out single chars one by one. Last but not least, follow good coding practices: 

IO: You use everywhere and (BTW, is much more convenient than a ). Even if you want to switch from console output to a simple Swing application with little more than a text area, you have to change everything. Same story if you want to provide a translation for your game. So follow the the Single Responsibility Principle: Your model classes like and should care about the state of the game and its transitions, and not about IO. Even if this is not a perfect separation, it's still better to send Strings to an class, and ask it for input, than doing everything locally. Then the class is in charge how to present the data. Later you might want to send just messages like or to IO, which gets the real output from a text file or so. Room: cascades are written better using . In your case an array with all strings would be even better, you need just to get the right one. 

Even ignoring the overhead of the class the code seems to be way too verbose, and even worse, constantly jumping back and forth between imperative and functional style. I'm still using a lot of for loops. Especially I couldn't find a good replacement for . Further, I found no good way to utilize , as its or methods seemed just too inconvenient. I'm looking for hints how to improve my code in a functional way without straying too far from the original snippets. [Update] Thanks to both answers and some API diving I came up with the following, which is IMHO a good compromise between conciseness and readability: 

The main problem is that Scala's is just too dumb: You can't do much with it except pattern matching, there is no or method etc. The -based sorting isn't nice, but I don't know a better way. I wouldn't sweat too much about performance. Often you have to make a choice between fast and pretty, and in this context I would choose "pretty". 

So all operation specific information is captured in the Op enums. If you want to add other operations like min, max, and, or, xor or mod, you don't have to introduce new if-blocks, just new enums. 

Now you could use a loop instead of the helper function (see TopinFrassi's solution), but I don't think there are big differences. Of course recursive code can lead to stack overflows, but this is no problem here, because Fibonacci numbers grow so fast that they reach long before that happens. If you decide to use s instead, it would be a completely different story. In that case you should use the following much faster formulas: (from $URL$ ) 

The question was, which is the biggest product you can make from the digits of 1 to 9 (which is 9642*87531, BTW). It is pretty clear that one number starts with 9 and the other with 8, and that you need to append the remaining digits in descending order to one or the other number. 

Sometimes they are hard to avoid, as in your example. I would consider it bad practice only in cases where the exception is easy to avoid (e.g. by testing the sign before calculating the square root). 

While everybody mentioned optimizing , nobody spotted the one glaring ineffiency: You can break the loop as soon as . Further you can skip the even divisors except 2: 

is gone. is more useful, especially you don't have to use null values to encode a removed briefcase. I changed the alignment of briefcase, so there is no more dummy value. Then I tried to simplify everything a little bit. This is far from perfect, there is still room for improvements. 

Of course this might be suboptimal depending on the intended use, but I think you get the general idea. [Update] After some meditation I came to the conclusion that I thought way too complicated. Try the following version: 

The other answers are excellent, I just want to point out a handy way to split positive numbers to digits: 

This is only one possibility to split view and model, the "right" way depends on your needs. But keeping both model and view in one class is a receipt for trouble. 

Refactor's answer is excellent and captures most points. One thing in your code which sticks out is the overuse of . E.g. consider 

Don't use arrays as representation for binary numbers. could save you a lot of work. Except from that, your code is very repetitive. An example: 

If I have time, I'll look deeper in the code. I think there are probably much more things that could be improved. 

As the majority already pointed out, your method is fine concerning the coding standards. However it has an asymptotic complexity of O(nÂ²). For very long arrays you may consider a more performant approach having O(n * log n) [...I think]. The code is very easy to understand: Sort the array and search from both ends. The only difficulty is that you need to keep track of the indexes as well, which requires to copy the whole array. 

You should use instead of , also in . Don't use in : If your fractions are always in reduced form, you can just compare numerators and denominators. In , you could test some special cases to avoid multiplication, e.g. if and (for ). I think for multiplication , it could be faster to reduce and , as well as and , instead of doing the reduction after the multiplication. There is a BigFraction class in Apache Commons, maybe you can get some inspiration there... BTW, method and variable names should be lower-case. [Update] I think you should always reduce fractions. This allows you to use shortcuts (e.g. in and ), and also faster calculations. If fractions are always reduced, you can compare numerators and denominators in (instead of calling ). Further, for multiplication you can reduce before you multiply: 

If you are really sure that an empty method body is okay for most sub-classes, you could follow the example of Swing listeners (e.g. / ): Make the methods in your class abstract, but provide an abstract class called extending , which implements that methods with empty bodies. That way you document your intentions: The methods must be implemented, but by extending the you say that you want for most of them the default implementation (which happens to have empty method bodies). Update: Of course, if you can use Java 8, you can write default methods in interfaces, hence an abstract class isn't needed. 

Your version is fine. As bisserlis mentioned, guards would probably look nicer. I find the following more readable, but of course it has worse performance: 

Could you please review the following code, and point out how I can make it cleaner, more idiomatic and easier to understand? 

Then you can use your solution for Q1 without much changes (I took the freedom to kill some parens etc): 

Usually only a few cells of a spreadsheed are actually filled, so I'd suggest to use e.g. a to save memeory and to allow to use bigger spreadsheets. 

You should have a look at Guava, especially at CharMatcher and Splitter. While both "manual" splitting and regexes certainly work, there is no need to make your life more complicated if there is already an easy and safe solution available. 

I'm not sure this is faster, but it's worth a try. Concerning lower-case variable and method names I thought about things like . 

Additional to sepp2k's excellent answer some math that could help you: If you have the prime factors of a number, you just take the exponents, increase every one by one and take the product. 

I would go with the first alternative and use . If you need this pattern more often, how about an object oriented solution: 

To your second question: I assume you want to traverse the tree in-order, and that the nodes have no link to the parent, only to the children. Then you need a node list from the root node to the current node, which can store if a node was already visited or not, too. Then you go left as deep as possible, storing the path in the node list. This is your first current node. When you need the next one, take its parent (from the node list). Next would be the right children of that node (if there are any) or its own parent. The best way to understand this is to take a sheet of paper, draw different trees, and look how the traversal must work. 

Just a little remark as an addition to the other excellent answers: Don't repeat yourself, always try to to find an abstraction for common tasks. E.g. If you need to time methods, don't do it "manually". Of course the "right" solution depends on your needs, but I would suggest something very simple as: 

I don't think you can do anything about this. You have to cast here, and in the process you lose all information about the type parameter: The compiler can't know that if you have a , it's always a , and "thanks" to type erasure it can't check the runtime type. 

Additionally to the excellent answer from ratchet freak: Always encode data according to their meaning, don't use another type just because it seems more "convenient". E.g. variables like represent "yes/no" choices, so an appropriate type would be - even if you "get" them as numbers: 

Additionally to the other suggestions: Write utility functions like , which could be used in several places. 

I have to say it's really hard to follow your code. Why do you have no sub-methods? What does "pomoc" mean? Why do you use if flipping the condition would avoid it? And can be written as An can be slow because of boxing/unboxing, maybe a specialized structure is faster (e.g. from gnu-trove) But the main questions is if you really use the correct algorithm. I can't tell without looking deeper, but if you're unsure, read "The Genuine Sieve of Eratosthenes" (it's Haskell, but you'll get the idea). Note that from a theoretical point of view there are "faster" sieves, but I think they are much harder to implement, and it's hard to say if you really see a speed-up. [Edit] Based on @Rohit Jain's solution, special-casing the even numbers and skipping unnecessary tests: 

There is not much "generic" here, the code is as type safe as with raw types. Further, usually isn't a good idea. Last but not least, method arguments should be written lower-case. Here my attempt (off the top of my head, couldn't test it): 

After finding myself sometimes needing a map of maps, and as I couldn't find one in existing libs (like Guava), I wrote my own implementation. Do you think this version is okay? Specifically: Is it acceptable that I don't permit empty "inner" maps as content for my "outer" map, hence probably breaking the contract of ? Do I miss useful methods, are some methods superfluous? Should my class implement the interface at all, as some methods work counter-intuitive when using this abstraction? Are the names of the additional methods too subtle? 

The smallest divisor of a number (greater than 1) is always prime. The algorithm in pseudocode looks like (untested): 

You could opt for implementing instead of , or even for making the member variable public (because it's final, and is immutable). [Some Random Thoughts] Try to simplify logical expressions as much as possible: 

Of course, you could add some error handling, e.g. ask again when the user misspelled an operator. Also keep in mind that division by zero results in "Infinity", which is fine here, but may be a problem in other contexts. 

If and are so tightly coupled with the feasibleNeighbor-calculation, maybe you should have something like a class which is holding all of this stuff, and which you can ask for the next neighbor list? 

Using varargs instead of an array for the argument makes it more flexible, e.g. better testable. In case you really want to copy the array, use , which is much faster than looping through. 

The code looks way to complicated to me, in fact this isn't even the kind of merge sort I'm used to, which is "split the list in two parts, sort the parts, merge them back to one list". Here is a short implementation: 

And last but not least a common trick for board games: Surround your board with an invisible border of one field (e.g. your 10x10 field would become internally 12x12), which are empty. Don't show them, don't allow the user to access them. Then, if you check the neighborhood of a field for mines, you don't have to check if you are off-limits because you have that safety border, and because these fields are always empty, your count is still correct. As a starting point, here is how I would start (without any user interaction or game loop, but with calculation and display done):