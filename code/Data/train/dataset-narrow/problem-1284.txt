Very nice, I like what you have done with it. Especially the Operator Modifier, clever use of lambdas clean way to avoid too much redundancy. First let me tackle the IAttribute and explain why you want to keep it. Well an abstract attribute is great when the underlying type is a T item. but what about when it is not! well how about this example: 

and whats cool if you find yourself doing the same few configurations all the time you can instantiate multiple reporters super quickly. 

nullable bools give me a weird twitchy feeling behind my eyeballs. If you need three states you should really wrap it in something like a Enum. EDIT: somebody already said that. oops. 

Unless I am mistaken you are dealing with a int32, string key value pair, why not use a simple struct consisting of an int and a string? although as this is CodeReview I have to say, your use of ternary operators nested in linq statements with more terniaries is damn near illegible. 

Secondly I think it is a problem that has its own implementation of because you then don't evaluate the base class implementation which could be invalid. A solution to that problem could be as shown below. Be aware that I have dropped the IPrimeChecker, because it is unnecessary. 

I think your solution is quite OK, it is doing what you want it to do. You can sharpen the if-statements a little by using for all but the first, because an animal can only be one kind. Alternatively you can experiment with a -statement instead which will make the code more clear. By the way: you don't need the flag for cats () because it's the 'lowest' level of animal type. You solution with a switch statement instead of if's: 

In short the prospect of setting the highlight colour should not really be dependent on the raw values, and if indeed it has to be it should be done in a safe manner. as it is there are a number of way's to break your application some accidentally while developing others while using the application by passing invalid data. 

or a weighted Modifier, which is just a modifier with an Int value, now you can sort based on that value and apply the modifiers in order based on their weight value. still agnostic from the Attribute. or whatever.... and conditionally apply these modifiers. The possibilities are endless, 

This is just a primer, allows the separation of rule creation from the actual parsing code. Does allow the extensibility of making smaller rules that you could combine to make aggregate rules etc... Finally it means you can make rules sets by instantiating different rule managers depending on situations. 

In this way the first permutation is returned as soon as it has been computed and everything is running more smoothly. 

As it shows, I have made the function generic (and guessed that cache is a Dictionary?). The last irritating comma (',') is removed by . 

Overall your code does what you intend and that's a good start: to print a diamond with numbers. The first improvement could be to handle an "arbitrary" sized diamond: 

In general it looks OK to me, but you could maybe consider the following: 1) Return a instead of and then yield the positive results when found: 

The main changes here are: 1) The naming: Instead of , the client now a job. The use of the term "Subscribe" was as confusion of the two concepts scheduling and subscription to an observable. The client of the Scheduler, should be agnostic about how the Scheduler works internally - and a scheduler schedules jobs. 2) Waithandles: When the Scheduler stops, it will now wait for running jobs to finish before it finally terminates. 3) Logging: Introduced some basic logging of events. 

So in summary i am not saying it isn't pretty cool, I can't really fault it as is designed, but as this is a code review, traditionally defined as an evaluation I have to evaluate the actual pragmatic value. and I don't see it. you can go fluent....er than code without architecting an entire supporting structure and creating a number of dangling hard to ducky-problem solve/ducky debug classes like _is. 

Yeah I know you could effectively use the AAttribute for this one too again, the number comes fron a wrapped sub-attribute and not an actual base object so this is a tad cleaner. So now you have an attribute decorator, you can take a really complex , modified attribute which, through whatever combination may end up returning you something like -999 and break your game, so now you take that modifable attribute, wrap it in a Clamped decorator and all the values returned from it are safely clamped to a pre-defined acceptable range. Next, as for: 

If you have no opportunity to change the two classes, you'll have to create some kind of wrapper for the pair of related ItemData and ItemClass instances. I think your approach is OK, but I have the following comments: I would not hide the creation of ItemData in the ItemBinder constructor. Instead I would call the constructor with the pair of ItemData and ItemClass instances. Instead of fields for the fields of ItemData and ItemClass I would create corresponding Properties with the appropriate accessability: 

To avoid the overhead of cutting of the length you could use an enumerator instead like this in order to handle the first group separately: 

Naming: is not an index, but the actual value in the valid sequence (from min to max). I would call it or or something like that. I don't like the name either, because the target is actually the sequence of numbers from to . would be better IMO. 

You require pry, and you don't seem to use it. Perhaps it is being used for troubleshooting, and the or other code, has been removed. In that case it may be more appropriate to simply use the option as in . Then you don't have to remember to remove that line, just the troubleshooting line. (Or even better, set up a system that lets you leave things in but turn them off and on from an option in the system call. Perhaps -w or -v flags. Perhaps an environment variable. A line in with this in mind may look like this: And a ) Looking at your tells me that you have an infinite loop. But you have a well defined exit strategy, there is no need for an infinite loop. Using something like will run the block at least once, and will stop when your method returns true/truthy value. You also call 'play' from inside the loop inside of play, but it is already going to start from the beginning of the loop. If you had folders , , I would expect some of the code in your file to be in maybe . The equivalent for sure. This will allow you to use the file in a way that someone that requires that library would expect. Right now, you are unable to require that library file without starting the game. The interface of using words like seems clumsy and error prone, even if it is nice. Creating a numbered or lettered menu or presenting the grid with numbers or letters could make play easier, less typing to do, less error prone. Perhaps a lettered 'x, y' grid. Presenting that grid would also document the game play, and make initial play more straight forward. Your "choose_character" method does two things, it prompts and processes the choice. The @player_character and @computer_character is repetitive, confusing in a way. Simply having @player and @computer is probably clear enough. @player.character might be better, though I think we consider that letter a 'marker', as the player mark may be 'X' and the AI mark may be 'O'. Looking at you could be using the new named arguments in Ruby 2.0. In the Board file you can likely use the Enumerable method, if an array has the markers that match the current players marker, then that player is the winner. 

If their role is more advanced than that with methods and state, it IMO calls for at class hierarchy in some way like: 

EDIT I admit that Husk has a point about especially in where the length reach as much as but tests on my computer shows only a pair of seconds in expense for n = 8. The algorithm exhausts the stack for n = 10 anyway... As an alternative you could use which seems to have the same performance as Husks version. 

I find your code clear enough, but you could improve it a little bit, so you only do the add operation once: 

There are a couple of simple errors: 1) In you replace the next line with the second part of the split instead of inserting it after the first part: 

Now, this is only one example of course, you could do a lot of alternate skill implementations. The final step would be i suppose to create PoisonModifier/ItchyLeftEarModifier etc and then apply them with some effect like +5% -20% etc, or whatever. This separation also means that while most things will be using the Skill.Value which in the case of a modified skill will be the modified version some special something could check if the skill is a Modified skill, if so cast it and use the base stat instead! (one final note) I was a bit wasteful with the Value aggregation in ModifiedSkillImpl, tbh I would probably have a private variable for modified Skill and only recalculate if the modifiers had changed since last call but you know, this is just a quick POC.