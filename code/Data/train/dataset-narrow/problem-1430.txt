There are magic numbers everywhere. If you decide to change the size of your board, you are going to have to change a lot of numbers. Normally you can just declare them as constants privately in a class, but because they are used by multiple classes I recommend extracting the magic numbers into a class. You shouldn't have public fields. The following: 

Calculating and can also be done using loops. There are LINQ methods to make this even easier. This requires . 

You can use the code from the horizontal method and modify the property calls to use the boolean. For example, you would replace with and with . It can then be used in your previous methods: 

Have a consistent parameter naming convention. has an underscore, but the other parameter names don't. I prefer to only use underscores for variables declared within classes but not within methods. should be lowerCamelCase. That is, . If will always be zero and will always be array length - 1, declare them in the method body. Don't make the method caller do unnecessary work. Use descriptive variable names instead of single letters. 

The second option above only works because you run the entire functionality of the class from within the method (which may or may not be bad form). When the new instance is created, the back and forth prompt is executed right away, so the moment it would go out of scope and get deleted (because it isn't assigned anywhere), is only after you are done with your input and output (and possibly been given anyother option to reset). 

You don't do this in though. If you have a list of length 4, the call will look past the end of the list. That's a problem. One that's easily fixed by the same checks as above. You probably also want to validate the input for . You don't want a position as input, and neither do you want an input past the end of the list. 

This checks if the minimal and maximal function values of the simplex are sufficiently close together, but an easy counterexample shows that this nowhere near guarantees convergence: Consider the function . Of course this is trivial to minimize, but using this algorithm, we would have a simplex of 2 points. Let those points at some point using the algorithm be and . Then the functionvalues will both be , and the algorithm will stop. Instead, I changed this to checking the value of the centroid of the simplex. 

The first thing you can do is assign all the properties for a thing in one line using an object initializer. The following: 

Since the loops are similar, you could extract one into a method and then replace them with two method calls. I'm going to replace the loops using LINQ. This requires 

If you want, you can create a class to store a spell, its cooldown, and its cooldown number, so then you would only need to create one array. You can use modulo arithmetic to make sure a number is within a certain range. can be written like this: 

You can get rid of a lot of repetition in by storing things in arrays and accessing them by the . You can set up your arrays like so: 

You only need one class, and then you can create four instances of it. Your "Spawn" methods can be extracted into a single method, with parameters to handle the differences. For example, because not the same for each obstacle, you can have that be a parameter or a variable in the class. 

If the input is not numeric, you return , but not when your input is outside of the range. You might want to add a check for that as well: 

This post is specifically for the GUI, since this is my first time working with PyQT, so I am not sure if all is done properly. The file with the file with the classes Query and Universe and an example JSON file can be found on GitHub. 

Only during shrinking do we have to evaluate more new points. So we can extend the code where we break the iteration with a modification of the array and move the loop evaluating the simplex to outside the while-loop. 

The latter is nice because you are certain you won't have any attributes from the last run leftover, messing with your methods, the former is nice because you don't have a multitude of instances (I am not sure what happens with the first application when you create another one, since it isn't stored anywhere). Not exactly knowing which way was the cleanest to do this, I asked a question on SO about resetting classes. It seems that calling or any -methods directly is bad form. We could however move the definition of the class attributes to and do the following: 

I don't know much about making numbers random enough, but I have some other suggestions. Instead of checking if a range of integers contains a number you can just check if the number is >= the beginning of the range and <= the end of the range. So you can replace this: 

Alternatively, you could have functions as parameters for selecting the properties, like using a lambda expression in . Edit: as for the first method itself: In the following line of code: 

it won't get rectangles that are at the exact same X position. But that won't matter if it's guaranteed that none of the rectangles overlap. Then there's this code right after: 

I think your version three is still better than my alternatives, but you might prefer one of them. is nice for replacing loops, and query syntax is nice for declaring intermediate values (like ) and replacing nested loops. But the method that takes a lambda that includes the index as a parameter is very nice for this situation. With enough practice you can get to the point where your code looks like version three right away. I rarely write loops anymore. I actually find them tougher to write because they make you focus more on "how" than "what". 

I am currently learning C# since the last week. I have little to no prior experience with any of the C family of languages. I implemented the Nelder-Mead algorithm for numerical optimisation of a function. My implementation exists of a function that takes two arguments, the function to optimize, and the amount of dimensions that the function has. So for a function that goes R^N -> R, the second argument would be N. The implementation is based on the algorithm shown in the linked article. Along with the algorithm, I also implemented two functions for evaluation of the algorithm: The Himmelblau function and the Rosenbrock function. 

Length You provide a method to calculate the length of the list. But from the moment of creation of the list, you should be able to track this length. If you add a private counter, increment it whenever a node gets added, and decrease it whenever a node gets deleted, you should be able to instantly provide the length, instead of having to compute it each time the user requests it. Repeated code You provide methods for deleting the first node, the last node, and any node. In the first two methods you kind of repeat the code of the latter method. You could redefine those by calling the latter: 

If you can only change a bool once, and the entire purpose of a loop is to set the bool, then you should just exit the loop after the bool gets changed. There's no point in looping more than you need to, and you also don't have to worry about the bool getting switched back. So you can write your example like this: 

The braces should all be indented by four more spaces, and should not be indented more than the above brace. isn't a very descriptive name. I'd go with something like . Most of your loops can be replaced with LINQ, which is more concise, safer, and easier to read, in my opinion. For example: 

If you wish to keep the speed of your original solution and increase readability, there are many improvements you can make: 

Why does have three parameters but only use one of them? should be declared inside the loop because it's not used outside of it. You can assign it on the same line that it's declared. 

Since that improves the naming, and removes the need to keep the attribute around. So we can turn that into a regular variable without the . Expand the methods to also allow for removing of that item. This is mostly relevant with the GUI in mind. It contained a bit of a workaround to be able to remove tables and columns from the Query. So I added an argument to the methods to be able to set to remove instead. 

I found myself wanting to use Linq to map void methods to an IEnumerable to modify all items. The existing Linq methods require a return variable when mapping, since they are based on . So I decided to try my hand at creating some extension methods myself. This is the first time I've done anything like this, so if there are any pitfalls I'm missing, please do tell. I created two extensions, one which applies a foreach loop to all elements, calling an for each. The second one is basically the extension, which allows for two s to be iterated together and again maps a to both of them.