This code has a baked-in assumption that there are four cutoffs. If you were to modify so its length is not four, then this would break. Instead, you could do: 

I would use a matrix multiplication. It is both efficient and leads to much shorter code, as you can see: 

I think the author meant that at each time step the walker will walk in one of three random directions (x or y or z), not all three. Without making drastic changes to your code, you could replace this section: 

where is a super fast (internal C-compiled) function. Question 2 Is the argument handling OK? I wanted users of the function to be able supply either ppm or mz_tol, but not both. Am I using missing() correctly? There are two schools for this kind of situation: 

If you only want to work with the 3 closest stations, you can write a function that will only keep the three highest weights on each row and turn all other weights to zero: 

Since you seem focused on functional programming, the main suggestion I'll have is regarding the use of arguments. It is recommended functions use all their arguments (see how does not use ) and more importantly, that they only use variables that are either passed as arguments or defined inside their body (see how uses that is defined outside). Fixing for that and making other personal but minor changes, the final code would look like this: 

Peter Cordes did leave you several review comments in the original SO question, so I will post the code-only here which is sort of adjusted by his advices (and my small modifications). Commands to compile: 

(the exact value stored in is , encoded as 64 bit integer value) So you are just destroying precision bits of the original value, but the resulting value can still contain decimals with precision you don't expect. For some more information study how the floating point numbers are designed, maybe this may be of help: $URL$ 

To get forward from this situation, there are two basic paths possible: 1) keep using HW floating point numbers This has huge performance bonus, so that's why the / are first choice citizens in C++ floating point number calculations. Usually the tiny inaccuracy of results is small price to pay for the HW boost of calculations. Then you should arrange your calculations in such way, that the cumulative error is smallest possible, and store around the values with maximum possible precision for any record purpose. You then round the value to proper number of decimal places only during output formatting, for example like to get the rounded to two decimal places in form of "string". Of course you should be aware of total possible cumulative error, and make sure it's within the acceptable level of inaccuracy for your software. 2) use other encoding of your numbers: some big numbers library One of the possibilities is to use some library for arbitrary precision [decimal] numbers (like Java's class, can't recall any C++ one from head). These encode numbers in some custom binary way (or even as string), and have their own versions of common math operations, working with these numbers. Usually imitating human base 10 number format - which is not perfect either! For example you have two forms for every integer number: , or numbers like Pi can't be written down without infinite number of decimal places. These work like charm for financial software, where human base 10 formatting is actually perfect fit, with all it's quirks and imperfections. The price is of course the performance, as each operation is emulated by several HW instructions, so even thing like simple addition may be 10-100 times slower than the HW . 3) use other encoding of your numbers: fixed math When you need only exact number of decimal places, like for example you want uniform distribution of space coordinates, you can use integers, and assign some bits for decimal part. For example 16b can be split into 8:8 whole:decimal part, supporting numbers from 0.0 to 255.99609375 (255 + 255/256), with constant 256 (inclusive) granularity between every two integer values. It may look a bit confusing at first, but these are easy to use in ASM with bit shifting (to get the whole part of number you only shift the value by 8 bits to right, to add two values you simply add them as two integers, etc). This is also sometimes used for financial software to calculate amounts with 2 decimal places, this is done not by allocating exact number of bits for the decimal part, but by simply having all values multiplied by 100, i.e. $3.59 is stored internally as integer, and when the value is displayed to human, it is temporarily formatted as . The limitation of this method is, that you have to decide the fixed precision for particular values, so it's not universal silver bullet. But compared to the big number libraries, the fixed math has performance very close to HW floating point numbers, on some CPU architectures it may be actually faster (like back in ages Intel 80486). 

so we will be calling . All that is left is to write : a vectorized function that will take as inputs two vectors of airport names and return their distances. We could first put the important data in a matrix with airport names as row names for easy access: 

Edit: And to handle a vector of as input, make these slight changes. It will return a list of matrices. 

You might also know that is a disguised loop: while syntactically shorter, it is just as slow when it comes to computation times. Instead of , you could just do: 

I think it reads a lot easier this way, where each line contains a test and the output value if the test is passed. If the test fails, we move onto the next line. And at the end, the last line contains the value if all tests have failed. I also like this layout because it looks a lot like how you would nest Perl's ternary operator: 

Instead, I would suggest you write a function to process a single sheet and only loop once using that function (disclaimer: code could not be tested!): 

is applied directly to rather than . The output is a matrix where each column is a -long sub-sequence of . takes advantage of R's recycling rules to compute, for each item in each sub-sequence, the signed distance to the corresponding element of . converts to absolute (unsigned) distances. summarizes each column into a single value: the total distance from for that sub-sequence. picks the minimum total distance across all candidates. 

I don't know any readable way to rewrite without parenthesis. Haskell is smart enough to calculate and at compile time. In terms of performance, if you don't specify end of the list there will be no checks for the end of the list at runtime (which is good in this case). 

With LambdaCase extension it is possible to write without (but it does not seem much more readable): 

creates cycle from a list. skips some characters and returns list starting from . Try it in ghci ( is infinite so be careful with it). 

Note that I'm using strict version of left fold (see here about vs ) and strict . This means that map of height counts constructed in single pass without thunks. 

is ok here, no need to make it faster. In functional programming functions are everywhere, even inside other functions and this is ok. Using ViewPatterns extension it is possible to rewrite as: 

Working with text is easier with . E.g. it has already defined. Tagsoup understands so you don't need many type conversions. For greater amounts of data it will be notably faster and much more memory efficient. Instead of defining you can convert tag stream into tag tree, take first node and convert it back to stream: 

It is possible to create cyclic directory structure with symbolic links, so it may be reasonable not to traverse them. E.g. you can use from package to traverse only real directories: