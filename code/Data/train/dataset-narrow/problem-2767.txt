In resume: in 2.5D an sprite is either in front or behind another sprite. In 3D, a mesh is made of triangles, but triangle is not the minimal unit when testing for depth, you can have pixel precision. Of course, camera rotation in 2.5D is impossible as assets were created for a fixed camera angle, while in 3D is natural, if the angles of the camera are restricted by design in a 3D game is another subject. 

How much you can approximate the results of 3D graphics using 2.5D? There is a performance and programming complexity horizon. When you approximate to that horizon you start to doubt if your project is really possible in 2.5D or if you have to go full 3D. For example, you can use z-buffering in 2.5D (in theory), but can you pay the video memory cost (old desktop computer with onboard graphics, not powerful mobile devices)? Do you want to pay the storage cost of having an extra image to save the z-mask of every sprite? Good candidates for 2.5D are RPG games, think Baldur's Gate series, or RTS, thinks Age of Empires 1 and 2 (AoE 3 is fully 3D and easily to differentiate). Useful references: Z-Buffering: $URL$ Orthographic projections: $URL$ 

@rolen123 answer is correct. I wish to introduce a data structure, QuadTree, to the formula. As you said, sorting a vector of thousands of entities every time you are about to render is slow. But if QuadTree is introduced things change. Implement QuadTree is not so difficult. Implement a QuadTree to only update entities that are moving is a bit more challenging but can be done, mine does. Most implementations in internet simple destroy the whole QuadTree and recreate it when something moved, that won't work for a fast paced game. I have a QuadTree.selectRect(x, y, with, height) method that let me obtain all entities inside the specified rectangle, entities have a z property but they are returned in any order. Then I run Quick Sort in the returned array. Then I render the entities starting at the one with the less z value. Hint: if an entity rectangle does not fit entirely in a node do not make multiple adjacent nodes reference the same entity, move the entity up to a bigger node is better. Sorting before rendering may sound like overkill but even 3D engines do some kind of sorting and games perform OK. 

I'm reading about efficient Frustum culling algorithms. I found an article about a smart method that first use the Frustum AABB (Axis Aligned Bounding Box) to eliminate most of the scene before check again against the actual frustum representing the camera. I didn't do any performance test yet, but maybe somebody else did and can answer this question. Let's say I'm using an Octree to quickly check again the camera bounding box. But I do not want to do a second pass again the camera planes. If I simply render everything so far, isn't that actually faster than do the second pass? Assume object geometry is loaded into VRAM using hardware vertex buffers. 

Java Monkey Engine If you are most comfortable with Java, you could use Java Monkey Engine for a framework to use while making games. It also has a decent amount of documentation/tutorials including instructions for integrating with Netbeans and Eclipse. 

This is a confusing, vague question but I'll give it a shot First thing to consider is whether you want success chance to vary with or inversely too your factor for consideration(level, experience, defense, whatever) your fomula can be a fraction with things that you want to improve your chances in the numerator and things you want to decrease your chances in the denomenator(this can just be 1 if nothing decreases your chances) Suppose we wnat your chance to recruit someone to go down with your level(so it gets more difficult) but to go up with your strength. Our basic formula so far might look something like chance = strength/level This would be a linear function. Depending on how you want things to scale you may want a different type of function. If you have a theoretical maximum you could for instance use a logarithmic function to taper off towards some value chance = ln(strength/level) With this you get diminishing returns. You also may not want throw in multiplicative factors or additive constants to tweak the data if it doesn't feel right with how you want to progress. chance = m * ln(strength/level) + k Finally since this is a percent chance you may want to try and normalize it and convert into a percent. For this we divide by your best possible values for chance and multiply by 100 chance = 100 * (m * ln(strength/level) + k)/(m * ln(MAX_STRENGTH/MIN_LEVEL) + k) I hope this helps. 

I am familiar with Unity and in the process of learning android SDK when the announcement about unity android basic came out. What would be the advantages and disadvantages of using the android SDK directly versus development using Unity Android? 

A friend of mine and I were discussing different idea for allow materials in a world to be destroyed in a very piecemeal fashion and he proposed the idea of representing solids as very viscious fluids. My intuition is that this would be either: A) very difficult, or B) very resource intensive, but I am unsure. Is such a model feasible for an RPG/adventure rpg/fps? edit:clarification: The idea is for collisions and objects breaking to be handled by this system. To basically allow any object handled this way to be destructable instead of having scripted destroyable objects. 

I am creating an android game out of a partner based trick taking card game. What are some generic approaches to AI players for these types of games and what are the advantages/disadvantages of each? 

The vector of booleans may work. And I think check the tile below the player character every frame is perfectly valid solution until you get to a point in your project where that does not work any more. For most games that may never happen. A more evolved version is what I'm doing in my latest HTML5 canvas experiment to find the right collision method to use in a game I want to create. My levels are also in tiles of same size and always aligned, only character and enemies may not be tile aligned. I represent the level as a string constant, soon functionality to load from text file will be added. For example: 

When using the "Each sprite know how to render itself" approach a render system became unnecessary. Then I ended with a main loop that used functionality of the scene "class" to efficiently cull the scene and then loop through a sprite array representing the visible part of the scene calling each sprite render function. As sprites are allowed to contain render code, anything can be an sprite including a health bar that needs no image data and is renderer only with lines of different colors (easy done with canvas calls). Also note that with the second approach sprites and entities are the same thing. I called them sprites because it was 2D game. In the first approach sprite was a "structure" that contains data for the renderer renderSprite function and a separate entity "class" that refers to a sprite was needed. In resume, my position is: 

Vector from Platform to Player. If you do not want to use an structure/class to represent vectors, then another option is to use separate variables for x and y elements: 

As our new moves applying logic process an axis first and then the other, a large displacement may end being saw by the collision code like a big L, this won't correctly detect collisions with objects that are intersecting your displacement vector. The solution is to divide large displacements in small steps, ideally your sprite width or height, or half your sprite width or height. To obtain something like this: 

I tried to model a render system for an html5 game and learned the following: We use render code separated from other game code with the intention of change graphic api at any time without having to touch anything except the renderer implementation. But, for html5, do we need this? Canvas is already all the multi platform it can be. The browsers are already responsible of implement the platform specific part. A render system, if used, must be very generic. I don't think a method called renderATree() should be in the renderer. The sprite representing a tree must contain the data that you need to pass to a render generic function to produce a result that looks like a tree. 

This is not trivial. In general you want to make your game predictable. You also need to synchronize the clocks in both clients. If you do this there is no need to send the asteroids position every frame because both clients will be doing the same simulation. After a given number of frames you make sure that the simulations have not changed. Once you have done this you can send each player input and repeat the simulation of what happened in the other client exactly. This is one of the most known articles and a good introduction. It's a postmortem on how they built Age of Empires multiplayer. You can also check this fantastic one. The author has written a multiplayer Asteroids game. There is a second article in his website with more details. 

You should check out this tutorial by Ray Wenderlich. It uses Cocos2d + Box2d to show how to write a game like Tiny Wings. The first part of the tutorial explains how to create dynamic textures: $URL$ Second part is how to use Box2d for the gameplay: $URL$ 

Did you search in the interactive fiction community? They still write parsers and some try to push the envelope by implementing new techniques such as natural language processing. See for example this link for articles describing approaches used: $URL$ 

Actually that "while loop" that you wrote there is the source of your problem. GetMessage puts your application to sleep until a message arrives. This is good for GUI applications but obviously is not good for games. The right way of doing the game loop is using PeekMessage instead so that your application is not put to sleep and can just keep spinning. Here is the loop that you can see in DXUT and in most DirectX samples: 

I kept investigating this and will post this for benefit of someone that has the same question. Seems like the right answer to this is to skip the ContentPipeline and use Texture2D.FromStream to load the textures at runtime. This method works fine in a PC and even though there will be a small performance hit this is something that I can optimize once I'm closer to the release date. For now, having the ability of dynamically modifying the content for both the editor and game are exactly what I need. Once the content is frozen I can optimize this by going back to the ContentPipeline. 

It's a very open question. Here are a few references I've found great for writing my always in progress engine :) Online references: 

You need a vector representing your velocity. This vector will modify your position every time the update method is called. Then in every update check if the player is not touching a platform. If he is not then modify the velocity vector by some positive Y amount (this is gravity) Once you have that all you need to do is detect when the player collide swith a platform and modify the velocity with a negative Y value (this is your jump) 

As previously answered, Allegro is already cross-platform enough. If you are writing your own game engine, and you want to work in the exposed API first, so you can see if It is convenient enough to use, and you don't want to work at low level yet, then you can use Allegro behind the scenes for now until you decide to finally replace that with your own code. Now, do you really need that? As Allegro is already cross-platform, if It already runs in all your target platforms then why the need for code hiding it. In the past I did something similar to the engine thing but with SDL. The idea was to write my own low level code for some core functionality at some time during development, but in the end time passed, the game continued, and SDL is still there. Replace it would mean to test the platform specific code in each targeted platform. Note that is still the idea, but It is always postponed for latter. In resume: Are you writing a game? Only wrap Allegro when you want to group repetitive tasks. Use classes calling Allegro functions where it have sense. Do not wrap simple things like ALLEGRO_COLOR except you want to add something extra that you know you need it to happen always when you use ALLEGRO_COLOR. Are you writing a reusable engine? As I said in the first paragraph, maybe It may be justified to start wrapping the Allegro API. Maybe you want to add a switch to the build configuration where you let other people decide if they want to depend on Allegro or another libraries that your engine can use. Are you writing an engine then a game that use it? Rethink things. What are the resources at your disposition (time/manpower)? Maybe you should be writing a game only. 

I thinks this is the same bug I found when experimenting with MonoGame to decide if I will use C#/MonoGame rather than C++/Various Libraries. I suggest the following work around: try to change the resolution more than once. The property AllowUserResizing must be set to true before doing the change of resolution. And you must call ApplyChanges(). All of this came from the bug report. I made a ResolutionChanger class that automates all that. The class has an update() method that should be called each frame. This update method will check the current resolution to see if it is the same as the last requested resolution, if it is not the same, the change is assumed as failed and the class will continue trying to change the resolution until it see that the current resolution is the same as the requested resolution. Note that I had some success with this approach but I observed that some times the game starts with the default resolution, switch to full screen and back to windowed fixs it but I don't remember now if that worked 100% of the time. I don't know if this will work for you, but you can try. How to use (in your main game class extending Game): In the constructor create a ResolutionChanger instance: