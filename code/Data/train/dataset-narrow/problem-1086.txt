It would be nice if there were something "between" a and an , which would be recognized as having an integer type as its underlying representation (like does) but could also control what operators should be available and how they should work. One could, for example, specify that it should be possible to add an integer to a day, but not add two days together. would allow both with casting, and neither without casting; a sensible type should allow the first without casting, but not the second. 

If another line of the file was 1111111144444444 3 one could infer from that that since at most one of the first 8 digits could be correct, and at most one of the last 3 digits could be correct, at least one of the five digits between had to be a four. 

Interesting design. Performance could probably be improved by allocating a couple of large buffers, and reading large blocks of input alternately into the two buffers until EOF is encountered. At that point, count backward through the two blocks until the proper number of newlines have been found, and then print everything from there to the end. If the input happens to be a disk file, one could seek to a spot near the end and count the number of newlines from that point on; if there aren't enough, seek back some distance and count the number of newlines between that point to the previous seek point. This would allow "tail" to operate efficiently even if the input is a multi-gigabyte disk file. 

Allowing code to derive inferences like the above is likely to go a long way toward making these puzzles solvable. The tricky part is knowing when additional inferences are likely to be useful (and should be added to the list of constraints), and when they become redundant (and should be removed from the list of constraints so the code won't waste time with them anymore). Note that development of inferences goes far beyond checking off possibilities as inconsistent with constraints. Since the starting set of potential 16-bit numbers is humongous, building upon constraints is the only way to reduce the problem to manageable size. 

Deleting an item from a singly-linked list requires finding the previous item. There are two approaches one can use to deal with this: 

If a class is supposed to serve as a data holder, two instances which report themselves as equal should have the same properties; further, values corresponding to constructor/factory parameters should match the values used in creating the object. It would be possible to have a polar-coordinate type whose properties were the rho and theta values, or an xy coordinate type, whose properties were x and y, or perhaps even an abstract coordinate type with subtypes that hold degree-polar coordinates, radian-polar coordinates, and xy coordinates (each of which would store a different set of properties). Defining how the latter should work, though, could be tricky. Consider what happens, for example, if one constructs a point with polar coordinates (angle=45 degrees, radius=2.0) and then constructs another point whose xy coordinates match the first. Any possible behavior by the class is apt to be "surprising", since the xy-constructed object will have a radius of 2.0000000000000004; this means that either: 

The most concise storage format which would be easy to work with would be a pair of UInt64 values, one of which would indicate which squares were occupied by white pieces, and one of which would indicate which squares were occupied by black pieces. One could find e.g. the set of white squares that also have white squares to their left by , or the set of black squares that have black squares up and to the right via . While working with bitmasks may be intimidating, it's a very powerful technique since operations can act upon the entire board at once. 

There are only 120 possible permutations of five items; if one starts by ordering items 1 and 2, and items 3 and 4, that will leave 30 permutations, which can then be sorted using five more comparisons. If you're worried about speed, use explicit operations on the five items rather than using loops. 

The ideal thing here would be a (or better yet, a variation of a which allowed one to retrieve a reference to the stored item which matched a supplied key). Such a data structure would ensure that strings were shared whenever possible (a behavior which would not only reduce memory requirements, but also expedite comparisons among them, since comparing two distinct million-character strings that happen to be equal will take much longer than comparing two references to the same string). If one uses a , which is the best of the pre-existing classes for the purpose, it may be tricky to ensure that strings get kept as long as they may be useful, without having the dictionary keep them around even after they've become useless (if a string value has been used once before but all references outside the dictionary have been abandoned, having the string remain in the dictionary past the next GC cycle will generally serve no purpose; even if the same sequence of characters gets read again, it would generally be faster to have the old string evaporate and store a new string in the dictionary, than to have to compare all the characters in the new string against the ones in the old string and abandon the new one). 

The first should round down to 12012345.0f; the second should round up to 12012346.0f. It's not necessary for the function to perform extensive calculations on the input string; it would sufficient for it to observe whether there are any non-zero digits past a certain point, but the logic to handle all the cases is apt to be tricky. 

Class properties have significant advantages over class fields, and a class which exposes autoproperties rather than fields can easily be changed to use "normal" properties later without affecting any of the calling code. Structure properties do not offer those same advantages, however. The only times a struct property has a real advantage over a structure field are when the property is defined as doing something that could not be accomplished by reading a field (in which case an auto-property wouldn't be suitable), when the structure needs to implement an interface that exposes a property, or when the struct has to be usable with code that accesses properties via Reflection. A structure is, fundamentally, a collection of independent variables stuck together with duct tape. Given variables and of some structure type, the statement will mutate X by overwriting all of its instance fields with the values of the corresponding fields in Y. This mutation is done without regard for whether any of the fields are public or private, read-only or mutable, and there's no way the code for a struct can do anything about it. If a structure allows all its fields to be read, and allows the creation of a struct instances with any combination of field values, then the structure will be semantically equivalent to a structure which simply exposes its fields, and it may as well do so. Only if a structure has private fields whose values cannot be observed, or imposes restrictions on the values fields can take, is it helpful to do anything else. Otherwise, the fact that struct fields may be overwritten outside the struct's control limits the value of making structures pretend to be immutable. 

IMHO, the best pattern would have been one which Microsoft explicitly discourages: having the the primary logic be in an overload which accepts a parameter indicating what failures should be considered "expected" [the more commonly-used and overloads would chain to that]. If had included an overload with a parameter, then and the normal overload of could simply chain to that. You could then have a overload with a parameter which would get passed to the corresponding overload of . Bingo--no code duplication. Since Microsoft didn't do that, your best bet might be to write your own method which includes a parameter and chains to either or as appropriate. In that case, while the extra layer of wrapping on would be a little annoying, the logic for would only need to be implemented once. Incidentally, while could be a , it might be better to define an enumerated type; the meaning of would be much clearer than . 

The general form of the problem as stated is NP-hard, since any 3SAT problem (i.e. $URL$ ) can be easily reduced to a problem of the stated form. Simply use one column per variable, have a line of all "2"'s with a score of zero, and one line for each predicate with a score of 3, using a three ones or zeroes for the variables of interest and twos everywhere else. Although many problems of the stated form may be solved in reasonable times using a combination of heuristics and backtracking, such approaches are unlikely to be effective on a problem which was designed to be difficult. I'm not familiar enough with Project Euler to know how hard its problems are designed to be, but would not be surprised if a program which could small problem nearly instantaneously might be unable to solve the larger problem in less than a century. To solve problems of this size, I think it will be necessary to draw more extended inferences by identifying rows whose numbers are related. Toward that end, I would suggest that the data format for your rows include the ability to specify a range of scores, and for each space within a row identify any combination of possible digits. I'd suggest probably using for each space a bit-coded integer. For example, if a column had a value of 18 (2+16--bits 1 and 4 set) that would indicate that that column should add 1 to the score if that digit was a one or a four. To see how this would work, suppose you were given the rows: 

I would suggest that the outer routine should receive a delegate which is called when a problem is detected, before an exception is thrown by, or allowed to propagate beyond, anything but the lowest-level code. The code within that delegate can hopefully receive as parameters whatever information is needed to proceed sensibly from that point; the caller of the delegate can then--based upon the return value from the delegate--either retry the operation or proceed as well as possible without it; alternatively, the delegate may throw an exception to cause the outer-scope action to be aborted (possibly after recording somewhere information about how or where the action should be restarted). 

What are people going to want to do with , and are they going to have any expectations about how it should behave if the underlying data changes? If the intention is that code which reads isn't going to use it after the next time anything changes, you could have each instance of your self create (or lazily create) an instance of , which holds a reference to its creator along with a "change count" and possibly the number of items in . Methods and properties of would ensure the wrapped object had not been modified, and would then use that wrapped object as a source of data. The indexed getter might look something like: 

Is a object supposed to represent a kind of card (e.g. "spade jack" or "diamond six") or is it supposed to represent an entity which can only be in one place at any given time? For example, if you shuffled together two decks, and the top two cards of the shuffled-together deck are both "club queen", should those be represented by the same object, or should one card object represent "club queen which is at position 0 in a particular deck" and the other one "club queen which is at position 1 in that same deck"? I would suggest that you define a concept of a "card container" [used for hands, decks, etc.] and then define a "card" to be an object which has a suit and rank, and always sits in some sort of card container, but can be moved from one container to another. Each container should have a means of identifying the cards which occupy it, and each card should have a means of identifying the one container which contains it. Moving a card from one container to another should cause it to be removed from the former and added to the latter.