Grades. Works especially well around final exam time. You can find the average. Find the highest and lowest. Find the average with the lowest dropped. Find the most common grade. Count how many are in the range 90-100%. Given an array of grades assigned for each class, calculate GPA. Given 3 arrays that represent labs, quizzes, and tests calculate the final average. Each array can be weighted differently to match whatever your grading scale is. Ex: I would have labs weighted at 10%, quizzes at 20% and tests at 70%. 

Yikes, that doesn't sound like a fun way to grade. Sounds about like what I do with students that are competing in ACSL competitions. But that's only 6 or 7 students, 4 times a year. I can't imagine trying it with 100 students all year. Here's what I'm doing, and what I've done. Online Autograder This is what I'm doing now. Kids login to Canvas and it launches an LTI tool embedded in an assignment. They do their coding in Chrome and click the Test button when they're ready. They can keep testing until their happy with the grade. Grades get sent back to Canvas. I still have to transfer them to our actual gradebook. I can then go back and download the submissions if I want to look at them for style or tips. Generally I try and do this with everybody on at least one lab per lab set. What I've found is that students average about 11 submissions before they move on to the next lab. I only grade the last one, although I'll go back and look to see how they progressed. Downside to this is that it works well for smaller labs, but not as much with larger projects. I can break down large projects into pieces that they can check, but eventually there has to be a full project turned in. JUnit Tests Before I moved online I would write a JUnit test for every lab, and usually I'd write two. One that I would include with the starter code and one, more in depth, that I would use to test. Students could run the test code as many times as they wanted. Then, they'd submit their solutions and I'd run it against the other test code. Biggest downside is it was pretty time consuming to write unit tests for every lab. I've gotten pretty quick, but it's still a time suck. Walk around Not ideal, but I can pick up a lot about students' code by walking around the room and watching them code. I do this a lot with projects to get a feel for where the kids are on the project. By the time it's turned in I've already got a pretty good idea on what they've done. Doesn't scale well though. Biggest class I've ever had was 34 students. "Participation Grades" Sometimes I fall into this trap, especially with my second and third year students. I give them labs, they work on their labs, and I assume that they're done correctly if they've been working in class. Only saving grace on this one is that labs are worth very little and tests make up a majority of their averages. So even with gimmie grades on labs, they can still get hammered on the tests. Admittedly not a good solution, and one that I'm trying to work my way out of next year. Eyeball It Skim the code and see if you think it works. Same as the participation, this only really works with smaller assignments and when labs aren't worth all that much. 

In addition to the excellent definitions already provided, consider taking a slightly different approach or at least augmenting it a bit. This comes back to good pedagogy: I wouldn't give students definitions without context. Moreover, I would support whatever concept I want to get across, no matter how broad or narrow, with specific examples and implementations. To explain programming to someone who has no idea what it means, it is necessary to have short blocks of code at the ready. Explaining it in the abstract probably won't be too successful. Relatively straightforward ideas like printing "hello, world" or the even numbers from 1-100 or the sum of the integers 1-50 would show the bare minimum of logical and computational ability. Maybe even something relatively intuitive like bubble sort or linear search. From there, compiling the program - assuming a language like C or Java - would at least allow you to explain the notion of translation. I like to use the metaphor that computers "speak" binary, but I speak C (or Python or Java or...). I need to translate what I want to accomplish into the language that the computer can understand. You can explain compilers/interpreters as a kind of translator that understands both computer-speak and human-speak and knows how to take your thoughts and turn them into "words" that the computer can understand. (You can optionally include the idea of assembly and instruction sets, but again, that's probably beyond the scope of this conversation.) 

It is clear to me that the Game of Life works for reaching both of those objectives, but I get a sense that I'm missing something more that I could use it for. Keep in mind that these students are relatively new to computer science and programming as high school students. Ultimately, what is the pedagogical value of Conway's Game of Life for a high school CS course? 

Essential Understanding 4.2 of the AP CS Principles curriculum is as follows: "Algorithms can solve many, but not all, computational problems." Among the topics I am expected to cover in the context of this standard are algorithms that run in a reasonable time v. those that don't, the difference between solvable and unsolvable problems, the use of a heuristic, and the existence of undecidable problems. My plan is to cover the 0/1 knapsack problem, the heuristic of a greedy algorithm, and the halting problem. This is a relatively small part of the course and is assessed by only a couple of multiple-choice questions on the AP Exam, so I don't need more than one lesson (or two) of material. That said, I am afraid any one-day lesson will be inevitably reductive as these are complex topics. Moreover, the students are new to programming and computer science in general, so I need to balance abstract with theory with concrete, relevant examples. What lesson ideas, examples, and/or analogies do well to serve the teaching of this standard? 

In “Gift of dyslexia” — Ronald D. Davis, one of the techniques used, to overcome dyslexia, is to make physical clay models of letters and words. As I read the book I realised that as a child I had made similar models in computer code. In the book they made models of letters, numbers, words, objects, verbs, ideas E.g. a model of “the” and the word “the”. I continue to create models in my head when I am learning. Not just the basic reading/writing concepts, but advanced stuff in CS, science, maths, … However it is sometimes easier if there is a real physical model. Therefore it is often good to have some physical model, but remember (and tell the students), it is just a model. All models are wrong, but some are useful. I like to use old mechanical computing devices, when teaching concepts in CS. I love the look on their faces, when I tell them that it is still done the some way, but smaller, faster, and with electricity in place of cogs, but still the same. So yes do it, but don't over do it. Mix it up: visual, audio, active, models, hands on, etc. (I wonder if you can use smell) 

When teaching I often have pupils struggle in the first few minutes. When they are setting the computer up, ready to start work. They often have to follow lengthy instructions, that I print on paper, of mostly screen snips (So this also takes a long time to prepare). What can I do to make this easier for pupils? For example I have had a lesson where I have had detailed instructions on setting up Python/Idle: Starting the editor, finding starter code, they contain many screen shots. This took me a long time to prepare, and is not easy for the pupils. They are not productive at the start of the lesson, and get demotivated. They need to get to: 

There is “A touch of class” by Bertrand Myers. It is a very good book, at least a semester worth of learning in it. I did not get OO, until I read it. I had previously done C++, java, C#, and some python. But when I read this book, I started to program OO properly. The book uses a language called Eiffel. It is a good teaching language, and also used in large systems, safety and mission critical systems. It is probably quicker to learn Eiffel then another language (or two), than try to learn other OO languages from scratch. (This is the authors clame, and my experience as a learner) 

Computer science is a discipline of problem solving. I use this phrase from CS50 often (mainly because I teach an adaption of it): 

Lately I've come across Conway's Game of Life in a number of different arenas (articles, conferences, blogs, etc.). Last night I coded it up in C and was utterly mesmerized watching it. That being said, I'm trying to come up with one or two precise, concrete, engaging concepts I can use it for in the classroom. It comes up in my course (CS50 AP) as part of a lesson on simulations. The objectives from the AP Computer Science Principles curriculum are as follows: 

This now becomes a teachable moment on a number of levels: imperative v. functional languages, recursion v. iteration, "expense" of function calls on the stack. Students appreciate being shown the messy truth behind topics that are sometimes treated reductively and simplistically. Let them wade in the mire and see what they think about these debates. Have them analyze the arguments they mind on here; now they are thinking on much higher, more sophisticated level about program design. The key line that I take away from all of these is this one: "You almost never use recursion for performance reasons. you use recursion to make the problem more simple" (top answer to the first post I linked to). It's often times an exercise in thinking more so than programming. From a pragmatic perspective, discuss use cases for something like merge sort and quicksort (recursive) v. bubble sort (iterative). Throw in traversing tree structures as well. There is a time and a place for thinking recursively. Iteration is not always the best choice to make. Last, from an aesthetic perspective, based on my time studying SML, there is a beauty, an elegance, an aesthetic to a well-written recursive function. It's clean, clear, easy-to-understand. If part of code quality is its readability, then recursion has an aesthetic quality to it that a for-loop arguably does not. 

I have a few suggestions based on my experience this year. I have one prep over two blocks, which meant that for every exam I wrote, I wrote two versions. Moreover, because I take a standards-based approach, students end up retaking the exam but a modified version at that. For some exams, I ended up with 4 versions. Here's how I sped up my own process: Focus on proficiency. Not every questions needs to "trick" students. (Indeed, "tricking" should never be the goal of an assessment: it should be an accurate measure of what a student knows and can do at a particular moment in time.) If I believe proficiency is 70%, then 70% of the points should be relatively straightforward questions that all students should earn. Maybe another 20% consists of slightly more challenging questions, saving the final 10% for the questions that might focus on the most subtle of details. By focusing on what all students should be able to do, I can worry less after the "craftiness" of my questions and get right to the heart of the matter. Write questions designed with substitution in mind. Let's say I'm asking questions to test a student's knowledge of basic Linux commands since it's necessary for our IDE. Whether I ask about , , , , etc. should be irrelevant; they are all fair game. Thus, one approach is to tell students to review from a list of terms, and come up with a potential set of 4-5 answers. Then, from class to class, you can simply change what term you are asking about. The answers don't change, but the questions do. No student will know in advance which terms will be asked about just that they will be asked about. Keep the method, but change the input. I recently assessed students on Python, and I wanted them to be comfortable with two key concepts: the use of for iteration and the basics of string access and manipulation. I didn't have to change the instructions from class to class very much, but by changing the input, I gave the two classes unique exams. They knew to expect questions on strings and iterations, but until they are faced with the actual input, this bit of information does not necessarily help them answer the question. I may have more ideas come to me as I read more responses, but here's my final, overarching thought: EXAMS ARE NOT SURPRISE PARTIES. Students, assuming they have been present and attentive in class, should not be surprised by the content of your exams. Let them be occasions for students to show you what they can do. While we as educators might stress over the perfect question to ask about, say, an , it should always come back to this: "How I can fairly and accurately assess what a student knows?" It is not, however, a chance for us to show how clever we are. Get to the point. Be clear; be fair. Let students prove how much they have mastered. Keep that mantra at the forefront, and test design can become simpler and faster. 

If leaning Object orientated, then I believe that learning Eiffel first is quicker. [This is not based on my teaching experience, it is based on a claim of Bertren Myers. Any my experience as a programmer. When I learnt Eiffel I realised that I did not know C++, then I knew C++.] 

I got this link from reddit $URL$ maybe it will be of use. But I doubt that it will make git easy to use. 

I would start by ensuring that you have a system with a good command line: Such as Gnu/Linux (A implementation of Unix, with freedom). It is also Free Software. While using it you may discover some piece of software, that you would like to improve. You could do what I did at Uni. We were asked to re-implement the basic Unix tools: cat, ls, grep, etc, this is good practice, and a good place to start. It will also help you learn about what Unix can already do. (What can be a 3 month project on windows, can sometimes be a single line of shell code in Unix.) 

You should always be researching. I am using research in a loose way here. Just as you should always test the programs that you write, you should always test the lessons that you teach: Evaluate how you own lessons go. Then tell others about the good ones. And here is the hard part, to be un-bias, tell them about the bad ones, tell them what did not work. Read and Promote So much policy is based on a whim. Read research, check on the strength of the evidence (sample size, method, reproduced, statistical significance, effect size, etc) Then try it out, and promote it, as above, but also by sharing links to the evidence. Evidence vs Emotion Evidence is important, but people make decisions on emotion. They will first make the decision, and then try to back it up with evidence. Therefore after you have found some good research, write an article to promote it. Instead of: “It has been shown that ???? is a good technique to engage your learners and improve out comes…” Re-write it like this:“Do you want to make lessons more fun for you and your students, want to improve grades, and spend less time preparing lessons? Then we have something for you. ???? is …” see “Start with why” — Simon Sinek (ted talk video)