The last thing: comparing s using operator after performing arithmetic operations on them can be wrong due to the rounding errors(I refer to this part of code): 

It's normal for Java programs to be longer. I wouldn't care about the number of lines per se. The method does too much stuff: 

there's no point in making a field. It can (and should) be just a local variable in the method. The same is true for other 's and test methods. Class design I don't think that the is a good name for your class. I would expect a calculator to be able to be instantiated once and then evaluate results of different expression. Something like this: 

Clipped Cartesian Space A bit of Linear Algebra Since it was mentioned in the question, perhaps there are some useful abstractions there. It is possible to think of and as two matrices. Each has two columns and an infinite number of rows. Going further can be transformed into the other matrix by the 2x1 matrix [1,-1] where the values are arranged in a column. Going back to the original Cartesian grid, we translate the solution for the portion of the diagonal lying in one quadrant, into the relevant diagonal for the other column: 

Makes the code more modular and expresses the 'business logic' in the underlying problem explicitly. Because Racket treats functions as data, higher order functions allow further expression of the business logic and decoupling within the implementation. 

There are several places in this code where a loop is redundant(or at least can be simplified). For instance, this for loop: 

First of all, you're using a wrong algorithm. A depth-first finds some path, but not necessarily the shortest one. What you actually need is a breadth-first search. You can just use a queue instead of a stack to fix it. Storing everything as a string is bad idea. You code'll be much better if you use appropriate data types. The position on the board or a shift vector for one move is not string. I'd suggest to create a separate class that holds a pair of integers to represent a position on the board and has a and an method (to get the next position after one move and to check if a position is valid). I'd also recommend to separate the code that reads the data and prints the result from the part that actually runs the computations. Fixing the indentation and spacing of code according to the Java coding convention would make it more readable. The names of the variables are also not very descriptive. For instance, what does mean? What is (which is, in fact, not really a string)? I have no clue. It should be something like and because that's what it actually is. 

The last piece is to undo my arbitrary choice of origin. It boils down to a simple 2d translation. If the bishop is on square then the equations become and . 

Sending a confirmation email requiring reply is a straight-forward method for validating email procedurally. When possible, not collecting email addresses at all is easy to implement. 

Optimization based on the Data If the data is not random or contains structural relationships then the search space can be pruned of values that cannot occur. For example, if in the tuple x it is always the case that when x1 = 0, 15 <= x2 <= 42 there is a constraint on the search space and we may not need to iterate all the permutations. Optimization base on Question If we are searching for the maximum of: (x1) / (x2) + (x3) Then we can prune x3 to a single value and similarly prune the pair (x1, x2). The Good News We never [outside of a classroom] need to produce the entirety of all at once. There is always some reason we are producing it and looking at that reason allows us to optimize. The price for that optimization is a particular brittleness, but the naive solution of iterating all permutations is also brittle because once the problem hits a certain size it doesn't work. Alternatives Data Compression can push back the point at which the non-polynomial nature of combinations limits the size of the input set, but it can't eliminate it. TANSTAAFL. Data compression, like any optimization, only works when it reflects a structural characteristic of the problem. Advice 

In fact, it can be a good idea to go even further and split your code into multiple classes (a class should also do one focused thing). A reasonable way to do it would be to, make the following classes: 

Separation of concerns. Ideally, one method should do one thing. I would expect the method to actually rotate the array. That's it. Your method also prints something to the standard output. There are two reasons why it's bad. Firstly, it's confusing. Secondly, it introduces more reasons for the method to change. For instance, if you need to change the format of the output or write it to the file, you have to change the rotate method. It's not convenient, is it? The interface is quite strange. The parameter of the method is redundant (it's expected to be equal to the length of the array, isn't it?). It also makes the interface less clear (what if I pass a different value of ?). The algorithm itself is not efficient. Shifting the array be one times requires time. There are at least two ways to make it linear. The first one is pretty simple. You can copy the entire array to a buffer and that assign in a loop. However, it requires additional memory. The second one uses a constant amount of space and operations. It goes like this: to cyclically shift an array by positions to the left, one can reverse the range, then reverse the range and finally reverse the entire array. Documenting your code is a good practice. It's not clear what the valid range of values for is from your code itself. It's also not clear whether it performs a left or a right shift. Your code formatting violates the Java coding conventions. The indentation is kind of messed up. The binary operators are not surrounded with whitespaces. The names of the variables are not meaningful (for example, what does stand for?). That's why it's hard to read. 

General Design The pattern means that each iteration performs IO. Because IO is slow and blocks writing the results of each multiplication to an output array and then batching the IO by writing the output array all at once is likely to improve performance. Algorithm From a pure algorithmic standpoint, using modular powers may significantly reduce computation. This website provides this example: Let us compute 1143 (mod 13). As we saw before we start with squaring this number: 

There are two levels to the problem: Computer Science and Idiomatic Programming. Computer Science The simplest structure for matching parentheses is a pushdown automaton. Pushdown automata consist of three parts: 

Implement a slow but obviously correct solution (in this case, it would just generate all subarrays, compute their sums and choose the best one). Generate thousands of small test cases and compare the output of your solution and the naive one. It's quite likely that you'll a test case your code fails if it's actually wrong (that's exactly how I found a counterexample to your algorithm). 

About thread safety: it is not thread safe. There is nothing that prevents member-functions such as , and others to be executed by multiple threads at the same time. Inside these functions several variables are modified. Modifying them from multiple threads without synchronization is an undefined behavior according to the C++ standard. How to fix it? The easiest way to do it is to use one for the and member-functions of the class(acquiring it in the very beginning of the function and releasing it in the very end). It is convenient to use an for this purpose. Something like this: 

Using an internal function, recursion, and a trampoline is a good way to structure recursive procedures on a lists. The code fragment is the same as . The name suggests an accumulator, however, the value it stores is the maximum, so might be better. Because of the letter can be confused with , can be read as slang for 'first'. I prefer as the name for a list of 's. The nomenclature has become more common in Lisps over the past few decades due to the influence of other functional languages. No matter how it is dressed up, there's a procedure in the code somewhere. And it has to be written. It is better to be explicit about it than to try to hide by embedding it in some other function. 

You can just remove it (and all other similar comments). Moreover, if you need to make a comment about what the piece of code does (like "# Then check if the value is nonintegral"), it's a hint that it should probably be implemented as another function with a descriptive name. You should strive for a self-documenting code. 

I do not see any reason to use pointers here and cast them explicitly every time you access an element. You can just use and get rid of all casts. You can also use smart pointers( looks like a good choice here). Here is my version of this class: 

This review is in response to the request for help on "overall coding practice." It does not delve into the syntax or semantics of the C++ language. There are three levels: Computer Science, Architecture, Variable Names. Computer Science Technically the implementation is not a stack because: 

The solution exists in the 99th layer of Odersky's onion because it requires 99 moves. With two glasses There are only six transition operations at each level of the onion: 

The class maintains the nodes as a set in order to provide set semantics. It uses to maintain a bag of edges as recommended by the Python documentation. The implementation of undirectional edges is left as an exercise. 

Printing the error message to standard output looks like a bad design choice (if you code is run automatically and no one is checking the output, it would just silently return . I don't think you want it). It would more reasonable to throw an exception in this case (I'd throw an instance of the ) because a situation is exceptional (the input is invalid and there's no meaningful way for this function to handle it). Moreover, one function should be responsible for one thing. Your code computes the value of the ackermann's function and does the logging at the same time. It's another reason to handle invalid inputs using exceptions. You can also simplify the code in the function by parsing the input as an integer. There's no point in parsing it as a float and then checking if it's an integer. You could rely on a standard function to do this job for you. This way, it would be enough to check that both numbers are non-negative. Now let's talk about variable naming: