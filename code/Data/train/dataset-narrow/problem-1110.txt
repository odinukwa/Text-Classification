I don't know what is. I'm guessing it's 26, but that's a guess. Also, what if is, say, 100? You haven't imposed any range on it, other than the conversion to . Let's replace the conditional stuff with an expression: 

Right off the bat, I have the ability to get rid of some of your "explanatory" comments. Getting rid of comments (in favor of "explanatory" code) is always a good thing! But really, it still looks bad. - WTF does that mean, anyway? Let's slather on another layer of macro: 

See this article by Raymond Hettinger for more details. Don't hold open files you don't use You open files in that you don't use and don't close. Avoid this. Instead, open/read/close or open/write/close them when you actually need to. The open operations are cheap compared to writing or reading from a file, and file handles are a scarce resource. Also, doing your open/read or open/write at the same time allows you to use the preferred Python idiom, , for your file I/O: 

We can use this in reverse: If K=10, as above, then K/blocksize == K/3 == 3 (remainder 1). So the 10th value in the sequence would be 3 blocks plus one non-block number. That is: 

You are not taking into consideration what would happen if the end of the string occurs. C strings are NUL-terminated, meaning they end when a "zero" byte is encountered. You want to do something like this: 

I find your while loops difficult to read and comprehend. Please consider changing to something more left-to-right, and more explicit, like: 

J_H provides some good feedback. In addition, I would suggest that you combine your SQL statements into a single statement, to reduce traffic back-and-forth to the database. Your code is really asking "do these entries exist in the tables?" So ask that! Use a nested select to ask your two different questions, and just do a on them. If they're 1 and 1-or-more, you're good to proceed: 

It seems like you are doing a little too much work. The maximum sum of a node that is None will be 0. The maximum sum of a node that is not None will be the value of the node, plus the of the sums of the two children. That recursion alone should be enough to avoid using intermediate data structures. Something like: 

Your current constructor makes a perfect function. Why do you need to after initialization? Are some of your members not properly initialized? If only there were some way to specify the initial value of an aggregate type... values are , which conveniently is large enough to hold a . Instead of creating enumerated values that are integers, why not create values that are characters? 

The same is true for the filtering of : you are looping over all rows, and then for each row you are looping over all rows again. This is operations, or O(nÂ²). There is no simple way to fix this. If you insist on computing the distances from each point to its surrounding points, you will have to structure your code this way. However, there are some alternatives: 

Congratulations! Your code looks pretty good given the background, and you have done solid work incorporating the suggestions from the previous review cycle. Decompose More With that said, I'd like to see you making more use of functions to decompose the activities you are performing. For example, you have some in-line code for loading the game data. Move that to a function that returns an object or data structure. Call that function from inside main. Likewise, is a bit too complex and too low-level. You also have some code that looks like it is left over from a previous iteration: . As far as I can tell, is always true when you do the test, which suggests that you intended to use it for something and changed your mind, or changed the code, or went and had lunch and came back, or something. I'd suggest you push your load-or-create-player decision down into a lower level function, break the loop if it returns (meaning "Exit Game"), and otherwise treat the two (load/create) cases as the same: you loaded and are ready to go, or you created and are ready to go. Centralize UI Actions You do a lot of work handling and testing user input. You implement menu selection in several places, and print messages to the user all over. I've suggested this in other reviews, and I'll suggest it here: create a class that has methods for common operations. Then call those methods! They should return whatever-you-need-them-to-return, correctly formatted and checked. If you write a menu, then the result should be an integer or a string (your call). If you ask for a number, the result should be a number. If you ask for a choice, you can pass in key=value pairs to define the choices and return values. The point of this would be to shrink the code you have, and eliminate any use of or statements, replacing them with calls to specific methods that always work and don't need to be checked. Keep Your Hands to Yourself! Finally, I'd like to point out this code from your class: 

The important thing here is that the method which deals with the fields and properties is a method, not a method. That means that if you decide to change how blocking works the changes will be in one place: on the Likewise, when you do damage to a monster, the class should handle applying the damage. That way, if you invent a monster subclass that is immune to swords (or whatever), you can implement that inside the subclass, rather than having to code it up in the various Hero subclasses. This is not to say you cannot use the attacker's info. For example, if is immune to swords, then the method could check the attacker's weapon. (Or maybe there needs to be some kind of attack details object...) But the part where it is immune is definitely internal to the class. And the part where it updates health, and divides by 2 if blocking, and ... Bottom line: don't touch another object's private data, let the other object do it. EDIT This is in response to your (first) comment. Consider what you are trying to do in : "Ask the user how they want to play, or if they want to quit. Then either quit, or set up the game the way the user requested, and play." First, the presence/absence of a save-game file is something you can detect. So you should only ask the user if they want to load a saved game, if there actually is a save-game file available. Otherwise, the menu should just be "New Game or Quit". This is something your code can check for: 

I have a few issues with your code. First, objects should always be valid. When you separate initialization and configuration, you create a seam into which bugs will surely crawl. Next, names matter. Your naming, and orthography, are somewhat bizarre. I'd suggest that you change your and classes to . I don't see any reason why the two should be separate classes. Instead, I think you need a single class with some helper functions. (Creating a class to "do something" is a Java-ism. Python very much isn't Java.) Your attributes should be spelled out. Remember that writing code is much more about communicating with the next maintenance guy than with the compiler. For use cases, I can see a couple. First, you might create a "character class" mechanism, with certain minimum and/or maximum attribute constraints. Second, you might have a "monster" mechanism, where it is interesting to specify some attributes, but the rest can be defaulted. So let's try those two things. First, the "specify some attributes plus a default" approach: 

I encourage you to abandon your present approach. Instead, try expressing each of your A/B/C/D proteins as integer numbers. Then express those integer numbers in binary form, and see if you can determine the operation(s) underlying the very, very regular pattern visible in the table given in the problem. If you transcode the "protein sequences" to a series of 2-bit numbers, I believe you can profitably perform your mutations at a high rate of speed. 

Iterators I'd suggest writing at least one position iterator for the . Something like , that would the cell positions in the right order for display. (Note: if Cell objects knew their own Position, I'd suggest just writing a Cell iterator and skipping the Position. But as things are, this is the way to go.) You could rewrite your function as a method: 

This looks like it might actually make a nice function for itertools. It just needs a option, I guess. 

You need to do a better job separating the "game board" from the verbiage. Also, maybe put some quotes and other punctuation around the printed answer: 

Command your minions. This is purely a "social convention." But the standard convention for commit comments and function documentation is to use the Imperative Mood rather than passive voice. It's almost as if your program is telling the computer what to do. (Wait, what?) Change this: 

Not a code problem, but a logic problem: why use player 1 and player 2? You ask for their names, and then the sigil they should use. Why not simply call them 'Player X' and 'Player O' all the way through? You could eliminate a lot of code that way. Your code does not have "basic elegance" of structure. This is hard to quantify, but I would say that basic elegance requires that your control structures be used in as natural a fashion as possible. Consider this: 

You are basically reformatting one group of fields into another. I'm not sure if that's a good idea - you might want to just make a straight-up copy of the fields, since that improves your "audit" capabilities - but if you're forced to use that format, then you're forced. Regardless, see this SO answer for an example of using a nested SELECT in an INSERT statement. You can obviously apply your formatting expressions to convert the field data. You'll want to do something like: 

When you are reformatting raw data from one device to another, be wary of Byte Ordering. Your code suggests this is not an issue - it may be that you simply aren't aware of if, or it may be that some lower-level library is handling this for you. When you are fetching single values, you don't need to allocate and free memory. Just examine the source memory area and return a single object. You can construct integer objects by fetching bytes, shifting them some multiple of 8 bits, and using a bitwise or to merge them together: uint16_t read_short_le(byte * p) { return *p | *(p + 1) << 8; } uint16_t read_short_be(byte * p) { return *p << 8 | *(p + 1); } 

But what if there was a dedicated function that returned empty neighbors? (Or unset, or reset, or however you want to call it):