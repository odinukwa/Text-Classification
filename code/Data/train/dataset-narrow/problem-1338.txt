You can still use a enum if you'd like but this function is very similar to so would seem to suffice. Every enum class has a function implementing (Enum Classes - Kotlin Programming Language). As such, would declare both and which seems confusing to me. I suggest defining superior and inferior check functions instead of but this may not be practical depending on how you are using : 

In some languages variable names like are common and expected but in Kotlin (and Java) I find it more common and expected to have variables names avoid abbreviations, use camel casing, etc. I recommend using instead of . You are returning a . This is fine but data classes are so much better and Kotlin makes it so easy to define and use them. I recommend creating your own type to return. e.g.: 

I wouldn't use or because it makes it appear that can be greater than which is not true. I recommend using . 

Personally I prefer "row/column" instead of "y/x". Thinking "y" before "x" is unnatural. You can always define your own methods too which can improve readability. e.g.: 

In my opinion, the main factor in preventing you from having a clean primary constructor is indeed the two paths to the super class (via or ) and having a super class define the property is in fact what also prevents you from making this a data class. I recommend making an or with no properties in its constructor. e.g.: 

You might want to take a look at Delegates.observable - stdlib - Kotlin Programming Language which you may be able to reuse to improve and reduce your code. 

will return . will return . If you want both to return then replace the with in . Marking as is purely optional but it seems to me like a good fit. 

This isn't very convenient but thankfully Kotlin allows us to use reified type parameters to define an extension function to simplify this: 

Sometimes in Kotlin you don't have to declare temporary variables so that you can do something with a return value before returning it. e.g.: 

You're method is not transitive (e.g. and but . See Any.equals - stdlib - Kotlin Programming Language for more details on the requirements for . You might also consider using from for testing your own implementations of . If you define your own method instead of defining a custom, non-transitive implementation than your existing solution can become much simpler: 

Another benefit is that automatically becomes a field for any object (this is also possible with standard class declaration by prepending to the front of the parameter.) These two examples don't really demonstrate the full utility of so if you'd like to learn more check out this link. STYLE Current Scala dogma utilizes camelCase. So I've swapped and for and . I also added a return type to your method . A QUICK NOTE ON TYPES One of the cool things about types is that they allow you to constrain your program. For example, as your method currently stands there are over twenty different collection types (of the mutable and immutable variety) that may be passed in for (see these inheritance graphs). Long story short, I swapped for . STRING OPERATIONS Finally, to get around calling I utilized a method from StringOps called which returns if the caller and the input are equal (regardless of capitalization), false otherwise. To be honest I only changed this bit to show you another possibility. 

Lists vs. Arrays The Scala version of your code ran surprisingly slower because you used a . In Scala you can think of a as a traditional linked-list. s don't provide random access to their contents. That is, accessing an object at index n requires O(n) time. This really slowed down your code because you index into in both your inner and outer for-loop. To fix this problem you can simply use a different data structure like an . 

I would say that your latest code looks fairly sharp. However, after translating your code to something I could test, I noticed a pattern that could be captured with the code below: 

As Illya has mentioned Regex alone cannot solve this problem. Instead, we must employ some type of stack-like data structure to give our program memory of past characters. The first three lines of the main function are just a cheap way to replace blockers with a single character. A better solution would be to tokenize so that this isn't necessary. 

Below I've written up an implementation of a recursive bubble sort that addresses the main concerns you mentioned. The areas your code can be improved matches what you instinctively pointed out in your bullet points. Whenever you use a or in Scala remember that it is in fact a linked list and so accessing an element takes linear time. This could add a significant number of operations to an implementation of bubble sort that utilizes a . As a substitute I used an which offers constant time access to elements. It is also worth mentioning that the container is mutable in Scala even if it is declared as a . We can kill two birds with one stone by rewriting the while loop as a recursive procedure. The two birds are and and our trusty stone is . 

This question might be more appropriate for programmers or codereview, but, this is what a code review of mine, probably with at least one controversial statement inside somewhere, would go like. Hopefully you will find some advice in here that answers your questions. 1) Make sure you want to be using C and not C++ (or Java, Perl...) for whatever you're doing. If you can avoid doing strings in C in real life code, always. Use C++ strings instead. And if you want a sturdy C library to do this in, consider glib (or writing C++ wrappers). 2) If you want to write a full ADT (abstract data type) for strings, follow the usual C paradigm: You should have functions , , and . The init will typically have a and if so cleanup will definitely have . The s I think (not sure) are only safe provided happens first and last, which without an that s would be bad. 3) But in real life I think an ADT for strings, which experienced C developers can program in pretty fluently, will make the code less readable, not more. 4) Always work on the stack when possible. is preferable to dynamic strings when possible, and it's possible more than most developers think. A few wasted bytes from safely overestimating is worth avoiding a crash or leak from dynamic memory usage. And your function from its signature looks like it will accept a stack variable as its first argument, then bam! realloc. If you're going to do something sneaky like this, it pretty much has to be with an ADT you wrote via a pattern similar to (2). 5) Along those lines, the usual way to pass a string to a function is so the caller is responsible for memory management - and in particular gets to choose whether it's stack or heap - and the inside of the function just respects those parameters passed. If you braek this I strongly recommend the ADT pattern in (2). 

You should be switching on event loop enum, which means, oh god, you have a three-layer switch. In any case, mp1 basically has an "on" operation and an "off" operation. You should code these up - either add them to mp1's class, or create a new object, or simply write helper functions, etc. This will reduce your inner switch to a much simpler one-line on/off situation, which is very clear and a good use of switch. In general very few lines of code should happen in switches: they should be functions that do analogous actions, on the same level. mp1 should be I think. 

Unfortunately this can sometimes look a bit strange using , etc. but in Kotlin 1.1 you can use bound callable references: 

And you can even pre-compute the required capacity to avoid unnecessary array copying while building the string: 

which will avoid creating an intermediary list (small optimization in this case). Perhaps a minor issue but I personally prefer using "index" instead of "i" or "idx" to avoid any ambiguity. "idx" actually has several meanings. I find used with to often be more readable than combined with : 

If you are going to have classes for computed numbers than I find (like ) much more readable than for , , etc. Naming an instance of as simply "tree" is rather confusing, I recommend using type names (at least the end of them) at the end of instance names (e.g. "stageTreeWidth", "stageWidth", "treeWidth", or simply "width"). Kotlin has a neat function to simplify building strings with a repeated char sequence. e.g.: 

If is never used then even itself can be eliminated and the tree string building logic can be placed in a single function: 

Using as a function name seems very ambiguous. The method name used in the Java class from LeetCode seems more appropriate: (thereby specifying that the arguments, although not numbers themselves, represent numbers). You can remove the explicit type specification for if you add explicit type arguments to . I personally find this more readable and less verbose: 

Instead of using you might check to see if the given product is greater than the currently known maximum product and then assign it if it is. This is minor but personally I prefer to avoid unnecessary assignments. I wouldn't worry about trying to do all of this in one pass. Each directional slice has different row/column bounds so I think four separate loops is the clearest/cleanest. You can remove some duplicated code when it comes to calculating the product and updating the maximum. 

You can use the slightly shorter instead of . You can also move trailing lambda arguments out of parentheses: 

Technically a "trunk" does not include the branches, etc. so "TrunkWidth" and "Trunk" are kind of confusing names for this. You might consider "LayerWidth" and "Layer". I see very little point to all these classes as they do not serve much purpose. A class with a single method to define its single behavior might as well be a method. If , , , etc. will be used by methods other than then it might make sense to have these as classes. If they are simply to build a string representation then I would drop them in favor of inline calculations (OOP does not mean that "every thing is a small object"; e.g. "height" and "width" may be attributes of objects but are not necessarily objects themselves). This entire collection of classes can be reduced to the following (assuming no other code is using , , etc.): 

You likely have a bug. if / if / else if will often trigger first if, and else if. Update: your code is indented horribly. And that's crazy, you basically have a nested switch. Yes, way too obfuscated. Please fix. int loop 0 and 1 only differ by one line of code. Just do them in common then 

There's something wrong with each of them, but I think what's wrong with the first one is more acceptable. The first has the defect that it requires unique prime factorization and the fact that . That's a pretty well-known fact, but the problem was "if 3 then fizz, if 5 then buzz, if both then fizzbuzz." The problem says "if both." so write "both", which means "". You used a math trick to condense this expression when the original problem did no such thing, so you lost faithfulness to the original problem. Simplicity of the math trick is besides the point, in fact. The second one is terrible, except I can think of one strength. Character-by-character string manipulation induces character-by-character thinking. Why did it drag me down into this sort of analysis? It's far easier to type and think "FizzBuzz" than it is to ponder on how "FizzBuzz" is a beautiful thing, made up of its constituent parts. Strings lend themselves to annoying off by one errors. I.e., where does the new line go now? It works correctly but I guarantee you it requires thought to write or evaluate. The second program is more expandable. FizzBuzzBazz would be a much easier program to write given the work in problem 2. It's not quite data-driven, but it would very easy to accept an Array of Strings corresponding to prime factors 3,5,7,11... and turn the second program into a loop. Also note that the problem statement in the more general case requires thinking about string concatenation. In general, I condone data-driven generalizations, so if the input to the program were a map of prime numbers to Strings, and it were implemented with a loop instead of an extra if block, I might call it clever but in the best of ways - it solves a more general problem, and data drives the magic numbers, and therefore has better separation of logic from appearance. For the kicker, also note that the first is a step away from generalization. So, it's applies to oranges: Invoking , or writing character-wise code that is halfway on the way to being more general. For what it's worth, I would prefer the first of the two. 

I've introduced a smidgen of strange syntax just to show you a possibility. As a way of explaining what is going on, consider that the following are functionally equivalent: 

Hmm I'm not sure what the requirements for 'python koans' are, but if you are getting counted off for the conditional, here are two alternatives: 

In Scala the pattern is an expression, which means we can use it to return a value (similar to Java's or C++'s ternary operator). You don't have to change much in order to take advantage of this: 

that you are immediately throwing away because you aren't assigning it to a variable. In other words you should only use a list comprehension for building a list, not for calling a method that is doing work elsewhere. An alternative implementation is as you might expect a nested for loop: 

Overall I'd say your off to a great start. Here are some of the changes I would consider making to your code: Formating Output When printing strings that encapsulate values/variables you have two (idiomatic) choices in Scala. Option one is to use string interpolation: 

To remedy this bug just call . A possible concise (and correct) solution to your problem using the built-in methods for sets in Python: 

Pattern Matching Within the helper function each layer of the recursion checks the value of against some constant value using an if statement. The more idiomatic way to do this in Scala is to use pattern matching. For example: 

When pattern matching and inspecting multiple values of a sequence type (, , , etc) you can reduce the length of your expression by using sequence patterns instead of explicitly breaking the sequence up with the operator. So instead of you can more concisely use . When you want to check for explicit values while pattern matching on an object you can use those values instead of replacing them with variables that are then checked with an statement. For example can be more concisely expressed as When using pattern matching on sequences (especially when the expression goes beyond the standard ) it can enhance legibility to use single letter variable names and comments instead of long variable names. I think that we would both agree that good code should describe itself through both value and function names. However, in this case there is no way of adding intuition with function names and so all of the description ended up in your value names. Like I said before, do what works for you. If legibility was our only metric then maybe pattern matching isn't the ideal way to implement your function. It could still be recursive, but instead of s you could use functions. Do whatever suits you the best but when possible I would recommend short variable names accompanied by comments over long variable names.