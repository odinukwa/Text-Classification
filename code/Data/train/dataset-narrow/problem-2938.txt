This function takes in a character corresponding to the card's value. I used a single as the data type for each card, so I needed a function that took in a card's name (i.e. letter) and returned its value. Were I to design this again, I would probably reduce it down to one statement and have a variable represent something like (and in that case I'd need to use statements, which I currently omit thanks to ). That said, the statement is a clear example where you don't want a bunch of statements. For the face cards that would be redundant. There's a nice mix of those cases that "fall through" and those that don't. Using card games where cards share the same value is a fun, but realistic example for students to see the value of a switch statement. I'll share one other short example where students have to implement a command-line calculator in C and used to identify which operation to perform. Here's the from there: 

I could keep going on and on, but this is sufficient for now. I believe strongly in CS50 and CS50 AP. The edX course CS50 quite literally changed my life. As one of their shirts says, I am "CS50 Proud." 

Key take-aways: goal-setting (both big and small), breaking the task into smaller pieces, assessing work at the end of each day to prepare for the next, keeping them accountable, deterring procrastination (as much as feasibly possible). Heeding student feedback, I plan to incorporate more formal check-ins along the way next year using the outline of the CS50 Final Project to guide how I structure the time. The four components of the final project are Pre-Proposal; Proposal; Status Report; and Implementation. Since I have four weeks, each component will be able to match the weekly progression quite nicely. Ultimately, when in doubt, I trust student feedback to tell me what worked and what didn't. That trust is key in my reflection on areas of success and areas for growth and in my improvement as an educator. 

I undertook this study myself about a year ago. I started working through the Programming Languages MOOCs on Coursera (Part A Part B Part C), which are based on a UW course of the same name. I didn't really know what I was getting into, but it sounded interesting. Before I knew it, I was learning a radically different approach to programming first with SML and now with Racket (Ruby is up next). Here are some of the key ideas that were a major departure from my having programmed in C and Python: 

I taught AP CSP this past year, and I cannot speak highly enough for the curriculum that CS50 has written for this course. I'll try to enumerate its strengths as objectively as possible: 

Scaffolding concepts in programming is essential to avoid that conceptual leap that is a hair too great. The logic of shows a logical progression of increasing complexity. It also affords those interested and more experienced students an additional challenge. Understand Sinatra? Move on to Rails. The extension for further learning is also an important factor to weigh. Where do you want all students to end up in terms of competence? What about this who want to and/or who can exceed that expectation? 

Once I do this, I can focus on each of these four parts, so students understand the different components that make up a loop regardless of the structure thereof. 

You've just demoed your first bit of code in whatever language you're teaching. The requisite "hello, world" has been said. The program has been compiled (or interpreted) and run. Now what? There has to be a program that follows "hello, world" that builds upon the basics of printing one line on the screen. What is the logical next step in an introduction to a new language and possibly to programming as a discipline in general? We all know program #0; what's program #1 and why? Note: I know this is subjective, but I'm hoping it leans the good way. I'm trying to ascertain the scaffolding at an introductory level. Once the cliched example is complete (not that it doesn't have a lot to teach in and of itself), what makes sense as the next curricular step? I think the need for justification based on experience, expertise, and facts helps it from being too broad, but I'm happy to revise if necessary. 

Build logic gates out of dominoes. Start off by showing this video from Numberphile in whole or in part. In it is a demonstration of how to use dominoes to model logical operations of a computer. It begins with a simulation of an gate and writes out its corresponding truth table. This is followed by the same process with , which then allows for the construction of a half adder and in conclusion a full adder. (You may also share this video with students, which contains an elaborate, 10000-domino construction. Per the YouTube description, "The result was a Domino Computer capable of automatically adding numbers. It can take any two four-digit binary numbers and return the five-digit binary sum.") Then challenge students to build elementary logic gates themselves (you might need a lot of dominoes, but I bet it would be worth it in the long run). You could start by having them come up with designs for , , , , , etc. on their own. Depending on how this goes, consider using this resource to help guide the design of gates in dominoes. After students create these gates, consider giving them longer Boolean expressions to model and solve using dominoes. This would also be a clever way of showing how DeMorgan's Law works. The level of complexity knows almost no bounds with this approach. I could see some students, especially those with a love for computer science, who would thrive doing a hands-on, constructive activity like this. 

At the end of the year, there is a gap between the AP Exam for AP Computer Science A and the last class meeting. Since students don't have to take a final after the AP Exam, there's not a lot of motivation for additional graded work. Nonetheless, I want to make the time meaningful, so my plan is to put together a short unit on Alan Turing, his contributions to CS, Turing Machines, Turing-completeness, the importance of the Halting Problem, the Turing Test, etc. Hopefully, I can integrate clips from The Imitation Game as well to increase engagement. The unit as a whole would last a little over a week and would be engaging (as something post-AP Exam in May has to be). This would be for a small class of students just having completed two years of AP Computer Science and very likely studying CS in college. Are there short lessons/units you have on Alan Turing that students respond well to? If you've taught some of the above concepts before (TMs, Halting Problem, Turing Test, etc.), what classroom resources do you have to explain them in a short, student-friendly manner? 

As a tool for differentiation, writing out code by hand is absolutely worthwhile. I taught this year in a classroom with whiteboard top desks, and students loved a) getting to writing on their desks (even being encouraged to) while b) learning syntax through multiple modalities. What might catch a student's eye or get instilled in her memory through handwriting is not the same as what she might see in her code in an IDE. On a pragmatic level, the AP CS A Exam requires students to answer free response questions, so it is essential that they be prepared for this task. I would be doing them a disservice to not require some form of written examination. That being said, the extent to which you grade this might be the determining factor in its success. As a formative assessment of syntax and of logical thinking, it works great, but again, unless its specific exam (or interview) preparation, it seems less effective or worthwhile. As noted above, students have to learn how to debug by reading and analyzing error messages. Nonetheless, I don't believe it's so much an either/or here. Use the handwritten assessments to inform instruction and re-teaching and to teach and reinforce concepts in a differentiated manner. 

I first heard of Parsons Problems thanks to CS Teaching Tips. They define these problems as follows: 

This analogy is strengthened by the use of "is-a" and "has-a" in the context of OOP. The transition from natural language constructs to OOP (or vice versa) may aid in discussions of class design. For example, a Car object could be a blue Honda Civic, the adjectives blue and Honda corresponding to properties set upon instantiation and the noun Civic either being the variable name of the instance or a subclass. Using natural language also helps with as students will hopefully see relatively intuitively that a Civic is quite clearly a car, but a car is not necessarily a Civic. 

The moral of the story here is that ethics must be discussed with students as soon as possible whether it is a high school AP course or an introductory computer science course at a university. This idea of trust must be imparted to students, and it must be emphasized that the world of software engineering and computer science in general is not in a moral vacuum. It does no good to address a particular issue, say data privacy, without first contextualizing it within a larger ethical system, one that sees each user as an end, not a means, and as someone who is placing trust in you the developer. 

I used a Parsons problem to teach functions. I used Google Slides to put different colored text boxes on one slide and gave the students instructions to arrange the text boxes in the proper order. A screenshot of what the activity looked like is below: 

Some of the best information I have heard about how to name variables, methods, etc. comes from the Stanford MOOC on iTunes: Developing iOS 10 Apps with Swift. In the first couple lectures, the professor talks through how to build a calculator app (and does so in front of the class in real time) and does a fantastic job of demonstrating why he is naming things the way he is. The essence, as he explains it, is this: a statement in code should read like an English sentence. One of the early requirements for the first assignment is to read through the Swift API Guidelines. Admittedly, this is designed for the Swift language, but there are lessons to take away from this for any language. The naming can be verbose at times, but such verbosity might improve code comprehension as students will have to know what a variable or method does in order to name it properly. Even just the following two would be a great start for most students: 

These would probably be the best places to start. I suggest working your way from the top down since the standards as listed progress in what I see as an increasing order of complexity/rigor. 

If the goal is to "explain the symbolic/mathematical logic concepts" which underlie computers and computing, then I cannot recommend enough the opening chapters of Nand2Tetris. The goal of the book/course is to understand every layer of abstraction from a program written in a Java-like language down to the fundamental logic gates upon which everything else is built. The opening chapter spends time discussing the most common logic gates and their respective truth tables. The initial challenge involves forming a gate using only gates. From there, students must build , , and along with and . The relevance to "real application" is immediate: these are the most foundation for understanding how things work at the absolute lowest level of computer hardware. The assignment is certainly one that stresses symbolic and mathematical logic in a real-world context. The book is split into two parts, each of which has a corresponding course on Coursera. You can also read the first six chapters of the book here, so the first three chapters, which focus heavily on logic and low-level hardware, are all available at no cost. 

My recommendation is draw from Brian Kernighan's course at Princeton that is designed for a similar audience to what you have. Here is the course material from Fall 2014. A few key lines from the course summary: 

I'm in the process of preparing for the second semester of AP CS A (Java). I want to review objects and classes with my students to prepare for our extended focus this semester on inheritance and interfaces. I've been using textbooks I'm not particularly thrilled with, so I wanted to put together some review material of my own and/or from other sources. My first Google took my right away to the official documentation from Oracle, and I found it to be a clean, easy-to-understand explanation of fundamental concepts of the language (which can't always be said for documentation). In particular, this section on Object-Oriented Programming Concepts is exactly what I was looking for in terms of simple, clear explanations with code samples. That lead me to ponder the following question... What, if any, benefits are there for teaching straight from documentation rather than a textbook? 

Here, 4 represents index 0 of an array of numbers I'd like to sort. I literally walk them through the algorithms, and they can see how much walking I have to do up and down the "array" in order to get it sorted. When it comes time to examine the code for these algorithms, I remark on the use of loops and how nested loops lead to $O(n^2)$. We compare the iterative approach with the recursive approach of merge sort (which certainly could be added to the "walking" demo), which goes back to something we discuss on Day 0 about linear v. binary search. I have students explore this visualization tool. There are also a number of videos on YouTube I draw from that compare algorithms sorting the same data. Students also have to complete an assignment called Sort Race, which requires them to implement sorting algorithms and test them against data sets of varying types: reversed, already sorted, all sorted but one, and random. When they see algorithms take a significant amount of time on an already sorted list, they get why it's not the preferred solution and can then go back to the code to see what slows it down (and what doesn't slow down others in some cases). 

In all circumstances students can access the programs on GitHub after class. Moving forward, I would like to develop a more consistent and effective approach. What instructional methods are most effective for teaching with sample programs?