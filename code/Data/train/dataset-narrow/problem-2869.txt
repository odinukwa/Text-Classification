It seems like the obvious answer is to do most of your detection client-side (for smoothness), and then you interpolate to what the server says if your client is too far off. The server will tick at a less frequent rate than the client (like, say, 10hz), and would probably need to have some basic "can this player have reached where he says he currently is from his last known location" code, which implies some kind of nav mesh-type solution and pathfinding. That might be prohibitively slow depending on what your needs are. You might make a design decision, for example, to not care about player-player collision on the server. Most games, as far as I know, don't even care about that on the client. It really depends on what your needs are. But the rule of thumb is that you should never trust the client. It if impacts gameplay, you have to at least verify it on the server. 

I think you can buy most motorola phones without a contract. If you did want to use them they would only work on Verizon. Like you can probably buy the Droid 2 by itself. 

Rim lighting. $URL$ Basically you increase the brightness of a surface the more the tangent is pointing away from the camera. 

First make sure that everything else is set up correctly. In a different script that's running somewhere, put in this bit of code (C#, and from memory so it may not be 100% accurate): 

My guess, in that particular example, is that he used the z value to determine what type of material: bedrock, stone, dirt, or air. 

Are you asking from the perspective of technicalities of implementing or the ramifications of the design? Either way, the answer to your question is "yes". From the technical side of things, generally speaking you just find the hooks in your code that are responding to your achievement events and put in your stat tracking code there. You might have to add some new things if you're tracking things that aren't exactly discrete events that are already happening in the game (for example: X amount of hours played). From the design side of things, well, achievements are extrinsic motivators and adding them doesn't really play too much into the core gameplay loop, except for people who want to seek them out. So they're pretty safe regardless. 

Without knowing which specific platforms you intend to support, I'm going to go out on a limb and say that Unity is probably the easiest and most turnkey solution for getting on a lot of platforms. Other games (like angry birds) are probably a hand rolled collection of libraries (e.g. Box2D) and custom code, and they probably do the porting from one platform to another themselves. 

Use whatever you're comfortable with. If you're not comfortable with any of them, just pick one of the popular ones. The choice of tool here isn't going to make or break your progress by any significant factor compared to the design decisions you decide to go with. 

This isn't really answering your question, but from my experience as a programmer, premature generalization is just as bad as premature optimization. You rarely gain anything and have to maintain it over the course of the project. My advice is to straight up use D3D9 client code in your project, and when you determine that you need to switch interfaces, make an interface with all the things you're currently using. Programmers are terrible at predicting what they might need, doubly so in your case where you're not terribly familiar with the material, so this way you're doing the least amount of work. See also: $URL$ 

Unity also does a few other things, like setting a "Name" property on the game object itself instead of in its child components. Personally I don't like the idea of your shared-data-by-name design. Accessing properties by name instead of by a variable and having the user also have to know what type it is just seems really error prone to me. What Unity does is that they use similar methods as the property within the classes to access sibling components. So any arbitrary component you write can simply do this: 

I mean, if you have specific questions on how to do certain things, that is what this site is designed for. For example, maybe you want to know about how to sync up client side movement with a server and have it not be choppy. Maybe you want to ask if the client should be authoritative on movement or the server should be. My advice to new people starting games is just to do it. Nobody can help you make your decisions. You can be spinning your wheels forever trying to do research on the "best way" to do things. But that really isn't important. What's important is building up experience on your own in order to get to the point where when you need to make a decision you can make an informed decision, and to keep an analytical mind open when you're working on things to see what problems and solutions crop up. For your example, talking about pushing updates to a database. Just do it. Then profile it. If it's slow, think about ways around it. If it isn't fast enough, start thinking about ways to handle it. If you need direction, then come to us for help. 

This code is a mess, but after a cursory glance I'm going to go out on a limb and say you probably want to check against the value of check_collision. The char you pass by reference into the function is uninitialized (albeit probably zeroed out in debug builds) and you don't set it in the false case of the function, but you immediately check it afterwards. Really what you need to do is attach a debugger to it and step through it to see what's going on. 

Your two options for low-cost hobby development are the android and WP7 platforms. The WP7 platform has a $99 yearly fee (same as the iPhone developer agreement, for reference). With that you get XNA which is going to get you up and running without additional middleware pretty quickly, plus you said you have experience in that platform so you'll spend less time trying to learn the tech and more time making games. However your best bet from a purely dollar-cost perspective is probably the android platform. It's an open platform (read: free). With the native development kit you can write your apps in C++. The graphics API is OpenGL ES (same as the iPhone, more or less). It's a lot more barebones in the sense that there isn't nearly as much of game-related things in the SDK like XNA has. However, given that it's a fairly standard/open interface, there's a lot of existing middleware (like this) that can help you get up and running on that platform quickly. 

It isn't about realism or not. It's about fulfilling a desire for the player. What you see is that the strive towards "more realism" is simply by trying to put the player closer to the place that they want to be. So you get better texturing, lighting, physics, etc. is all towards putting the player more into the suspension of disbelief. Now that being said, it isn't exactly about what's "real", but what people "expect". A perfect example of this is the weapons in Modern Warfare. The guns do not behave at all like they do in "real life", but they behave almost exactly like people are used to seeing them in movies. So when they get a particular gun in their hands and fire it off, it feels "real" in the context of their knowledge. 

While your question made no reference of them, I'm going to be working on the assumption that your angle calculation question stems from wanting to know the minimum angle between two vectors. That calculation is easy. Assuming A and B are your vectors: