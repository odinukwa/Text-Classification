If you can program in Go, Node.js, or Ruby, then you might want to look at GoBot.io. GoBot is a lightweight framework that has several communication frameworks and Raspberry Pi is one of them. I have my Linux laptop speaking to a Raspberry Pi Zero W, just to see if I could do this. My next experiment will be to have wired communication. If you look on the front page, they have "sister projects" written in Ruby and Node.js. The Go code runs on a larger computer (PC, Raspberry Pi, that sort of thing) and through and "adapter" (a communications protocol) they communicate with microcontrollers if necessary. The same technology allows for communication between multiple Raspberry Pis. It is a much lighter framework than ROS, though, but it is much easier to learn. 

You specifically mentioned a USB to TTL converter. The Raspberry Pi is a 3v3 device and TTL is a 5V specification. Or did you mean a USB to 3v3 serial converter? 

Run your code with a profiler and debugger. Something in the script or how its set up is causing the script to fail. My best guess is a memory leak or a variable overflowing. Especially with C code involved, my mind jumps to memory leaks. It is easy to forget who is supposed to free memory that comes out of a function. And automatic garbage collectors are not perfect. Variables overflowing is a distinct possibility. Why are you increasing a variable ever 30 seconds or so? Wouldn't it be easier just to calculate the value when you need it? Posting large code has been done before. Unless you post it, anything we say is just a guess. 

This might be caused by some missing environment variables; namely the variable. It would explain why a command that doesn't use the display, e.g. , works while doesn't. Assuming that your display is numbered 0 (default), try adding this at the top of your python script: 

If the data-sheet for the model B+ is correct, the APX803 is hooked up to the red PWR LED as the wiki states. I can't account for the blinking (could it be caused by C6? Is it actually the raw input power drops you're seeing? Is it a feature of the APX803?) but it certainly shows that the APX803 can make or break the ground connection of D1 (red LED) via Q1 (depletion-mode n-channel MOSFET): 

How it could/should look (with back-EMF protection in the form of a flyback diode. The term "flyback" only refers to the application, not the diode itself. For your low current setup, use any regular diode capable of handling hundreds of volts. Eg. a 1N4001) Check the schematic above... Here you see a circuit with voltage spike/back-EMF protection added in the form of a diode. There's a DC power source (Vs) on the left, a coil (L1) at the top that could be your relay, a resistance (R1), a switch (SW1) and a diode (D) placed across the coil. See how the diode is "pointing towards" the positive terminal on the power supply? This means that no current can flow through it during normal DC operation. However, as soon as you turn off the relay the diode will ensure that the power stored in the coil will loop around in the coil itself until the resistance in the copper windings has "eaten up" all the energy; thus sparing your controlling circuit (SW1) from a nasty shock. The same solenoid setup as before but this time WITH a flyback diode across the load. See that nice, horisontal line? That's safety. $URL$ But wait, there's more! Instead of mucking about with individual transistors and diodes, I suggest you buy 10 trusty old ULN2803 ICs for ~Â£1 on ebay including free shipping. (I'm not affiliated with any vendors. I simply picked the cheapest product). The ULN2803 is a so-called Darlington transistor array. A single chip effectively gives you 8 individual NPN transistors in one small package (it actually contains 16 transistors but that's hidden away in the chip). They are perfect for your application since they have built-in flyback-diodes and each output can handle up to 500mA (~300mA when controlled from 3v3). They even have built-in input resistors of 2.7 K so you can and should connect them directly to the Pi's 3v3 GPIO. If you get these ICs, you can safely connect up to 8 relays/motors/whatever and control them via 8 GPIO pins. Providing that all the relays are powered from an external supply - not straight from the Pi - this is a safe, cheap and stable solution. It could be done like this. "Do you know of a way to trigger a "power cycle" for the pin without having to physically unplug the ground connection?" Yes! Let a semiconductor do the dirty work! Simply connect GND from your sensor to one of the outputs of your newest investment - the ULN2803 :) To reset your sensor, you simply write a low/0 to the GPIO pin, wait a few seconds and then write a high/1. 

You are defining the location of the scripts with the "~/" notation, which only works if the same user that is running the python script is storing the scripts. I'd put the scripts in something like /opt/project_name/script_a.sh The scripts might not be executable by the user that is running the python script. You might not have the #!/bin/bash at the top of the shell scripts. 

If you only want one picture per day at the same time, it might be better on batteries to shudown the pi after taking the picture and storing it. Then use a timer to turn on the pi at the same time each day. You use use a very small, low-powered microcontroller to do this. They could run off the same power supply. I haven't heard that the Raspberry Pi has a low-power sleep mode that can be set to wake up at a given time. This would be extremely useful for your application. The battery for the power supply should use some environmental supply, such as solar, wind, or water to recharge. I'd use a lithium-ion battery. I agree with OyaMist that you'd want about a 12v battery and use a dc-dc converter (not a normal voltage regulator which wastes a lot of power). And unless you need something more powerful, I'd suggest using a Raspberry Pi Zero. It's cheaper and you save more power. 

Linux/Unix also has the scheduler which will run scripts and commands at specific times/intervals. It wakes up at the start of every minute and checks if there are jobs to do. This is perfect in your case. Instead of using python, you can type in your terminal and copy/paste the line below to the bottom of the file. I'm assuming that your username is - if not, change the line below accordingly. 

I don't understand what is doing? It's typically used after a . Writing to stdout puts something in a buffer and flushing stdout takes the contents of that buffer and prints it to screen. I don't think you need it here. If you insist on doing this in python, here's an edited version of your script (but there's a simpler way below the script). 

Current won't be an issue (motors require more current than a few IR LEDs and a comparator) but can the L298N provide voltages as low as 3v3? Also, do they flip the polarities to change the direction of the motor? If so, make sure you don't end up doing that with your digital logic circuits. Diodes are your friends if reverse polarity is a risk. Anyway, if you can get 3v3 out of the L298N modules and don't overload the thing by driving two motors meanwhile, it should work. Otherwise, just get some DC-DC buck converters, connect them directly to your power supply and have dedicated power to the comparator board - maybe via a MOSFET if you need to turn the thing off. 

You do not want to power the motor directly from the Raspberry Pi. I'm surprised that your attempt at it hasn't destroyed the Pi already. The L9110 chip datasheet states that the L9110 Vcc (input power) can be from 2.5V to 12V. The +5 volt specified input is probably because the motor can't take a high voltage. You should not use USB to directly drive a motor. One way to power this is to get a 6v battery pack (4 AA batteries - non-rechargeable - would do) and connect it like the breadboard power supply is connected. Another way would be to use the breadboard power supply and power that with a 9V battery pack (6 AA batteries). Happy Making! 

I need more information. What is the range of travel? I ask because there are different cellular standards in different places. Pianywhere (BTW: it would have been nice to have a link there) would do the job in many of the places. For example, The Americas is one region, Asia another, and GB and the EU yet another. The Pianywhere does seem to have a GPS in it. I have no idea what the SparqEE is, but if you'd linked it I'd have looked. Other things to think about with travel would be power: if you have to run on batteries, how are you going to charge them? And what about weather-proofing if necessary. I assume the Pi will be outdoors because GPS doesn't usually work indoors. 

"I suspect that my issue could be that I am drawing too much current from the pi." Whether or not that's the case, I'm not a fan of the "modern" practice of sourcing relatively high currents from the Pi. In all my setups, I only source power from a PSU - if not to avoid overloading then simply to avoid introducing ripple and noise in the Pi's power rail that might disturb digital signalling. Instead of sourcing from the Pi, use a 12 volt supply or a laptop PSU and get some cheap switching regulators for producing the voltages you need. Rule of thumb in case you're going to do it anyway: never go above 80% capacity in any circuit. Ever. About the relays... Whenever you're powering coils and other inductive loads (motors, solenoids and relays being the most common examples), you're effectively creating a magnetic field that resists sudden current changes as long as the coil is powered (in practical terms, think of the powered coil as an energy storage area). When you suddenly cut the power, i.e. turn off your relay, the magnetic field collapses and this energy is converted to a huge voltage spike. This phenomenon is typically referred to as "back electromotive force" or "back-EMF" for short. Since the energy can't just disappear, it'll have to travel down the supply line where it hits your controlling circuit. This means that your NPN transistor might be taking a beating whenever you turn your relay off. Transistors and digital logic don't like that one bit! Oscilloscope output showing the voltage spike in a solenoid being turned off: $URL$ 

I've never heard of trying those strategies. I've never heard of a Raspberry Pi hat or other add-on that adds a new CPU. I suppose you could use the Raspberry Pi Compute Module with multiple modules, but that would be more expensive than choosing a more powerful single-board computer. There have been people who have made parallel computers with a network of Raspberry Pi's. These clusters are more educational than useful, but they might increase your CPU speed enough, and they should be able to share a hard drive. I don't know if this will help enough, though, because I've never tried this. Have you considered a more powerful board such as the Udoo x86 series? This is an x86-based board (or rather several of them with increasing speeds and prices). It will run Linux just fine, it can also run Windows. It includes an on-board Arduino clone, which is useful for robotics. The Raspberry Pi, while a wonderful computer for some things, has too many networking bottlenecks to be useful where networking is important. Don't get me wrong, I like the Raspberry Pi. I have many of them. I'm going through my electronics, and I have many more than I thought I did. Maybe I will try making a parallel Pi someday, purely for educational purposes. 

It sounds like the power supply is failing to regulate and dropping out momentarily. The answer below seems to describe a similar scenario and the rpi wiki also mentions that the blinking PWR LED indicates an issue with the power supply. From this question: 

Since OP was getting an rather than an , something was clearly being imported correctly but simply didn't have the method . By calling from a script, not in IDLE, to get a list of all available module methods, we found out that he was actually importing a different, home-made script with the same name as the module (). It probably worked in IDLE because it runs from a different folder. So... Use when you get an and avoid using module names for your home-made scripts - it'll make things less confusing. 

Basically your current relay setup (No back-EMF protection) To mitigate the problem, it's common practice to add a flyback diode across the terminals of the inductive load (in parallel from GND to the positive terminal). You have to insert it so the little ring/stripe on one end of the diode is closer to the positive terminal than GND. Be careful with the orientation of the diode; put it in the wrong way and you've created a very good connection (low resistance path) from the positive to the negative terminal, also referred to as a short circuit.