Make it fully iterator-based By using the functions in , you can make your algorithm have a more "iterator-oriented" feel. I almost converted it to work with bidirectional iterators (with the additional cost than is \$O(n)\$ instead of \$O(1)\$ for bidirectional iterators) but stopped myself since I would have to alter a bit the logic of your algorithm and comparing the original and the new versions would have been trickier. Let's say that the final steps are left as an exercise to the reader :p 

Of course, none of this is meant to be used with a C++ compiler and all this code is merely done for fun; I would never use that as production code. Also, I already know that all those macros pollute everything, but I don't care - all of this is just a proof of concept. So, would there be any way to improve the interface even further? Moreover, are there ovious errors in the implementation? 

Actually, how your pseudo-random number generator is declared does matter, for depending on how it is declared, you may avoid using a lock to generate random numbers. Generating a random number is alreadu an expensive operation, so locking them makes it really expensive. If you make your pseudo-random number generator , you don't need to lock anything anymore before generating a random number, it will be inherently thread-safe: 

Hum, first of all, there are way too many comments. People simply won't read them, you should only keep the meaningful ones. For example, you could remove: 

With all optimizations turned on, this code is a little bit faster than the previous version, but it's still far from being as efficient as the version which converts the Gray code back to a regular integer, performs an integer addition and converts the result back to a Gray code. Hey, we can't optimize such an algorithm without twisting it in every way possible! This is why, we will also try to... Find a better end condition Currently, the algorithm loops over every bit in before ending. It may be possible to end the loop sooner. Let's have a look at a big old truth table that we will use for the rest of the answer. For the sake of brevity, I used the names from the original pseudocode to name the columns. I hope that the parallel with the code I wrote isn't too hard to make (\$ A = lhs_i \$, \$ B = rhs_i \$, \$ E_{old} = lhs_p \$, \$ F_{old} = rhs_p \$, \$ S = A \oplus B \oplus res_i \$, \$ E_{new} = lhs_p' \$, \$ F_{new} = rhs_p' \$) \begin{array} {|cccc|cc|cc|} \hline A & B & E_{old} & F_{old} & A \oplus B & S & E_{new} & F_{new}\\ \hline 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1\\ 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0\\ 0 & 0 & 1 & 1 & 0 & 1 & 0 & 0\\ 0 & 1 & 0 & 0 & 1 & 1 & 0 & 1\\ 0 & 1 & 0 & 1 & 1 & 1 & 0 & 0\\ 0 & 1 & 1 & 0 & 1 & 1 & 1 & 1\\ 0 & 1 & 1 & 1 & 1 & 0 & 0 & 1\\ \hline 1 & 0 & 0 & 0 & 1 & 1 & 1 & 0\\ 1 & 0 & 0 & 1 & 1 & 1 & 1 & 1\\ 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0\\ 1 & 0 & 1 & 1 & 1 & 0 & 1 & 0\\ 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1\\ 1 & 1 & 0 & 1 & 0 & 0 & 1 & 0\\ 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1\\ 1 & 1 & 1 & 1 & 0 & 1 & 1 & 1\\ \hline \end{array} Looking at the very first line of that table, we can see that when \$ A = B = E_{old} = F_{old} = 0 \$, then as a result, we have \$ S = E_{new} = F_{new} = 0 \$, which means that since our result was filled with \$ A \oplus B \$ from the start, then we can stop the loop when the aforementioned condition is met (everything equals \$0\$) since the following bits S will always be \$0\$. An easy way to do so is to "consume" and in the code with right shifts so that they eventually reach zero and to change the loop condition with bitwise ORs (here, only the loop for the sake of simplicity): 

We can depend upon tar to not create empty archives. So if the filelist is empty no tar files are created. 

Any particular reason you handled the first one using exception and the second one using an if condition? Also consider returning an error code, If program can be used in non-interactive way, printing any errors to stderr also helps. I would also modify it as 

As you can see, the reason you can't use rndStr directly is that rndStr uses IO. So it cannot be directly used as a function. You can think of it this way. rndStr returns some thing that is wrapped in a box. You need special constructs to unbox it, and the special construct is either <- . You might also notice that main has the same kind of signature. That isn't a really good analogy, and I am not the best teacher :). So if you really want to understand what happens, it might be better to read any simple monad tutorial. 

The options are globals. So perhaps it is better to specify that explicitly. This will help in modularization later. 

by keeping a list of values equal to pivot, you can ensure that your sort works even if there are non unique values. 

Why not use a hashmap as the main DS? That way, you optimize for when name and event are defined, and suffer only a constant penalty and degrades to linear for other cases. (In your solution the cost is always linear). (As below) 

The same program with a few changes. first, try to refactor your functions so that they are small, second, Often, using a case statement is more clearer to using cascading ifs. third, 'using namespace std' is a bad habit. It is probably ok to use in a small one off program like this, but avoid polluting your global namespace in larger projects. And avoid magic numbers when possible 

Congratulations on your progress, :) Welcome to monads First thing you have to keep in mind is to restrict the time spent in imperative world. So take out as much stuff as you can from the do ..., and refactor them into smaller non-IO code. 

It is rubyish (and smalltalkish) to use select, inject, collect etc rather than explicit loops where possible. 

I suspect a simpler approach would be to just join the tokens together to form a sentence as string, and then use list of regular expression patterns to substitute each case. This will reduce the complexity, and will be much more readable than your example. (I will flush it out later.) pseudocode: 

Does position have a constructor? If not, it would be nice to create one for it. If yes, it would be better to use it. 

Please spinning it to a separate function. Here is what I think is a little more simpler implementation. 

I suppose you feel that foreach is a kind of a map, and that inhibits you from exiting in the middle. In most code that I have seen, the first form is preferred except in the cases where we need to get the index where the break happened. i.e This is ugly. 

I removed the Combination data type because it did not seem to be adding any use to the program. Instead I modified the show to be more intelligent. I also got rid of isNext because it is actually trying to do an Enum poorly. So instead we have an Enum and a Bound (They are not completely necessary, but going by the spirit of building the language in which to describe the problem first, I would say they are justified.) 

One suggestion is to make the roles two classes, initialize them based on the role and call the save function. 

The given problem can be attempted in a slightly different manner. You can see that the pairing corresponds to binary digits with { standing for 1s and } standing for 0s. For e.g the pairing with the maximum value for say 4 {}'s is 11110000. So all we have to do is to generate every number from 1 to 11110000 and strike out all numbers that do not conform to our requirement - that is, at no point while counting the digits from left in a number, can the number of 1s be lesser than the number of 0s, and also that the total count of 1s and 0s must be equal. A few optimizations can be done, For e.g, all odd numbers can be eliminated. And the total number of digits have to be even, etc. If the number of braces are , then the algorithm is of complexity. So it is not an efficient algorithm. I wonder what the complexity of your algorithm is, and how you can show that your algorithm is indeed correct. For additional ideas ref: catalan numbers. 

Today, I will require your help to improve an iterator adapter. The goal of the adapter (I called it ) is to adapt iterators for example: map iterators return instances, a will provide an iterator which iterates through the keys while a will provide an iterator which iterates through the values. Here is my implementation: Here is the header file: 

Today's question will just be about a small utility that I needed at some point for one of my projects: a template to detect whether a template is specialized for a given type. The utility uses from C++17, but this alias template is simle enough to be implemented in you favourite C++ revision, whichever it is: 

That way, your code and the client's one do no rely on a particular container type, but work with any compatible range. That's how genericity is achieved in the standard library. 

Since all the values in this line are known at compile time and is apparently not meant to be changed, you should consider making it both and : 

That way, if you change to something else in , you won't have to update accordingly. It would also be a good idea to add other common subtypes such as , , ... as in the standard library containers. A lot of template code out there relies on such subtypes. Standard library style As I just said, writing containers that look like those used in the standard library generally makes them compatible with more existing code. Therefore, your functions should be named as in the standard library: instead of and , uncapitalized and would have been better alternatives (that's actually why I try to write my code with the same case as the one used in the standard library). The full-lowercase member and will work with both C++11's and and with the range-based loop. Also, you miss a overload for and . This should be a matrix by default, not a vector Currently, many of the main operations clearly consider the class as a vector and not as a matrix. Those main operations are , , and somehow the constructors. For a "matrix", I would expect to return a row or a column (it depends whether the matrix is row-major or column-major, documenting that would help) and / to help iterating over rows or columns. Being able to treat the matrix as a vector is often useful, but it should be explicitly required by the user, not the default option. If you want an example of implementation, the last matrix class I wrote provided the methods and that returned s. I also wrote a container view, , so that I could write this: 

CRTP helpers When using CRTP, it is common to write methods in the base class to avoid having to deal with the pointer and to use reference semantics instead: 

By the way can also be used to compute \$ lhs_{new} \$ so that the code looks more symmetrical (even though it does not improve the performance): 

None of the other answers mentioned that there is actually a problem when the value passed to the sieve is a prime number. For example, returns a vector containing . This is due to the vector being too short by one element: it considers the elements between \$ 0 \$ and \$ n-1 \$ while it should consider the elements between \$ 0 \$ and \$ n \$. It should have been declared as: 

I think that the goal of avoiding overflows is reached: the accumulation is guarded against overflow, and the division of every element to add by the size ensures that the result itself can't overflow either. Regarding the precision, adding integers in an as long as possible ensures that no precision is lost before the division. In the best case, a single division will occur. Moreover, the algorithm should divide bit integers most of the time, which may help the precision too. I picked to have the best precision guaranteed by the standard too. Now, there are a few known shortcomings, to name a few: 

I did manage to improve some things since the question was posted. So here is what I discovered, that could somehow improve the implementation and the usability of the : 

I actually slightly simplified the way user-defined literals are used in the standard library for your example: there are actually nested s in so that a more precise selection of related literals can be done if needed (for example, import only the -related literals). Since you have only one literal, you don't need to have so many nested namespaces, but you can still add them later if needed.