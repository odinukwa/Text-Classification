still there is an if clause which we could make shorter. there are numerous techniques to toggle/select/cycle values from a limited set. here i am tempted to use a very lazy one (as the number of iterations is small) 

this would be less heuristic than your approach, although you probably will again apply some more algorithms/heuristics to find the 'exact' match start/end. 

comments and docstrings in you use a parameter choice which is one-based. this is not common and not mentioned in the docstring. so while there is a 6 line docstring one of the most important facts for correct usage is not mentioned. While your parameters and return values are listed by name there is no hint about the correct type nor the value range. 

Proper error handling so now the big bug. if we cannot place the player in we switch user. if something is an error report it to the caller. that does not mean to print something to the screen but to return an error condition or raise an error. Output to console shall be done from main only. so we refactor to return success and remove the print 

We can also store the entire current question in the ViewState to avoid having to store individual properties of it, such as the answer index. We can do this by adding the attribute to the QuestionModel class. Note that if we do use the ViewState, we should also encrypt it to avoid disclosing the answers and other internal information. To do this, we can add to the Page directive on the .aspx file. Also note that we'll need to find a way to provide access to the correct count to Results.aspx. For simplicity, we can use session data for this specific case: 

Two items I would have a look at in terms of the actual calculations. Use Full Names in Methods For clarity, and because the few characters are inconsequential, I'd prefer to see the full names of the units being used in the method names. This will improve readability and understandability of the code. 

You already got some advice on coding style. however there is a big flaw in your algorithm which is not addressed by the accepted answer. you try to iterate downward to get an effective implementation but you got the inner loop wrong. while you expect the outer loop to do few iterations your inner loop does check relatively low numbers early. you tried to limit that by stopping the iteration at 900, a magic value without reasoning. so your implementation may give wrong results as a pair of 901*901 is much smaller than a lot of untested pairs. you need at least a check if your product is bigger than the biggest untested one 999*900. on the other hand if we do the inner loop right all problems are gone. we use the outer loop for the lower value and the inner loop for the greater one. we do not need an arbitrary limit any more and we are quite efficient. 

Only Handle Answer Checking on Next Click There's no good reason to check anything about the selected option when it's checked; we really only care when the user clicks next. This greatly simplifies the logic, as we can remove all of those methods, and implement all of the logic in the next button click method. For example: 

This is unnecessary. Without it, it will propagate the exception up, the same as manually rethrowing the exception. Remove Unneeded Controls You seem to have both a radio button list and 4 radio buttons. We really only need the radio button list. There are also a few panels that aren't needed. Use ViewState Instead Of Session Instead of using the session to store data between questions, we can use the ViewState. The ViewState doesn't persist the data on the server, but rather stores it on the client side. Since we don't need to make use of the internal state data (such as the current question), we can store it in the ViewState. Using ViewState also allows a user to have multiple question sessions going on at a time in separate windows, whereas the session data would otherwise be mixed between them. We can also use properties to simplify this access. Instead of using strings to access the variables, we can implement the access in the property, which will prevent us from accidentally using the wrong key. For example: 

explicit loops python has list slicing and list comprehension. in you use comprehension but could use the more dense slicing 

it is clear and readable and tells all and shall not be done any other way. Now about sorting a . You rely on a 3.6 implementation detail that will be guaranteed in 3.7 when released. whenever you do such a version-stunt you shall check the version and either raise an error or implement a fallback (e.g. ). However when 3.7 will be released there might be a sort for implemented as well. Your solution is most likely becoming obsolete when becoming legal. About coding You define an inner function for no reason introducing a lot of complexity. In your inner function you check the existence of an outer to decide on returning a , that's awful. You mix and exception handling in for control flow. your clause is a completely regular case. You shall not implement a silent fallback to sort by string (or whatever the type is) when the user requested sorting via . this is a complete fail, hiding a user error and presenting false data as regular result. 

Overall, I think this code is a great first try. That said, it has a lot of room for improvement in terms of simplification and improving readability. As an aside, I'm not sure if you have a strong motivation for using Visual Studio 2010, but if you don't, I would recommend considering using a more up to date version. Visual Studio 2017 was recently released. Naming Conventions The naming of the methods should be PascalCase, and should not be abbreviated. For example, instead of , use . This improves readability and is consistent with C# conventions. You also use Hungarian notation for the question class. I would also denote that it is a model. Instead of , it should simply be . See $URL$ and $URL$ for reference. There are some great points in that documentation. Use C# Auto-Implemented properties The class can be greatly simplified using C# auto-implemented properties. Use instead of creating you own backing fields. See $URL$ for reference. I would also rename the Question property to QuestionText to avoid confusion. With this, the Question class could be extremely simple: 

EDIT One important point I did miss on the first glance. You do sort optionally on conversion or by default on representation. the second one is a bad idea, as you cannot sort comparable objects by their built in comparison functions. instead you force str representation which in terms of sorting is useless. So you shall not force but have the identity function . might be a third option to sort for. To your changed code - let's assume we have to write a function like this. if we have a look at 

Before adapting we have a look at the names which are not reflecting reality. the loop shall be because it is a single row. likewise should be as there are several data/spacing/separation parts in there. That said we change to (still not perfect) 

so any other variable referencing a node or even the root node will possibly reference something old. 

Factor Out Constants Several of the numbers used are constants which could be factored out, such as the difference between Kelvin and Celsius (273.15). This will prevent typos from causing calculation errors. Something like the following: 

Ideally, it would be great to have a result information class that we could serialize and pass through, which might include the percentage, which answers were right/wrong, etc. Note: It really shouldn't be using the session at all here (see reasoning above), but the architecture of transferring the data is out of the scope of this question, so this is here for a proof of concept. Separate Data Access From Rendering Currently both handles data access as well as calling the rendering method. I would extract the data access to it's own method, something like: 

Putting It All Together With all of this, we end up with the following. Notice that we've reduced the size of the class by almost half and made it a lot more readable. CodeBehind