Compare these two. The first one is nearly unreadable - sure, some of the gems are visible, but many of them aren't. On the second one, the grid stands out instantly, as does the dialog box. While there's only one gem on the board, you can instantly see where it is. 

As long as you're doing reasonably conventional binding, LuaBind will do everything you need. Binding classes and functions tends to be a one-line-per-function deal. If you'd like an example, here's the applicable file from the game engine I've been working on (look for module(L) for the start of the LuaBind interface, DontKillMeBro<> is a little system I rigged up to let me more precisely time object destruction for certain sensitive objects.) If you want something more complex, you're probably going to need to use the actual Lua API. Luckily, the Lua API is reasonably simple. 

Eve Online actually has several different solutions, all intermixed nicely. First off, while your character gets "more powerful", it's not really getting all that much more powerful over time. The first few weeks of training (which, keep in mind, happens offline) give you access to most of the basic cheap powerful ships. You can pump months into some specialty niche topics, giving you more powerful ships, but those more powerful ships are far, far more expensive. Second, Eve Online supports and strongly encourages group play, and groups are vastly stronger than solo fighters. Ten players with hundred-million-isk ships ("isk" is the game currency) can easily take down someone in a billion-isk ship. In fact, ten players in ten-million-isk ships can probably take down a billion-isk ship. Goonswarm, one of the most powerful alliances in-game for some time, got its start and its military backbone with sheer untrained numbers. Third, you don't have to gamble a lot on PvP if you don't want to. Those low-tech easily-trained ships won't cause you to lose much if you get blown up. The later high-tech ships will cause you to lose huge amounts, but nobody's forcing you to use them, you can keep on using the cheap less-powerful ships. While your skills definitely give you significant edges in combat, with a lot of 10-20%'s here and there that add up quickly, the second biggest determiner of your combat abilities is the hull and gear you're using, so a six-year-trained pilot in a cheap ship will still rapidly lose to a six-month-trained pilot in a pricey ship. (The biggest determiner is the player skill, of course - sheer character skill points comes as a rather distant third.) I haven't seen any attempt to import these mechanics into a conventional fantasy MMORPG, but I think doing so could be extremely fun and interesting. 

9 days? No sweat, man! I've made over a dozen games in one week each, with a 48-hour limit a few times. So, here's what you've got to know. First off, you need an idea. Now, you might think that the best way to get an idea is to not restrict yourself. Oddly, you'd be wrong. Humans seem to be better off exploring ideas within the confines of a stricter concept. That means we need some concepts. Luckily, there are tons of concepts available for easy pickings. Here, for example, are a ton of historical concepts from the Experimental Gameplay Project (which I highly recommend taking on, by the way.) Pick one. I recommend picking the most recent one. Tada, you're making a game about economy. What does that mean? I dunno! That's where it's up to you. Maybe that's a business sim. Maybe it's about recycling. Maybe it's about making careful use of resources. You've got a word - "economy" - and now it's up to you to make a game. Write down a bunch of ideas. Throw out the bad ones. Pick the idea you're most interested in. Start writing code. Now, keep in mind this is going to be a bit of a crapshoot. It's possible you'll pick a brilliant idea. It's possible you'll get seven days in and say "well, that idea was pretty crummy actually". If the latter happens, finish the game anyway and chalk it off as a learning experience. Now, how do you make a game in nine days? First: ruthless cutting of features. You don't need a title screen. You don't need an escape menu. You don't need good art or good music. If you get in five days and your game is done, yeah, sure, go back and flesh things out, but for now your goal is to get your gameplay working. Sit down and work until your basic gameplay exists. Then work until it's done. Don't waste time on finicky details, don't worry about making things look perfect. If you find a bug, think about whether it's worth fixing or not. If your character has a graphics glitch when he fires a gun, congratulations, you've just invented a weird kind of muzzle flash. If you're designing a clock and the face looks wrong, awesome, you've got a weird art deco clock. KEEP WORKING ON THE IMPORTANT THINGS. Second: get rid of distractions. Yeah, I know you want to read Reddit. Don't do that. Stop reading Reddit. I've found that streaming my development as a video keeps me on-track - if I get distracted, everyone will know - but you probably don't want to set that up right now, you've got a game to write. Third: Keep a list of goals. Again, cull it ruthlessly. Anytime you find yourself unsure of what to do next, that means you need to consult your list. If your list doesn't tell you, that means you need to improve your list. Fourth: Make sure everything is worth the time. Yeah, you could download a good sound design package and spend five days learning how to make good sound effects. NOPE. You'll have time for that once the competition is done! Grab SFXR. You have five minutes per sound effect. GO. Are you an awesome artist? Can you make a great character sprite in a day? NOPE. Your main character is a square, your enemies are triangles. GO. Good luck! This kind of a challenge is very difficult but it's also incredibly rewarding. If you really want to get into the games industry, I can promise you that releasing twelve games, one every month, looks miles better on a resume than a four-year college diploma. As an example, here are a bunch of games I made under similar constraints. Yours probably won't be that developed - you just don't have the time or the experience - but it's certainly doable. Are you playing those games? STOP. GET TO WORK. YOU DON'T HAVE TIME TO PLAY GAMES. GO GO GO 

I'd say no. Windows will be using spare memory for this caching - it's basically free. Unless you've got a fancy system to somehow expand your process memory to cache more data when Windows is under low load, and then contract it again when Windows decides it wants more memory, just let the computer do what it's good at it. I don't think increasing load time in order to give better load-time predictions is a good tradeoff :) 

Once all of that is done, it's time to work on compatibility. If you're working on a AAA game then you have some way to test your code on many different kinds of hardware - maybe it's inhouse, maybe you contract out to a testing firm, whatever. A lot of your code will break on specific graphics cards or specific driver versions, and you get to fix as many as you can. It's also time to consider optimization. Rendering is a big, big speed issue, so now you have to figure out how to exploit the hardware at the deepest level in order to run as fast as possible. If you think this may conflict with "compatibility", you're right! It totally does! The best optimizations, you'll find, will just flat-out not work on some cards. You get to balance all these factors. Around this point, your artists will be demanding new texturing tools or new animation features, and your level designers will want new terrain rendering techniques. Go back to "the next three major steps can be done in any order" and repeat until the game is done. Gameplay: I'm going to skip the parts that aren't terribly visually noticable. First, you sorta have to wait until terrain rendering is in, although there's a lot of backend stuff you can do until then. Once you've got that, you'll set up some basic collisions. This will likely take the form of flying to a location in-game then pushing a button that drops a cube. The cube falls and hits the ground. Once the cube lands on the ground consistently, you can start setting up player movement, so you can run around the world in the same way as a player does. Once you've got basic movement physics working, you're in one of those "these can be done simultaneously" segments again: 

While this is of dubious value with your actual situation, the best way to make small background music is to use a MOD-style format. These are formats that contain a small number of sound samples and the music in a note-by-note format, rather than a gigantic waveform that's been compressed to squeeze space out. Check out the S3M and XM formats, as well as the original venerable MOD format. Sadly, there's no practical way to convert MP3 into MOD besides paying someone to do it by hand, and even then you may lose music effects as you're limited by the technical abilities of the format and the player. 

Clever economic manipulation. Say you've got two people playing the game. Frank has a lot of money (he's a millionaire in real life) but not a lot of time ingame. He wants to get some really awesome and expensive equipment and go kill Starfuries (they are the best thing to kill) but he has no interest in grinding ingame to gradually get the gear he wants. He does not care, in any sense, about the $15/mo monthly fee for your game. He will probably forget to unsubscribe because he cares so little. Bob, on the other hand, is a highschool student. He has no money and absolute tons of free time. Huge amounts of it. He's managed to get his mom to pay for a few months of subscription, but that won't last forever. So here's what you do. You make an ingame item, a "Hunter's License". A Hunter's License can be traded on the auction house ingame. It can be redeemed for a month of subscripton time, and it can be purchased out-of-game for $15, it just shows up on your character. Frank buys a pile of Hunter's Licenses and sells them on the Auction House. Bob spends a few days farming money and buys his Hunter's License for the month. Everyone wins: 

Two suggestions: Exponents! Calculate some "base xp reward" for each level. Then the formula for a kill is base_xp_reward * pow(1.1, target_level - player_level). You might want to clamp the gain to a maximum, to somewhat nullify exploits, and you might want to give zero XP below a certain difference, to prevent farming of lowbies. (Base XP reward can be a simple exponential progression also, if you like - constant_factor * pow(1.25, level), perhaps. Then you can define the "exp to level" in terms of a multiple of the base XP reward. Might be easier to balance this way.) Alternatively, let's make this really simple. Do the same base-XP-reward thing. Then figure out a table by hand for the bonuses you want from various level differentials. Make it ratio-based, so that killing someone one level above you always gives, say, 10% bonus XP over the base reward. And now you don't need to worry about a formula at all - you can just make the numbers do what you want. Formulas are overrated, sometimes you just need to jam some numbers in and play it by ear. 

I am not a lawyer and this is not legal advice. These are things I've heard many times over and have no reason to doubt. Game mechanics cannot be copyrighted or protected in any fashion. I could make a game called "Crystallized" that was Bejeweled, in every imaginable way, and as long as I didn't copy the art from Bejeweled (either directly, or by drawing new art that just happens to be nigh-identical) I'd be totally fine. Game mechanics have been copied often enough that, if this weren't the case, I have no doubt we'd have heard about it by now. Game design is pretty much one giant incestuous ball of borrowing, and, honestly, is better for it. Keep in mind that you can be sued for anything, even if you're not breaking any contracts or laws, and they might win. But I've never heard of that happening with regards to game design. 

To be honest, I'd take the simple solution. Make a matrix that defines the structure. Whenever a block is changed, attempt to apply that matrix to all locations that might have created the new structure. That's going to be width*depth*height locations, since the player could have finished any point on the structure, but it shouldn't be too bad because most of these locations are going to early-exit when the first check fails. Basically, you've got a 3d matrix, and you're comparing it against another 3d matrix, at a bunch of offsets. From here there's a bunch of totally optional optimizations you could do. For example, if your structure is extremely sparse - i.e. the player is building a tall tower with a sphere at the top, but you don't care if the bottom of the tower is surrounded by trees - you could turn it into a list of blocks instead of a matrix. (I'd generate the list from the matrix - the matrix will be far easier to maintain directly.) If you wanted to be super-clever, break the structure apart into blocktypes. If you know that the player just changed block 1,2,3, and you know that placing your structure at coordinates 0,0,0 would require block 1,2,3 to be obsidian, and block 1,2,3 is wood, then you don't even need to try block 1,2,3. Generate all possible offsets for the structure given that the player has just placed a specific type of block. Then, when the player places that block, just check the pregenerated possible offsets. But, seriously, this is all optimization. Just make a matrix, then compare your matrix with the world brute-force style. Assuming you're making something Minecrafty, people really don't place all that many blocks - a few blocks every second at most. Unless you have hundreds of huge structures you'll be able to test that easily.