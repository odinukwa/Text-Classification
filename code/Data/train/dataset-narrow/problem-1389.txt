Side note: Whether or not a door will be open or closed at the end depends on how the prime-factorization of it looks. Consider the number \$12\$ for example. How to prime-factorize it? \$12 = 3*2*2\$ And the door will toggle on \$1, 2, 3, 4, 6, 12\$. Note that those numbers can be written as 1, 2, 3, 2*2, 2*3, 2*2*3. That's \$6\$ times, which means that the door will end as being closed. Unfortunately, there is no efficient way to prime-factorize a number. What you have built here is very similar to a number sieve, but instead of removing non-primes you are toggling them. Modifying your code to be a real sieve instead would not require many changes to the code. 

THIS IS BAD! A caller of your method has absolutely no guarantee that nothing went wrong. And is therefore unable to tell any potential user of your application that something did went wrong. Simply printing the stacktrace accomplishes nothing for robustness! Additionally, the only exception that should be able to occur is , there is no need to catch all the other ones. 

Edit: In the comments below you asked for a cleaner way for the user to see every step, you can accomplish this by using a callback . Then you can modify your code to: 

Although I understand that you mean that you want to use composition over inheritance for your , your (and your itself) is using inheritance: 

Normally when you need "different return types", you can use generics. However, since you want these s to be in a List of some sort, using generics goes out the window since a List cannot be defined properly to contain both and , so the only solution would be to have a in which case the reason for using generics in the first place is lost. Your class makes sense if a counts more than one of the things. If the counter is only meant to return an int or a list of files, then using a is quite useless since many fields will be null. Regarding Banthar's comment to your question, you could modify your existing interface to 

So what's left are the shenanigans with the . Which seem over-complicated and make it hard to determine the logic. Here's my solution: 

You do these lookups multiple times: , , yet outside the they aren't used. Why then define them outside the , and why is this an array? Why not simply assign the result of and to a local variable? 

Background One of the projects I'm working on is an Intranet website which is a front-end for several kinds of data, each aimed at a different set of users. Access to the website is handled through ADFS; users are put into one or more Active Directory groups and it is this membership that determines what pages they get access to. The website was an afterthought to a larger project, and while usually we build Angular SPAs with an ASP.NET Web API back-end, it was decided that this should be a fairly simple ASP.NET MVC website. User management Managing Active Directory groups using the usual Windows tools is a rather cumbersome excperience, and thus we usually implement an Admin-only management page in our projects where we can easily search for users and add them to or remove them from the various Active Directory groups. We usually copy-paste these implementations and change the necessary variables (group names etc.), but that couldn't be done now since the front-end is in Angular (the code of the ASP.NET Web API back-end could largely be re-used). And thus I quickly whipped up a simple implementation in ASP.NET MVC. However, while it does work, I'm not happy with one part of the implementation. I suspect I'm not well-versed enough in ASP.NET MVC, and thus I'm hoping someone here might come up with a better solution. User 

This is not a variable so it should not be named with . is a better name. @Heslasher is correct that you are using a lot of magic numbers in your code, especially when it comes to this variable. I think a better approach for it though is to use an 

Overriding methods in an interface. These lines in your interface can be removed entirely, they don't provide anything extra since extends . 

Games and Players I imagine that one of the most common statistics you would want to display is: "What are my win statistics against player X?". For such a query, the table is really not optimized for it. Let's say that you want to make a query for "Find all game_ids that the user id 6354 has played in" 

So you create a and a and give them both the reference? Let's see how you use that in the classes then. 

The works just like an ordinary , so you can add and remove and from it. From the EnumSet documentation: 

Use an if-statement to check if you are currently processing the last number. This will get rid of the last for-loop in your current code, which only loops through the array and shows the non-zero number it encounters. There is some things that can be simplified within your algorithm as well. 

You are right that returning an object where is a function would not work, but it would work to return the result of a call to a function! You can also restructure things a bit to reduce duplicated code. By having a starting string or a starting object, and optionally adding to that string or object if some conditions are fulfilled. This is untested code, but I think it should do the same as your original. 

You have a constructor with nine parameters, all of them nullable. That's just asking for problems. Perhaps named arguments could be a solution, but in the context of your code I don't even see the point. Why not keep it simple, and do this: 

and aren't good names, not in the least because they contain the word "String". Wouldn't and be better? 

Not going to review all that, just going to focus on one aspect: your table structure. Edit: ugh, now I read your comment (which was posted while I was doing this review) and most of my review is irrelevant. Still, my point remains: this is really bad database design. 

Except for I don't see how this isn't handled by the logic inside . Of course you need to rethink and , but that seems a more elegant solution than the 10+ lines required to add a first entry to . 

Why do you employ a when you don't do anything with it? Especially when you should be using it. Right now the names of the various fields are defined in two places: 

I don't think you need either to be stated explicitly, since the previous code will always return a value (or throw an exception). 

There is also the presence of several magic strings, which reappear elsewhere in your code (the ). This indicates to me that these values should be s in a separate class, so that should there ever be a need to change them you only need to do this in one place. I would even consider something like this: 

Class names should be PascalCase and should not contain non-alphanumeric characters, so breaks those rules. etc. also break the PascalCase rule. Methods shouldn't contain non-alphanumeric characters either; breaks this rule. Parameters should be camelCase, so for instance and as used in violate this rule. Local variables like as used below should be camelCase: 

It will serve as a marker interface and just declare all of your other interfaces as follow (IGetService for example): 

Next we will need an implementations of this interfaces (I supposed that you are using MySQL as database, since its shorter syntax for limitation and offset is the same): 

If you want to clean up a bit the method, then I think that you should try another, more object oriented way of writing the method (currently the method is written procedurally). Implementation 1 First lets create few interfaces, which will represent the Limit and the Offset: 

Implementation 2 Suppose that you want to you use the long syntax of limitation and offset. Then the code will look like this: 

Now, suppose that we have some data access object called PersonDAO, which should retrieve all the persons in a given range (bounded by limit and offset), then the code would look like that (I`ve change the name of getPersons method to retrievePersons, since we actually retrieves the person entries from the database, rather than getting them from some POJO): 

I have implemented it with Map, as @Majiick suggest, I also took his aproach of implementation. In addition I have also used Map.Entry, which you could also take a look. In the end your code would look like this one: 

P.S. I am not creating a review of the code, since you are asking for a performance suggestions and advices 

Finally we will need one more interface, which will serve us as a glue between this two interfaces (I called it Pagination, since most of the times, offset and limit is used in combination for pagination of some API): 

This is waaay too many arguments: . Instead, have publicly available properties so your code becomes much clearer: 

This wasn't tested, this was written in Notepad++. Look at it as an example of reusing code. (Also, what kind of front-end is this code for? ASP.NET WebForms? Isn't there a better way to bind a grid to data instead of looping through something?) 

seems to take a dozen(!) or so parameters. Instead, pass a single class where each of these is a property; that way it is easier to read and there's less chance of making an error. Also, considering that much of these parameters are part of , why not simply pass that class instead of copying over its values? 

In addition to @user1118321's review, I would also suggest to rethink your conditions. You seem to tend to do "negative" checks, you're even combining two in this case: . I'd much rather have this logic: . To me this second version is easier to understand: if the is null or its is null or empty, then execute this simple bit of code that doesn't need the , otherwise execute this more complicated bit of code that requires the . This is IMHO even more important when using ternary operators. Parsing requires me to think a lot more than if you'd written . 

Even formatted like this I feel there's too much going on: the casts to don't help, plus there's the odd check that the first item is an while you use for the other types. 

Considering the default value of a boolean is , you are in danger of unexpectedly adding a query filter. IMHO you should use only nullable booleans in a filter like this. To me the default behavior when sending an "unconfigured" filter to this method -- e.g. without setting any property -- is that a query is constructed without a single clause.