First thing first - PEP 8 is the de-facto style guide for Python. It's a good idea to just stick to it, and for the most part everyone else will too. This would look like 

looks strange - of course it will be since you've just checked for it. Anyway, this can now be avoided entirely since we have a object. You run (although you call it in the call signature!), but you also need the . It turns out you're passing this as a global! That's bad! Instead, add another parameter so you have 

They differ by . So we are adding up: $$ 1 \, (\text{divisor} + 1) + 2 \, (\text{divisor} + 1) + \cdots + (\text{divisor} - 1)(\text{divisor} + 1) $$ Letting \$\text{divisor} = d\$, this is just $$ (d + 1) \sum_{k=1}^{d - 1} k = (d + 1) \left( \frac{1}{2} (d-1) \, d \right) = \frac{d^3 - d}{2} $$ giving the much simpler 

My explanation of algorithm I spent more than one hour to review my last practice, and like to ask code review for C# code. Highlights of change 

Hard level algorithm It is hard level algorithm, and Leetcode shows that there are 231.9K submissions. I like to post the algorithm for code review, I did study discussion panel on Leetcode 212 to get one idea to solve the problem, and then I carefully prepare my own learning notes as well. It is also a good idea to discuss why Trie is needed for better time complexity. Brute force solution is to go over each word in the dictionary, and then try to find it in the matrix. The total number of search using DFS is m (words) * rows (matrix) * columns (matrix). The brute force solution has timeout issue through Leetcode online judge. We like to review why the time complexity should be better. Let us go over dictionary with 4 words, "aaa", "aaaa","aaab", "aaac". If we pre-process the dictionary and store all words in a Trie, and then we do not have to go over each words to search matrix. We only need to go over each element in matrix as start char in a word, search the trie to find match words using recursive function. The number of search using DFS is rows (matrix) * columns (matrix). Second advantage related to the above 4 words ( "aaa", "aaaa","aaab", "aaac") is taking advantage of Trie data structure. The space complexity of Trie is better compared to hashset or hashtable. The same prefix "aaa" is only repeated once in the Trie. Trie against Hashset Related to the test with a dictionary "aaa","aaaa","aaab","aaac","aaad", let us work together to talk about the difference. For example, if the dictionary is saved in hashset, then go over each word in the dictionary, try to find word in matrix. For example, "aaab", the first three letters has to be compared and they are the same first, then the last letter will be checked. Same will be applied to another 4 words. In total, the prefix "aaa" will be compared exactly 5 times in order to find those 5 words. Can we do better? Just compare the prefix "aaa" once? Cetainly we can. We can save the words in a trie instead of hashset. a | a | a |\ \ \ | \ \ \ |   \ \ \ a   b c d Trie efficiency talk It takes some time to get comfortable to design a Trie. So far, I have written a Trie implementation more than 4 times in C# last 3 years. Given the fact that I have worked on computer science study and full time work more than 20 years, if I practice one algorithm a day, then it is around 60,000. Definitely I should practice more how to write a trie, use the trie to get better space complexity. How to design a Trie so that the space complexity is minimum? For example, the dictionary has the following words, "aaa","aaaa","aaaaa","aaaaaa". How to store them in Trie efficiently? a | a | a word: "aaa" | a word: "aaaa" | a word: "aaaaa" | a word: "aaaaaa" The above diagram shows that those four words are saved in a Trie. How many char 'a' are saved in Trie, only 6, not 3 + 4 + 5 + 6 = 18 chars. Four words are saved along the trie nodes. Every node can represent a word, it does not have to be a leaf node. The C# code is written based on the study of one of Leetcode discussion. 

You have nondeterminism in your code, which will make it very difficult to have fair benchmarks. Case in point, CPython produces different results to PyPy. We can fix this by removing said nondeterminism. I believe your only significant source is 

The th person's list of friends is the list - take a single of the first dimension and the first of the second. The matrix in Numpy is thus the same with another dimension: 

No concerns; this is a good thing to do from a documentation perspective and it's even better with IDE support. I would be hesitant with ; the standard name is the shortened , so it would be. Even so, it seems strange to put all the ABCs in one place; why not put them with the classes that implement them? In , you do 

Preferably, it should also be fleshed out with useful information. Many of your other comments are mostly useless: 

Introduction of Algorithm: I am learning the segment tree and also binary index tree this weekend, and I studied binary index tree from the article on hackerearth related to binary index tree and segment tree from the blog algorithm: Ahoy, Pirates, so I decided to take some time to practice the algorithm, spent a few hours to work on the algorithm "Kindergarten Adventures" on Hackerrank university codesprint again. Also, I like to present the idea from Hackerrank editorial notes first, and then share my C# practice code to ask for code review. Editorial notes: If a student asks for a minute extra time, then he can never be happy. We can ignore him. If a student with id asks for a minute extra time, then if we start from id \$a-t\$ (if \$a-t\$ is negative, wrap it around), then he will be happy. Not just that, if we start from any id lower than that he will be happy. So we get a range of students ( the range may wrap around ), from which if we select an id, we are sure to make happy. For each student, we get a range. Now, we have to select an id which is covered by maximum number of range. This can be done using Binary Indexed Tree or Segment Tree. We need to deal with ranges that wrap around. The students are sitting in a circular fashion. Imagine they are sitting linearly like an array from to . Now just append \$1\$ to \$N\$ to the array, so that we have two segments that go from \$1\$ to \$N\$. Now any \$N\$ consecutive elements of the array is a valid ordering of the students. Now work with the second segment of the array. For each position \$N+1 \le i \le N+N\$, if student \$i-N\$ request \$t\$ time, then we need to add \$1\$ to range \$i-N+1\$ to \$i-t+1\$. Next, to find the value of \$X\$, we iterate over \$1\$ to \$N\$ using \$i\$ and select the index for which sum of values at position \$i\$ and \$i+N\$ is maximum. My Implementation of segment tree I documented the step by step how a segment tree is built using the array starting from , and added some notation for each node in the segment tree using array index ID, range of the node is represented and also the value of node in the comment, went through the sample test case . Make sure that every step is making sense and then assume that the learning of segment tree can be accomplished by this simple test case. Most important is to implement the API of Modify and Query using time complexity of , whereas Modify function is the second argument which is the range of interval, Query function is input argument value. Otherwise timeout will be an issue in the problem solving. Test case study I did spend time to learn the algorithm about time complexity. For any N smaller than , I certainly can choose as to analyze. Suppose that there are students in the circle, suppose that the first student only need to minute to finish drawing, so that the first student can complete the drawing for any student chosen by the teacher to start. Related to SegmentTree class Modify API, it has to increase those nodes by value . If the time complexity is linear , and if all students has operation, then there are operations of N2 = , almost million operations, but the time limit is only 3 seconds, so I am pretty sure that the function will cause timeout. So that we have to lower down to intervals to cover the range of using segment tree. To make it simple, we assume that the range's width is instead of , and see how many steps we need to mark in SegmentTree class variable tree[]. We will show only increment operation. Let us get our hands dirty on the calculation of tree.Modify(0,1024,1). We read the code pasted here first. 

Some of these comments are trivial, so remove them. Also, use an early return, since it's now a stand-alone function. 

We're doing then then , etc. From onwards, though, there aren't many things set each run. We end up moving back-and-forth in the array a lot, spending more time "seeking" in memory than actually setting items. Consider, though, this decomposition: 

but never use 'em. That's a good way to hide bugs - don't do it. I would deduplicate the actual shifting and outputting by acquiring the arguments separately. First check 

to store . An alternative is doing away with those altogether and storing strings of the form where the is a not a character but an end-of-string marker. This would give: 

Each pass of , one more element on the end of the array is already sorted. This means we can give a paramenter of how many elements to skip. 

is the real beast here, but I'm going to wait before tackling that. I will post the updated code in another answer because I have run out of characters to add it to this one. 

I am not sure if variable names can be named better, and 5 arguments in depth first search function can be replaced by better implementation. 

If the friendship \$1\$ and \$3\$ are added before adding 4 and 5, then the value is less than \$24\$. After the contest, I studied one of C# submission with maximum score, and then did some code review, tried to understand the graph design and also read the hackerrank editorial notes, understood the process to get maximum value of friendship. I put together C# code and also tested on hackerrank, the code passed all test cases. Please help me to review my C# code. Hightlights of changes Add name variable in the class GraphNode to help identify node; add the test case to help understand the algorithm, and be able to add comment to explain the function Connect; use meaningful variable names after code review. I already spent hours on the algorithm and really look forward to work hard on graph algorithm and be able to perform one graph algorithm in week of code contest in short future. 

I have seen something like this used effectively for an online visualisation, although cannot remember what. I suggest doing something similar to simulated annealing where the sharpness of the curve starts pretty flat (say, approx. linearithmic) and ends up close to an infinite potential well. 

uses , which takes \$\mathcal{O}(n)\$ time, and you do it \$\mathcal{O}(n)\$ times, which makes \$\mathcal{O}(n^2)\$ total. The merge is normally implemented by pushing one element at a time to a mutable buffer. 

doesn't seem to be useful either; if the in the is ever hit the loop will be exited by the and if not, the will only exit after anyway. Therefore we can have just: 

I want to quickly list things wrong with this line. Most of these are very minor, but it's a lot for one line. Further, the big problem is particularly big. Minor 

Don't use generic-yet-novel exceptions like - it tells you nothing you didn't already know. Rather, reuse standard exceptions to give the user some way of distinguishing errors based off of meaning: 

I came cross the better idea to solve the algorithm array quadruplet through April 28 10:00 PM mock interview. I like to share better idea to write the algorithm with more elegant code and also address the issues in the above implementation. I continued to learn the algorithm array quardruplet through mock interview practice. I had practiced over 10 rounds of mock interview last 12 months, and every round I had to work on the algorithm at least two times. I have worked on the algorithm over 20 times, but I could not come out better idea for my own question here last 5 months. But on April 28, 2018 I had five mock interviews a day. At 12:00 AM, I had chance to interview a peer using array quadruplet again. I found out that the peer had hard time to write a brute force solution. Later in the day my fifth interview, starting from 10:00 PM, the peer finished his algorithm in less than 9 minutes, I finished my algorithm in less than 20 minutes. So I asked the peer a few questions to test his strength on algorithm. The peer has ICPC contest experience with medals in high school, a senior in the university, and then I asked his solution of array quadruplet since I tutored the peer the algorithm for a brute force solution early in the morning, I like to learn from others on this algorithm as well. He wrote the pseudo code first, and I did not understand his code. So I asked him to explain the algorithm with the example. He gave me some explanation with an example. Here is the peer'a analysis using C++: unordered_max ‹ int, pair ‹ int, int› › allSums; i: allSums will contain arr[j] + arr[k] for all (j < i && j < k < i ) 

Of course, this doesn't matter because your code assumes . However, this is never made explicit. Thus you end up with code that is broken for the untested general case and inefficient for the specific case. You can also trivially remove by moving its functionality inline. Another think I don't get is why deserves to be a type. Generally, it seems that your code works along the lines of 

the paper I linked suggests that the dynamic programming solution isn't appropriate because it has a memory cost $$ n (k-1) \cdot m^{k-1} $$ where \$k\$ is the number of partitions, \$n\$ is the number of bricks and \$m\$ is the maximum value of the numbers. For \$k = 10\$, \$m = 2000\$, \$n = 10\$ we would need... $$ 10 \cdot 9 \cdot 2000 ^ {9} = 46080000000000000000000000000000 $$ ...a lot of memory. If you want to use this option for the special case of small \$k\$, Wikipedia has a good rundown for \$k = 2\$. Nevertheless, there are better algorithms, though, particularly because you have 300 seconds. Implementing the full searches from the paper would be overkill, but it would make sense to incorporate some trial-and-improvement over the first greedy algorithm. I would suggest writing a 2-way differencing algorithm and differencing the smallest and largest towers with this technique. Repeat until a near solution is found. 

To summarize, to increment nodes value by 1, only need to increment nodes represented in tree variable, the index array is . The design concern The API Modify and Query works together very well with SegmentTree, but however each node in the tree does not explicitly include the range it covers, I need to look into this issue and see if there is a quick fix. I may not fully understand segment tree or binary index tree and have some misunderstanding of segment tree, I like to ask code review. The C# code passes all of hackerrank test cases. 

I ran the submission again and it works for Leetcode online judge. I also questioned myself about hash function design last year, should I focus on the study of computer science or mathematics, cryptographic hash function? 701 is a prime number. 

Problem statement You're researching friendships between groups \$n\$ of new college students where each student is distinctly numbered from \$1\$ to \$n\$. At the beginning of the semester, no student knew any other student; instead, they met and formed individual friendships as the semester went on. The friendships between students are: