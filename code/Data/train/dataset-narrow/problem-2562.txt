would mean a sequential list of references to ComponentClassName and whatever you do you get a reference, then do that in C# don't have sense, something similar as what I'm doing is better for C# (each entity have a vector of pointers, well references in your case, to components, static casts are still needed). In C++ you can do std::vector and that would be different than std::vector (with the * at the end) so the method suggested in the wiki may still have some sense in C++, maybe it requires even less memory than what I'm doing. You still may prefer the wiki suggested method as you stated that you are concerned about doing casts constantly. With one vector (List) per component type, and the entity being only an integer, you don't need casts at all. Something like: 

If your x and y coordinates are taken from the center of each sprite then don't worry simply apply the first formula. To detect if boxes overlap 

The principal difference between a script or a program is that the script is completely dependent of the API its scripting engine exposes to it. If I code a game in C++ using a C++ game engine, I'm not doing any scripting, my resulting binaries are standalone and are not limited by the engine's API. I can use the virtual filesystem (if any) of the engine to read files, or I can completely bypass it and use calls to the operating system API. Usually, when the game engine support scripting, I only can do what the scripting language syntax + game engine API allow. Given that definition, If I'm coding a game engine and I want to support scripting, simply distribute a Python installer with the game engine and an API to allow the scripts to interact with the game engine may not count as scripting, as a Python program can do pretty much what a standalone program can. To adjust to my definition of scripting, a modified version of Python may be required, with many modules removed or somehow not allowed to use, then you can say the user of the engine is doing scripting, and not a full program that interact with the engine. The javascript running in your web browser is a better example of what I have for scripting. You can do almost everything with it but I challenge you to write/read a file to the filesystem or use any of the OS APIs. It is completely restrained to what the browser engine allows It to do. It results convenient to the developer and protects the user. There are game engines that have their own scripting language and others that implements an existing one. 

Do experimentation and get random features may or may not be harmful. It may even be beneficial or unavoidable. For example: you know that you want to support jumping (many 3D/2D RPG do not allow to jump). How do you know it? Because you imagined a game map requiring jumping to sort an obstacle? So the jump implementation is good enough as long as it lets the player sort that obstacle or does it have to comply with certain characteristics like maximum reachable altitude, can be it boosted by items or game objects in map, physics must include acceleration or bounce (when Mario jump into an enemy He gains impulse to elevate again and that is very important for the game play)? If you already can answer those questions then your design documents (imaginary or real) are very complete. If you cannot answer those, then your design is incomplete. In this case, you will have to go again to work in the design or do experimentation to fill the gaps. The opportunities may be very open or very restrictive. If some of your game levels will have obstacles, and you just need the jumping for them then there are a lot of freedom to decide the maximum reachable altitude or the speed, maybe you decide to pretend there are a physics engine begin it all just to improve the visuals of the jump animation but you do not need it for anything else. (In many 2D RPG games you cannot jump when you want, but as long as there is a single tile hole in a map, trying to step into it automatically triggers a jump to the floor tile next to the hole tile) I understand that It is OK to go to code without a complete design as long as you respect what is already decided. Also It may be unavoidable in some situations as game universes may be built from a variety of different thinking processes. For example a card game: I know I want the cards to have Attack and Defense, a certain numbers of card in the table at a given time and that the player during his/her turn can choose with which card attack which other card. It may look to some as an already complete design, but then it comes the balancing of the game, only possible through many simulations. After many simulations I decide that a card with Attack 10 is overpowered, I can simply delete it from the game but I like it too much so I will do something different, I will create a new rule that says that if a player attack with such a card it cannot attack with other card during that turn. Now I have a new rule that enriches the game mechanics, but apply it to a single card looks weird (like a dirty hack), I realize It looks weird and then I decide to create a new set of cards that have high numbers but the new limiting rule applies to them. Now I have a more complex game mechanic, built above the simpler original one, in my opinion, I turned it to my advantage to make a better game. Now, one thing about that last example, in the proposed example of the card game, new cards may result in new assets (cost increase, time increase). But I think is a good example of let the opportunities you only see when coding influence your design decisions in a good way. I don't think most of the games we play were fully designed before coding, I'm sure they had to make difficult decisions to comply with timelines and so. When somebody else is paying for it all: explain, negotiate. 

renderer.renderSprite(sprite, posx, posy, rotation, scale); If this where C++ renderSprite would probably contain api specific calls (DirectX, OpenGL), but being a html5 game, it probably contains only canvas calls. Having a render system then is only a choice of code organization. If you still need a method like renderTree or renderMonster then I would make them part of the sprite or entity. The Tree "class" then share the same prototype of the sprite "class" but define its own render method. In javascript this does not look so unnatural, I remember doing something like this: 

Ok, but consider the cost of constantly modifying the tile map dimensions. A Tip: don't even include set methods for the size in your tile map class, but have them in the constructor, you can plan your design so you never need to recreate a tile map except when entering a new room. When entering a new room destroy the tile map and create a new one. You probably want to unload the tile index and load a new one at this time too. Also, for tiles width and height, you want to set them in the tile index. Usually you will have the same size for all the tiles of the index, so remember w and h for each tile is not optimal, best is have a single w and h members variables in the tile index class. 

Is enough to know that T is greater in one axis than the sum of the length of the two relevant half extents of each involved box to know that there is no overlapping. Then you can stop and assume no collision. Logic to detect collision finalizes here for most games. If your objects are moving really fast, more than its width or height in a single game tick, then you will need a more complex method, like divide the movement in small steps (less than the box dimensions) and then do the collision check. Remember the previous position is useful for this. What to do when colliding? For the case of Player Sprite vs Platform. Assuming Platforms never move, whatever impacts them. If collision is positive, then you will have to find penetration vector to move the player sprite back. We are using AABB to make that task simple. You want the sprite to remain in touch with the platform, not to go back to its previous position, that may be far away. We already calculated T, and used it to find overlapping, now we will use it again: Formula for penetration vectors lengths. (We don't know direction yet).