I wrote this code for dynamic strings and would like to know what mistakes I've made. It's just a struct that gets filled on the first call to and freed on the first call to . It uses for concatenation and supports a few basic operations. Here's the header 

I was reading about opaque pointers and decided to try it with queues. Please review my code and let me know if there are any errors and how to improve code quality and performance. It uses lines to enqueue and dequeue. All lines have fixed sizes and dequeue/enqueue never share a line. New lines are added only when all lines are full, not counting the dequeue line. The lines are stored in a linked list. queue.h 

I found myself writing code to run at a specified frequency more than once, so I decided to make this simple timer. My main concern is that this is not the most efficient way of doing this since with I would just ask for the time in ms and sleep in ms. I'm storing the current time in to avoid the possibility of it becoming greater than the final time and generating a huge pause since it's unsigned. Usage is pretty simple, is called once before the loop and is called once at the end of every iteration. timer.h 

Summary: While I'm no c++ coder, it looks for the rest good. If you really want to score high you could use recursion for the for-loop. 

It's hard to say but if I get this with an interview, you will not pass. On the other hand, I'll find it good you come to here to learn. Number 1 is really red flags. Let's start with the review. 1. No with logic. I removed the comment lines to point it out. 

All over : Nice readable code, as an outstander, who doesn't know the things the other classes need to do I still understand what this class has to do. 

Method names do not start with a capital. starting with a capital is for classes. Fourth : You rely on users of your class that they close your connection. You will have memory leaks cause they will forget to close your connection. There are 2 possibilities what you can do. First : 

You are declaring this synchronised. So if 2 threads are calling this method, the second one has to wait until the first one is finished. Because you don't have an input variable, the output will always be the same, setting false. In this case there are no race conditions what could affect the outcome of this method, so I wouldn't make it synchronised. private static final : You are making a great use of the fields. What I'm not liking is the next step : 

This is known as a guard statement, and they are very nice. Avoid using without specifying the type of the exception you wish to catch. In this case, it's particularly bad as you are not even logging the error; someone could come along, shoot a bullet through the hard drive of the machine you were running this on, and your service wouldn't note that anything of interest had happened. I'd suggest that when a request fails, you return a non-200 status code; at the moment, your bullet ridden hard drive will not cause a single non-200 status code. Download If the file exists in Mongo, but not in the FS, currently you say . However, due to the statement which doesn't specify exception types, your code also says that no matter what else goes wrong (recall the hard drive with a gun wound). I'd find out what class of errors come under the file not found category, and then treat them differently to others. Currently, if the user looks up a file that doesn't exist, you return , which I think bottle will complain about. It'd probably be better to add a guard clause along the lines of 

I'm not 100% sure there is a particularly elegant way to write this. If the code did not have a different body for each statement, one could rewrite it like this 

You do not check if qc is null, what is possible when you get an exception. You have 2 options for this. 

We start with that tab disabled. As the subscriber is created you can set the disabled to false and set the source of the include, so the tab will unlock. Another option, what I use in mine application is using the "visible" attribute. 

Now you have a more generic method that can sort, even more entries in the map is no problem. Hope you have something from this review. 

As you can see now, I can easily refactor the code. Let's say you class grows and we need to change the to For me it's one little change and it's completly done. Your old class, you have already to change it 3 places, possible fault's .(forgetting one to change) waiting to happen when your class grows. 

for the same result. Naming : While you have not many var's to call => I like that you already point to the bottle. Still I'm thinking could be a better var name. While loop : Well it doesn't make a big difference but for your own sake, use a for-loop. You don't forget to substract one then. 

I just wrote this pool to avoid calling and when I have some code that frequently allocates and deallocates chunks of same-sized memory. I would like to know if there are any bugs I didn't notice and what would be the best solution to achieve this goal. I'm using some small functions that aren't really required because I find the abstraction nice when using the code later and because I noticed the compiler will optimize them away when link-time optimization is turned on. I'm using about the same code I posted before for the stack. 

I'm using these 2 functions to handle file input/output and would like to know if there's anything that should be changed. For content retrieval, enough space is allocated and the file content is copied. To make sure saving a file either saves all or nothing, I'm writing to a buffer then renaming it after all content is successfully written. I'm particularly interested in knowing whether these functions are safe or not since is considered dangerous. I read the main risk is a file with the name returned by being created before we are able to do it, so I'm using to make sure it doesn't happen. Is this enough or there are other security concerns that I'm not aware of? files.h 

The intendation is correct but always use braces for if's. A lot of mistakes with if's comes from this. Example : 

It's clear that this String need's to hold todays day formatted. The thing what you could improve is making the static. Like this you don't have an instantiation each time you create an instantiation of the 

This is completely safe in your pojo, nobody could even acces the object. And outside the package no one will ever see this method. The advantage is when you refactor or the method name, your test is automatically updated. 

This field could be because you set it in the constructor and there is no setter for setting this at a later point. LogFileFunctions.java Javadoc preffered 

A bigger problem here is that you don't log the . It vanish in thin air cause you don't use the in the catch. Succes with finding the problem at that time. 

Code should be self explaining, so if you need to put comment behind a variable name to explain it, there is something wrong. Mine suggestion is : 

Personally I wouldn't do this. The reason why is when your field change name, your test fails because the field is hardcoded there and with refactoring this isn't persisted to the test. What should I do? Normally your is in the same package as your . When this is correct you could use a protected method. Example : 

MainHandler The name tells me nothing. Due to your routes being defined in a different place, maybe naming it something like would be better (though I still don't like that). An oft advised idiom on this site is the use of guard clauses. I'd recommend using that here; instead of 

Yes, that function terminate (unless the semantics of are stranger than expected and is an infinite generator). One thing to be concerned about might be that, should your query take a very long time, you would not delete a single blob before a is thrown, and so schedule another task without doing any work. This is a bad thing, as you may end up with many jobs that simply get half way through a query, give up and then schedule themselves to run again. The worst part is that your only indication would be that your log would be full of level messages (i.e. messages that will be ignored), giving you no idea that this travesty was unfolding in your task queue. I would recommend you add some kind of limit to make sure you are decreasing the number of blobs towards zero each time. You could think of it as an inductive proof almost; see Burstall's 69 paper on structural induction if you feel like formulating a mathematical proof. However, that is probably not necessary in this case. My suggested rewrite would be something like: 

edit : This last one is wrong cause doesn't implement . Or from java 7 you can use try-with-resource When you extend and implement the you can do the following : 

Or something like that. Let the method return the actionlistener, but in the creation of your actionlistener use also at least 2-3 methods. Edit : Your problem : Use instead of with your eventlistener. looks for multiple button clicks, so it will merge some events. 

Default values This is a part I have to say. It's educated to me so I educate further but I'm not a fan of it. 

We all know what you are trying to do. But what happens if is magically turned 10? You have a bug that will not correct by himself. Let's say we do the following : 

I was working on refactoring your code. When I was finished I saw that @tim already posted an answer. He address the most what I also wanted to point out, but in mine opinion he forget 1 thing. 

Are now package private. Declare them private and if you need them outside provide getters and/or setters. So it should be : 

I'm looking at this class and I'm confused. The reason why is that I'm doing web programming so a dialog can be asked on different sessions. In that case this class is useless. In stead of holding your and in your class as static variable, just return them in the method. Then your 

Note that this does not explicitly address the lack of an inductive variable, though it does limit any damage done. Another thing to note is that you have a race condition on the . Should the method be called concurrently, say by process A and B, then the call to could return the same set of bobs to each. They would then attempt to delete the elements twice, which would raise an error on the call, leading to fewer blob deletions than expected. This problem gets a lot worse when we consider more processes and things like unspecified ordering. The correct way to handle this is to treat any exceptions thrown by the in a more nuanced way than you are currently, and accommodate multiple attempted deletes without prejudice. Your current code will work fine at the moment, the problems will manifest themselves when things get more complicated. While I am sure Google's infrastructure can handle these upsets, your bottom line may be less flexible. 

I think that covers it from me. There will probably be someone out there who will turn up shortly to shout at me for talking about security without a PhD, but I think you should be OK (Hash your passwords, kids!).