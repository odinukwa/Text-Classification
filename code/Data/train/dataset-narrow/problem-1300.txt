Flexibility You have fixed your data type to be . What if I want to store, say, a double, or a in my list? Fat chance. Instead, you should make both classes templated, so that you can have lists of whatever type you want. Interface I'm sorry to tell you this, but your linked list is basically useless. Why? Because you don't offer any interface for iterating the list. So what can be done with it? Currently only two things: It can be printed and you can calculate its sum, so not very much at all. What you're really missing is an iterator interface here (although a pointer interface would be a start, I guess). Although iterators are kind of cumbersome to implement, they are one of the most useful features of modern C++ and required if you want your class to be able to operate with standard algorithms. For example, there is which makes your function obsolete (and is also more versatile). Furthermore, you have a lot of and methods which are hardly necessary. You should take a look at what offers as an interface and orient your code at that. Another thing which is really important is that you disobey the rule of 3/5/0 (depending on the C++ standard you're targeting). Although you do implement a destructor, things such as copy- and move-constructors are missing, which makes your class hard to use (making copies is basically impossible). That also answers your question of what you need to do to be able to pass your list as an argument to functions: implement all required special member functions. Lastly, we need to talk about error handling. A method such as has a huge problem: You cannot really signal an error. Although you were farsighted enough to take care of the fact that your list might be empty, you didn't find a good solution to that problem: Just returning -1 is bad, because as a user you can't distinguish were this number came from. After all, it might just be that the first element in the list had the value of -1. Luckily, C++ comes with a special error handling feature: Exceptions. Instead of returning you could just throw an exception and have the error be unmistakably passed to the caller. However, exceptions are expensive and should be used sparingly; maybe you'd want to consider having as a return value instead (if you are using C++17, of course), or remove the check altogether and make it the user's liability to check the size first (In fact, ) General Hints and Tips about Coding Style 

I personally find it very important to not be sloppy with code (as I presume you do, since if you didn't, you would not be coming here for code review), which includes comments. The reason is that introducing sloppiness at one point tends to carry over to other parts of the work, at least for me. More importantly, however, comments are a way of communicating with other programmers; as such they should be clear and easy to understand, which is somewhat hindered by bad orthography and grammar. 

There is more to review in your code, but this answer is becoming more and more of a wall of text, and you'll have a lot to do understanding my points and the reasoning behind them and realizing them when reworking your code. As you may have realized already, your code is not exactly top-of-class (which is totally okay; changing that is the reason I suppose you're here). In particular, it doesn't even work as expected, which is actually a disqualifying criterion for CodeReview, but I'll turn the other cheek that this time since you didn't seem to be aware of this and didn't mention it at all. My suggestion is this: Take your time, work through this answer, ask if you don't understand anything, and, when you're finished implementing all suggestions, post a follow-up question with your reworked code. I'll be happy to do another iteration on your program. 

As I stated in the comments, both of your approaches have a time complexity of O(n), but your first approach has a O(1) space complexity whilst your second one requires O(n) space in the worst case, because creates a copy with all the matches removed. From complexity point of view, your first approach is basically ideal. In order to replace all occurrences of a char, you at least have to iterate every char in your input once, which corresponds to O(n) time complexity. Also, space complexity is, as stated, O(1) which is, obviously, the best case. 

You are missing . Fix that, or your code might not compile on a different compiler than what you are currently using. Don't use C-style arrays. C++ offers , which adds some more handy functionality (such as iterators) and prevents some nasty bugs (caused by array-pointer-interconversion, for example). Don't use C-style strings. Either use , or, when you are sure that the underlying string has a long enough lifetime, use . C strings are inherently unsafe and thus discouraged in modern C++ code. should most likely be , since you are modifying neither nor and both are small enough to be efficiently passed by value. This does not necessarily apply anymore, however, if you follow my suggestion from point 3. Use less . I'm sure you will not suffer too much from writing every few lines, and both people reading your code as well as the compiler will thank your for it (also, you're preventing some nasty ADL bugs, which can be a real pain to debug). 

What is evident from this is that variable points to an array on the heap containing pointers to objects on the heap. However, your destructor only takes care of the objects the contents of the array point to, not of the array itself. The fix is simple: Just add at the end. Speaking of which... Don't do manual memory management in C++ unless you really, positively, absolutely have to. Take this as a lesson. Your program leaks memory, which is one of the least bad things that can happen when working with manual memory management. The potential to shoot yourself in the foot is much, much greater, and C++ offers a variety of auxiliary classes and containers to prevent you from leaving your toes somewhere during program execution. Knowing this, let's look for help in the standard library. Your use case is something like this: You want an array on the heap, the size of which is fixed and which contains owning pointers to objects on the heap. What standard containers offer such functionality? Well, since your size is known at compile time, would be one possibility, although in that case, the contents would live wherever the enclosing object lives (i.e. if you have your queue on the stack, all of the memory for this array is also going to be allocated on the stack), which comes with a risk of stack overflow. Thus, let's make this an . Another alternative would be to use the arguably most common standard container, , which is completely dynamic (i.e. can change its size at runtime) but usually doesn't incur any additional costs when accessed like a normal array. The decision about which one should be taken depends largely on whether you want to keep as a template parameter. In my opinion, doing so is almost completely useless since you don't really do anything at compile time with it and it hinders interoperability. Instead, I would just have the constructor take the desired size as an argument and initialize the underlying container dynamically, in which case becomes unfit since the size is no longer determinable at compile time. Ultimately, the choice is yours; however, you should ask yourself whether you can provide any real justification for restricting the use of your queue to cases where the required size is known at compile time (which is not the majority of cases as far as I can judge). Even in that case, the benefit that provides is largely marginalized to the fact that you're allocating it on the heap. But even after that choice, we're still not done here. Another reason that raw pointers are largely discouraged in modern C++ is the problem of ownership semantics. What are ownership semantics? Well, basically it means expressing which part of your code owns which values, and which part only uses or borrows values from other parts in the code directly. There are different approaches to this for different parts of the problem, but for the owning-pointer-to-heap problem, C++ offers and since C++11. The benefit of these pointers is twofold: Firstly, they express how the object they contain is being owned (single ownership for , shared ownership for ) and secondly, they provide safety through RAII abstraction of the memory allocation process. Both pointers automatically free the memory they point to when being destructed. In your case, the ownership relations are clear: Every object in your queue is a part of the queue and only of the queue, i.e. the queue owns it uniquely. The container just hands out pointers to single elements so that such elements can be used by other parts of your code, while not giving up and transferring the ownership over these elements. Accordingly, this is a perfect use case for . The element type of the container you choose should be , and those elements should be initialized using (or if C++14 is not available to you). 

Both of these are to be found in the body of the constructor. Obviously, you are trying to align you definitions/operators. Even more obviously, you are failing at it. Although both of these lines align with something, what they align with is not all easy to recognize. I don't know whether this is the fault of a tab-width mismatch between the code block and your original code. All I can say is that that indentation looks out-of-place, and left me confused the first time I glossed over your code. In general, aligning initializers etc. is completely acceptable, but you should refrain from doing it if the alignment reference is not at most one line away. Otherwise, it will just look strange, and overall a programmer's as good as you unworthy. About Ah, C-strings. Don't use them unless you definitely have to. Why? Because... 

First of all, as πάντα ῥεῖ already stated in the comments, using is not a good idea, and doing that in a header if a lot worse. You're begging to introduce subtle bugs into your code as time goes on and things are added to your project and the standard libraries. Typing a few times is not going to kill you, I'm sure. is a code smell; relative paths in an include often indicate that your project structure is not good or your compile flags are not complete. You should specify all necessary include directories in the compiler invocation command line. is not portable and should thus not be used unless absolutely necessary. Is this the case here? I don't think so. Make users of other operating systems (i.e. operating systems that aren't Microsoft Windows) happy and remove that line. What happens if I enter the string to your program? Whoops, undefined behavior! Why? requires to be at least two characters long, which in my case it simply doesn't happen to be. You should add a check to verify that this condition is satisfied. seems redundant and superfluous. All of those includes should be at the top of your implementation file, not in the header. All includes that are not used (e.g. ) should be removed. The function doesn't serve any real purpose, except obscuring the fact that something throws and exception, which can lead to people wondering where those exceptions come from. Also it isn't used, so it should be removed as well. 

Please feel free, of course, to also review my code generally without respect to the above questions. 

Don't use . does the same thing, but doesn't include the unnecessary flush comes with. You don't need and . You can generate all lowercase letter by adding their offset in the alphabet to (i.e. ) thanks to the (almost) ubiquitous ASCII encoding. The same is true for digits. is not the right type for index variables. Use somethings more appropriate, such as , instead. You should export some of your code to proper functions. Just putting everything into makes your code hard to read and prone to bugs. As Cris Luengo pointed out in the comments already, is not null-terminated, and thus you're causing undefined behavior when writing it to . is one character longer than it needs to be. Since you never do something with it that would require it to be null terminated (and don't even null terminate the string, just keep an unused character at the end), it suffices to make its length .