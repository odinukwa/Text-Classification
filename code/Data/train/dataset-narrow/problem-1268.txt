Some points: Formatting Your formatting is a bit hard to read. I have fixed it for you, but keep in mind of these standard Java Convention rules: 

Your indentation is quite messy. Indentation is usually 4 spaces in Java, so use 4 spaces. Including some other minor readability improvements (such as each line is a maximum of 80 characters), your code will look like: 

To prevent inheritance: Easily fixed with the keyword. To prevent other parts of code to instantiate your class: It doesn't really matter, does it? You have no code that is not in the class, so instantiation does not matter. 

So if I have 2 arguments, I get the message . Umm... I provided 2 arguments! Suggested fix: Change the above code to: 

Now, why is the first line not necessary, and even discouraged? Well, because you should declare variable right where you need them, and not before: 

I am not sure if this is the formatting problem in copy and pasting from IDE or it was like this in the IDE in the first place. To correctly format your code here, you can copy and paste from your IDE, select all your code, and press or click the button at the top of the editing pane: 

It is usually better practice to import specific classes. Also, I don't even see the use of any of these packages. Don't import what you don't need: it will affect performance. Formatting Your second class seems to have two-space indents. Java standard conventions suggests four-space indents. Your spacing is also inconsistent. Consider: 

Well, read on! Immutable classes should not have any methods. This is because an immutable class should only represent objects that don't change. If a person needs to be changed (not likely though), then the most obvious way to do so is to directly call the Constructor for a new Object, as a person with a different characteristic would not be the same person. 

Otherwise I think I'd go with with a hash of subroutine references. It's easily readable and simple to update. 

If you are using the standard library classes of the same name, I would give the following names the correct namespace qualifier: , , . In C++, this works just as well, IMHO it's mildy more idiomatic. 

Being a trivial POD-struct, most compilers will have little difficulty in eliding most of the implied copies. There is some argument that deserves to be a class as you have no setters for its members, but given that it has little behaviour and the behaviour it has can be provided by free functions I would keep it as a POD . Clients can choose to make a instance should they so choose. Also, I don't see any need to make take a reference to a . It can return by value for more readable code. 

In addition to the other comments, I would also use a different naming convention for types and objects. For example, this looks unconventional. 

One disadvantage is that you can't easily construct a temporary with explicit initial values. If you need to do this you could consider a helper function analogous to . E.g. 

The comment is really bad because it talks about whereas gets the value and gets the value . I think the comment needs a pair of parentheses if the code is doing what you meant. To be robust, you should check whether the parse worked. 

I don't think that your solution looks bad. I would probably use a temporary variable to make the line length a bit more readable. You could consider from the module. E.g. 

Caridorc gave you a lot of good suggestions for rewriting your code. I would just add one thing: if you're just getting started with Python, I recommend using Python 3. From your use of and without parentheses, it seems you're using Python 2. It's good to be aware of Python 2 since there's still a lot of it out there, but Python 3 is the future. Although Python 3 isn't backwards compatible with Python 2, it's not like the case with C++03 and C++11 or Perl 5 and Perl 6 where you essentially have a new language. Python 2 and Python 3 are about 90% similar in the core language. And the last version of Python 2, Python 2.7, has several Python 3 features backported to it, including the function. So if you learn Python 3 and then end up having to work on Python 2 code, you won't have much trouble learning the differences. Aside from that, I would just recommend carefully studying the code that Caridorc gave you. It's a very clever and concise way to write this program. 

This makes testing easier; I can pass in whatever I want without having to build any context, and I can check the return value. Using return values also lets you use doctests, which are one of the cool features of Python that no other language I know of has. 

Then you could do destructive updates to the game state much more succinctly. On the other hand, having a giant, monolithic variable being passed through every function is sort of not functional to begin with. In the following code, I'm going to treat as a global, because if you have a mutable variable that you always, without fail, pass into every function, wherein you make destructive updates to it, you basically have a global. Let's cut the clutter and just treat it as such. James Hague discusses this issue in Purely Functional Retrogames Part 3 and Part 4, and I'll go over what he says below, but for now, we'll have a global game state, because I do prefer that having a global game state that takes up space in the argument list of every function. To get out of doing destructive updates, Hague suggests unpacking only the pieces of the game state which are relevant to a given function, passing them in, and returning a value which represents the effects on the game state to the main loop. The main loop can then update state based on what value it gets back. This would get rid of a lot of the calls to in your functions; you could bundle up all the necessary changes inside the functions, return those changes, and then have a single at a higher level that makes those changes. With this kind of system, you might move between quadrants something like this: 

Now let's do some actual reviewing... OOP Java is an Object Oriented Programming (OOP) language, which means it's based on objects. You did a good job trying, but if you leave a default constructor and let the calling code do the work, it's not OOP at all. Let's do some serious redesigning: 

Though, as mentioned in the Bugs section, it doesn't really work. In Hmm... Here you don't do ... Also, here: 

Your solution seems generally sound. I would make a few changes: You are surrounding your whole code in a try-catch block. Instead, surround the area where the has a chance of being thrown (Also, use to print for errors): 

I think I can separate Python from Java anc C++ now, so the is no longer there. But just in case, is there a stray ? Is the way this class is constructed Pythonic? Are the docstrings good? 

But most of my complaints (apart from the Exceptions) now don't really apply to the new answer that @rolfl has given. Just keep in mind of these things when writing some other code! 

Even though it saves a lot of lines and typing, it's at the cost of performance and readability. Import each class individually. 

This is because quicksort is \$O(n \log n)\$ while bubble sort is \$O(n^2)\$. How I would do quicksort: 

EDIT: The above review, if not using Java 8, should be replaced by @EricStein's code. Also, is a bad name. Try . 

Similar to , but and result in , and every other combination . What is happening is that the ASCII values are 'd and 'd. Is this really what you want? In this case, you have to do it the tedious way: test each of them to : 

It's just a convention but being able to easily spot names that denote types helps if you start to use more complex expressions. For example: 

is almost always a bad idea. Even in small programs I would avoid it. Your algorithm for is just plain wrong. The area of a triangle is half the length of a side multiplied by the perpendicular distance from the third vertex to the base line, not the distance from the vertex to the mid-point of the base. (Think of a triangle with vertices at (-1,0), (1,0) and (1, 1). The area of this triangle should be 1, not sqrt(2).) Reviewing your class, the default constructor doesn't initialized the member variables. This may be acceptable for performance reasons - for example - if you deliberately want to be able to create large arrays of uninitialized but it's often safer to explicitly initialize all class members in a constructor. Having both getters and setters for and effectively makes them public data members. The only functionality that has is but this can be provided as a non-member function. Once you've done this your class provides no functionality that a simple doesn't. In addition, you can use aggregate initialization for a which can be useful. E.g. 

Personally, I would also avoid . You need to either or to use it. Although the system call itself is standard C++ (from the standard C library), what you pass to it is system dependent. In general I don't believe you should make your programs stop artificially. If they are designed to run in a terminal then the terminal user will be able to see the output even after the program exits. 

Then you can call instead of and instead of You could also put a inside to make things even shorter. These changes give you a kind of API to shorten and simplify interaction with your game state. Here's what those helpers would look like as macros. (Hopefully; I'm far from a macro expert.) In this case, since we're not doing anything special with the order of evaluation, the macro version of looks exactly the same as the function version. 

It's a bit shorter than . (I like Java well enough, but it sure can get long.) Here's the entire code sample with my suggested changes, including the one that eradicates and boosts performance that Chris Hayes suggested: 

and instead of a sequence of vectors, we'd get back a sequence of maps with keys , , and . This usage is totally unrelated to your original intention for this code, but it shows how generally useful the function is—so why make it private and hide it where no one can access it? Let it out and see what uses people can find for it. Finally, for such a small program it probably doesn't matter, but one of my favorite features of Clojure is docstrings. I would write one for any function I was publicly exposing: 

If you run that code, it will print "File opening failed". Of course, that's not really what happened; what happened is that exceeded the maximum recursion limit and the code threw a . But the clause is misleading us. Now imagine that this code is much, much larger, and also you didn't write it. It could take days or weeks (depending on complicated the code is) to figure out that the code is lying to you.