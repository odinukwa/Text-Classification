The reason for this is that returns , and is true. You should pretty much never use . Always use for type-safe checks. 

Unit Tests and Single Responcibility It's always good to test your code. With random data, this is a bit complicated, but at least your original mistake of the same input generating different urls would have been caught by tests. Now the question becomes how to test that there will be no duplicates when randomness is involved. And the easy answer would be to remove the randomness from it. As creating random numbers shouldn't be the responsibility of this class anyways (it's already responsible for managing urls), you could create a interface (with as method) whose instance you can inject into the class (via the method). For unit tests, you can then simply create a dummy random object which returns a static value. Your test would then look something like this: 

Without the validation for directory traversal, this is basically just a renaming of , etc to . I'm not sure it's worth it. You do save the file exists and is file checks, but you have to check the return of the include call anyways. It does however give you one central place where all includes take place, so if you do want to do additional stuff when including (like checking for directory traversal or normalizing paths for different OSes), it wouldn't be bad to have code like this. 

As already noted in this answer, you should really use prepared statements. You should also not use simple sha1 hashing. Just because you added a parameter to sha1 does not mean that you are using bcrypt. The second argument of sha1 is regarding raw output, not regarding the hashing itself. I provided a link to the correct function in my last answer, it's here: password_hash. Apart from that: 

You only use $integer in this one place, so just get rid of it (you can add a comment for clarity if you feel the need for it): 

Yes. is 100% user controlled. Because of this, an attacker can upload any files they want, including PHP files. If this is actively exploitable depends on what is (is it publicly accessible? then you are vulnerable), or what you do with the file at the end. 

It really depends. You would still spam twitter with requests if you handled it like that, so it's probably not the best approach. Still, it takes a while to see when what is happening in your code, because of the nested s, the , and the check for the variable. Because of this nesting, it's also easy to miss errors. For example: If your cache file doesn't exit, and the rate limit is exceeded, nothing happens. There is no feedback for this at all. I would probably go with a structure like this: 

? I don't really think so. The second is clearer, provides less room for error, isn't really longer, and is more flexible. Misc 

Your extension check is pretty much useless, as I can still upload a variety of files with extensions that can gain me code execution, such as php4 or .htaccess. If possible, use a whitelist approach instead. But in your case, it doesn't really matter, as you are not using the extension anyways, the filename is just a random 5 character string without extension. You should also always use prepared statements. Yes, is currently controlled by you, but who knows, that may change in the future. Apart from this, I don't see any vulnerabilities in your script. My guess is that the vulnerability is somewhere else (seeing the logged request that you suspect would still be interesting). 

Now it's very clear what happens when. Duplication and functions Following a redirect with is very good practice. You can make sure that you always do this, simplify the code, and make it easier to modify later by extracting that to it's own function (eg ). True or false Something is either true or false. There is no reason to do an else check on true if you already did one on false. Note though that some equals checks can be unexpected, so you should always use strong comparison () if you don't have a reason not to. 

You can remove , as is already . And to get rid of the nested statements, you could use early returns: 

Performance As your code is executed on every request, it's best to optimize it. First of all, you perform two queries when one would be enough. You could join your and method to a method which returns both values in an array. It's not all that clear, but how I understand it, you do not use a session for login check at all. It would be better to add code that handles the normal session checking, and only use the cookie based authentication if no session is set, and then set a session (so would become , and you would not have any queries on subsequent requests). Security If is user controller, you have a second order SQL injection in . Either way, I would use prepared statements for all variable content just to make sure. Even if there isn't an injection at the time, I could imagine that you will extend your code in the future. For example, currently, there can only ever be one login cookie, so I'm assuming you only allow one user. But this might change in the future, in which case will not be the static string , but some kind of identifier send via cookie. These changes would not be made in and , so it would be very easy to forget to secure the queries. The documentation of says: , this is because it's based on the time it is created. It's not so bad because your salt is actually random, but still. If you are afraid of collisions for the token, you could generate a truly random string and prefix it with the username. Misc 

Now the duplication is gone. Further Improvements Now, the simple approach did remove the direct duplication, but we still have two similar for loops, and we have a function that accepts arguments that do not have real meaning in that context. Let's improve it further by adjusting our print feedback function: 

Your function level comments could sometimes be more concrete. For example : Always? No. Then when not? Why are two passwords passed? Does it hash the password? If so, how? Does it echo something to the user? When does it return what? Naming Your names do not always express what the function does: 

To summarize: Your approach changes input data before it is inserted into the database, which could impact usability. This doesn't even add that much security, and is certainly not considered a best practice approach to security. name This functions doesn't really have anything to do with names. I'm glad that you are not too restrictive, but really, this is nothing more than a length check, so it might as well be called . email This is fine. doesn't follow any email specs, but as it's PHPs inbuilt filter, it seems ok to use it. Style / Coding Standards I'm glad that you asked about this, as there are a couple of issues: 

Security You have an auth type that is called , but which doesn't work on cookies, which is odd. Apart from the added complexity (you have to add it to every form yourself), this is also bad as you can't make POST data httpOnly. It also doesn't make any sense to me (it doesn't work as a remember me token or anything). It's also very unclear to me how you match a "cookie" to a specific user, as it's just random data. If you deviate from the standard approach of sessions and remember me cookies, you should really properly document why and how exactly your mechanism works. 

Structure It's really good that you put the connection stuff in it's own class. But right now, this class is hard to use, as you are printing in it, and swallowing exceptions. As you have a GUI, it would be nice to report errors in the GUI, not on the command line. So your class should throw exceptions instead of printing the errors. Your fields should also be private and accessed with getters. The biggest problem with your code structure is your GUI class though: It's way too big, and it has a method with 360 lines, which is just way too much. Nobody is going to read or understand that later on, and it makes your code very hard to extend, debug, profile, reuse, etc. This gigantic method also contains a lot of duplication, for example the ActionListener are pretty much the same. Create an actual class for them, and pass the button as argument. This would already help quite a bit. If you then extract some of the GUI init code that logically belongs to each other to well-named functions, this would already be a great first step. Misc 

It's not only cleaner regarding strucure, but it also avoids unnecessary overhead and exposing data you don't actually want to expose (eg the id, possibly). Of course if for some reason you do need the whole object, @Mike Brants solution using would be recommended (here you can also define what data you pass on, and using it wouldn't mean having to rewrite your entire application, as the view doesn't need to change). 

It's essentially the same code, making your functions unnecessary. If you do want to wrap mysqli - which may not actually be necessary in your case -, make sure that you: 

I wrote a class which can format input so that it is properly aligned. I'm interested in all suggestions (regarding structure, usability, style, naming, comments, etc). I'm especially wondering about: 

SQL Injection To expand a bit about what @Ã…na said: Yes, you are open to SQL injection. doesn't actually support multi-queries, so the described attack doesn't work, and I would also suggest a different defense than escaping. Even though multi-queries do not work, an attacker can still read out any values from the database. There are two possibilities for this: 

The only reason you have all these methods in the first place is because it's unclear how to use the method. If you would just document it properly, you can remove all the other methods that don't actually contain any logic themselves. I'm unsure what the difference between amount and rent is, but it may make sense to have two methods: and . If both are needed, you could also just query once and save the result in private fields. What you definitely do not want is what you have now, where you add a method for each amount of rooms you expect. That's what method arguments are for. Security You are vulnerable to SQL injection. Never put variables into a query directly, always use prepared statements. Naming 

You can, but it's not necessary. The rule of only having one return doesn't have to be enforced, and often leads to less readable code. 

If you don't like that the array is accessed twice, save the value in a temporary variable. Or just return directly like @dusky did: 

So each field is separated by 3 from it's vertical neighbor, by 4 from it's diagonal neighbor, and by one from its horizontal neighbor. So your code might look something like this: 

Note also that I replaced your s with s, as only one condition can be true at a time. No need to check the other once. You can also use this function in your method. You can do the same for the type checks: 

The definitions of and are still a little vague as I understand them, so your document could also look like this: 

I think you already have a great answer about the general approach you took. I'll focus on the readability of your code, as there are some very simple things that you can do to severely increase it. Paragraphs Currently, almost every line is on its own paragraph, resulting in way too much vertical whitespace. Your function for example is 82 lines. Just by using sensible paragraphs (eg no new line after or before ) you can get that down to about 50 lines. If Structure When writing an , it is generally a good idea to put the case that contains less lines first. It is really difficult to find the corresponding when you can't even fit both of them on the screen. Often it also makes sense to return in the else case, thus avoiding deep nesting. Comments Your comments shouldn't simply repeat what your code is already telling us. Comments like that do not add any information and distract from the actually relevant comments. Examples are , , etc. Exceptions There is no need to catch exceptions if you can't actually handle them. Just let them bubble up until you actually do know what to do. And if you do use PDO exceptions, you might as well also use exceptions for your own error messages. It is preferable to returning null and setting an error message (which the caller may or may not check). If you follow all that, your method would now look like this, which I think is a lot more readable: 

@Max already did a good job at describing how you could write better code. Here is what is wrong with your current approach: The main problem is that your classes are tightly coupled. All the files you posted need to be aware that you are using PDO, which isn't good (it's hard to read and maintain). Your class also doesn't make any sense. It doesn't contain code that is specifically concerned with anything related to admins, it just contains part of the database access code (but for some odd reason not all of it). So what I would do now is: 

Readability Your code is extremely hard to read, which makes it hard to concentrate a review on the specific points you want reviewed (although I think that the general structure of your linked list is actually alright. I would probably put and together in one class, but other than that it seems fine). When writing code, try to think about the people who are going to read it (this might include you in the future). The lack of readability has a couple of reasons, many of which can be fixed really easy: