I am especially interested in whether the code is pythonic and how it could be improved. E.g. the use of regexes to parse the instructions feels kinda hacky. 

I'm currently using the Advent of Code programming challenges as an opportunity to learn some python. The following code is my solution for the Day 8 challenge, where the task is to write a programm that reads a set of instructions which are then performed on registers. Registers start with a value of 0. Each instruction may increase or decrease the value of a register. The programm should return the maximum value in any register at the end of execution as well as the maximum that any register had during the whole process. An instructions looks as follows: . Where is a name of a register, is either to increase the value of a register, or to decrease its value. is a comparison operator. The instruction should only be executed if the condition is true, e.g. will increase the value of the register by 10 if the current value for register is less than 0. I read the input from a file called . An example input can be found here. The expected output for this input would be . 

Let's say the user picked "heads". We go into the first conditional and call . If that returns 1, we print that the user won. Say it returns 2. Now we go into the conditional and call again. Now, half the time, it'll return 2 again and the program will look like it works. But the other half of the time, it'll return 1, and this conditional will also fail so that your code will print nothing. You definitely want to only call once per prediction: 

This returns a generator, instead of a list, but generators are typically far more useful anyway. I feel that this approach makes it much more explicit what it is you're actually doing: you're yielding the first element, and then the pairwise difference between the rest. 

and has several examples in the standard library (, , , , , and ). A lock is something which, for lack of a better description, locks a lockable object. The simplest lock in the standard library is , which is just an RAII scoped lock templated on a and can be implemented via: 

Use when it's appropriate. E.g. in simply write No need to write something the compiler knows anyway. This way you can also change the container type without changing this part of the code. Unecessary copies In the following code, you're creating and copying too many objects: 

The same goes for your checking for random events. Make that a function that can take a probability and returns or : 

It's easier to write and read. The same applies for creating a random number in some interval. And while you're at it, you can also exchange the random number generator for a better one. Simplifications Your method is rather strange. If you later decide to start your population with 100 bunnies instead of 5, you would require a lot more variables to fill your list. To initialize your list with a number a default created values, simply write . This will fill the list with bunnies, which should be some variable in your class. In your method you should use a range-based-for loop instead of your loop. That will make getting the iterator beforehand obsolete: 

Why are we enumerating anyway? Enumerating is for enumerating. But here, the round number doesn't actually correspond to the letter number. It should just be an external variable: 

Same idea, just more direct. For that matter, we don't even need the ! is an expensive type to construct at compile-time, so it's best to avoid it entirely. Just pass in the types as a pack (though the following doesn't compile on gcc - though even there you don't need , just use a light wrapper like ) 

As a possible optimization, the copy assignment can reuse the same buffer if it's already large enough and copy assignment for cannot throw (simply then manually destroy all the leftover elements). Virtual destructor?? There is no reason for the destructor to be virtual. You're adding a vtable to your class for no reason. With the new change to using to allocate the array, we now need to use to delete it (along with manually destroying every element): 

Repetition You have four s defined. All of them forward to the appropriate , which is good. But we still have to rewrite everything. We could make this a non-member template: 

Note that I already change the container type to . Otherwise the random access through would not work and you'd have to use again (or save the iterators instead of indices). 

The use of the range-based-for is great, but you should use a reference there, since you only need to read one value of it. Otherwise each female would be copied as the variable . Furthermore you are creating a new object and copy that into your list. You should use the method in this case, which will directly create the object in the list: 

Another thins is your constructors for . They do exactly the same thing, expect for the initialization of . If you want to change it you always have to do it twice. You could simply redirect the calls as in: 

Game Currently your game is just a bunch of methods. It should be a class that keepts track of its population itself, not by passing a list of bunnies. Now I can easily "cheat" the game, by manipulation the bunny list from outside. By keeping track of its own population you could also do things like running multiple games simultaniously, e.g. to compare experiments based on different starting conditions. This would eliminate the static variables in your bunny class. Seperation of concerns You should seperate your logic from your output. E.g the shouldn't do any output. It's the games task to do that. Update: Use as a default Currently you are using as your container for bunnies. While that sounds reasonable, in C++ you should stick to unless you have a very good reason not to. Especially since you are randomly selecting bunnies from you list to manipulate them, a is far better than a , since that can be done immediately, while for a list you have to loop all the way to that element. Bug As mentioned in the comments, the method doesn't do what you want. Through the method you are creating a copy of your initial bunnies that a normal. You then only iterate and manipulate this copies list of bunnies, not the original. So your vampire bunnies are not successfull at all. So instead of returning a list of normal bunnies, return the indices of the normal bunnies. And then randomly select ab index out of that list and change that bunny: 

for in . And the expectation is in . We want to iterate over both lists simultaneously... "zipping" through them. For that, there's : 

Never use There are times where you have a compelling reason to use . This really isn't one of them. Either make your function recursive, since it is in all but name. Or rewrite it to be iterative. Both of those would be preferred solutions. The reason I say this is because your logic is sort of logic a binary search, except the two different changes in range occur in different places and use different mechanisms. This makes it difficult to understand and, I imagine, debug. A Better Algorithm Add a helper function that will count the number of elements in your given range, breaking out early if you hit the amount you're going for: 

But then for the other special member functions, you should either default all of them or omit all of them: 

Metaprogramming is all about convention. If everybody doesn't agree on convention, everybody's metaprograms may as well be written in different languages. The most core convention is that the "return" of a metafunction lives in a type named . But a fairly common one is that when you need a "metafunctor", you pass something like this. The advantage of something like this is that it's always easy to create a type, but usually not so easy to create a template template (which would be the alternative). Specifically here, we need: 

Includes I figured your has some includes for , , and stuff. While you might find that helpful to only have one header , it's rather bad practice. A header should only include the stuff it really needs, no more. Otherwise you might create false dependencies. E.g. your is the only one that uses , which it only gets through including that doesn't need it. So if you change the includes in you might break . Also every header should have include guards, to prevent double inclusion. Avoid using Don't use to print the end of a line to your stream. It flushes the stream unnecessarily and makes your output slower. Simply use . For more information see here. Don't use Your header has a somewhere. Don't use that, you are poluting the global namespace with a lot of simple and common names. It's also less readable that way. The name is the namespace is so short on purpose, so that's it not a hassle to write. Again, for more info on that matter read here. Don't use magic numbers You are using hard coded numbers in your code for specific checks (required age for reproduction and max population). While it's easy to see what they are used for it gets harder to change them later on, the more your program grows. Use named variables for them, so it's easier to understand and you can see where they are actually used. Don't repeat yourself Whenever you write the same code twice, you should ask yourself, how you can prevent that in the first place. There are multiple instance where you create random numbers in some interval or check whether an event happened with a certain chance. Make those two things functions that can be reused and more easily read. And while you're at it, replace the random number generator with a better one(you can watch this to see why is considered very bad)). You could write a small namespace for such utility functions, e.g.: 

Okay, that's pretty simple. We just have a double loop looking for . That just leaves . That's a function that takes the starting point and returns the largest possible product starting from there. Once you reduce the problem to just one source point, then it's not so bad: 

No extra functions or partial specializations in necessary. Some Checking The in has to be and the has to be integral, as far as I can tell. It'd be worth just adding some assertions to that effect: 

Memory Handling I see but I don't see . Your tree leaks memory. It needs to clean up after itself in a destructor. And once you add that, you get into the Rule of Three: you need to add the copy constructor and the copy assignment operator, otherwise you'd still leak when you copy your tree. Usage Your code looks like an implementation of , and your usage suggests the same, so it'd be better to change your template arguments from and (which mean nothing) to and . Using as the key is confusing - you should name it . Although conventionally nodes for maps in the C++ standard library use s. You should make it clear that needs to be both LessThanComparable and EqualityComparable, or provide ways of passing comparators in as template arguments. If I try to for something not in the map, will eventually become and then you return . Oops! You can insert elements with duplicate s. Is that intentional? should be spelled . Other