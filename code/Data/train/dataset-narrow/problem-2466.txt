I think that using one of the time-bounded variants of Kolmogorov complexity you can build a problem that uses only the binary representation of a number and (I think) is unlikely to be in $\mathsf{P}$; informally it is a decidable version of the problem "Is $n$ compressible?": Problem: Given $n$, does a Turing machine $M$ exist such that $|M| < l$ and $M$ on a blank tape outputs $n$ in less than $l^2$ steps, where $l = \lceil \log{n} \rceil$ is the length of the binary representation of $n$ It is clearly in $\mathsf{NP}$, because given $n$ and $M$, just simulate $M$ for $l^2$ steps and if it halts compare the result with $n$. 

Where "sequence" is a generic sequence. Then, when defining a T-computable sequence, they restrict the attention to binary sequences: 

In the opposite direction, if a valid solution to the original MSP exists, it also represent a valid solution to your problem: just pick $A'_i = A_i \subseteq A_i \cup \{z\}, B'_i= B_i \subseteq B_i \cup \{z\}$. PREVIOUS VERSION The decision version of your problem MAXIMUM $l$-DISJOINT $k$-SET PACKING PROBLEM is: Input: an integer $q \geq 0$ and a collection $D$ of finite sets, each set contains $k$ elements; an integer $0 < l < k$ Output: a set packing of $q$ or more sets, i.e. a collection of partially overlapping sets $D' \subseteq D$ with $|D'| >= q$ and foreach $A_i, A_j \in D', | A_i \cap A_j | \leq k - l$ (the last contraint means that two subsets must contain at least $l$ distinct elements) When $l \geq 3$ the above problem remains NP-hard and this is a reduction from the decision version of MAXIMUM $l$-SET PACKING PROBLEM which is NP-hard because $l \geq 3$ ($k=l$): Input: an integer $p \geq 0$ and a collection $C$ of finite sets, each set contains $l \geq 3$ elements; Output: a set packing of $p$ or more sets, i.e. a collection of disjoint sets $C' \subseteq C$ with $|C'| >= p$ Reduction: simply pick $q=p$, and add $k - l$ new shared elements $Y = \{y_1,...,y_{k-l}\}$ to every original set $A_i \in C$; i.e. $D \ni A'_i = A_i \cup Y$ Suppose that $A'_i, A'_j \in D'$ (where a D' is a valid solution to your problem), then by construction they already share $k-l$ elements (the $y_i$s); so they cannot share more elements, otherwise the number of disjoint elements would be less than $l$: $(A'_i \setminus Y) \cap (A'_j \setminus Y) = \emptyset$. But $A'_i \setminus Y$ contains exactly the elements of the original $A_i \in C$, and $A'_j \setminus Y$ contains exactly the elements of the original $A_j \in C$, so $A_i \cap A_j = \emptyset$ and we can conclude that the solution $D'$ corresponds to a valid solution $C'$ of the original problem. The opposite direction (if there exists a valid solution $C'$ for the $l$-SET PACKING PROBLEM then there is also a valid solution $D'$ to your problem) is immediate. 

Perhaps we can prove a $\log n$ space lower bound for SAT in this way (but I'm not confident with limit/asymptotic analysis, so my answer can be totally wrong). On a Turing machine model with one read-only input tape and one work tape, both over binary alphabet $\Sigma = \{0,1\}$, for every decider with $c$ states on an input of size $n$ we have that : $$T(n) \leq c \, 2^{S(n)} \, n \, S(n) \quad (1)$$ otherwise the Turing machine will loop forever (the $2^{S(n)}$ component represents all possible tape configurations, the $n$ component represents the input tape head positions, while the $S(n)$ component represents the work tape head positions). On a one tape single head TM over binary alphabet (1) becomes $T(n) \leq c 2^{S(n)} S(n)$. Multiplying both terms by $S(n)$ and applying the general space-time tradeoff for SAT, we get: $$n^{1.801+o(1)} \leq S(n)\cdot T(n) \leq c \, S(n)^2 \, 2^{S(n)} \, n$$ So picking a space upper bound like $S(n) \leq (\log n)^{1 - \epsilon}$ for SAT would lead to a contraddiction, indeed $$\lim_{n \to \infty} \frac{n^{1.801}}{ c \, ((\log n)^{1-\epsilon})^2 2^{(\log n)^{1-\epsilon}} n } = $$ $$\lim_{n \to \infty} \Big( 0.801 \cdot \log n - \log c - 2 (1- \epsilon) \log (\log n) - (\log n)^{1-\epsilon}\Big) = \infty$$ 

3-OCC-MAX 2SAT: given a CNF formula $\varphi$ in which each clause contains at most 2 literals and each variable appears in at most three clauses (counting together both positive and negative literals); does there exist an assignment that satisfies at least $k$ clauses? In P. Berman, M. Karpinski, On some tighter inapproximability results (1998). Lecture Notes In Computer Science, vol. 1644 (1999), pp. 200-209 : ... for any $\epsilon > 0$ it is NP hard to decide whether an instance of 3-OCC-MAX 2SAT with $2016 n$ clauses has a truth assignment that satisfies at least $(2012 - \epsilon)n$ clauses. As noted in the domotorp's comment, if a variable appers only positive or negative we can fix its value (satisfying and deleting all the clauses in which it appears); so we can assume that the 3 occurrences are not-all-equal ending up in a "3-NAE-OCC-MAX 2SAT" instance :-) 

are in some sense "equivalent problems"; so if your boss asks you to create a program for packing boxes into a container ... you can give him a Minesweeper solver ... :-) 

Valid configurations for each type of cell. But the cell types are obviously a direct transposition of the four gadgets used in the bounded planar Nondetermnistic Constraint Logic (NCL) and the valid configurations match the constraints of the corresponding vertices in a constraint graph (blue/red arrows in the figure). I'm wondering if a direct quick reduction from NCL is possible. It is immediate to reduce a planar constraint graph to a game (CHOICE cells with a "free" endpoint can be used to build straight links and 90° turns). But in a bounded planar NCL problem $P$ the edges are reversed dinamically (though an edge can be reversed at most once) and the aim is to reverse a single edge; on the contrary the game is static. A possible approach is: build the corresponding game from $P$; "break" the edge that must be reversed (eventually expanding the board) and force it in the final direction using FIXED cells. Then one way is easy: if $P$ is solvable, the corrisponding game has a solution (represented by the final configuration of the constraint graph); but the other way is more problematic: 

Due to the $2i$ element, the vectors $x'_{2i-1}$ and $x'_{2i}$ cannot be contained in the same subset; and a valid solution to the 0-1 VECTOR EVEN-ODD PARTITION correspond to a valid solution of the original 0-1 VECTOR PARTITION (just pick elements 2m+1..2m+n of each vector of the solution discarding vectors that contain all zeros in those positions). STEP 4 0-1 VECTOR EQUAL SUBSET SUM (the problem in the question) is NP-complete: reduction from 0-1 VECTOR EVEN-ODD PARTITION similar to the reduction from EVEN-ODD PARTITION to EQUAL SUM SUBSET, as proved in Gerhard J. Woeginger, Zhongliang Yu, On the equal-subset-sum problem: given an ordered set $A = \{x_1,...,x_{2m}\}$ of $2m$ vectors over $\{0,1\}^n$, we build a set $Y$ of $3m$ vectors over $\{0,1\}^{2m+n}$. For every vector $x_{2i-1}, 1 \leq i \leq m$ we build a vector $y_{2i-1}$ over $\{0,1\}^{2m+n}$ in this way: 

If you are looking for different approaches/algorithms to the problem, perhaps the right "google keywords" are Rank aggregation or Weighted rank aggregation. For example see the paper "Rank Aggregation Revisited" by C.Dwork, R.Kumar, M.Naor, D.Sivakumar. The rank aggregation problem is to combine many different rank orderings on the same set of candidates, or alternatives, in order to obtain a “better” ordering. Rank aggregation has been studied extensively in the context of social choice theory, where several “voting paradoxes” have been discovered. The problem also arises in many other settings: 

At every step you are calculating the value $x$ at the top of a "reversed triangle", and the value is simply the sum of an adjacent element in the previous row ($y$ in the figure) and the opposite vertex at the base of the triangle ($z$ in the figure). 

read the unary input (and store it in the counter); return to leftmost symbol; divide the counter by 3 until the counter contains $2^n$ in this way: go right looping from states $q_{z_0}, q_{z_1}, q_{z_2}$ and subtracting 1; if counter reaches 0 in state $q_{z_0}$ go to leftmost symbol adding +1 and continue the division loop, otherwise add 1 (if in state $q_{z_1}$) or 2 (if in state $q_{z_2}$) and go to leftmost symbol adding +3 (i.e. recover the previous value of the counter not divisible by 3) and proceed with step 4.; at this point the counter contains $2^n$; calculate $2^{f(n)}$ using the $T'(n)$ space available on the right as the second counter (the value of the second counter is the distance from the leftmost symbol $\$$).