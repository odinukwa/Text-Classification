As you can see, is much faster than implementation. Actually, if you are using cpython you do not really want to reinvent standard library functions because they are pretty nice optimized by c compiler and you code will be interpreted instead of compiling. In case of pypy you probably want to make some research, because JIT interpreter have a lot of different corner cases. 

Complexity Sequence definition $$ F_{n+2} = F_{n+1} + F_n $$ which means that your complexity is \$ O(n) \$. Matrix definition $$ { \left ( \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right ) } ^ n = \left ( \begin{matrix} F_{n+1} & F_n \\ F_n & F_{n-1} \end{matrix} \right ) $$ As you can see with matrix definition we can improve complexity using exponentiation by squaring which tells us that $$ A^{2n} = A^n \times A^n, A^{n+1} = A^n \times A $$ Which means that complexity using matrix definition is \$ O(\log n) \$ Big integers Fibonacci numbers are fast growing sequence, so in order to store values you have to use arbitrary-precision arithmetic. 

var_dump($zones); HTML After viewing the results you can create your own view to display the date without having queries and other not view related stuff between your HTML stuff. (I'm sure that i have made some typos in the code but it should work after some fix.) 

Yes the code has grown a little bit but i think everything is in place now lets see what i did. I have splitted the parse and the apply operations into different method and i have elminated the double split (separator '-') and removed the foreach loop and changed it to a Linq call with string.Concat(IEnumerable). You can put additional error checks into the method i have only added the null check in the input methods (constructor). The KeyValuePair is not the best to hold two indexes togatcher becouse it stands for a complete different stuff in the framework as it's name is telling us. The class bejavior can be overridden in derived classes because of the virtual methods and the separated reponsibilities. Test I have created a unit test too to check the results but i have only implemented one trivial test. 

UPD: With single attribute you should create singleton, which will handle synchronization. I had try to draft singleton, but it is not so easy for me. It should be responsible for removing duplicates from task queue and watching on data consistency. 

Garbage timeout Look at dummy example of garbage timeout at fiddle. I'm creating array of 30M elements of , that are binded to root object - window. 

Theory Fist of all check this article about memory management, it will help to find leaks if any. Look closer at this part 

Second quote sad that it is enough to be unreachable from so called roots objects to be collected with garbage collection. So if you follow all recommendation and memory still leaks, than there is one of problems: 

First i have introduced an overloaded method to remove the null check against the List (null object pattern for collections are the empty versions of them). Changed the type to ICollection which is more flexible and intruduced a new static member which get involved in the process where no parameter is passed (can be static for reading it is thread safe). I also removed the AddRange call becouse internally it is interating through the parameters with a foreach loop but only works with Array type parameter so after introducing our foreach loop calling Add manually we have removed an extra ToArray() call which would involve an unnecessary memory copy in the background. Also changed the fill of the DataTable to a more used way and the MySqlHelper.ExecuteReader() does the same thing too. 

Data structures for characters set Storing characters set in the form of the in order to use method every time you what to figure out a position of the element is not the best choice in case of performance. You should probably use additional for excample: 

At least this code is called more than once, so it is reasonable to make a helper function for this purpose and make more reusable code. But I'm sure that you need few strategy classes and multiform manager to hold options and build flow using strategy instances. 

Nodejs and preallocation Lets start with this test where we conditionally switches allocation from static to dynamic. 

If the Place have a string property what can be use at the "is kochi" check then use that in the Any() and leave out the .ToList(). Instantiating the TestDataContext() in this method is bad (can not test the method) please inject it as method or class constructor parameter (you can inject a lambda for instantiating it also). (Syntax errors maybe exists in my code [powered by Notepad].) 

First i have provided az overload to avoid unnecessary passinf if the IEqualityComparer and in the method i'm checking against null values. Then checking their references because if they are the same there is nothing to do. After this i'm using the as operator to check if the input collections are real ICollections and if they are are their Count equal. The casting is fast no need to iterate throught the IEnumerables to get a fixed size collection to get the item counts. Next step is to get the item counts it is using a Dictionary (as Hashlacher did it) with another casting to try get the initial size of the dictionary (not good idea when we have a list with 5 million items but every item is the same). If we have the counts we can make another checks against them: if the item counts or the null counts aren't equal then the collections aren't equals. If the counts are OK then we try to check every item from the source collection whether it is in the other or not. If not the collections aren't equal. 

You can use 2 custom attributes instead of one. In this case you should not swap value, just replace it. 

Note: it is not final or most optimized version ever, I have tried to show you set of approached you might want to know to optimize your code even further. Benchmark using browser Just open console in your browser and paste following code 

field has standard $URL$ for it's numeric value. class property can make some troubles if future, when you'll need to make some manipulations with this list. But in this case it is acceptable solution. there is library called cities_light, it has states and some additional properties. Cons of using it - it require to download it's database (about 400MB) during migration. overuse of property. You should use boolean field and then adopt data presentation on form. Also, you probably wish to separate this huge model into few for performance improvements, but this require some profiling workaround. 

Now the controller expects a bookisticsEntities instance as constructor parameter but the default controller factory in the MVC framework only can use a parameterless constructor so you need a solution for this; use a dependency injection container like Ninject! It's easy to use available through Nuget. N-tier It seams to me your application missing one or two (maybe three) application level becouse currently you managing the database directly which is not a best practise. You have to build at leas one level between the MVC and the dataaccess tier which is called business layer (or two: a service layer and under that a business layer). In this way you controller will expect one or more different type of object instances but not your database model! If you are done whith this you can use simplified models in your application, for example in the Books action method you can use a model which can contain the author's name, identifier and the books also (books can be simplified also). Learn Entity Framework Read a lot about how EF works. :)