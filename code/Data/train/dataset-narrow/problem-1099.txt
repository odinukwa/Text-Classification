You should avoid doing the same math operation for every iteration of the loop unless the result will change based on something that happens in the loop. In this case, you are only reading from the array. So instead you can say 

It's generally better if you choose one style and stick with it. It may make sense to mix the first and third lines in the same program, but the first two lines should not coexist. I would use the second and third versions, but if you like the first, you could use the following with it: 

My reasoning is that when we just removed from the , why should we be comparing it to other elements? It's already gone and we shouldn't remove other elements based on something that is no longer in the . Note that this has no functional impact, as we know that and are equal if we just removed . But I find it easier to follow, and it avoids an unnecessary assignment. The new logic is that we either remove from the list (as a duplicate) or we update (since there are no more duplicates of it, we need to start looking for duplicates of ). We don't do both at once. 

You don't need to pass and into your functions. You are passing everything by value, so you might as well declare them inside the functions. The versions outside the functions are never used. If you use Caridorc's method, you could just 

Class names should reflect what the class does. In this case, I would expect a name like or even . It's not clear to me what even means. Perhaps a reference to the lack of a temporary buffer? Then it should have been . Or just . 

You also might want to consider calling that rather than . To me, implies that it could be at the beginning or in the middle. In fact, my first thought was that you'd insert at the beginning of the list. Alternately, you could also just make into a node. 

First, we define a constant to hold the possible digit values. Then we make a new that masks out the . If is allowed, then we generate all the numbers that start with separately. Then we remove from the , as it won't be allowed in any of the other numbers. printNumbers 

If this were a random function, I'd write out the name: . If you really must abbreviate, would be better. However, as I noted earlier, this isn't random. You are just mapping one input to another, so a name like would be better. There may be an even better name. 

We initialize our list of primes with and . The reason is that is the only even prime and is the only prime divisible by three. So we know that no greater even number will be prime and that every third odd number won't be. 

And if the function ends with , everything will just work. This might have been what your original code tried to do, but the of an did not produce the desired results. 

This is also unnecessary. The function will return naturally at the end. You only need to use if you want to leave early. 

Your function could check the first heuristic and then fail over to the second heuristic if the first wasn't detailed enough. 

is not correct. does not return a value, so this won't work. It's not clear what you should do instead. Throwing an exception is one possibility. 

I also added additional whitespace for readability. Since this is only supposed to work for valid day and month values, I added some basic checks. Even with these, it will still allow dates like the 31st of February, but this restricts the range somewhat. I just return an undefined value implicitly, but you could explicitly (which would do the same thing) or do something like throwing an exception. Note that this also handles if the month or day is given as a string (e.g. January) rather than a number. Handling zero values with different returns than a value of one is possible: 

This uses a single subselect to replace from step 2 with a new version that only includes those / pairs where the second rating was higher than the first. 

That's the chance of not matching a preexisting selection with tries. Note that in that case, the tries can match each other. If you want the probability of a collision: 

Why do you need this? The way that your application works, region B always starts at the beginning of the buffer. There is never a time when you change other than to set it either to or the beginning of the buffer. Why not get rid of it entirely? Then you'd just have to maintain . That would also eliminate an entire class of problems that could arise because someone modified outside your methods. Note that you can read from where you currently read from . You can drop the two assignments: 

There's no need for an else clause that has the same code as the then portion. I also changed the inequality order. The reason is that in C style languages it is particularly easy to write where you meant to write , , , or . As a general rule, it is valid to have an there, so the compiler can warn at most. If you write the comparison backwards, e.g. , then the compiler will throw an error on the typo. This is by no means required, but some of us do it as a matter of course. Obviously there's no point to this unless you are comparing to a constant type value or an expression. Incidentally, I prefer not to use an else with a . An else is essentially negating the if check, so you have clauses for and not . I find it easier to follow if it is and not . Note that in some cases the else is so trivial relative to the main clause that it doesn't make sense to invert them, e.g. 

You shouldn't call this variable . Elsewhere, you use to mean the number that you use to generate the other numbers. You shouldn't also use it for the result. I'd name it either (standard for an unknown value) or (each value that you check is a candidate for being the one that you want). 

When I look at this code, I find an immediate criticism that may help. You name many of your functions as nouns, e.g. 

in your block. I actually think that you are better off allowing the exception to create a stack trace and crash the program. While testing this, I was drawing the exception because the file was in the wrong place. Since you don't log the real error anywhere, I had to remove the / block in order to get the error message. If you mark the method as throwing an , it actually makes it easier to debug.