The good news is that you don't actually have to do this yourself, because since Java 8, there's a method that does exactly that: It returns a comparator that considers less than (and equal to ), and if both objects are non-null, compares them using the provided comparator. The code sample above is in fact a slightly modified copy from the source of . Since you order non-null elements according to their natural ordering, you would just need to call . So the first three comparison stages can be reduced to the functionality of these four comparators: 

Instead of questioning whether it is a good practice, it would be more helpful to be aware of what your first code actually does. JLS §15.9.4 has this to say about the creation of an object: 

I think the main cause for the complications you mention is the fact that the state of a object can, in essence, be reduced to the s of the four subtypes of (by the way, unless you have a specific reason for the s not to be any implementation of but indeed an , you could declare these fields as s instead of s) and all other fields depend solely on these four lists. So you have the same property stored in muliple places, which naturally makes things more complicated, because you have to ensure that the different representations of the properties (i.e. the lists on the one hand, and the individual fields for each property on the other hand) don't contradict each other. A way to circumvent this would be discard the fields storing the individual properties and replace them with methods that calculate a property based on the four lists, like this: 

Of course, it is possible to check whether the collector has the characteristic and to manually ascertain that the stream is sequential, but then I would ask the question: Why bother with such a complicated design, when you can just call on the stream and iterate over the elements in an old-fashioned, but simple and straightforward way? This would be much more to the point, and the risk of headaches would be minimal. 

Unfortunately, I am not experienced enough to give you advice on the specific aspects you mentioned in your question, but maybe you still find some of the following points helpful. 

First of all, your code does not validate the month. If the month parameter is set to anything outside the range of 1–12, then all three fields , and will be initialized to their default values . Now, the reason you are not convinced of your code might be that it contains a lot of duplicate code, namely the validation of the year and the assignment of the three fields of your class. You could start to rectify this issue by putting the code to initialize the instance to the default value of 1.1.2000 in one place only, instead of repeating it for every possible case of an invalid date. A way to do this would be to create a static helper method that validates a given input date, and if this method returns , i.e. if the input date is invalid, then your is initialized to 1.1.2000. 

This does not address all the issues with your code, like the countless unused variables that might be relics from earlier attempts, but it might give you an idea on what you can improve with your code. I would advise you to return to get another review if you have reworked your code (simply start a new question and create mutual links in the old and new question), since, as you say, the code is really very messy. 

Admittedly, this is more code than your version, but then, you don't consider the possibility that the range is smaller than the velocity, and if this is the case, an object might bounce off an edge more than once. The above code could be optimized by first calculating the velocity modulo twice the range, because after two range lenghts, the position and velocity of the object will be identical to its initial position and velocity. Also, you should validate the arguments. This not only entails checking whether the arguments are valid with respect to each other (e.g. whether lies within the permitted range), but also handling special cases like the infinities or . E.g., if you check whether , then you automatically have covered for and , because the comparison operators and the equality operator always return if one operand is (even returns , which is why there's a method ), but might still be if is also . Also, should probably be greater than (which would not be covered by the aforementioned condition either). 

The same can be applied to as well. This reduces the number of methods needed in to 2, namely the two "deserialize" methods. Maybe you would agree that, with such a design, the class can be dropped as well, because now it is nothing more than a container for 2 methods that both merely wrap another method. 

The only reasons I can think of that your code was deemed incorrect are that it doesn't consider 0 as a perfect square, and that you don't consider the possibility that (although maybe the test defined as being greater than or equal to and this is not a negligence of you). As for the performance, here are some suggestions: 

Since every value in the lookup table is the sum of the value above it and the value to its right, we can first fill up the rightmost column from top to bottom (since the values in the rightmost column have no value to their right, every value in this column is identical to the value above it): 

You could speed up the first version by switching the loops, so that the loop over becomes the inner loop, and short-circuiting the loop over , because once you have found a character in that matches the current character in , you don't have to loop over the remaining characters of (mtj's suggestion to use would amount to this). As for the second approach: Why do you first convert the strings to a before iterating over their characters? You did not do this in the first version, so what do you gain from it by doing it in the second version? About your question which approach is better: Depends on what you mean by better. I think both versions are quite straighforward and to the point. For large strings, the second version might be preferable because it has a lower time complexity. However, you write that the strings will contain at most 50 characters, so the benefit of constant-time lookup might not outweigh the cost of creating a and implicitly converting each primitive to a object. But this is just a guess, I did not measure it. 

This a bit more complicated to read than your code, because you have to manually find the element and keep track of the index (which you need to calculate the number of steps), but on the other hand, you only have to iterate over once per character from because the removal is accomplished via , whereas your code would require two (implicit) iterations if you make a instead of an : one for finding the first occurrence of the character, and a second iteration for removing it via (if is an , then would be able to find the element in constant time without needing to iterate over the list, but the actual deletion would, as already mentioned, require all subsequent elements to be moved, which is not the case with a ). Update Inspired by your idea not to reset the iterator over when there are consecutive identical characters in , I've tried to apply this principle whenever the next character in has not yet occurred in during the last iteration over , and not only when the next character in is identical to the last character from . The trick was making the check whether a character has already occurred in cheap enough so that the savings in loop iterations are not outweighed by the overhead of the check itself. I originally tried putting the characters encountered during an iteration over in a , which would be the easiest solution, but this turned out to be far too slow to be worth it. Then I tried using a array that contains a value for every possible character that signifies whether this character has already occurred in , and this did indeed speed up the program, not in a groundbreaking manner, but definitely noticeable: 

This means that and are initialized to even before the constructor is executed. So your statement is completely pointless, because is only assigned the default value which is already assigned to it. I see no problem with your second version (apart from the usage of a non-existent constructor, which I already hinted at in a comment). Every field is initialized in the constructor of the class in which it is declared, which, although not strictly necessary for non- fields, still makes the code easier to read because you don't have to jump around classes to understand the fields' initializations. Also, the class is antiquated. If you don't need synchronization, you'd be better off with an (and if you do, there are still better solutions as explained in the link). Besides, you are using a raw type, thereby denying the additional type-safety provided by generics. Edit Actually, there is a problem in both of your versions that I hadn't spotted earlier: Your constructors never assign a value to the instance variable . Instead, they declare a local variable with the name that hides the instance variable. To rectify this, you need to remove the type declaration from the assignment, so that this: