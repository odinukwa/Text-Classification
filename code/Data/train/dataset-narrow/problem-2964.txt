Then I point them to their notes for a myriad of examples for how to declare an integer variable, or even to a previous, simpler exercise where they had to do it. In other words, I make them find the answer themselves. This gives them a greater feeling of accomplishment and also makes them less dependent upon me. I find that by giving them this "scaffolding", I rarely have to provide an actual code solution, but will upon request. 

If that's all they need to read, they can go from there. If they need to read further, then what follows in the same document is the step by step algorithm, but not code. If they get stuck in the algorithm, on, for example, a line that says: 

I'd like to introduce my students to Nodes and then require them to implement their own Linked Lists, Queues, and Stacks before showing them that their language (C#) provides implementations of these data structures. I suppose my motivation is that they will 1) understand better how these structures behave; 2) gain general language practice; and 3) appreciate libraries and be more motivated to search for an implementation before writing their own. Is my motivation valid? What are other reasons to ask them to implement these data structures? Is there any reason NOT to ask them to do this? Would I be wasting my and their time? 

I think this answer is a little different, please remand me if not - I provide an algorithm with my coding assignments, and I almost always have code I can point to in their notes or previous assignments that is exactly what they need to fill in the algorithm. First I give a general description of the problem: 

Of note from other posts: Reading the answers to Techniques for encouraging pair programming and What advantages/disadvantages have you seen with Pair Programming in the classroom offers insight into the problem of encouraging students to actually "work" together, which can be part of the problem here. The real issue, however, isn't that the other students aren't willing to do the work, rather that the Lone Ranger just does all the work, usually before work begins, without the others even having the opportunity to work. Two other questions, Is it possible to ensure division of labor on a group assignment?, and Problematic student at a very high level, help with creating the environment and assignments to enable group work, and determining if someone has gone rogue and done all the work. Neither deals with preventing the Lone Ranger from repeating once the problem has been identified. 

After learning the material, the gifted student should make a presentation (depending on the field or material chosen, perhaps an example\demonstration would be useful). Here the teacher should make it quite clear that the rest of the class are not as immersed in the material (if at all), and so the presentation should present the key points. From a presentation such as that, the rest of the class get the basics and core ideas of the material and the gifted student learns a very, very important skill: presenting something they are fully immersed in to people who have no knowledge in the subfield. They learn how to remove unneeded details and keep only the points that don't require a whole lot of other details. This skill is somewhat scarce among enthusiastic and motivated gifted students. 

You can introduce the idea of best practices. Show them examples of right vs wrong for each of the practices you want to teach them: 

I have seen pair programming both succeed spectacularly and fail miserably. The difference comes from a combination of a few factors, which are, in a way, the advantages and disadvantages of Pair Programming. One clear advantage is that both students in the pair get experience in writing code, and later reviewing code. (The pair programming I saw had students switching places every so often). This is a great way to give students the skills of coding and reviewing. Reviewing a peer's code can give the reviewing student 1) a broader perspective of code writing and 2) a toolbox for self-evaluation. So pair programming is very good for the reviewer. The programmer gets a lot of hands on experience, and also learns an essential tool, which I sometimes call "Evaluation in Runtime". This means that the programmer learns how to evaluate their work as they go, because they are given feedback from the reviewer. So the coder gets a lot of experience and some very important skills, which is great. 

In my experience, there are always students who are resistant to moving to more advanced constructs. They want to stay with what they already know. For example, when they are taught arrays, they continue to use individual variables when they are able. When introduced to the foreach loop, they continue to use bounded for loops. When they learn about functions, they resist modularizing their code. After working extensively with arrays, they don’t want to move to using built-in collection types that offer more flexibility and behavior. It is sometimes difficult to impress upon beginning programmers the usefulness of “new” constructs, because the exercises and programs they are capable of undertaking do not sufficiently demonstrate the power and usefulness of those constructs. What are ways to encourage beginning programmers to embrace more advanced constructs without penalizing them? I am looking for more "carrot-y" answers than "stick-y". 

Every career has "gotchas". There is something about every job that is undesirable. That's why it is called a "job". But students can make sure they are matched as well as possible - minimize the "gotchas", so to speak. I entered CS because I loved to write code. I stumbled into the field as a junior in college and immediately changed my educational course. I am thankful for that "accidental" encounter, but it wasn't an accident, I don't believe, that I loved computing as soon as I was exposed to it. My "desire" had been predicted. I remember taking a career assessment of some sort as a sophomore in high school. I remember the career assessment saying I was a good match for "computer science". I remember thinking "what the heck is that?" (this was prior to the PC revolution), and I remember immediately dismissing the results of my assessment. But the assessment was correct. I say all that to say this: students should be encouraged to use career and interest assessments in high school, maybe even repeatedly (once a year). A quick Google search reveals many free assessments, and my state's college foundation provides 7 of them for free in one place. Up until recently, the students at my high school had been required to do several of these assessments as sophomores. Unfortunately, with a change in management, that practice ceased. But I still have my students do them as part of my class. We all should, I think. Using assessments such as this at least helps students better understand themselves, and may prevent them from making a very bad career choice. Of course, sometimes the assessments will be downright wrong (I recently had a student, one of my very best programmers, who loves to write code, is good at it, and knows she wants to go into CS, have an assessment tell her she should be an artist; however, I don't believe it was entirely off track because her code is very creative and is an artistic outlet for her). But sometimes career and self-assessments will help a student think outside the box about what they want to "be". And that is a good thing. Another thing my school does is bring in professionals to share about their jobs. They speak briefly about their backgrounds, what they do, what they like about their jobs, and what they dislike about their jobs. They usually speak during lunch in a classroom. The kids eat their lunches while they speak. It is very informal and always well attended. The feedback from the students is always very positive. Our local CDC (career development coordinator) organizes these "Lunch and Learn" sessions, as we call them. We have 5-6 a year. These are tangible things you can "do" to help students get ideas about careers. Some students may still fall headlong into something that is not a good match for them, because of tunnel vision, or peer pressure, or parental wishes. But some of them will identify or reinforce what they love to do, and they will be willing to make the trade-off: you pay me to do what I love X% of the time, and I will put up with the 100-X% of the time I have to do stuff I don't necessarily like. 

etc. In this specific lab, they idea is for them to see: $$y(t_{n+1})=y(t_n)+\frac{\Delta y}{\Delta t}\Delta t\approx y(t_n)+v(t_n)\,(t_{n+1}-t_n)$$ with $$v(t_{n+1})\approx v(t_n)+g*(t_{n+1}-t_n)$$ and then run over times $\{t_i\}_{i=1}^n$ and see that the $y$ values they get are the same as: $$y(t_n)\approx y(t_1)+v(t_1)\,t_n+\frac{1}{2}g\,t_n^2$$ However, because they use , they get rounding errors when dealing with small time differences ($\Delta t$). I don't want to get into the whole floating point arithmetics field, because they won't understand that (the word "exponent" would frighten them, to say the least). On the other hand, if they use , then the rounding errors wouldn't be significant (because they aren't dealing with $\Delta t \le 10^{-5}$ of a second). So I try to explain that they should use , but just stating it as a "rule of thumb" isn't a good idea (because there are cases where one would prefer ) So, what explanation, as to why they should use for these things, would be compelling? Better yet, is there any way I can show the students such an explanation? (Perhaps an online, interactive demonstration of floating point precision etc. - I couldn't find one) 

Although "gifted" is broad, it has been made far too clear that potential (implied by the student being gifted) is not enough. They need intrinsic motivation. This is fairly straightforward: The only way to make such an activity work is to get the student to be enthusiastic about some field of their choosing. Many gifted students have ADD\ADHD (Correlation, and not causality), which means that sitting with them to get them started is no easy task. But it can be done by appealing to their strengths. If they have shown special affinity or liking of some field or subject, or have been "always interested in ...", then one should start by suggesting that field or subject. If the student seems interested, one should proceed with explaining that research is a necessary part of the activity. From this point the student should be fairly independent, and the teacher should only be checking in from time to time. (obviously a deadline should be set...) 

Note: Like the OP, I teach high school. Some of the things I discuss may not be useful in a university setting. Resubmissions are not a factor for me because I will take anything from any student at any time. And it must be correct. So they get 100%, or they get nothing. Wait before you shoot me. Timing: When I assign an exercise (program), I let my students know when it is due. I create the assignment in the grade book with its due date but leave it blank (we use PowerSchool as well, mentioned in another answer). As the students complete exercises, I check them off on a paper checklist. When the due date for a particular exercise arrives, I transfer checkmarks from my list to the grade book. If the student has a check, they get the points. If they don't have a check, they get a zero. To get a check, their code has to be correct. It must have the expected output. It must adhere to all coding conventions. And it must use the structure suggested in the assignment (e.g., a foreach loop instead of a bounded for loop). Of course, I allow for personal variation that is not blatantly incorrect. Coding is a creative process and each student develops their own style. I use zeroes in the grade book because it creates a sense of urgency in most students. But the zero is just a place holder, a reminder that something is missing. The student may, at any time, turn in their missing items, up until exam day. I clearly communicate what the zeroes mean to both students and parents at the beginning of the semester. My students actually like this method and give me positive feedback about it. I allow what some might call "late" work because not everyone works at the same pace. Some students are just going to struggle (and Carol Dweck suggests that the student who struggles may actually learn the material better in the long run than the student who gets it immediately). Not everyone has a wonderfully happy, supportive home life. Not everyone has a two-parent family. Not everyone feels accepted and affirmed at school. Not everyone is healthy all the time. I don't know what my students face when they leave my classroom. If they really want to do the work, I want to take it, no matter how long it takes them to complete it. Do some students abuse this? I don't have many who try. Students who care about their grades will work diligently to get work in no matter when it was "due". Students who don't care weren't going to turn it in anyway, due date or not. Even with this system, I would say 90% of my students turn in their work "on time". Cheating: My best defense against shared code is my familiarity with each student's coding abilities and style (or lack thereof!). When not actively teaching, I am circulating the room, interacting with my students, watching what they are doing - not in a hawkish way, but in an interested, encouraging way - "oh, you decided to add graphics to the assignment, that's cool". This way I can watch progress, help with errors I see before the student gets completely off track or wastes a bunch of time, or notice a student go from blank screen to complete multi-page solution - still highlighted from the clipboard - within one circulation of the room ("hmmm, where'd that come from"?). I can also gain insight as to how and why they do things, become familiar with their coding style, and nip bad habits in the bud. When I first started teaching, I thought if they were coding quietly and there were no questions, I should just sit at my desk and ignore them. Not anymore! I stay engaged and give them my full attention the entire class time. They deserve it, and it really makes my job much easier in the long run. (Honestly, a very good rolling chair helps with this. I have my lab set up so I can easily roll and achieve maximized, efficient coverage). Checking code: I don't ask students to submit code electronically. I check code for assignments with the student at their computer. Meaning we scroll through it together, with me asking questions as I see fit. If it's good, they get a check. If it is not, I tell them what to fix (or guide them to it), and they call me back again for a re-check. This works for me because a) I'm familiar with the way they do things and can almost immediately tell if they are showing me code they didn't write; b) I'm an extremely fast reader; and c) I make sure I have written a solution myself ahead of time so I know what I'm looking for. Note: If I really feel I need it, I already have an electronic copy of students' work because of the way our network is set up. Every student has a virtual drive. All student work is maintained on their virtual drive that only they can access when they are logged in at school. Yes they have a lab computer, but they are restricted from accessing the C:\ drive. Any projects they create (code or otherwise) are saved to the virtual drive. Teachers can access all students' drives. So I can access each student's work from my own computer. If I have academic dishonesty suspicions, it is easy enough to compare time stamps or file sizes between or among students and determine if sharing has occurred. Johnnie was missing 10 projects yesterday, but now he has them all, and every folder was created at the same time (when he unzipped his friend's work)? Nada. In summary, "resubmission" is not an issue for me. If my students did the work, and they want to give it to me, then I want to take it. 

As always with javascript, show the right&wrong: Show them, using the exact piece of code from your example, but add another line: 

I started teaching NodeJS to some of the students in the computer science major at my school (these students know the basics of Java and OOP). The idea is for them to make a small web project (such as a grades and averages calculator or a display for a timetable etc.) using javascript. I plan to teach about javascript, client-server separation, http requests etc. The main problem is the vast number of JS libraries in existence. I intend to emphasize that most of the code is already written. E.g. the code for creating nice graphs exists in charts-js, and responsive client side frameworks (angular, react) exist. This project is also meant to teach the notion that programmers rarely write programs from scratch, and that they should often see if there exists a library\framework that give a functionality they need. However, with Javascript, the vast number of libraries makes it somewhat difficult to know which ones to pick. It's not impossible, but I'd rather students not waste time on that. I ran this by a handful of students, to see whether students actually get overwhelmed. From what I saw, students are likely to waste time reading up about the library they are checking (somewhat like reading a review for a PC before buying it). Research is great, but the amount of wasted time was quite big. So, what can I do to teach them how to "sniff" the "correct" library more efficiently? In other words, how can I teach them which metrics are significant (and why those metrics are important) when deciding whether a library is useful? Bearing in mind that the time it takes is to be considered, I'd prefer ways and metrics that are generally faster (e.g. reading up the documentation of a library is somewhat slower when compared to checking npm's download in the last day)