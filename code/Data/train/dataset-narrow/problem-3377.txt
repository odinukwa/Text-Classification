You may want to launch your C++ application via a subprocess, launched from python, then communicate with it using stdin/stdout. This way, both programm will run in parrallel (python needs to be launched first), avoiding the need to switch from one to the other. Here is how to launch your subprocess: 

I found that using a read-only file system was a fine way of dealing with file corruption errors on classic Rpis. In your case, you may at least try to put the partition in read-only mode. Edit your file to add at the end : Then edit the line defining "/boot" your /etc/fstab : 

Raw image data can be edited with Gimp, as long as you respect original image format and resolution, or can be computed on-the-fly, using some usual graphic functions. I use this trick to get a boot splashscreen before plymouth launch, it may be enough for a simple UI. 

About point 1: You will need a RTC if your Rasperry can't rely on an internet connection to get synchronized. I suppose you want your alarm-clock to be "disconnection-proof", unless you want to explain your boss you are late because of an ISP failure conjugated with your DIY-addiction :) So yes, an alarm clock definitively needs some hardware RTC, some are GPIO compatible, in order to improve the native Raspberry system clock. 

About the amperage, a circuit will draw what it needs. The rule is to keep the voltage matching with the source, and to have a bigger amperage on the power source than the need of the device. If your first intuition was true (devices are breaking), a lot of electronical devices wouldn't work ! I.e. consider a speaker amplifier. It's consumption varies over time, depending 1) on the gain setting : more volume, more consumption 2) on the sound given as input : amplifying a silence consume less that amplifying a sound. Obvisouly, sound engineers don't change their power supply when they raise or lower the volume button, nor at each drum kick ! Instead, they use a power supply big enough (in ampers) to work at high volume. 

I think I found what you are looking for : In this exemple, we see that two switches are controlling one lamp, so toggling one of these switch will toggle the lamp. 

The point your are looking for is the difference between arduino pins (5V) and rapsberry GPIO (3,3V). With this in mind, we can deduce that every passive components (switchs, potentiometer) will be compatible, and most part of the active modules won't be compatible. For more details, you need to look at each module specification, and check for the component operating voltage range. By exemple, the datasheet of this gaz sensor show that the circuit has to be in 5V, so not compatible. Edit : a convenient way of solving this point is to actually use a arduino, powered and driven from the RPI USB port. This solution may also lower the RPI CPU usage, as some part of the signal processing may be put on the arduino part. 

I doubt this would work without rewriting a (large part of) it. You can see that this library includes "arduino.h", wich refer to a lot of arduino specific hardware implementation. What you can do is downloading the python library : 

Last step tell the system to use this device tree file. Edit /boot/config.txt file and add at the end : 

I think you are lookking for uv4l This program offer a built-in web server, allowing camera configuration, live stream with low latency and decent fps, low CPU consumption, and some extra features that may, or not, fit your specific needs. I tried some other solution (ffmpeg, gstreamer), and I think that , being a userspace driver level, is the most performant tool for this. And it's easy to use :) Look at the demos to see implementation samples 

Please note there is a clear distinction between errors, based on the numbers at the end and I won't go into much details as they can be easily discovered online if required. These fixes assume that you have all the needed connections working (power, SD card, HDMI, wired keyboard, mouse) and are using Raspbian along with NOOBS. The details for error ending with 2 is at the end of the answer. If your error message ends with 6, like this: 

I am running Raspbian on a Raspberry Pi which is located in a remote location. I use Putty to connect to it via SSH. I can connect fine but when I try to run any command I get the following: 

Start the Raspberry holding the key. Once NOOBS loads, press to access the recovery command line. Login with username and password . Type . This will scan and attempt to repair the corrupted file system (replace ext4 with your partition type if needed). Note that the mode of (i.e. only typing instead of ) is not supported. Type to shutdown the Raspberry cleanly. Unplug the power cable and plug it back in. The Raspberry should now start fine. 

I am using the Raspberry with Raspbian "Wheezy". Using the Midori browser (or any other) is rather slow and personally I would find it quite annoying for day to day use. As for videos, after one day of trying to make YouTube work I gave up. I have not overclocked it so that might help a bit though. I recommend you not to use it for browsing and such if you're not a patient person. 

Start the Raspberry holding the key. Click the button or press . Click the tab or press the on the keyboard. Replace: 

In some cases, the Pi might ignore the change made in the NOOBS GUI and you would still see the exact same error, with at the end when booting. In this case, tktbjp's answer might help: 

What I don't know is where this file should be or if it should contain anything else. I know about the init.d folder, but seeing the skeleton example I imagine there should be a simpler way to do this simple task. 

it is likely that the problem is caused by an update bug. The fix involves switching that 2 into a 6: 

I've looked at many answers online but they all assume I am physically collocated with the Raspberry, which is not the case for me. I can't simply pull the plug to restart it or use the GUI. I need to fix this issue to have it operational again. Doing a restart using would be the most straightforward option but that doesn't work either. Note that the only command I managed to find that works is . I've tried , , , , , but none work. EDIT: After about an hour, some memory freed up somehow and I was able to restart it. I pinpointed the memory leak to be caused by a python script set to execute daily that was hanging every time. Moral of the story: always set a timeout on all scripts and kill them after the period has passed to prevent memory leak issues! I am still looking for a way to do it as waiting is not really a guaranteed solution, nor is it available to everyone. 

This question has been asked quite a few times before but I didn't seem to get it working using the existing information. My Pi runs Raspbian. I have a Python script named dnscheck.py which loops forever. I need it to run at boot. I know I have to create a .sh file containing something like 

You may want to use . easily implement camera control and webRTC streaming, in a very efficient way, and quite easily. So your RPi will stream the camera on the network, while the computer will acquire frames from the RPI via opencv videoCapture class, as if it was a classic video file or camera, in order to analyse them. More information about uv4l here : $URL$ 

Both may happen ! Take an exemple : Consider a LED on the GND/V+ GPIO Pins, without resistor. The formula : I=U/r show that we could get an almost infinite intensity (Ampers) consumption when the resistance is negligeable. This would lead both the LED to break, and the polyfuse (an inboard over-current protection) to trigger. In this case, it's hard to predict the first element to break, it's a course between the fuse and the LED. 

As pygame rely on SDL system, we have to define the audio driver for SDL. This can be done with environnement variables. You can define it in your python script, but this must be done before you init pygame. 

We can see that one battery is already not powerful enough for the raspberry (1.75A instead of 2.5A), so powering a motor on the same battery won't just work. I don't know how other people solve this case, but you can look for lighter hardware that would limit the need of power (arduino ? rpi zero w?), or for bigger batteries. 

Well, in fact you need to track when your "rpm printing" function was launched, storing this event time in a variable (let's call it ), and continnually check this variable in your while loop. 

About the software part, i strongly recommand the tiny program . Basically, it copies everything going through the HDMI output, /dev/fb0 (even disconnected) to one internal display, i.e. a touchscreen on /dev/fb1, via GPU. $URL$ Just launch it and stop it via a tiny GPIO interface and you have your switch :) Provided you found some wireless HDMI system, this should fit your needs. 

I see 2 methods to solve this issue : 1 ) Find the root origin of the corruption The only case of SD corruption I met was linked to unwanted reboots, always power-related. Did your system shutdown when you plug the last HDD ? Are you sure that your USB Hub has sufficient electrical specifications to handle both HDD ? 2) Use a read-only filesystem: If the cause of corruption can't be identified, or can't be solved, you may want to use a read-only file-system. The aim is to use your and partitions in read-only mode. Putting your main system in frozen-state protect it from corruption. The whole SD card don't have to be read-only, you still can have a read-write partition made for storing datas (which still can be corrupted !). When you need to edit your system file (configuration of some service, i.e.) remount the target partition in read-write mode, do your work, and put the partition in read-only mode once done. If the protection of the stored data is important too, you may want to use a tmpfs partition (RAM stored memory), and sync it from time to time to a read-only partition made for storing datas (putting it in read-write mode for a very small amount of time, reducing the risk of corruption) Switching your system to read-only is a bit tedious, as you will see in the tutorial, you should make a backup of your SD-card once done. $URL$