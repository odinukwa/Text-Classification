I commented here months ago that I was going to hook my BMP085 up and write some code, which I finally did over the holidays. I've written a short C++ class using libi2c; if you have any I2C devices running this will already be installed, but you will need to install the header files () in order to compile. The class is in a tarball with a short demo program here. The demo produces output like this: 

The IP address there should be that of the other pi. You can instead use a hostname if, e.g., you have Avahi set up. You can then make this simpler by adding it to : 

I suppose not, but this may create a hassle for you if you suddenly do need a keyboard...or it might make no difference at all -- part of my suspicion is that it actually isn't accomplishing anything, since the "keyboard setup" is something that is static configuration and can be manually changed as required. To disable a service, . 

It indicates there is no card in the SD card reader. The source Jacobm001 refers to actually predates the 2.1 The BCM2835 models, including the B+, will start up with only the red light on in this case. The BCM2836 model (i.e., the 2 B) will start up with both lights on steady. It is a little odd you get an HDMI signal, but if the Pi otherwise seems to work, nothing is broken. 

There are sort of a few ways to define "virtual terminal", a strict and more formal way and a more casual and perhaps common one (depending where you are...), the latter of which is really a colloquial synonym for terminal emulator or pseudo terminal. The strict definition refers to the text consoles usually accessible (at least on linux systems) via AltCtrlF[1-6] -- actually F7+ may also work, but generally only the first 6 have a login prompt running on them, so anything beyond that will be a blank black screen (however, programs can still use them for output). If you look in these are devices (beware is used as a prefix for other terminalesque things) and there are probably a lot more than just 6 or 7, or the number of F-keys. These are called "virtual" because historically a single terminal was a physical piece of hardware combining a screen and keyboard. Virtual terminals probably require the OS to have access to such hardware in order to be useful, but they're not the hardware itself. They're software implementations of hardware protocols derived from very old school equipment (with some new school tweaks). Hence you can have an arbitrary number of them running with just one screen and keyboard. Pseudo Terminals and Terminal Emulators A pseudo terminal is a more general case of a virtual terminal. They're used for, e.g., remote logins and terminal emulators. Terminal emulator often refers specifically to the GUI window based programs you are familiar with (e.g., on Raspbian, ) but might also be construed to include that and virtual terminals proper. Anway, is called openvt because it is for opening a command via virtual terminals (VTs) in a strict sense, i.e., not including GUI emulators, remote login terminals, etc. These have some characteristics which place them closer to the actual hardware than most pseudo terminals. For example, the GUI desktop is actually run via a VT, and when a desktop is in use, it will occupy one. If you cycle through alt-ctrl-f[1-7] you should notice this; I used 7 instead of 6 because it is common to use the 7th one for this purpose (since it's usually the first one with no login prompt running), which is what it looks like that command targets: 

There is a bit more to the GPIOs hardware wise; for example, there are several PWM (Pulse Width Modulation) clocks available. However the serial buses are the primary means of communication with sensors. 

The vulnerability described in that article sounds like a complete and total disaster that Apple should be hussling to fix ASAP. However, it obviously won't work on GNU/Linux including Raspbian. With regard to resembling the issue of the default privileges given to Raspbian's user, I'll point out two very significant differences: 

1. Modules can be either built-in or loadable. Loadable modules are files in directories, which are part of the root filesystem. A just loaded kernel can't mount the root filesystem if it requires stuff from in order to do it. Those modules either have to be built-in to the kernel, or put into an initramfs. 

"Smoke detectors" are actually gas sensors and they come in various flavours, but as far as I am aware there is not one ring to bind them all. I think the kind commonly used in home alarms is an MQ2. Carbon monoxide sensors are MQ7 based; you will find descriptions of other "MQ" sensors online. However, they are analog devices, so you will need to use an ADC with the pi. 

You want to use a use a TCP server/client model. Either end can be the server, the other is the client; the client connects to the server and establishes a connection, then information can be sent back and forth. Skeleton code for a basic client or server is probably only a dozen or so lines in python. Start by developing an echo server -- something that simply sends back the same message it is sent -- and then work from there. You will get better help with this on a dedicated python or C# forum -- nothing about the task is specific to the pi. You should first look around for TCP networking tutorials involving either language and work through those. This way you can save yourself some time by coming to the table with specific questions and code demonstrating what you have tried/what problems you are having. 

Probably not completely, but keep reading. Although the 3 is the fastest pi, it is still not something that is on a par with, e.g., current x86-64 processors. You could compare this to your smartphone. I have a fairly new, fairly fast, Snapdragon "octocore" (8 cores, 4 x 1.5 Ghz + 4 x 1 Ghz) based phone w/ 2 GB RAM that manages to avoid any "periods of of grey ugliness", but it goes through a sequence of irrelevant glitzy screens during its 10-20 second boot cycle. It's probably doing a fair bit more than a Pi based kiosk during that time, but what's missing with the Pi is, as you notice, something to span the gap between the boot splash screen, which probably ends once init starts X, X takes the display, then starts the program that sets the background. I've used for this and on a B/B+ it takes perhaps a couple of seconds, on a 2 it is noticeably faster but there is still a blank black screen for a moment. Whereas on a desktop or laptop this is not really noticeable. [I don't know why you are getting grey here and not black; I would guess that's either because the brightness is set very high or because the software involved does take the display but shows just gray while it is processing the image.] One of the reasons that or other software may require some time here is because it may have to adapt the image dimensions slightly (I think it can be dysfunctional this way, such that a 1920x1080 image on a 1920x1080 screen may end up scaled and tiled along one edge...), and for compressed formats (such as .jpg or .png), do the work of uncompressing them. So, you want to ensure: 

Yes, they are identical in this sense, except that the default desktop environment (DE) on raspbian is LXDE. However, it is available for normal Debian (which I think uses GNOME as a default) and other distros, so if you are looking for information about it, stuff about LXDE on the Arch wiki, etc. is fine. According to LXDE's own wiki, doing this is as simple as putting a file in . That format is actually an XDG standard probably implemented by most DE's. E.g., I notice I have some on this box, created by KDE: 

Added Aug/2016: Beware that at least some recent versions of Raspbian "-lite" may use as the default despite the fact that the lite version does not include the GUI fundamentals and hence can only present a console login. Further, if you happen to notice this and change the target to , the system will fail to boot with most essential services running. In short someone who did not know what they were doing did something absurd, and hopefully it will get corrected... 

Anything that's attached to it does not, including a wifi adapter (Ralink RT5370) that works fine on every other other model of Pi I have (B, B+, 2, 3). I notice that when I plug in another USB device to the hub, what's already connected suddenly appears. The new device does not, but if I unplug it and plug it in again it does. Unfortunately, I want to use the pi headless with just the wifi adapter, and if I plug that in after boot, it causes the Zero to reboot (just like some things do with the model B and the built in USB ports). As with the model B, I figured this is due to a voltage drop in the 5V system when there is a sudden current draw the circuitry supplying the Zero's inbuilt hub can't handle; I have tried this using 2.5 A 5V adapters sold for use with the Pi and that work well on other models, so I do not think it is insufficient supply to the Zero itself. There's a barrel jack on the side of the hub to provide external power. However, the retailer warns this is connected to the cable as well (meaning it shouldn't be used that way if the Pi is powered normally), although this connection can be snipped easily by opening the case. If this worked, it would mean having to provide separate power for both the Zero and the hub. I thought about wiring the barrel connector to the Pi's 5V pins to see if that circumvents the issue, but since the Zero can be backpowered via the OTG hub, I decided to try using it that way instead. This works, and solves the issue with spontaneous rebooting [alhough this later proved inconsistent], but it does not solve the issue with anything attached to it at boot not being recognized, meaning I still have to (unplug and) plug the wifi adapter in once the pi is running to get it online. :/ Is there anything I can do here?