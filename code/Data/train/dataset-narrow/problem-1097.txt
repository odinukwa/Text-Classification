In addition, to separate out your printing of the state, I would create a bit of a string helper function... I'll explain it later, but show you here, now: 

The custom wrapper class introduces a significant concurrency bug. The contains the control information for the entire spliteration. The use case you present is: 

Fundamentally the issue is that you've joined two separate problems in to one function, and the result is a poorly defined operation that's a bit brittle. What you want to do is expose a channel that sends Frame instances each time one is available. This will result in code that looks more like: 

Now, the recursive method should return an , and it takes the maze as input, not from a static variable. To avoud the use of the 'n' variable, we use the basic information from the maze. The following is a copy/paste of your code with slight modifications: 

the stated goal is to return a new list, but your code returns one of the input lists that have been modified to have the merged results. This is buggy. If the first two elements in each list are equals, your initialization process will fail, one of the comparisons, either the first, or the second has to have an component, either or . As it stands, both the and the will point to the if the first values are equals. What's ? Why is it not ? Why use templates at all if you have only one template type that works? 

You use a Utils class here for this message, but not if there's no ? Additionally, if the here successfully parses as an int, you don not actually save the value to ... you just throw it away. So, even though you say you support changing the port number, you never actually change the port number. Finally, what should you have done in the main method? At minimum, I would have preferred to see the code: 

if your number of digits is always going to be less than about 10, then you can use a single random operation and a string format, to do all the work without the loop. Consider a method like: 

If you are familiar with regular expressions they can be helpful in cases like this too. A file extension is anything after a that's not a and is not at the string's beginning. So, this requires a pattern that uses a positive lookbehind, and then a generic match on the extension: 

The clone Now, about the array clone... you don't need it. Your issue is that you should unswap things after swapping them: 

Note how I have also used the conventional C# style there for the braces.... 1. Switch: A switch statement can work on chars: 

When interfacing with 'library' code, especailly when the library is a Java representation of some low-level interface, it is always somewhat ugly. What you see as having readability problems is true, but it's not your fault (mostly). In circumstances like this, you have to transcode the data in one format, to another, and that other format is highly structured, and specialized. The only way for the code to make sense is if you have the specification for that other API in front of you, or know it really well. In cases like that, I always find it best for the code to represent the specification as much as possible. In this case, I think it does.... ... this is even true for the 'magic numbers'. Normally magic numbers are 'bad', and your code is full of them.... but, if the specification contains things like: ... Repeating group consisting of xxa - 3 bytes, xxb - 3 bytes, xxc - 2 bytes, xxd 2 bytes, ..... then you really are doing things 'OK'. In general, in these cases, the best you can accomplish is to contain the ugliness in a single wrapper library that does the transformation for you, and does not leak the ugliness out. There are three things I think you can improve: 

I know that's not the expected output of the test, but it helps to show you that the solution should be done in one place (the instance) and as a reusable mechanism (so that you can create different instances of for different word lists, or grids. Now, about the algorithm. Your logic for building the search query arrays is a good one... but the implementation needs some small tweaks, and the input should be parameterized. Basically, this code is OK, but could be better: 

See it for yourself Note the multiple temp tables, and the variables for the pivot, and the query. Ugly, but it may give you some ideas. 

The result was a sort in 0.096 seconds, or 150 times faster than your code. Now, this code is not exactly simple, so, be warned that it is a little obscure. The first thing I did though, was create a class to abstract away the low-level IO: 

With the above code, you have now set up a general purpose Collatz Stream that is self regulating, and can be used in any way. The code is certainly longer than what you have, but, the result is a lot cleaner, and more versatile. Adding terminal conditions to a stream is not well covered in Java8. I would expect that subsequent versions of Java will have a stream stage similar to 'filter(...)' which will be called and will terminate a stream when the given condition is true. Until that arrives, we have to do it ourselves. Update: I tried to look around to see if there was a more Java8-ish way to specify the Collatz sequence, and figured the right way to do it was to create a generic class for streams that contain a self-modifying stream. Given that the Collatz sequence has a well known terminal value (1), I figured that a construct like: 

Note, if is null, we are inserting the new value. There is no reason to make a copy of it (and there's no reason to do the manual cast either even if you need to make a copy...) Doing the setting of the in there as well is.... wrong. Consider the following: 

Dumping some SEDE experience in as well as a SQL review. SEDE Specific things first Parameters SEDE caches the results of a query if it is run with the current data set (caches are cleared when the data is refreshed). If you run the same query twice, the second time will return the cached data. If the query has not been run, then you need to be logged in to refresh the cache. If the query has been run, then you do not need to be logged in to SEDE to see the data. As a consequence, if you share links, you should pre-populate the cache too. Your query is parametrized, and as a result, you do not have any cached results... BUT.... SEDE parameters are of the form . Use this to your advantage. By supplying a default value your query will likely be 'prepopulated' So, set up your parameters like: 

I don't like the "create if the list does not exist" logic in the first block. Using the as an "output-parameter" is ugly. should not be modified. The new head is returned anyway. The calling code should be able to tell if the head is null before it calls the insert method, and instead call a 'create' method of some sort. Additionally, that check is only ever needed once for the entire list, so it is a waste of time to check it for each level of recursion. you cannot insert at the beginning of the list. If you are intending to insert the values and your first node starts as 4 at the 'head', well, you can't insert before that..... Your code requires that the first node is always the minimum value in order for the sort-order to be maintained.