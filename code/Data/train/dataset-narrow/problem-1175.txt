is an example of a comment not getting updated when the code is - place comments as near to the code they comment as possible, and check comments, too. s for input size & path: there are ways that do not require a recompile. lacks a specification, in the code: What is it to return? What are required and admissible side effects? While the first two parameters are not hard to interpret, it would be nice to have stated explicitly to be inclusive or exclusive. You code picking a pivot index/value directly into a function named - consider to factor out . (Do you try to follow a coding convention? Some of your function names are CamelCase, others lower.) You spend many lines to place the median of three at , even with three comments about the individual conditional swaps (something else to potentially factor out), but without a comment for the three combined. Not naming piques me more than & - not sure why. Why are & declared outside the ? Why do you need ? Next, it gets weird: an open coded swap, followed by indirectly recursive calls to (still in ) &dash; and no for an function - you should be getting a warning. In , you manipulate ( or might be more appropriate) in a way that looks evident - it misses the comparisons in selecting the pivot. ( misses the opportunity to save comparisons capitalising on <= == <= .) And, again, does not (always) return a value. 

The first check is for the length of the string: If it's odd, the can't be balanced. I then iterate over the chars of the string: 

I like using exponents to factor each digit into its value place. I don't like having to define a mapping for each number from 1 to 3 and 6 to 8, and repeat that for the 10s, 100s, and 1000s digits. 

I started out with this solution. It's iterative, and not very efficient. It multiplies all number combinations, adds the products to an array, finds the palindromes, then chooses the max. 

I wrote a random world generator for the classic Snakes and Ladders board game. Snakes and Ladders is a dice game played over a grid, usually 10x10. You win by reaching the last square first. The board has ladders and snakes that connect specific squares. Land at the base of a ladder and you climb to the ladder's head (good). Land on the head of a snake and you slide down to the snake's tail (bad). Snakes and ladders are key value pairs; the represents the start point, and the represents the end point. Both are identical except that a snake's start point must be greater than its end point, while the opposite is true for a ladder. World rules: 

A square can technically contain the tail of a snake and the base of a ladder, or head of the snake and head of a ladder. But this could have weird side effects (presumably why I've not seen a board with those characteristics): You slide down a snake only to reach the base of a ladder that takes you to the winning square; or you climb up a ladder only to reach the head of a snake that drags you down. While not fatal, such side effects muddle the role definition of ladders and snakes; in that, ladders are no longer necessarily good, and neither are snakes necessarily bad. Example World 

â€” alas, at least I and CodeYogi have mis-read the problem statement: The numbers in are a subsequence of . One solution looks similar: 

Where are the doc comments? Your naming is intuitive, the formatting familiar. If you used (thanks, h.j.k.), I wouldn't have considered factoring out histogram collection. If using s that can be constructed with an expected size provided, do so. I'm convinced using one histogram is better: smaller memory footprint, no need to "filter" entries. Downside: separate s opened a promising opportunity for concurrency where my half-assed timings indicate adding a to h.j.k.'s approach to just slow things down. Using a sorted vs. a fast one and sorting the results is an interesting choice. You can combine both using a modified counting sort: 

(Some peculiarities in diction, formatting and code factoring are due to the "code keyhole" on SE, esp. my dislike for horizontal scrolling.) Pretty late in the effort it occurred to me that Python may be a better choice (3.3? 3.6? 2.7? comments welcome (regarding any language in wide-spread use among, hm, "programming juniors", actually)). Uneasy with the design, I didn't invest due diligence in testing & "tallying" (counting/computing comparisons&assignments) (yet) - I'd regret major effort invested there on any reader's part. 

(While expected run lengths for uniformly distributed bit patterns are (1 +) smaller than 1,) There is no need to process the remaining bits in a loop: 

The very first line of the code presented features a strategic mistake: This is an undocumented not implementing an : "no one" will ever be able to provide a drop-in replacement for any implementation, let alone pick it from the likes of trove or Goldman Sachs collections. "Hearing" list-of-strings in a Java context, I "see" . Looking at what interface specification there is, I see a lot of (just as Timothy Truckle did), and a bit of : I'd willingly take serious a implementing if it extended a "standard" implementation: just consider supporting streams. I follow the concern regarding (the very first conditional statement prevents fulfilling the comment above), but beyond insisting on monotonicity, only seems guilty of not using (just as ). You claim (without providing a MCVE (which would likely render the question OT on CR)) - I'd look elsewhere: what about decreasing twice? A nice touch would be copying the beginning of the array up after a removal if it was shorter than the end. And using any unused indices at the beginning when adding (hey, half-way to circular buffer). I'd let petty concerns lie if it wasn't for - just don't get into a habit of (ab)using like that. 

But since Rails is pretty well tested, I feel like I can trust its JSON return. I'm not sure if this approach makes my tests brittle, since any change in the response body will cause the tests to fail. But maybe that's a good thing? Here's another example: 

I improved with my second iteration, but it still relies on iteration. I narrowed the range down reasoning that the largest palindrome is likely to be the product of two numbers within 901 and 999. This time I multiplied all the numbers, but only saved the palindromes in the array, then selected max, which saved a step. It's noticeably faster, but still not optimal. 

I honestly think your first version is the best one. It's readable, and makes more sense at a glance than the refactorings. That said, I would consider a couple of things. 

Using a hash instead of an array alleviates the problems of 0 index when using arrays. It makes more sense. 

The best way to ensure a bullet proof implementation is to avoid having a square contain more than one object. For example, there's an edge case where a square can contain a ladder's head and a tail, causing you to progress even further. To do that, the placement should be delegated to a method that checks if the square is occupied. This requires tweaking the initialize method, but it's worth it: 

Your view will be simplified too. Instead of calling you can treat the decorator as the binder object. 

Recently, I wrote a simple program to solve the change-making problem. Rather than the tabular dynamic programming solution (described in the link), I tried to write a solution that uses memoization. 

Here, represents a mapping and , the string keys of the the dictionary (my solve function visits the territories in the dictionary iteratively; once we've exhausted this list, we have know the problem has been solved). Here's an example how this problem can be instantiated: 

I've written the core functions for a basic 2048 game. I know Python isn't a functional programming language, but I like the "functional style" (easier to maintain, simple to understand, more elegant), and have tried to use this rather than iteration, mutation, etc when I can. From a functional perspective, what more can be done to improve my code? From an organizational perspective, would it be best to include these functions inside a "game client" class, or better to leave them in a separate module? Right now I have the separate, but coming from a OOP background, my feeling is that the helper functions should be in one class. 

Notice that is used to keep track of the possible colors a can take. My function in fact adds some optimization to the standard backtracking method by reducing the domains of neighboring territories. In this function, the variable is used to iterate through the keys of . As I write in the comments, this code adapts the approach typically used to solve puzzles: the idea is to make a move and then continue solving the rest of the puzzle, moving to the next open spot on the board. Since we can't iterate over a "board" with explicit indices, I iterate over the keys of 

It accepts a grid. A grid is just a has to cells and portals. It doesn't care what, and how. As long as it gets a hash, it works. The old method had a bug. If a player rolled in excess of the board size, it would exit its cell, even though it had no where to go. The new fixes that. The player only exits if it enters another cell. If no movement happens the method returns nil. 

Personally, from my experience of reading and watching educational materials, the newer syntax is preferred where possible. It's also less keystrokes: instead of is easier for me. 

The second method returns a JSON representation of an object, and accepts options. This is what I expect the response to be. So I compare the output of this method to the actual response. 

Ideally you will want a nice helper for this. Now you can helpers from inside the decorators using the context. 

I would suggest using a service object. I would like to see what others think about this. It looks like there's too much going on for the controller. The controller should be responsible for execution and value return. The model for processing the object. The service for wiring up the object and giving it prepared params to do its job. This is not tested, but just to give you an idea. I would go further and condense the and methods in the model so that the service just receives an error or an OK to give back to the controller.