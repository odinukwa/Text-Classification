and then the only unique code I would have to write for that door is the FireballTrap component. It would use the same Lock and Portal components as all the other doors, and if I later decided to use the FireballTrap on a treasure chest or something that's as simple as adding the FireballTrap component to that chest. Whether or not you define all the components in the compiled code or in a separate scripting language isn't a big distinction in my mind (either way you are gonna be writing the code somewhere) but the important thing is that you can significantly reduce the amount of unique code you need to write. Heck, if you aren't concerned about flexibility for level designers/modders (you are writing this game by yourself after all) you could even make all the entities inherit from Entity and add components in the constructor rather than a config file or script or whatever: 

I find it useful to build profiling in. Even if you're not actively optimising it's good to have an idea on what is limiting your performance at any given time. Many games have some kind of overlayable HUD which displays a simple graphical chart (usually just a coloured bar) showing how long various parts of the game loop are taking each frame. It would be a bad idea to leave performance analysis and optimisation to too late a late stage. If you've already built the game and you're 200% over your CPU budget and you can't find that through optimisation, you're screwed. You need to know what the budgets are for graphics, physics, etc., as you write. You can't do that if you have no idea what your performance is going to be, and you can't guess at that without know both what your performance is, and how much slack there might be. So build in some performance stats from day one. As to when to tackle stuff - again, probably best not to leave it too late, lest you have to refactor half your engine. On the other hand, don't get too wrapped up in optimising stuff to squeeze out every cycle if you think you might change the algorithm entirely tomorrow, or if you haven't put real game data through it. Pick off the low hanging fruit as you go along, tackle the big stuff periodically, and you should be fine. 

Plugins for Unity can be written using Objective C; refer to this page: $URL$ However I wouldn't assume that a code library of thousands of lines that wasn't designed to be used as a Unity plugin will work as a Unity plugin. It's all free so you could download Unity, fire up the demo project, and then try to integrate your Objective C library. 

One of my favorite classic arcade games also happened to do fake 3D: Space Harrier In that video you can see a few tricks they used, but one of the most effective visual effects is so seamless that you might not even notice it happening: when the player (or importantly the camera) moves, they use parallax to give objects in the scene a feeling of depth. That is, closer objects move side to side faster than distant objects. The classic example of parallax is looking out the window of a moving car: nearby stuff like street signs whip by in a blur, trees further away move more slowly, while distant things like mountains barely appear to be moving. In addition, objects don't scale linearly as they get closer. That is, objects only scale a little while far away and scale up faster when close; scaling linearly would be if they scale up at the same rate the entire time. You say you're already scaling your objects as they get closer, but you may be scaling them linearly and that looks flat. ADDITION: Afterburner is another classic arcade game that used a lot of the same graphics tricks. 

Limiting the number of bone influences is common, yes. You can either 0-weight unused influences, or have a loop/early-out mechanism to skip. As for whether it works for an RTS, I don't have a reference for you, but I imagine you're going to need LOD if working with a large number of characters on-screen, and also if those characters are small. LODing skeletal characters is much the same as LODing anything else, except you'll probably want to LOD the bone influences and skeleton as well as the mesh. For example, a low-ish level of detail might only use a single bone with the highest influence per-vertex (also known as "hard skinning"). You would probably also limit the number of bones in the skeleton for a low LOD model. Finally - consider whether you ever need to render the characters close-up. You probably only want to model, skin and animate the characters for the closest view distance... certainly you don't want to be storing all the runtime data at a resolution far higher than you'll ever render. You might find that you just don't need more than a very basic skeleton and a couple of influences per-vertex for your situation. 

I don't know about 99/1 but there is a reason I set my desktop background to the slogan "Ideas are easy, Implementation is hard" 

As already mentioned by Vaughan the most popular free 2D framework for Unity is SpriteManager. However another widely used 2D graphics framework is 2D Toolkit; that's the one my company is using. It costs money, but it's not much and the framework has more features than SpriteManager, like tools to generate sprite atlases. ADDITION: I just successfully displayed images loaded from the web, here's the code 

You will probably have to adjust parts of your application for the different platforms, but you won't have to do much because very little will change. Technically you can directly deploy unchanged an app created for Android onto iOS using Corona, but you will probably want to tweak a lot of things in the app in order to optimize for the different platform. For starters, you may want to incorporate iOS-specific features like GameCenter. You didn't directly ask about it but I do want to clarify, you definitely should get a Mac if you intend to deploy onto iOS. Because Corona is a cross-platform development tool, sometimes people on Windows plan to just compile for iOS on a friend's machine. That is never a good idea, and you should always be able to directly deploy onto and test on the target hardware yourself. 

The result will be that the object's vertices will first be scaled (along the local XYZ axes), then rotated (around the local origin), and then translated into "world" space. Then the world-space co-ordinates will be translated such that the camera is at the origin, and finally everything will be rotated around to the correct view direction. This is probably what you want for a basic scene. As Richard Fabian says, you generally want to consider the camera transforms as an inverse, though you might equally replace the camera transforms with a lookAt() function or similar, to directly construct an appropriate view matrix. If you push the matrix stack after setting up the camera, you can pop/push for each object without having to set the camera up again. 

You could search in both directions - from the current tile to the nearest neighbour, but also looking to see if another tile has the current one as nearest in the opposite direction. Move to the closest of those two if different. 

First off, have you already seen Lime but don't want to incorporate that framework, since its entire purpose is to incorporate Tiled maps in Corona: $URL$ In your searches of the Corona forums, did you find these threads? $URL$ $URL$ $URL$ A while ago someone had asked about developing efficient tile map performance/culling and I provided an example of one simple approach using quadrants to organize the tiles for efficiency. Then p120ph37 showed up with an even more efficient technique that changes the frame of the sprite objects without actually showing/hiding sprites. 

Since you don't want to use Canvas I would look into Spritely or gameQuery. Note that both are plugins for jquery, which you are already using. 

A script is only run when it's in the scene. So any scripts on a prefab will only run after the prefab is instantiated. That of course means you have to instantiate the prefab from some other script, not from within its own script. 

Something I've used, which works well even for irregular UV maps, is to turn the UV patch into a bitmap mask, and maintain a mask for the texture itself, searching for the first position the UV patch will fit into. I order the blocks according to some simple heuristic (height, width, size, whatever), and I allow rotations of the blocks to minimise or maximise the chosen heuristic. That gives a manageable search-space for brute force. If you can then iterate that trying several heuristics, and/or apply a random factor in choosing the ordering and iterate until some time limit runs out. With this scheme you'll get small UV islands packed into the gaps made by large ones, and even in holes left within single UV patches themselves. 

A cross product ought to be perfectly reliable for any planar polygon. If you've got problems with that, it's almost certainly just a bug in your code. As others have said, it would be useful to know why you think your normals are wrong. 

First off, this trope is hardly specific to games; it is extremely common in movies and TV shows too (refer here $URL$ ) The reason is pretty simple: those sound effects are cool, and a completely silent game would be boring. 

Typically, a frame is drawn every time through the game loop. Thus, the FPS tells you how fast the game is looping. That said, more sophisticated rendering architectures often decouple the rendering from the main game loop. In that case, the two are only vaguely related. 

By far the majority of browser-based games are done in Flash. However the newer and growing in importance game format is HTML5 (ie. games programmed in JavaScript that use the new Canvas element). I've also seen many games that are pretty much just static images and web forms for the UI and the server simply constructs different static HTML pages in response to the player clicking on the buttons. Up until recently Unity used to be another format for browser games. However the latest version of Unity actually deploys Flash content, making Unity games a special case of Flash games. The only other format I can think of that has any impact whatsoever in browser games in Java, because that's what Puzzle Pirates used (and even that I'm not 100% sure about). That is a single game that came out years ago, hardly worth worrying about. 

Having more maths knowledge/ability is never a bad thing. However don't take it as a bullet point for the CV - it's only going to be useful to you, and/or an employer, if you actually get something out of it. Which means actually learning stuff, and being able to demonstrate it in an interview and use it in the real world. That can be tough, because IME maths is quite often a subject taught without much context. You may have to provide your own - look at what each topic can be used for and you'll probably absorb it a bit better. I wish I had done this a bit more myself. There are topics in maths I know I covered at university, but didn't take in because I wasn't given any indication of what they were useful for. Now, 15-20 years later I'm coming across things where I need that knowledge... and it's not there ;)