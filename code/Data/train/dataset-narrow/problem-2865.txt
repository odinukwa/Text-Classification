You might want to "just calculate" the answer but I'm sure that you'll find it insufficient once you've got it because of the highly interactive nature of your "free fall" physics. Consider using a different approach: Searching. Here is how it's done for Super Mario AI: $URL$ Searching possible pathes to get from A to B allows for unlimited interactivity in mid-air while still being computationally efficient. 

As already suggested by @Philipp creating, storing and rendering are often handled very differently when in comes to indoor vs. outdoor. This is because the requirements and challenges are typically very differrent. Example: Outdoor: 

@Byte56 is right. You only want a direction vector without any information about the distance to the target. You can get that by normalizing your vector to unit length. Do this: 

It depends if any of your physics can happen outside the flat player space. As ghostonline said debris and ragdoll animations are a classic example of out-of-2D physics in an 2.5D game. Another example is bullets: If there are any projectiles in your game, do they follow the curvature of your 2D space or do the travel straight ahead even if that means they will leave those bounds? Also mapping a physical 2D space to a curved 3D visualization correctly is (correct me if I'm mistaken) .. not that easy. You will need an injective projection functions probably involving lots of splines or something similar. While having curved 2D game spaces is a nice add-on, it requires quite some overhead for the code. That might be the reason why there is no such thing in Trine. But the game was fun anyway, wasn't it? I'd think twice about a feature like that. 

There are many solutions, depending on what kind of effect you want to achieve. Here's a simple 'rebound' solution: When a collision between object 'A' and the wall is detected, do the following: 

This already narrows down the cases, but I added some further optimizations: 3 . I have a Collision class: 

In my collision detection loop, I make a new Collision instance for each object in my scene that happen to participate in a collision. For example, if obj1 collides with obj2, I will create two new Collisions so: 

Get a Vector V_r which points from the collision point to A's center point (let's call the center point P_A ). Set the object's new position P_An = P_A + (V_r * d), where d is a distance. This distance must be so, that after you set P_An, the object is no longer colliding with the wall. So d depends on your collision detection method. With pixel perfect collision, d must be large enough to put P_An on a different pixel than which P_A is on. Let's name the object's velocity vector right before the collision V_v. Set the object's new velocity to V_vn = -V_v * c, where c is a constant value somewhere between zero and one. This will provide the effect of some "inertia loss". 

I know some people frown on link dumping, however I found this to be a very enlightening paper, and it obviously conveys way more than I could elaborate on : $URL$ 

A quick test, just grab the logo image from the SFML site and paste it into the working directory of your project (or just somewhere simple and explicitly state that in code i.e. "C:\test\img.png") 

in each Update() call. targetPos can just be a gameObject in your scene indicating a position to the left, just outside of the visible screen space (at which point you can kill/recycle your pillar). If you need objects which have their own speed then alter or add to the 'speed' variable for each required gameObject. For example a projectile being shot by a trap towards the player from right to left might be moving at playerSpeed + bulletSpeed etc. On the topic of recycling objects : instead of instantiating a new gameObject for each obstacle such as pillars, especially in a tight loop or Update() function, instead investigate object pooling in Unity where you can just keep recycling from a pre-allocated list of gameObjects. --- EDIT forgot you're using rigidBody ---- After you instantiate each pillar with an initial velocity (moving towards the player from right to left) then it sounds like you could then use an InvokeRepeating or something similar to fire off an increase in speed of each subsequent pillar by just adding force to the current velocity : 

The reason I'm using CardId's instead of CardName's, is that your card names might change with localization, or patches (typo fixes etc.). If you associate an Id with each card, then you won't have to worry about those changes. 

In my opinion, the Elder Scrolls approach is more viable in a single-player game. The player doesn't have to start over if he wants to try a different play style. In Morrowind for example, you can be an armored melee fighter for the first 30 levels or so - and then decide to try the thieving skills / quests without receiving any penalty (or having to create a new character and start from level 1). 

I also use complex maps with "lots of irregularities" in my game (pretty much like the game Worms). I have premade graphical elements which I put at arbitrary positions. These elements have minimal bounding rectangles (MBR's). When a character is inside the MBR of a map element, I do a per-pixel collision detection. It is important, that I'm taking into account only the intersection of the map element's MBR vs the character's MBR. TL;DR: Minimal bounding rectangles, then a finer (e.g. per-pixel) collision detection when they intersect. 

In my opinion it is perfectly fine to model the behavior with a FSM. Oftentimes we create inferior models with cluttered if-statements like suggested in the comments. But the FSM is not the problem. To me it seems like you are experiencing jittering movement because your AI ship is always just at the border between "too far" and "close enough". Think about widening this border by using too different radii. One for getting a bit closer than absolutely necessary (r1=50m) and one for "oh I'm no longer close enough" (r2=80m). Where r1 < r2 and r2 = your original radius. Go to state once you are within r1 and only go back to when you are within r2 no longer. In the meantime fire at the player and dodge bullets. 

It seems you are using non-power of 2 texture dimensions and mipmapping which calls for trouble because the minifying interpolation has incomplete information along the edges. Prefer to manually expand all textures to power of 2 before loading. Use the desired color for those padding pixels. If you have many small textures of arbitrary dimension it might also be a good idea to create a single power of 2 texture atlas. 

Once thats set up you can then interrogate a tile in your move path to see if its walkable based on the terrain type, or if it's blocked by an child obstacle etc. 

You've already got most of the setup. What you could do is just control the Campfire from the other collider inside the Collision method [untested code] : 

$URL$ If you're using Aron Granberg's pathfinder, then are you perhaps using one of the smoothing modifiers? This would result in the unit trying to optimize the path which would probably prevent the unit from hitting each node as it steps through the path. Or is the problem that you have a consistent offset when the unit paths from node to node? 

Additionally, I've noticed that you're loading a new texture for each block. This kind of defeats the object of using a texture. With a texture you want to load it once into video memory and then point all of your sprites to that once instance to reduce draw calls and memory requirements etc (aka batching your draws). In 2D games using the concept of one large texture atlas is very common because it's so efficient. You could have a variety of block textures all tightly packed into one 'blockTypes' texture and then just use 'sprite.setTextureRect' to refer to different sections of that texture as mentioned above. I'd just throw a few texture atlases into a map so that you have a single texture dictionary to refer to in all of your block objects. 

I have recently implemented a similar scenario in my game. I have the same principles (e.g. no friendly fire etc.), and this is how I've done it: 1 . All objects (even Environment) have a PlayerID property. In your game, for example: Environment.PlayerID = 0, Player.PlayerID = 1, Enemy.PlayerID = 2 etc. If a bullet is fired by the player: Bullet.PlayerID = 1, and so on. 2 . The first step in my collision detection is to check if the two objects I test for collision are actually the same. The second step is to see if their PlayerID's are the same: 

In your collision detection loop, when examining obj_A for collisions, you create a new , and add all other objects to this, which collide with obj_A. Once this list is built (you finished examining obj_A), you can call the ApplyCollision method with the list as an argument. In the ApplyCollision method, you're stepping through the items of the list, and yes: you will probably need a switch statement at this point, since a Bullet will probably be destroyed with a nice visual effect when it hits a Wall, while the Wall might only get a decal. And the Bullet will cause damage to a Player or a Vehicle, etc. But everything else is generic in the collision detection method. 

From my experience recently in doing a few 3D animations, I found it very simple to just split up the animation into 3 separate clips. That way I felt that it was quite intuitive and easy when creating transitions between each animation clip in each stage of the overall animation. You also have a great deal more control over the animation transitions using this method. If you split the animation up then just ensure that when you import the animations that you check the Loop animation check box in the Animations tab for the middle climbing animation clip and you should be good to go. You can then also use State Machine Behaviours to drive any additional actions like playing sounds or effects etc during each clip. I'm sure you could also perform some complex looping logic as you allude to, however that seems unnecessarily complicated and error prone in my opinion. 

A great explanation of a well known voxel chunk system can be found in the minecraft wiki Regardless of how you want to store the data programmatically, the ability to generate smooth flowing infinite voxel terrain comes down to a smartly optimized neighbouring chunk loading system. "The exact number of generated chunks varies in single player mode, depending on view distance and movement. In multiplayer mode, a grid with a default inradius of 10 (for a total of 21x21 or 441) chunks is loaded around each player and sent to the player by default, although this can be configured to be between 3 and 15, usually only lowered with a poor connection home server. These chunks may have activity (mobs spawning, trees growing, water flowing, dropped items disappearing etc.), while the other world chunks are inactive, stored on your hard drive. Chunks will not save again if they were saved in the last 30 seconds." So effectively in a player driven game like minecraft you're only ever creating/loading a small number of chunks around your player at any time. It's quite tough to troubleshoot your slow chunk loading issue without more information or code examples etc. 

Take a snapshot with the method. Load the resulting data into a with the method. Render the Texture2D. 

This way I can customize the collision effects only when necessary. For example, in my game bullets simply disappear (with an explosion effect) when they collide with anything, so I don't have any 'if' blocks in the Bullet.OnCollision method. 

You can check the button state easier using the and methods. These both accept an parameter. See the MSDN article. 

If I detect another collision for obj1 in the same Update cycle (with obj3 for example), I just add the obj3 to the coll1.Colliders list, and create a new Collision for obj3 (unless one already exists). 4 . Once I went through all the objects in the scene, I have a nice list of Collisions. Now I can go through that list, and apply the collision effects to their "Victims". 5 . I handle the collision effects in the Player, Bullet etc. classes. For example: 

A simple transaction would be, if the player with the id 5 sells 10 steel to the shop, to reduce the 'amount' value by 10 where the 'tradegoods_id' is 3 (steel) and the 'player_id' is 5. Of course you have to check if this is a valid transaction... But I think you get the idea. Edit: Important to note that your clients should NEVER access directly the SQL database. They only communicate with the server application, which will access the database when necessary. 

I'd advice on using SQL databases whenever you can. They are robust, well known, easy to interface, scalable and all. The only downside might be performance. But as you are not asking about how to store your live game objects on every update performance of the database itself will very likely not be a problem. Make sure to learn about serializing you savegame-relavant part of your game state. Pushing those into a database should be fairly easy then. 

Modelling everything in the metric system I also observed that gravity feels much too weak with regards to the player jumping (in a platformer). Much like "on the moon", "jelly", "too much phyics", not "arcade" enough. On the other hand players in games are regularly able to jump to great unrealistic height too. TLDR: high gravity feels very fast paced and arcade, realistic gravity sometimes might not give the desired game experience. 

Maik is right, Baraff's papers are an excellent start, but don't forget Chris Heckers write-up on rigid body dynamics: $URL$ ! Also his advice on "[..] you will throw your engine away" is entirely true. But you will learn a lot! Regarding the CUDA/OpenCL part of your question: If you know CUDA then switching to OpenCL becomes very easy. I'd recommend learning CUDA first, because there are so many good tutorials, example code and computation libraries out there. For example: 

Wouldn't it be simpler to just use some integer state logic to drive the match comparisons? For example you could just keep track of each Tile's state and colour and do numerical comparisons instead of interrogating the actual texture of each gameObject? This has the added value of using a single Texture Atlas to store your tile textures and then just map to that Atlas as per the norm if a tile needs to change via a user mouse click. A quick comparison example for you to Ctrl-F5 (if you run it a few times you'll get a match) : 

When importing the animation there is a 'mirror animation' checkbox under the Animations Tab in the Inspector for that asset. If you check that box and rename the animation to "myanimation_mirror" or whatever then you should have 2 mirrored animations. 

Using a 2D tile array for your world/level generation and representation will definitely simplify things. For example you could internally represent your world in a grid of tiles and take it from there : 

When I implemented something similar I used a messaging system exclusively to handle the necessary communication between different entities in various systems. That way the messenger can perform the relevant required component checks while marshalling the your messages between the entities. You can think of the Events as mini SubSystems if you like. It also cleans up your systems quite a bit as well as providing a great deal of de-coupled logic, and hence less dependency chains overall etc. (contrived and untested psuedo-code disclaimer) example :