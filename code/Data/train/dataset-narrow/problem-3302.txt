The Pi3 will run quite happily on a quality 1A supply. If it does not work you have a PS or cable problem. See Raspberry Pi Power Limitations Many Pi users do not understand "current" - provided the voltage is correct it will run - of course this means the PS has to be able to deliver the correct voltage at the current actually required. 

This question has been asked many times. Rather than repeating a long list of suggestion follow the process suggested in:- $URL$ It may be a problem with the SD card - the only way to tell is try another; they are cheap enough! SD Card socket problems are also common (most caused by moving the Pi with a card in place). If you search you will find suggestions on repairing the SD Card socket, although the contacts are rather delicate, so I wouldn't be poking at them unless necessary. As a last resort get a new SD adapter and glue in place (with a removable adhesive). 

No! You can use a relay. I suggest you do some research before connecting anything to your Pi and learn a bit about circuitry. There are hundreds of books and tutorials. 

should show supported modes. You will only get a response if the connected device supports CEC; monitors often only respond to DMT. There is no page for , but will show the commands. should give you all supported data. 

Yes. You ran which installs the latest development software which is untested and has a couple of known issues. You should never do this unless you have some particular reason to run development. On top of this Berryboot has its own loader which you have probably damaged. 

If you had followed the Foundation advice which is to do a clean install of Jessie none of this would have happened. It is NOT possible to upgrade by the method you used. It is possible to upgrade, but involves a much more complex process, involving manually installing new components. 

You can not monitor voltage, because the Pi has no analog capability. (You could, of course, add an ADC to monitor the voltage.) The under-voltage warning is produced by a chip, and is ON or OFF. SeeRaspberry Pi Power Limitations for details. will show the current state. You may be able to write something to monitor this, but AFAIK there is nothing currently available. See the following for detail $URL$ 

As @ppumpkin states this could be ground loops. Strictly each Pi power supply will float WRT ground, but the Pi should be isolated, although if connected to external devices will reflect their state. Rather than worrying about the actual cause (which you may never find) you should apply normal design principles for working in noisy environments. Such as shielded twisted pair for inputs, Ferrite rings for common mode rejection, common ground points, separating power and signal ground. Using high value (10kΩ) resistors just makes the system more sensitive. In extreme cases you should use isolation. This is really NOT a Pi question, and you may get more information on an Electrical Engineering forum. 

has nothing to do with setting which is normally set system-wide in , although there are many other options. See if you want to customise the PATH. 

Your code won't run - you don't even have a and never call wiringPiSetup. I can't figure out what your circuit is even trying to achieve. You have to make up your mind whether you are asking a question about gpio pins or how to write a threaded program (which doesn't belong on this site). 

As others have pointed out you can't do this via USB (at least without writing your own drivers). There are 3 simple options (without any additional hardware); serial, SPI or I²C. You first have to define what you are trying to achieve. Serial is the time honoured solution; indeed once all UNIX machines did this, before IP was invented. There is a lot of support built into any Linux system to support this. The other protocols are more suitable to using one device as a slave. 

Your Pi is NOT getting hot. It is running within its designed operating range. Don't worry about it unless it exceeds 85℃ 

I don't use the (soon-to-be-obsolete) , but the Foundation now has wheels for most libraries - although I do not know if this was propagated to I recently (October 2017) installed pre-configured libraries with which should be your first step. 

There are many methods (of varying reliability) to determine this. One of the most complete and reliable is which produces the following output. 

This question is NOT Pi specific. If you want to write in Python, and allow users to execute it, they can read the code. If you want to hide code you need to write in a language that can be compiled. 

As Joan has answered it depends on the pullups. The Pi has 1.8kΩ pullups on board. I would just remove any pullup on the module, and it will work. NO you cannot use a resistive divider. is bi-directional, so needs level converters. is output, so no need, but I would be unhappy connecting any 5V without a converter. 

If the "measured voltage at test points and got around 4.5V when booted" then you are lucky the Pi works at all. This is below the minimum rated voltage. If it is this low when booted then the transient would be even lower during startup. 

Read particularly the section. DO NOT use use Device Tree! Pick any of the listed modules. I recommend which is a good performer and works from 3.3V, although many of the others work well. 

First - unless you you use raw disk mode backup and restore will be glacially slow. I doubt the copy or restore would complete in 3.4hrs, so you probably had an incomplete image. The following are the scripts I use on my Mac. (And before @goldilocks adds his comment, I usually use to make copies.) 

Some time ago I updated Gordon Henderson's pins for the B+ This shows all the common numbering schemes for the pins. $URL$ $URL$ as @steve-robillard said the first 26 pins are the same, unless you have one of the Rev 1 boards which have 3 differences (mainly I²C pins). 

You COULD assign a domain name, if you have one, and want to address it over the internet. You need network services to enable domain name resolution. What I suspect you actually want is to symbolically address your Pi on a local network. The Pi, like most Linux systems, has a ; by default. You can see this by entering on the command line. You can change it to something different (and preferably unique) in . Raspbian (you have not told us what you are using), by default, runs as a Zero-conf client. This enables programs to discover hosts running on a local network. You can easily connect from Linux and OS X with (the default hostname is raspberrypi) This should work with popular GUI ssh programs. This is sometimes problematic with some versions of Windows and networks which use .local in a non-standard way. (See $URL$ NOTE resolution does not work in some contexts e.g. in . The following should resolve IP (and can be included in bash scripts) 

I use a script to set on the Pi itself on 1st boot. This can be read from a file, or generated. NOTE The other answer may work (I haven't tried it) BUT only does half the job. If you do not also set the name in (which does) you will get strange "Not Found" error messages when attempting some networking. 

You don't say which Pi, but the later models reduce clock when not used. The only way you can save more is to remove power. The circuitry to control power will cost more than the power in 10 years of use, so this would actually result in waste. This also adds the problem of detecting potential use. You will find a few similar questions, but no solutions. The only real solutions are for those running on batteries/solar power. 

There are probably other issues in reliably detecting loss of power in your circuitry which you will have to address, but if your question is detecting an external 5V level you should use a voltage divider. 

You can NOT shutdown without shutting down USB. Rather than trying to look at heartbeat I suggest you use the which is designed for the purpose. 

Soldering to the Pi board is not recommended; for a start the solder is low lead, and has a high melting point. If you are going to try, don't even attempt the solder pads - there are test points with the supply voltage. It would be better to solder to the pins on the HAT; even better use proper external connections. 

You would be better to use a transistor to drive the relay, or better use an open collector driver to directly power the motor. You will find lots of examples on the web, many specific to the Pi. Try the MagPi magazine. Provided you use a diode from the relay to the +3.3V rail to prevent voltage spikes you won't do any damage, even if it doesn't work. 

The link is underwhelming. The Pi will have a Link-local address by default, and there is no point in trying to set another manually. You can easily connect from OS X with (the default hostname is raspberrypi) without knowing the IP Address. See How to set up networking/WiFi for more detail. You have not said HOW you are trying to connect to the internet - it CANNOT be done through the Mac without interfering with . 

I often use to use my monitor in portrait mode. I use the default detected screen resolution. does NOT change the way the screen image is actually displayed, it only changes the way the framebuffer is filled by the GPU. (It also probably changes how the image reported the monitor is interpreted.) You seem to be trying to specify screen architecture and micromanage settings. The screen characteristics you list with do not seem to agree with your settings. You also seem to have conflicting ideas about what your monotor does; "LG 21:9 (2560x1080) monitor" vs "framebuffer_width=2560 framebuffer_height=1080". You should concentrate on getting a normal screen display with consistent settings before trying rotate. 

This is not an answer to the question you asked, which is difficult if not impossible. On the other hand if you do not wish to keep "dragging my mouse and keyboard and internet connection back and forth to the other room" this is easily solved. Most distributions are easier to setup INITIALLY with a keyboard and mouse, but once this is done you can configure and operate your system remotely with a combination of and . I have 5 Pi and a large number of SD Cards with different OS and/or setups which I swap between Pi. These are all configured with , or other remote protocol (I use ). 

There is a lot of idle speculation about SD Card speed. All the standards for 6/10 etc cards guarantee is minimum write speed. This is mostly related to video recording or similar activities writing data in bursts. Unless you are regularly saving large files there is no difference, and as Patrick Cook says higher write speeds may come at the expense of read, which is more significant for most Pi applications. I see no difference between 4/6/10 cards. The standards do not specify read speeds which differ between card manufacturers. All of this needs to be taken with a grain of salt. Most (if not all) manufacturers do not recommend using SD cards for OS. 

Should work NOTE will OVERWRITE anything, without warning, so double check your flash drive location. You should ensure the flash drive is NOT MOUNTED You may need to precede with 

The SD is dead - this is a rare occurrence, but does happen occasionally; I had a brand new Sandisk card which failed in the same way, and was replaced under warranty. There are a few similar reports on this site. 

This means that GPU is using 128M. This can be verified/changed in , although I have not reduced the GPU myself. I am going from memory, but I think this is the default, possibly related to Camera. At least you now know where your memory is. 

Whatever you do DON'T "stick a coin battery in series with the GPIO". You will destroy the Pi! See $URL$ A MOSFET would seem most appropriate, but you need one with a low threshold which can be switched by 3.3V (the majority of power MOSFET need more). 

Do NOT WASTE YOUR TIME worrying about SD card wear! This is one of the urban myths. Any decent card will have wear levelling. If you did REALLY want to minimise writing to the card this file would be one of those LEAST to be concerned about. (There are stacks of logs written.) PS If you DO want to wear out Flash memory, I can show you how to do this in ~24hours, but you have to really try. PPS is never ACTUALLY written; it is just an entry in the directory, which is buffered, and only occasionally written to disk, along with other filesystem changes. 

You could make a script BUT scripting is far from straightforward and you will probably never need to repeat. 

Provided you have a good PSU you don't need one with the B+. The earlier Pi Model B had limited current. There is a ~1A polyfuse, which meant that only 1A - current needed by Pi (~700mA) was available. The B+ can supply 600mA (more if re-configured). 

This is a classic bus driver issue. There is no single answer - it depends on what speed you expect, distance (and thus indirectly capacitance). In traditional logic this would be addressed by i.e. the number of standard inputs that could be driven. To enhance robustness you could use a driver. It also depends on topography and distance - do you plan to have 20 wires from 1 Pi or a single wire which connects to 20 others on a bus? The short answer is that if you are not expecting high speed and are operating over short distances it should work.