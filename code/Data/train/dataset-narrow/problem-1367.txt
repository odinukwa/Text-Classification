Of course, you can replace the variable assignments with additions of a cell to , I just wrote it this way so that it is easier to understand. The indexes for the lower and upper neighbors are still calculated even though they might not be needed, but for the lower neighbor index, the code is still at worst just as fast as yours (if the index isn't needed), and faster if the index is needed. So the question of whether this code is in sum faster than yours ultimately hinges on the performance impact of calculating the index for the upper neighbor in advance. This probably depends on the number of rows in the list, in that if there are more cells with an upper neighbor than without, I'd guess this code is faster, but you'd probably have to try it out, because, as J H said, who knows what optimizations are already done by the JIT, and in the end, you might only save a couple of microseconds (or so). 

You could try taking advantage of the fact that, if you remove the first and last letter of a palindrome, then the resulting string will be a palindrome too by storing the indices of a discovered palindrome substring, along with the indices of all substrings that you get from that string with the method mentioned above, in a cache so you don't have to check these substrings separately. This means that you would have to check the substrings in descending order with regard to their length. 

In the following, I am going to propose a few alternative, simpler notations for single statements in your code, even though some of these examples will be irrelevant after following mdfst13's suggestions because they can be replaced together with other statements by one, simpler statement. 

A final comment on using . You list the fact that it has a built-in method for calculating the greatest common divisor as the only reason for using it. But a method for calculating the gcd is easily written in a few lines. If this is really your only reason for using , then you might consider writing a simple method for calculating the gcd of two s (or alternatively s, as ponomandr has suggested), and reap the benefits of using primitive values instead of s (e.g., as you have noticed, the use of operators). Of course, on the other hand, you would also have to deal with their limited range. Update 

In general, your code looks fine to me. You could make and in . Also, you don't have to create three separate objects in . Instead, it would suffice to create only one from and and pass that object to the threads you start, because the objects themselves will never change, only the the point to, and since they all point to the same (which is ), creating a separate for each thread is redundant. And about that : I can't envision a scenario in which an could ever be thrown in your program, but your comment "" implies that you think by merely swallowing the exception, you let the flow of your program be unaffected by it. However, this is not what would happen if an were actually thrown. If your code actually caught an , then it would no longer wait for to die, but instead, the for-each loop would move on to the next thread, if there is one. So theoretically, it could happen that, if an is thrown, by the time you call , not all 3 threads (or however many you start) are dead yet and the guinea pig is secretly still being tortured. To prevent this from happening, you could rewrite the code to look something like this: 

Overall, I think your code is clear, well structured and easy to follow, and the variable names are informative. However, I found some flaws with it, which I will address first. Correcting (potential) bugs 

I don't think it can get much simpler or more straightforward than your code. One way to improve upon what you already have is to also handle the case that the maximum value occurs more than once. True, the exercise does not prescribe how to deal with this situation, but it's something you might want to consider. You could also choose a more meaningful variable name for , like you did with the other variables. 

First, I benchmarked 10 test cases where every array contains 10,000 random integers, with a different random prescribed sum for every array. Here are the results: 

First of all, I don't think using a global variable is going to make a significant difference in performance (if at all), because it does not inhibit the creation of objects per se, it just doesn't cause them to be passed from one method to another. But you are still creating objects with all your invocations of , and whether you pass them to one of your own methods or directly to is, in the end, only a matter of readability. Your javadoc comments reveal that you once had the transcoding methods return a instead of . I would go back to this approach, because then the methods would only access state that is directly passed to them as arguments, which I think would be a clearer code design than if global state is involved (by the way, your method still has a local variable that hides the field of the same name). I know your question was about performance, but your code is so extremely complicated, probably much more complicated than it needs to be, that it would most likely be more than helpful to first clean up and simplify the code before thinking about performance, because then it will be much easier to spot opportunities where you can save performance. The first thing I would rewrite is your implementation of the various tokens and the method to obtain the appropriate token for an , because it doesn't depend on anything else in your code. There is a system to your assignment of the letters to the various ranges, at least until the letter P, so instead of hard-coding every single token that falls into this system, you can write an algorithm that calculates the letter based on the system. The last two tokens are exceptions (for whatever reason), so you would need to handle them separately. 

I think this better represents the intention behind the code than using a (or a , which, I agree, is more appropriate than a here), because collecting the elements to a is not an aim per se, but just a means to accomplish something else, whereas the stream describes exactly what you want to do, seeing as streams are meant to represent operations on data as opposed to storage of data. 

OK, so much for the code. Now, for â€¦ The Algorithm Your algorithm works, but it requires a condition that is not necessary for the applicability of the task of finding the maximum frequency of elements in an array. This condition is, of course, that the elements must be comparable, either through their natural ordering, or through a . What's more, this ordering must be consistent with equals, otherwise, the method will be out of control. This greatly reduces the usability of your code, even though the task it carries out is a relatively simple one. But you could simply iterate through the array, counting the frequencies of all elements along the way, and then determine the highest frequency and get all elements with that frequency. That way, you won't have to worry about the elements being comparable, and because your code doesn't do more than it needs to do, it will probably also be faster. Update Another problem just occurred to me: By sorting it, you are modifying the array passed to the methods (in case it is passed as an array and not as varargs), but you don't state this in the method's documentation. This is inconsiderate. You should either specify this in the documentation, or create a copy and sort this copy, or simply require that the array passed to the method be already sorted (like the methods in the class).