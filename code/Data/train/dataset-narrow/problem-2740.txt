Each job should have a) an importance b) assignment status (# of workers assigned) A worker could then decide for the job that gives him the most "reward" per time. The reward is calulated by the importance divided by the number of workers assigned divided by the time he needs to invest (walking and doing the job). If your worker can specialize on jobs (e.g. wood chopping) they will actually prefer tasks they can efficiently do. Jobs should of course only be assigned, if they can be continued at the right moment (e.g. resources needed must be available). To avoid having some jobs undone for long time (e.g. because its far away). The importance should increase with time. In case of harvesting the importance should also be dependent on how much resources of that type are available / needed at the moment (e.g. produced units divided by unit requested in a give period). To avoid workers to change their job to quickly, let them only change their current job, if the reward gets significantly better (by a given threshold). Also you could apply the doubled costs for the initial walking to the job, when calculating the reward per time values. Furthermore, you should let recalculate the workers optimal job one after each other, not all at the same time. Additionally, add some randomness to the calculated rewards. This will cause a better distribution of the workers to different jobs (this way they do not just "all" go to do the same job). But, this effect is already reduced by serially recalculating the next optimal job for a worker and adapting the number of workers already assigned (more workers on the same job reduce the expected reward). The algorithm maybe needs to be adapted a bit, if your jobs can only be assigned to one worker. If this is the case do the following: A worker chooses the job with highest reward per time (importance divided by individual time needed). If another worker can do the same job with a higher expected reward per time, he kicks off the currently assigned worker. The new "unemployed" worker then tries to find another job. In your example this could be like this: 

Singletons to me are ALWAYS bad. In my architecture I created a GameServices collection that the game class manages. I can search add to and remove from this collection as required. By saying something is in global scope you are basically saying "this hting is god and has no master" in the examples you provide above I would say most of those are either helper classes or GameServices in which case the game would be responsible for them. But that's just my design in my engine, your situation may be different. Putting it more directly ... The only real singleton is the game as it owns every part of the code. This is answer is based on the subjective nature of the question and is based purely on my opinion, it may not be correct for all developers out there. Edit: As requested ... Ok this is from my head as I don't have my code in front of me at the moment but essentially at the root of any game is the Game class which is truely a singleton ... it has to be! So I added the following ... 

Ok the question is pretty vague in that it reveals nothing about your game design but here's my take on any form of "game world": You painted a picture of this in my head .... 

Combining Randomness You need an algorithm that allows each player to contribute to the final random number in such a way that he can change the final outcome to every possible value, whatever the others have contributed to the random number. This way, even all other players may try to work together against a single player, but can not decide the outcome (or in any way influence it). How to do that? Imagine we want simulate a dice of 6 sides. If we play alone, we use a random number generator that outputs a large random number r. Then we get the final value by calculating . The same works for multiple players, that role their dice individually. Imagine you have a box (or urn). Every player runs its random number generator (concealed) and writes that number (r1, r2, r3, ... rn) on a sheet of paper and puts it into the box. Now the players take all the numbers out of the box and calculate their sum to generate the groups random number . This one is used to calculate the result using . If the other players would cheat (by working together), a single player could still change the result to any value. Why is that the case? Imagine we had 3 players. Player 1 and Player 2 try to cheats and work together against Player 3. Player 1 and Player 2 only contribute and to the sum . So what they can decide is what the result of . The value is the same as . As Players 1 and 2 may decide r1 and r2 they can decide the part let us call this one . The final result is then . So whatever players 1 and 2 are trying r3 can change the result to any value from 1 to 6 without changing the probabilities. If you do not believe it, try c = 0 and r3 = 0 .. 5, which gives you the result 1 to 6. Try c = 1 and r3 = 0 .. 5, it will give you the results 2,3,4,5,6,1. Try c = 2, r3 = 0 .. 5. You'll get: 3,4,5,6,1,2. To depict this phenomena imagine a Wheel of Fortune of a game show. It has 6 zones (0, 1, 2, 3, 4, 5) that lock in "digitally". You can push a button to turn it one zone forward (from 0 to 1, from 1 to 2, from 2 to 3, ... from 5 to 0 and so on). The Game starts with the wheel at position "0" and each player is writing down (concealed) any positive number. Now they must put away the pencils, so anyone can change the number and each player must show all others his number. Now each player pushes the button as many times as he has written down on his sheet of paper. And we get our final random number (0..5). This game would take very long and would be very annoying, if we would not remember to following: each 6 times the button is pressed the wheel is again at the same position. So each player may just calculate his number "mod 6" and push the button and turn the wheel forward that many times. The result is obviously the same. Or as a formula: . Exchanging Values Now over a network we don't have a "box" to put in the random values of the player (trusted third party). We also can't check the players have put their pencils away. So we need another algorithm for that. Kolrabi already explained it. You can let calculate a hash value (e.g. SHA1 hash) of the random value by each player first. Then they all have to release their hash value to the others. If you do it correctly, nobody can just "quickly" calculate the random number from that. So nobody can just take the hash of the others to change the final result in a deterministic way (Imagine: he is the last player and he just spins the wheel forward by his number of times. But he doesn't know what the position of the wheel is when he starts to turn it - so he can not decide the outcome). If everyone has got the hashes of all others, everyone checks that he got the same hashes from all the others. Don't know if this is really needed. But, afterwards everyone has the the same hashes. Now, exchange the random numbers. Everyone checks, that the numbers match to the hash value (by calculating the hash values of all numbers and checking that they are equal to the hashes that the player had exchanged before). If there was no problem above (all had exchanged the hashes correctly, hashes match the random values) you can calculate the result by summing up the random values and calculating "mod x" + 1, which gives you the result of a dice with x sides. This result should be (I'm not a cryptograph) random evenly distributed as long as at least one player used a random number generator that generates evenly distributed values. What means "If you do it correctly"? You must prevent that any player may calculate the random values from the hashes. There exist at least two ways how a player could do that: 

You can only use Visual Studio to debug unity projects if you have unity VS. From someone who has it, unless you are part of a team and all running unity pro you could probably do fine with unity and it's built in install of monodevelop. Mono develop still lets you debug your projects just not using visual studio. The unity VS plugin attaches you to your game code which you can't normally do because it runs within the unity process itself (by design i believe). 

No each component part of your scene has its own matrix as the matrix represents the combination of scale, rotation and position for that object. 

Depends on development methodology the fast answer is "When you have enough information to begin writing code". My thinking on what "enough" should be is something like ... 

ok im not a c++ developer but i do this all the time in c#. Essentially you need to wrap up a vbo and a ibo in to some container like this ... 

Now here's what throws me ... I'm comparing my "grid data" (so basically my block data) to some "isolevel" value. Every implementation i've seen (the easiest being here: $URL$ does exactly that but it creates a load of float values using something like simplex or perlin noise and runs through this logic. floats? not bools? So ... Given a Block[,,] if i check each blocks state (Active property) and return a simple true or false ... why do i need a float / double value or should I say ... what is the purpose of the float value that requires it to be a float and not a simple boolean? I gather they are referred to as "densities" which implies that I missed something because i've been thinking of them as the point cloud data to be evaluated and a voxel (to my knowledge) isn't a "density" value its more like a switch (on off). 

Do you evade in the sense of "to flee" or "to (non-)cooperatively walk around each other"? The answer to both questions is quite easy: 1) To let A flee away from B... let move A in the direct opposite direction of B relative to A. Which means: The direction vector should be Position(B) - Position(A). You'll then need to calculate the angle from this Vector for you data model (I think using atan(y/x) of the direction vector; or maybe atan(x/y) ... just try). 2) The let them -cooperatively- "walk around each other" just remind, what you do on the street, if you confront someone walking in your direction. You have to decide for a general "evasion"-direction. Which means: left or right in 2D. So either both actors evade on the right... or both of them evade on the left around the obstacle / other actor. This means you have to adapt your moving angle in one direction. The amount depends on the size of your bounding box. Note: I suggest you to use a bounding circle instead of a bounding box (as the corners of the bounding box will cause problems). If you run into performance problems only check the distance in case of collision. Use a hard limit and a soft limit for the obstacle distance. So you'll have 3 states: No Obstacle, Obstacle in Soft Limit, Obstacle in Hard Limit. Then observe the state changes. When the state changes from "No obstacle" to "Obstacle in Soft Limit" adjust your moving angle to evade. If it changes back to "No obstacle" adjust it back to move to your target position... It it changes to "Obstacle in Hard Limit" stop & wait! If you don't have a state, it will be quite complicated... as your actor will turn and turn and turn while it detects a bounding box collision, which makes it actually move in a circle and will maybe even let it crash into the obstacle. 3) For non-cooperative evasion you'll need to additionally 'evade' in a stronger manner as the opponent is not evading (passive, following a static path) or even trying to hit you (i.e. a missile). Hope this helps Stefan 

I find it hard to determine the wheel RPM since I'm only making a simple 2D game of rotating object via Z-axis. I wanna try this solution but I got no change since I'm trying to find the RPM from a game object that has a rigid body 2D and a circle collider. I decided to think of something more simple but alternate solution. I'm a bit good at math but not much. Took around to calculate but no luck yet. I want to know possibilities of checking its rotation from transform properties, figuring out yet about 6 degrees per second equivalent to 1 RPM as said from the link. I used the method for rotation speed. Also, when the rotation value reaches beyond 360, clockwise or counter-clockwise, sometimes it goes back either 0 or a negative value and I have to maintain total degree so that I can compute for the overall RPM. Please help me. Re-direct from my original question: $URL$ 

I finally understand about Preferences. Here's the example and observe the comments. Take note that this is sample from my previous projects. 

When I played it on the Google Nexus 7, the circle turn into a slightly oblonng shape, resembling as it was being flatten a bit. Please observe this snapshot below and you can see the blueberry is almost but slightly not perfectly rounded: 

Implement your own version of the rigidbody script. Make your world a whole lot bigger and rotate it under the player as they move rather than rotating the player round the world. 

Ok maybe i'm missing something because its getting late and i've been programming now for about 72 hours straight (minus a nap or 2) ... I'm trying to write a shader for unity that will apply triplanar texturing to a mesh, here's my shader code ... 

My guess is that the unity compilation process is not creating a correlation between these 2 because of that mismatch. 

Now I just need to add in things like variances for lighting and such :) I hope this is helpful to someone out there getting to grips with triplanar texturing :) 

In most game engines today the typical design is that a scene is a graph / tree of components some of which may be renderable. In a sense you are correct, every object is basically a node in a tree of things. You may have heard the expression "Entity Component System" and the expression "Component Composition" in relation to game engines and more specifically scene based objects. These 2 terms refer to a mechanism for maintaining a hierarchy of objects that are part of a renderable scene not all of which may contain a renderer. Component Composition is particularly useful for games because it refers to the mechanism of using composition to dynamically bolt bits of objects together in order to achieve something useful where each bit would be function / behavior of the object I am bolting to. For example: In unity (arguably one of the most popular engines for indie developers today) we can create an object in our scene which is in itself just a container. I can then add child objects to that object which are also just containers. I can then add things like renderers and mesh information about materials behavior like input control or other behaviors like gravity to an object. So I could say "this is a terrain object", and this child of that terrain is a character object, which has a controller component to allow the user to feed input to the character. So to put this back in to terms that match your question ... Your scene node object would contain a mesh component and a renderer component for rendering that mesh. The renderer would use the mesh and a material to draw the object in our virtual world each frame. Also: Other things that might be scene nodes / objects would be a camera, audio source, a light source, none of this as such would typically be renderable but arguably have an impact on the scene, it is the job of the engine to determine how to interpret your defined scene graph / tree. 

Replacement costs can vary with time, as your player maybe improves some building and is able to produce units faster for less money. So you should recalculate the efficiency during the game regularly based on current courses. Defeating the player means driving some or all of the resources of the player down to zero. Which in the end means that he can not produce some or any new units. So even a harvester working near to the player can cause damage to him, as it is harvesting his resources, which in the end isn't available to the player anymore. So the player must e.g. invest more time to gain such resources. 

A* and Dijkstra are quite a bit slow when you use it for a huge amount of units at the same time. You could use some simpler algorithms as robust trace and improve their found solution. The solutions from robust trace (which in a simple ways finds a way around obstacles) can be improved by checking at each position of the found path if it can walk the direct line of sight to any later position on the path. You should also improve robust trace by comparing the way "left" and "right" around an obstacle and take the shorter path. The algorithm with these optimizations should always find a way to a target (if it exists), even in a complex maze. The difference of the found solution compared to the optimal path is negligible in most cases. You can reduce your collision problems by calculating the paths one by one by a global path planner, which keeps track of which position on the map is already planed to be blocked at a certain point in time. The unit will then either need to walk around the other unit or wait a bit, till it moved on. While this can cause performance issues, you can stick to a simple algorithm, that just plans a static route using the currently blocked fields on the map. While executing the plan a unit will eventually see it's planned path blocked. In such a case, let the unit execute its planned route for some more time (if possible) and observe if this special point on the map is still blocked. If it gets "unblocked", continue ... if does not get "unblocked" for a continuous time span (of e.g. for 3 seconds) the unit should plan a new route. These algorithms will be have a well performance even on slow computers. I implemented them about 10 years ago on a PDA using a V30MZ processor (33MHz, 16-bit) to route about 200 units of a real-time strategy game. It worked very fluently ... 

less mesh objects less draw calls more opportunity for the engine to determine if it can save on draw calls with batching on its own 

This will execute the same function every 2 seconds change the delay to change how often the function is called and set carryOn to false to stop calling the function every "delay" number of milliseconds ... 

This also means you can apply a transform if you want to convert the data in to a "current version format" before loading the data so instead of having lots of versioned functions lying around you would simply have a set of xsl files that you choose from to do the conversion. This can be time consuming though if you are not familiar with xsl. If your save files are massive xml could be a problem, typically i've save files work really well where you just dump key value pairs in to the file like this ... 

Plot N number of points within the array and set their values to true set all points that represent a line between the current point and the next point to true fill the shape by setting all inside points to true 

The engine is the underlying platform on which your game code sits. The purpose of the engine is to abstract the raw driver / dx / opengl API away from us and make it easier to work with. It merely acts as a "toolkit" on which we build our games. Languages (such unrealscript) are simply part of that toolkit and enable us to do what we need. Ok so for your many questions ...