When stuck on a machine without fancy Compiz effects one can fall back to the good old tool, its not as pretty as a real fullscreen zoom, but gets the job done most of the time. 

Input devices register as in Linux, to interact with them you have to open that pseudo file and read from it. Example source code to do in from C can be downloaded via: 

The Windows Vista and Windows 8 boot loaders should now be each on their own partition where they belong. To get rid of the boot menu one has to delete the Windows 8 menu entries from the Vista BCD and the Vista entry from the Windows 8 BCD, as and don't seem to work on their own. This can be done easily with EasyBCD. Another thing to keep in mind, most of the Windows boot fix tools will work only on the partition with the boot flag set and do not allow to operate on a different partition. Thus one needs to ensure with that the boot flag is set for the proper partition. This caused most of my confusion in the process, as even tools like EasyBCD would constantly try to operate on the wrong drive (i.e. the Windows 8 partition was marked bootable, needed to reset that to the first partition). If everything is done should properly detect both Windows partitions and be able to boot into each directly without the Windows boot menu. 

To reset a Linksys router, hold the "Reset" button for 30 seconds; the Power button should blink as you do this. Release the button, and then unplug the router from the wall for another 30 seconds. Plug the router back in. Connect your computer via Ethernet and log in to the Linksys router using the default settings. Once reset, you need to reconfigure the WAN settings. Log into the router by going to 192.168.1.1, and use "admin" as the password. Leave username blank. If you're using PPPoE, which most people do, you will need the username and password from your service provider. This is usually written on the contract that you signed when you ordered the service. Don't forget to change the Username and Password to gain access to the router under the 'Administration" tab. 

When you care about being able talk to multiple developers at once I would recommend Teamspeak or Mumble (Ubuntu has packages for both). Both provide excellent audio quality and I found them much less troublesome then the classic VOIP solutions. 

The variable takes the position values where the jump occurs and then just uses to slice the file into pieces at those positions. The result are then separate mpeg files for every chapter, as the jump occurred whenever the recording was stopped and restarted. The resulting mpeg files where jump free and could then be processed as usual. The script itself actually doesn't call , it just outputs the commands needed to slice the file into pieces. 

Try switching the playback output in MPC-HC: In MPC-HC, select View, Options. Then under Playback, Output, change the DirectShow Video to something else. Video Mixing Renderer 9 (Renderless) for me has been working great. If that doesn't work, go down the list and try all the other different ones. 

After upgrading to Windows 10, I am unable to mount many ISO files I had. It keeps saying "The disk image file is corrupted." I have about 10 of these ISO files and they all come up with the same error. I searched for many solutions with Google and none of them helped. I've tried to make the iso default for Windows Explorer. I have tried to uninstall all 3rd party software for virtual CD's. I have tried using many 3rd party mounting software. All of them gives me an error. I even tried copying the files to another drive and a USB drive and it gives me the same errors. I know the files are good. So I tried the ISO files on another PC running Windows 7 and it worked instantly with no errors. It mounted and the data was in perfect condition. One thing weird is that I have tried mounting a Windows 7 iso I download from Microsoft and it mounted without problems. Now these files worked when I was on Windows 7 on the original PC. Once I upgraded to 10, they no longer work. Windows says it's corrupted. 3rd party software just says error, can't mount. Copy files to another PC with Win7, works perfectly as it should again. I'm confident this is a Windows 10 problem. Anyone know what's going on? 

If you just need it once in a while, not permanently like you get with , and the solution isn't flexible enough, you can also use good old bash scripting: 

To let the Grub boot disk load the grub config file of your Linux, then boot into that and restore the MBR with . Just play with different setups to find one that you like. 

Are you sure the content of authorized_keys is correct? Maybe something went wrong when creating the file. To fix that try removing the file and then use: 

I want to copy files securely from one computer to another, the other computer however isn't trusted and I don't have direct access to it other then giving the owner of the computer instructions. In addition to that this is a one-time only situation, so any cumbersome setup should be avoided. What would be the easiest and most portable way to do it? What I have in mind would be a program with the following workflow: 

Have you tried restarting and cleaning the print spooler? Step 1 Click the "Start" button on your Windows desktop. Type "services.msc" in the search bar and click "Services" from the results. Step 2 Scroll down and click on "Print Spooler" in the list of services. Click "Stop." Step 3 Click the "Start" button and then click "Computer" from the Windows Start menu. (Click "File Explorer" for Windows 10) Double-click "Local Disk (C:)." Step 4 Double-click "Windows" and "System32." Double-click "Spool" and "Printers." Step 5 Right-click each file in the Printers folder. Click "Delete" and "Yes." Step 6 Go back to the Service window and start the "Print Spooler" by right clicking it, then click on "Start." Source: $URL$ 

Once you have resized the partition you also have to grow the filesystem to fit the partition, this can be done with one of (depending on the file system you use): 

This might need to be done from a Windows Installation disc in recovery mode. Fourth step, boot with the Windows recovery disc and let it repair the Windows Vista boot or do it manually with: 

You are not supposed to read from uinput, as uinput is for creating user space devices and sending events to them, so the message is normal. I assume that it was either a simple permissions problem or a change in the location of the uinput device itself (i.e. /dev/uinput was expected but it was in /dev/input/uinput), both of which have changed in Ubuntu a while back, so that programs that expected old behavior might have gotten confused. 

Drivers that Microsoft or laptop manufactures provide are usually the most stable and compatible drivers. This doesn't necessary mean the newest drivers which may have less compatibility overall for different types of hardware/software combination. For example, the last driver my laptop maker provided is dated 2014. However, I can download the newest, or even beta drivers, from Intel (for my HD 4000) directly from Intel's website. Here's the link for yours: $URL$ You can do the same for the AMD part: $URL$ From what I've learned on mines (HD 4000 + Nvidia GeForce GT 650M), the Intel drives the internal and external displays (HDMI or VGA) by default. The Nvidia kicks in when needed. For example, when you run a 3D Game, the Nvidia will be used. The Nvidia software is able to do this automatically or you can actually select it per program basis. So I can actually force the system to use the Nvidia card for Excel if I wanted to. I'm not sure if AMD has something like that for theirs but you can install it and try. 

This is a guess: It might be that the time resolution is not large enough and the files are different while their timestamps fall into the same second and have the same length, so rsync can't distinguish them and skips them, thinking they are the same. The option might help in this case, as that will force rsync to check the file content, not just file size and timestamp. Another alternative to is , which will force rsync to checksum each file and should guarantee you that the directories are exactly equal afterwards, it will however slow things down a bit, especially on large file hierarchies. Another more mundane issue could simply be failing hardware, RAM, harddrive or whatever that leads to files being copied incorrectly, I have seen that happen quite a few times. To check for that use a memory checker like and do repeated copies of the same directory structure to a different target directory and compare the results, if the results are different each time, something is fishy.