Notes A faster way to check if a file has been processed would be to add a character indicating that it has been processed, for example: 

Consider what happens if returns value A, but before the expression is evaluated, is changed to some other value B. This could cause to say that the queue is empty when it isn't or that it isn't when it actually is. Conclusion These are two of many issues that are currently in your code. I've decided to stop here since that's a pretty bad problem. This current implementation if not safe at all. I recommend you do some more reading and learning about thread interaction. Good luck. 

I've actually implemented the same functionality in the past, so here are my comments. Wrong behaviour? It depends on what you can consider wrong. Consider running your own example and inputting . The 2nd will be left in the stream buffer and will be automatically assigned to your 2nd variable. This clearly causes weird behaviour, but it is the same behaviour that occurs when normally using . Suggestions The following are what I consider to be useful features for such an utility function. Better interface In order to provide a nicer interface, you could instead read a single value from your stream and then discard anything else that's been left in the stream buffer; calls to will always return one single value and successive calls won't be forced to take what's left in the stream buffer. Example 

It's much better to make the default controller name part of the application configuration and have the router take it from there, because it's reasonable to want your "home" page to be equivalent to the "/something" url instead of "/index". The same goes for 

On principle the code is sound except for one issue: you do not check if the language is "valid". This raises some questions: 

In both cases, the sane outcome would be to default to your "main" language, which would probably be hardcoded in your application. Another issue you may want to consider is that nobody knows that there is an Accept-Language header and how to use it, so using that as a source of the user's preferred locale is not recommended: 

This check with would allow any url that maps to a function to be successfully dispatched, even if that function does not map to a "real" action (it can simply be a helper method). That's not really a security issue (you can easily make sensitive functions ) but it's not very consistent: targeting will get you to the index page, while targeting e.g. will show a blank page as most likely does not directly produce content. By demanding that actions are implemented in functions with names starting with "action" you can make sure that this never happens. The default action is a special exception to this rule, as it allows the controller writer to effectively specify which url routes to the default action and what the default action should do at the same time. Third: It's not consistent to show a 404 for a missing controller but not do that for a missing action and use the default one instead. You should do the same in both cases, and the right choice would be the 404. Fourth: Parameter handling needs immediate attention. To begin with, you are sanitizing parameters to an unreasonably restricted set. What if there's a search action somewhere and the user wants to type in a character like or a non-alphanum string? Clearly parameter sanitization needs to simply be removed. Apart from that, you are passing GET parameters to the controller action positionally. The positional part is not a dealbreaker by itself (although it would be a dealbreaker in a framework, or if the URL format were configurable), but the GET restriction is a bit ugly. However, this cannot be fixed easily because there's no good way to know where parameters from $_POST should be inserted, or what their order relative to one another should be. To address this, you need to make the code reflect into the controller method and look for argument names and default values, pull these out from your list of GET parameters and $_POST, place them in an array ordered by the position of each named parameter in the function signature and call the function with that. You should also probably return an HTTP 400 if the action turns out to have a non-optional parameter the value of which was not provided. All in all not the end of the world, but a speed bump and a non-trivial amount of code. 

You can expand on this by providing functions that use the "Error hiding pattern". That is that they return a to indicate whether the input operation succeeded or not, while the result is stored in a reference parameter. Other isn't the only object that can be streamed from. For example, you can also stream from files. You should provide a way for users of your function to specify what they want to stream from (this can be as simple as having a parameter. 

2.2. function_traits.h These are simple template class specializations that provide the required function traits for the implementation of . I realize that specializations for and functions are required. 

Welcome to Code Review. This queue implementation is not truly concurrent-ready. Arbitrary initial capacity 

Specialization for special types You can also provide a way to read whole lines through template specialization or through a different function, since it would be useful for strings (reading a phrase, for example). More functionality You can provide a way to obtain values based on a predicate. So that it can be a lot easier for people to get valid values. For example, I want to get easy input of an integer that is between 0 and 10 from an user. Example 

Since it has been said already, I will leave the issue at "figure out what's responsible for memory management" without further explanation. I have a few things to add: DRY, DRY, DRY! (ha.. ha... tumbleweed) It is possible that some day, you will want to change your container type. Maybe you import a library, maybe you need different performance or thread safety, maybe you write something entirely new that better serves your purposes. You did half the work of protecting yourself from this change by making a for , but you also have throughout your code, as well as its corresponding iterator. You can DRY that up by using the instead of in all cases. Possibly add another for the iterator type. That's just to save some keystrokes, though, rather than typing out every time. You probably won't ever change the fact that you need an iterator specific to your container, so is also fine if you don't care for brevity. The other thing I see repeated over and over is the code to select a subset of your s based on their subclass. I doubt that your 's role includes enforcing the class hierarchy, so you don't want the manager coupling to it. That makes your manager brittle to any extensions of you may make later - at best, every new type requires not only its own code and header, but also a change to the manager class, lest it remain un-queryable. There are two ways to go about reducing that coupling. Probably real OO gurus can think of more, but I'll stick with the simplest: 

What this means is that when the comparison fails, E is updated to the current value of X. If the comparison succeeds, X is updated with the value of N. Therefore, you don't need to update X again! That is the whole point of a compare/exchange operation; you're basically saying: "I was the last to modify X." Issue #1: Unsynchronized access to writer In your code, you perform a store to the atomic variable with a copy of a value you last obtained from the update performed in the compare/exchange operation, but this is not atomic. 

3. Sample usage Here's some sample usage to show how a user can get the return values. Basically, the user would send in their function/functor to the dispatcher and would take care of the rest; the dispatcher would return the from its submit-a-function function. 3.1. Example 1 This example is pretty much just a test of the template deduction rules and shows how you can use a collection to erase types. The main feature is that you can have a collection of functions that all have different signatures and return types. 

That really depends on the functionality you want to guarantee. Assuming this is working code and your interest is to "declare" all aspects of a "class" in one block and also have reflection (access to the class hierarchy, via in your example, it breaks if you have a name collision. i.e. you want properties called and that have nothing to do with the framework. I'm having a little trouble seeing how this code works, though: 

/UPDATE In a more inclusive sense, the pattern you're describing breaks a lot of the functionality that JavaScript provides natively when you use established idioms for creating objects. You lose , you lose , you lose , you lose , you lose , and you lose either lint or . You're also forfeiting your IDE's documentation and code completion for your classes and constructors (unless you're writing code in notepad anyway, or something). It comes down to priorities: how desperately do you need single block "classes" and reflection, and how certain are you that this is the only way to do it? 

Here it is much more obvious what you method you should be looking for. It's true that you, as creator of the code, do not need this -- but others might, and it's a totally free lunch. Second: this line bakes an application configuration decision inside the router. You don't want to do this, as it's totally reasonable to want to change this configuration most of the time while the router would stay mostly untouched. 

You do not have to go to all this trouble to implement a caching wrapper. It can be done much more simply: 

But why also rename to and add the "action" prefix to method names? Consider also your dispatch code: 

All the basic parts are here, but there's still room for improvement. First of all, I wouldn't have the constructor call and then call because it makes the second method less discoverable when the code is being read. Contrast this with: 

In your shoes I would totally scrap using (IMHO it's useless in practice). If you want to go the extra mile and auto-detect the user's locale, use an IP database (I have used MaxMind GeoIP in the past myself) or the upcoming W3C geolocation spec. 

3.2. Example 2 This example displays a more "real-world" use. Instead of having the function call , that would be done by threads consuming from the data member. Since this is an example, I've provided a simple function that works only for free functions; overloads can easily be added to deal with functors and member functions. 

Why have you decided that the default size should be 100? Different people have different needs; having default values like this isn't a good idea because there is no true advantage to having a default size of 100. While this is subjective, I suggest you remove that default size and just have users be required to specify the size that they want. Compare/exchange confusion There seems to be a misunderstanding in regards to the use of compare/exchange. The compare/exchange operations work as follows: 

To indicate that the first three files have been processed. You would then only have to check the first character of every line you read, instead of the whole file name, to know which files have been processed. This is the technique I would personally use, as it doesn't require an extra file and it keeps the original file mostly intact while providing a much faster comparison. 

This looks perfectly good to me. Everything has a unique purpose, everything is either clearly explained or self-explanatory. Unless you have tested this and found a performance issue, and you are sure that it is happening here, do not do any optimization to this. There is no loop and no recursion, the code itself can't properly be an optimization target. If you are observing that this is running slowly, the hidden costs of setting the scrollbars must be the cause. To address this you will need to change your entire strategy to keeping the contents in the right place using CSS only. I have to say that while I find using the position of some element (?) to be a pretty elegant way to duck issues of messing around with coordinates that will be inconsistent otherwise, it is technically the best practice to do all positioning with CSS. 

I see some opportunities for improvement, which will get this up to about what we expect from a . First, the imposition that the stored elements are is not optimal. Sooner or later you will want non- elements, and you will not want to write and maintain another for each data type you want. is, in fact, the least useful element type I can think of. The solution is a class; instance objects would be declared ; a programmer will expect this syntax and the reusabilty it produces. Second, there should be no method as it is unclear where the new element is added. Instead, we expect methods like for O() insertion at and O(N) for what you are currently doing with . Third, you may recognize your as being O(k); this is because you've actually written a queue (with minimal modification, a deque), which extends a real . A real has no need of a tail pointer ( here). 

1. Description 1.1. Functionality The objective of these types is to provide type erasure for any function while maintaining the ability to provide a return value through a combination of and its associated . 1.2. Motivation This is useful for any sort of dispatch manager, a thread pool that you can submit tasks to being the actual target; where a task is any function with any parameters and return type. 2. Implementation 2.1. deferred_invoker.h This is the main functionality. Type erasure is provided through the base class, which simply has a virtual member function that is called when the function has to be invoked. The specializations will then know how to deal with the invocation and whether they have to save a result. They also take care of ensuring the correct initialization arguments required for the call are initialized and saved in a tuple. This applies for template parameter which is any function. A simple tag dispatch system takes care of return types. I've omitted a third implementation of for lambda and functor types to focus the review. It's basically the same style as the other two (possible design issue?), but it takes a copy of the lambda/functor and the arguments, instead of a pointer to the function.