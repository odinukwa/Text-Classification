This is brilliant! Our controller square input allows us to do this and more importantly should Bobs hat magically only have one thruster that can go a maximum of 100 units a second well that's okay. We can then give him a direction using inverse tan: 

Initial idea based off your Actor structure: You are basically just wanting a character to be null, if you have removed it from the list that updates and renders it why not just set to handle resource disposing in and track the resources themselves as part of your overall design. Otherwise these items will not be handled correctly and cause issues longer down the line. MonoBehaviours are handled behind the scenes and have a lot of code behind the simple function, so it's not as simple as a one line solution: 

You really should tell us how this is being constructed as different technologies can have different advantages to your situation. Is it in Flash? PHP? HTML5? JavaSript? Java? The "web" tag doesn't give us much to go off. That being said: One of the most secure ways to transmit points score is to not let the client side decide what those points are. What you want is to create points based events: 

You can get the displacement from to by subtraction. I'm not sure if your direction is normalized or not, but if you normalize the direction and normalize the displacement vector, will reach if those vectors are equal. 

If you just want a number of items placed randomly within a range (which, from your description, sounds like that may be all you want) that could be done pretty easily. Randomly choose a number of trees to place, then iterate through a loop where you randomly pick an X and Y coordinate and put a tree there. Do similarly with enemies, rocks, anything else. This simple method would be easy (a few random numbers and a few loops that make more random numbers) to set up but wouldn't necessarily clump things together. If you mean you want actual terrain randomized, Perlin noise is a commonly used way to generate heightmaps or other clustered groups. You could use it to determine forest areas or enemy campsites, etc. in addition to a simple heightmap by changing some of its generation parameters. EDIT: Googling "Javascript Perlin Noise" provides a good number of results if you want code to adapt. I came across this code which may be useful for you. As for how to use it, you can generate 2D textures using whatever code you decide and use one as a height map, another as tree density, or enemy density, or rock density, or water depth, or whatever. 

Just to extract an answer from the comments: Zophars Domain shows you a list of tools that you can use for NES ROMs including Graphics Extractor and Inserter which allows you to extract and insert tile graphics from the ROM. To use this you need the Extractor executable and the Inserter. Use the extractor to get the tiles first, edit them in your editor of choice (MS Paint ftw) and then use the inserter to pop them back into the ROM. Make sure you create a backup in-case it corrupts the ROM image. 

I would suggest not setting your vertical speed to -10 as this is essentially doubling the effect of gravity which can have some serious adverse effects later on. I would replace the collider with a spherical based one on your character: 

This will destroy the object after three seconds. Put this in your script after you have sorted out your text and GUI related stuff and you're sorted. 

Lastly, if the design of your games doesn't call for the complex math, don't use it. :) But, of course, don't let that stop you from delving into designing a game that does. 

The documentation isn't terribly clear on it—and I'm not currently in a position to verify it—but I believe that the force applied from (link) is applied at that object's root location (at its ). If not at , then at the object's (link). If you want to apply a force vector at a specific point, you probably want to use (link). Similarly, there is (link) if you just want it local to the object itself. And, for even more control if you know the torque you want to apply, there are (link) and (link). </wallOfLinks> 

You can treat this as a conversion from spherical coordinates to Cartesian coordinates. Assuming the ray should have some length , your , , and components can be calculated like this: 

The ball, by pretty much the law of Pong and physics must either be going towards player one, or player two, not both. You could use this to switch interpolation priority between the two players. When the ball is heading towards player one then use player one to synchronise your information, as he is the only one that can affect the outcome of if the ball manages to either bounce in the opposite direction or score for player two. Once the ball starts bouncing in the opposite direction (either because player one succeeded to hit it or player two scored and the next round began) you can then use player two to synchronise your information with. Which ever player has to interact with the ball next, is the player that should report where they and the ball are. This way the lag is only significant against the player who doesn't need the accuracy at that time. 

Since finding the exit is the first goal, then the process will have two phases: clearing fog, then finding a path. When clearing fog, the goal should be to clear it as efficiently as possible. A simple way to do this is to pick the next step that will clear the most fog, or pick the next step that will take you toward the nearest fog if no immediate fog is available to clear. More complex algorithms will depend on the type of terrain... a hedge maze has a different optimal exploration method than a wargame hex map with fields, forests, and rivers. When the exit is found, then just path to it, with the obvious 'fogged terrain has a moderate cost that gets updated to the real cost once explored'. The fog cost can be adjusted to whatever level you desire... very high costs will have the AI take long backtracks to follow explored paths to the exit, while lower costs encourage the AI to attempt to find new shorter routes. Which is better depends on your terrain generator. 

Without any knowledge of what your game is, the theme of the game, or what kind of things you want to be moving, all we could possibly do is throw out random ideas hoping you like one. So... here's a rampant brain dump of ways I can think of to get from to : 

It's likely you're always going to get a collision with the floor; if you're using gravity, your cube is essentially going to be almost constantly hitting the floor in addition to any other objects it hits. The trick is in determining if there are additional collisions that involve a wall. Without knowing much about your specific implementation, here's what I'd suggest: In , check every 's normal to see if it's perpendicular to the floor. For now, I'll assume that your cube rotates to have its vector parallel to the ground on which it's moving (resulting in its vector pointing away from the ground). If that's wrong, let me know how you have it set up and I'll try to edit the answer to fit. My code is in C#, if you're using JavaScript, there will obviously be some differences. In your cube's collision code, you'll want something like this: 

There is nothing stopping you from using 2D sprites in a 3D world. Unity has support for 2D, 2.5D and 3D in all combinations of the set together. "I want 3D models in a 2D game." - Fix the camera to a pan only system and use 3D models. "I want 2D models in a 3D game." - Fix the camera to follow a 2D sprite but use the 3D character controller. Try it. If it doesn't work or you have issues along the way, come back and we can help! 

Firstly, you need to use a switch case statement and decide which direction overrides the others, for example, if they press all four buttons, which button should be listened to for input? This gets put in order within the switch statements. Edit: For clarity about the above statement. You do need to use a switch case statement (or similar structural logic) to stop the following from happening. 

I have recently finished the coursework for an MS in Computing with emphasis in videogame programming from the University of Utah. They also offer an undergrad emphasis that I don't know a lot about. I found that having a BS in vanilla Computer Science from another school helped me have better understanding of pure programming concepts than learning game-specific programming may have been. Focusing those skills toward programming for a masters degree helped me add to that knowledge in pretty valuable ways but, for me, a foundation of non-focused programming has been integral for my success in the master's courses. 

Your question is a little vague. Are you specifically asking if Edge uses 2D or 3D graphics? Or looking for thoughts on whether your similar game should be in 2D or 3D? Edge certainly looks like it's using full 3D graphics, a fixed camera angle, and orthographic projection. The fact that a number of game objects rotate leads me to believe that it's all 3D cubes that can be transformed in various ways. Rather than going through the process of animating a sprite for the necessary cube rotations, 3D graphics would look smoother with less overhead, in my opinion. However, one could very easily make a similar style of game in isometric 2D. If you're asking how you should do it, what does your past experience point to? Do you have more 2D or 3D work experience and do you want to branch out into what you don't know as well? What engine(s) are you considering? I think, all things being equal, a simple 2D version of that style of game would be quicker to set up than a 3D one.