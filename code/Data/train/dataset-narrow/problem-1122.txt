The trouble here is I don't know who owns the pointer that is returned. Is it a pointer to a static array. Is it dynamically allocated. There is no way to know from the language level based on reading that interface. In C++ it could look like this (probably not but steering clear of vector for you). 

Sure. But why not have a graph class. Then you can have more than one graph. Also you search algorithm uses another glboal. 

You should seed the random number generator only once during an application run. By seeding it multiple times you ruin the distribution. So move this out of the loop and put it just after main starts. Random Number generation. 

The parameter is not mutated by the function nor should it be. I would expect it to be passed as a const reference as part of the documentation of the function that you are not going to mutate it. This also helps in future maintenance as it stops people from accidentally mutating the object in a way that later code would not expect. My final thing is I did not see any encapsulation of the concept of a car. You treated it all as lines of text. If you had invented a car object you can define how cars are read from a stream and written to a stream etc. Thus you encapsulate the concept in a single location. I would have done something like this: Probably still overkill. 

These are basically global variables and anybody can access an mutate them (not just maliciously but accidently). C++ has the ability to encapsulate all the parts of a class and protect it from accidental misuse by only allowing certain functions (methods) to access the raw underlying data. 

Initialize to zero automatically You can declare and initialize thes buckets using one line (no need for the following loop). 

Do you really want to bind your object to always using pointers? Just use logical names for the members try not to encode type information into the name of the member it already has that information in its type. Style Tip Don;t do this: 

Read any other C++ review on this site. We say don't use this. Read another review and you will find why. Naming conventions. It is more traditional to use an initial lowercase letter for objects(this includes functions/methods). 

The worst case scenario is that you need to calculate this for a value of 100. You only need to calculate this one for 100. Also you can calculate it off line and now it is a const expression. This is then a const expression and thus you don't need to calculating it. 

Every coding standard is going to tell you not to do it. So get used to it. Technically there are a few corner cases that will come and hit you and putting each variable on its own line makes it easier to read. Also note it looks like you are initializing all values to zero. That's not happening so all of these (apart from the last one) are undefined. Also defining arrays with a non cost type is not technically allowed. 

Keep it DRY. Either move this into a separate function (called from each case). Or move it to before the switch intirally. 

Don't generalize an exception Here you are catching a specific exception that could contain lots of information and replacing it with a string. 

Not sure I like the fact you have different behavior for a newly constructed verses an old vector . Seems like the stuff for a new vector only belongs in the constructor. Did not realize how much I disliked that brace style until now. Sorry I can't keep going. 

Indentation Fix the indentation. ITs important; people reading it need this so we can quickly spot the logical scope of operations. When the indentation is broken it makes the code hard to read. Using std Stop doing this: 

But if we look at we see that it also has a constructor that accepts two iterators so you can simply use this to construct the vector: 

Using hides errors and will result in more bugs. The only reason to actually use is when you have shadowed variables and you want to distinguish between a local and a member. If you allow shadowed variables you will eventually forget to add and get the wrong one. The compiler will not be able to detect that you got the wrong one and thus you have introduced a bug. The better solution is to not allow shadowed variables and make the compiler generate an error when you do have shadowed variables. Since you now never have shadowed variables there is never a reason to use . One Initialize per line Just like normal variable declarations where you should only initialize one variable per line (we are human and we somebody probably has to read your code. You should arrange your initializer list so each member is on a separate line. 

If we are building a tree I would normal expect the return value to be the tree we are building. Not a way of filling out the tree. So I would expect the function signature to look like this: 

If you are not going to do anything in a method that the compiler defines then best not to do anything. 

This function has two distinct actions. 1) Find a Node 2) display a node. You can separate these out into there individual parts so they can be re-used more easily. 

If you do it this way you need to take control and do manual memory management (a bad idea). Most specifically your code is not exception safe. If your code or anything you called throws an exception you leak memory (OK so this function is simplistic enough that it is unlikely but code has a tendency to evolve over time and you want to write code that is easy to maintain so writing it exception safe to begin with is a general goal). Also C++ has a tendency to have early return backed into the code. This is because of automatic memory management that has been developed over the years. If somebody modifies your code to have an early return (say because they found no zero's on the first pass). Then your code is now likely to leak. So designing your code again t to use automatic memory management just makes your code more maintainable. I would use a vector here: 

fibo_8 Not sure why you are doing this. fibo_9 Don't understand this at all. I would write like this. 

The difference is that also forces a flush. This is basically never needed. The automatic flushing of the streams is nearly always better. The only thing this does is potentially make the code less efficient for flushing too much. Don't bother with in main 

In the constructor that just takes a size. I would initialize all members to their default value even if POD. 

If you are not going to create a long running thread pool (and manage the threads over many jobs). Then I would let the system do it for you; the function potentially runs stuff in parallel and manages a thread pool for you. 

But the problem with this is that this only breaks up words based on space. What happens if there is punctuation in the input? Well just imbue the stream with a facet that tells the stream functors that all non word characters are space and then the stream operators will work. 

RAW pointers have no ownership semantics associated with them. Thus it is not clear who should clean them up. In this case you do clean then up, BUT not in an exception safe way. In C++ code it is generally a mistake to have any pointers in the code (pointers should be wrapped up in smart pointers or containers). In this case you should just have a simple vector of objects and you should return a reference. I know it looks expensive to copy back a vector but RVO and NRVO will take care of that and usually the vector is constructed in place at the destination and no copy is required. As the num vector is not changed. You should pass it by const reference. 

The command pattern is your friend. You can then use a std::map to convert a user input string to a command during execution. 

Algorithms: You should be looking at using a standard algorithm with a lambda (or at least the new range based for). 

Note: array access is not validated against the array bounds. Normally you don't check as we do not want to impose an extra burden on the responsible just because there are bad developers. But it is traditional to add at() method that does the same work as operator[] but also validates the bounds of the array access. 

xsgetn/xsputn eof I think you return result of these functions can be incorrect. You should only return if you did not get/put any values. You return if you have filled/emptied all the data. 

I might move the into the the trouble with that is you need to change the iterators from being iterator_const (once you have fixed the first point) to non const. The advantage of course is that you don't have to return a from a function.