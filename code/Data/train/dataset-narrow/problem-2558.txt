Anything that can affect the fundamental outcome of the game in this manner should be based on delta times. Delta time ensures that the correct amount of actual time is perceived by the game logic, usually delta time is handled in ms. 

Its a guess but ... Maybe they just have a skybox behaviour where they track clicks to particular locations on each "quad" of the box. This basically means each "scene" is no more than 1 cubes worth of verts and indexes. Puts a lot of load on your artist though. You could test this by rendering a normal cube inside out and putting the camera inside it, by turning off the z buffer you would basically remove those square edges you might expect from a normal cube. 

I would start here ... $URL$ Then end with a sprinkling of ... $URL$ I'm guessing the latter you already did, so essentially you are just doing the first part in reverse. 

The problem is that I only get 1 pixels worth of sample from the texture so I end up ultimately just "colouring" the verts instead of actually texturing them. How do I tell my shader to build a colour that results in the texture being drawn not just 1 corner pixels worth of it? EDIT: The code in the shader is an implementation of a vertex and fragment but the fragment part came from a pixel shader ... i don't understand the difference there (my first problem) I can't say i've ever written a fragment shader before (a second problem) Also i'm not setting any uv's in my cpu code (a problem when I come to use my shader but i'll face that later) ... odd that I get anything at all to be honest, however I'm applying this to a cube game object generated by unity and I get strips of texture so i can't be that far off. 

The new exe can then be configurable to call any number of things every minute. The other way if you don't want the separation is to have something global and static on the server that contains a timer and on every "elapsed" event call the api method talked about above. I tend to go for separation that way my server can just literally be a bunch of API calls. 

Ah ok I didn't think I needed the input layout any more Changing the second example to include this ... 

My understanding from reading your code is that you send a message passing a param (the damage amount) ... 

Any ideas? I'm using C# and if it helps anyone Unity too. This is part of a much bigger problem so it doesn't sound like much but it will hugely help. Thanks guys. 

This resulted in the texture being "twisted" in the middle. It was hard to explain exactly what I was seeing because there were more than 1 problems with it however taking the time to check through all the steps got me there in the end :) Thanks everyone. Sometimes it's just good to talk about it. 

After thats been done once I begin looping through my meshes first i apply the shader constants for the buffers im about to render (world matrix for the object) then I go in to the mesh class and call draw which sets the right buffers and then calls draw on them ... 

Surely the "speed the player is moving" is something you can "acquire" from all this data you are gathering or calculate in some way? Without knowing more about your solution it's hard to be precise. 

Create an API call on your game server that will handle the saving of player Create a new executable that would simply make an api call to my game server every minute. Schedule that using windows task scheduler 

I would suggest going with something like XML (if you save files are very small) that way you only need 1 function to handle the markup no matter what you put in it. The root node of that document could declare the version that saved the game and allow you to write code to update the file to the latest version if need be. 

A connection is opened to between the server and the client. The server asks for some basic params like "who are you". Client sends "im this user". Server sends "ok you're at pos xyz, on map, foo, get ready!". player sets up anyhting it needs to in order to get a world rendered and the player in the right part of it. Server begins streaming updates as they happen to all clients connected. Clients push events as the player triggers them. 

Here's how most people start out in it for "basic" terrain height maps ... Create my volume (voxel array). Generate a Y value for each x,z im interesting (terrain heightmap generation). Loop through a column of voxels from 0 to terrain height and set their values as "inside the volume" (on). Generate a mesh based on examination of the volume by looping through each voxel and asking "is the voxel on each face resulting in a sign switch". For example ... Lets take the most basic way of handling voxel data and assume all voxels are boolean true or false where true is "something" and false is "nothing". I have a height map value of say ... 3 so using 1 for true and 0 for false my data for the current column would be ... 111000... This tells my mesh generator that at point x,3,z I will need to render "something". taking this a step further we can then do the check on all sides of our "volume of space for a voxel and its neighbours" ... Assuming a voxel is a cube (which makes sense when storing as a voxel[][][]) you can do something like ... 

You could also make ActionManager static if its a global thing. This is sort of how tasks work in .Net but with added clever threading abstraction. 

Unity has 2 static functions on the graphics class to allow you to do this. It does however avoid the CPU altogether (desired result) 

It looks like you have a view projection specifically for your lighting ... so my guess is that the GPU is culling any math outside your view frustrum ... Maybe try placing the "camera" for building your light map in a more "overview" type position or something? but surely you only want to do light math in front of your camera not for your whole scene? 

Sort of, but the engine is much higher level than that ... It says "using this function you can draw stuff and define something you call a wall, in which you can also define something you can call a window and put that inside your wall". Engines don't worry about things in the real world like "walls" they translate your definition of a wall as shape and material information in to API calls against directX or OpenGL. 

Lots of assumptions made here. This is "seudocode" thus I don't claim it works in any manner but it should help to explain the approach to you. Hopefully from here you can (from your game code) figure out the exact solution. 

The pro way I found the reality is waaaay more complex for "realistic" planets. It seems the best results are achievable through using a stack of noise functions in a tree like fashion. Typical example might be something like this: $URL$ I built a basic tool to try this out for my own use. I good start point might be to try perhaps a module stack like this ... billow > scale > clamp = result That should get you "island like output" with a binary result for a given x,y which you can then feed in to other modules to get the desired final value. Playing with the frequency settings on your billow should then allow you to adjust the size of the islands up to the point of generating continents. What to do with the basic map: I took the result of that and fed it in to a select module to determine if I should pull from an ocean module (outputs very low values) or a continent module (outputs from sea level up values, with region a region module for things like plains, mountains, ect). My model isn't as complex as the version they have on the libnoise site but gets reasonable results in under a minute for a reasonably large planet on a single thread on my cpu. I'm still improving my generator stack and also threading the generation in to chunks to improve the performance. Using the gpu is another option, not sure if there's a library available for that though so you might need to code a perlin lib for your gpu yourself if that's the route you want to go down. 

As with all demos they are often not very modular and over wordy, but also I wanted to play with other ways of rendering in these simple scenarios before I move on to more complex things. So I updated the code to this ... 

Then map just figures out the chunk on get and set calls and calls the same method on the chunk. The chunk looks at a subset of the map so should be faster when performing lookups on tiles. The common scenario I guess will be things like ... Player moves over a chunk boundary so map / some parent goes and adds new chunks and fills them with tiles. This also allows you to "pick portions" of the map for rendering calls to help optimise the engine a bit more. And by tracking the current chunk the player is stood on you can make any player interaction with the map much faster too :) You will however need to address the problem of chunk bounds if you only look at data on a chunk by chunk basis so be aware of that. 

I took a similar approach here: $URL$ My code basically does what the .Net 4 tasks stuff does (well some of it) in that I pass a lambda in and get a task back .... 

I need to find out how to populate an array bool[x,y] with a random filled shape. lets say I want a triangle depicted in my array i would define an area within the array and set all points to "true" that exist within the defined by 3 key points. Now lets say my array is ... bool[100, 100] I want to define a shape with N(random) number of sides. 

EDIT: Maybe someone can confirm or deny this but given a radius and 2 angles I believe this is referred to as a polar coordinate? So in that light I guess i'm asking how to convert from a polar coordinate defined as the following .... 

Now you just need to raise this enter event on your tiles ... So presumably you have some sort of character object that you can handle move events on? This is where you game logic comes in to play, how does your character move? about exactly? 

Then when you read from this file you always write and read a variable in the same way, if you need a new variable you create a new function to write it and read it. you could just write a function for variable types so you would have a "string reader" and a "int reader", this would only fial if you changed a variables type between versions but you should never do that because the variable means something else at this point so you should create a new variable instead with a different name. The other way of course is to use a database type format or something like a csv file, but it does depen on the data you are saving. 

This technology is very real but its nothing to do with gaming it's purely a search algorithm that they have invented for quickly retrieving a subset of points in a point cloud database. The idea is that given any amount of data in a sort of "database" of points in their format the "algorithm" they have developed will quickly return a sub selection of those points, a point for each pixel on the screen. This is not however your typical "voxel engine" type technology used in games (eg minecraft, everquest next, or similar) as this data is nothing more than coloured pixels. This is purely spitting out a colour at a specific position in the 3d world and cannot be interacted with in any way. Games have a bigger more complex problem to solve with animation and interaction with such data and the fact that the data is not static and changes constantly presents a bigger problem than just storage and retrieval. People claim this technology is a hoax because they assume that Euclidean are targeting the games industry but after an initial video showcasing the technology and comparing to the graphics in modern games they have only delivered solutions for things like mapping technology to show areas of the real world from survey data. IMO: Euclidean were idiotic to even suggest a link to gaming in the first place because this technology is clearly not capable of doing all that a game engine does it purely finds a set of sets ... nothing more. So in short ... Yes its real but no its not anything we can use to build games with and its hardly massively ground breaking technology. It's a bit like saying "we found a new way to query a blob of data and it's really fast". Good for them, but that's not useful to the gaming world! 

If the game updates and renders faster than that then few will be able to react fast enough for it to make a tangible difference, however hardcore / professional gamers push this statement to the limit every day proving that somehow some people can react faster than the average to state change. Computer applications these days are variable based on the load being presented to them as it happens (so an explosion may effect frame rates / update speed depending on programming) which may have a positive or negative effect. Having a faster PC means I am less likely to be affected by the next guy in this situation which could give me a temporary advantage. 

Generate your quads in "chunks" then group the chunks in to a "World" parent object. Assign a single material to the parent then pass that down to the children. The children can then share a single material. If your doing what I think your doing (making a tile based map for your game) you may want to build a sprite containing all the tile textures then each tile will have uv coords that map to part of the material main texture. Effectively this results in ... 

flush out data no longer needed because its behind your plane lookup from a subset of 200GB of height map points on a hard drive the set of points you need to populate the new edge verts of your map. build the new mesh info query google for new image data upload the new data to your gpu render the frame 

However when all is said and done there are so many variables in play that can take effect here. For example: The computer is typically running through refresh loops that are insanely fast compared to the rate at which network traffic is received ... so is there any gain to having a superfast pc that then can't update the network at the same rate? What you tend to see with RTS games is that someone "hosts" the game by starting up the client on their pc and starting a "server" their interaction with that server is going to be orders or mangitude faster than anyone on a LAN or over the internet so games hosted in the cloud tend to have a better "fairness" to them in that everyone is interacting with the same internet latency (to some extent, ignoring ISP perversions). But taking all of that in to the inner workings here Yes an individual command might be slower to place on a slower pc on a slower connection but the overall game state is a long running process that all users are within half a second of each other in seeing so for the big picture it likely makes little or no difference. In short ... as long as the game meets that first point threshold of 25 to 30 FPS it really comes down to ... If you see an enemy now or in half a second time are you more or less likely to issue the same command? My thinking is ... YES you are so .. NO it makes no difference. In an FPS style game however where the game state (perception of at least) changes so fast that may not be quite the same in that I may go left unless I see an explosion in which case I may go right ... my perception is shifted enough that it could effect my decision. So the real question that should be asked ... What is the frequency point at which a game update affects the decision a user will make? And that is a tough one !! 

Ok the obvious stuff ... Remove all the timeout calls. Remove the Thread.Sleep() calls. Have you tested just this code on its own? How do you know its "slow"? Are you sure the code that reacts to this isn't slow? Why are you creating a new connection on every send ... The process should be ...