This is not redefining the collision response; this is a layer before that. The collision response is determined fully by the contact points calculated from the collision. As I said, I'm not familiar with Bullet Physics, so I don't know whether its architecture is amenable to this. 

The code you posted in your answer will fire at the same speed no matter how far the slingshot is stretched, which is physically incorrect. Using vector operations also greatly simplifies the code. 

You say you have found the collision normal. Since the shapes are AABBs, the normal will always be along one axis (six directions). All you need to do, then, is modify the player state as follows: 

I don't know if this is the actual cause of your problem, but your comparison function is invalid. In most cases, including (which I assume you'd be using, though you didn't say), one should not assume that anything other than a strict weak ordering (that is, something that defines a unique (up to some equivalence class) rearrangement of the elements being sorted) can be used in a sorting algorithm. According to Wikipedia, a strict weak ordering is a partial order “in which the relation ‘neither a < b nor b < a’ [incomparability] is transitive”. Your comparison function does not meet this criterion; for example, if three same-textured sprites A, B, C are positioned such that A and B overlap, but C is separated, then A and C are incomparable, as are C and B, but A and B are not, so incomparability is not transitive. Another way to put it, also from Wikipedia, is: 

If I understand correctly, your algorithm so far finds the position along the motion of A at which A and B are just touching. With that position, perform an one-dimensional intersection test between A and B on all three axes. One (or more in corner cases) of these axes will have no overlap; the hit normal should be parallel to that axis and in the direction from B to A. If more than one axis has no overlap, then you have hit an edge or corner perfectly; you could either arbitrarily pick an option, or sum the results for a "rounded" corner. 

set the velocity component along that axis to zero. set the position component along that axis to the “just exactly touching” distance, which is easy to calculate from the dimensions of the AABBs. 

For the best simulation accuracy, you should choose units such that typical numbers are close to 1 in scale; this will ensure your physics' floating-point computations are as accurate as possible. This applies to all numbers — lengths, masses, etc. So, for games with human-scale objects like cars, 1 = 1 meter is a perfectly fine choice. On the other hand, if you were, for example, simulating a pinball machine, it would be good to scale things so that the ball's radius is 1. 

If the difference in displacement values between two neighbors becomes greater than a threshold, consider them to have broken apart — no longer affecting each other. (Depending on the material, the threshold should likely be relative to the direction of gravity; for example, for neighbors which are oriented (mostly) vertically, if the upper block has a higher displacement, they are under compression, whereas if the lower block has a higher displacement, that is tension.) If the displacement of a group of blocks is constantly increasing, then that group is unsupported and should start actually visibly falling, which I recommend handling with a regular physics engine (or adjacent-voxel movement), independently of this system. I leave it to you to figure out how to detect that complete group. 

First of all, consider if you want to prevent cheating. If you do, you must have a server (that is, a computer which belongs to neither player) which not only enforces the legal moves but also calculates the remaining clock time. Then it is just a matter of accurately displaying that time. If you aren't going to use a central server, then: My first concern is that you're seeing much more clock error than you should be. Modern computers and smartphones should not drift 10 seconds in 60 seconds. This suggests that you are not properly implementing timekeeping. For example, one such mistake is to do things like request of the system "call me back in 1 second" to tick the game clock and do that repeatedly. This causes trouble because the time spent executing your callback adds to the overall time; you need to measure from some reference point (either when the game starts, or the time at which you expected a given callback to be called). Another thing is to make sure your time synchronization takes network latency into consideration. Doing this right is hard (see NTP for details) but you don't need high accuracy, just to not have a consistent large error. 

The joint should spin the smallest amount to match the direction of the joystick. This means that if the user spins the stick faster than the joint can keep up, it will start turning the other direction to make a shorter motion. This can be implemented as: 

There are a number of ways to do this, which end up being equivalent, but I'll explain how to do it in terms of basic vectors. (By the way, I strongly recommend that you stop using paired 'x' and 'y' numeric variables and start using vectors for everything; it makes many things easier to express, and reduces the chance of making a mistake.) Conceptually, we start with a line from the start point to the end point, break it up into segments, and then displace the points of the segments according to a sine function. I'm going to write an example in JavaScript and write my own vector functions, but it should be easy to translate. A key point to note: I've written this code in terms of 2D vectors, but the basic algorithm is completely generic and will work equally well with 3D vectors. This is one of the key advantages of working with vectors: the code is designed to generate a wave in a 2D plane, and doesn't care how many extra dimensions it's not looking at there might be. First, the setup: 

I'm not familiar with Bullet Physics, but I've used ODE. There, after the yes-or-no collision test, there is a more detailed shape-shape collision test which generates a set of contact points. In your case, your world is a collection of boxes, so you could do this: 

Don't use the distance. Instead, subtract the fork position vector from the pull position vector and use (some constant multiple of) that as the projectile's velocity. This will automatically scale appropriately for the pull distance. (Actually, it should possibly be squared — I'm not sure what the exact physics of a projectile accelerated by a slingshot band would be.) Never mind: relating the energy, 1/2 kx² = 1/2 mv² ⇒ v = √(k/m)x, tells us that velocity is proportional to stretch distance (assuming the slingshot relaxes neatly and so doesn't waste energy, which is probably a good enough assumption). Based on the code you posted, and assuming you have overloads for vectors in your language (I don't know what you're working in): 

I am working on a cube engine and solved this problem by treating each movement step as three separate axis-aligned movements, each having its own collision test and response. Thus, the upward motion never sees the blocks on the left, because it's either before the leftward motion (free to move) or after (in which case the leftward motion was stopped at the appropriate position), but in either case the upward motion does its collision test directly upward and so does not see the blocks of the wall. The disadvantage I see is that fast diagonal motions may "stick out to the side" and hit things they shouldn't, but I haven't seen that in practice yet. 

Same as option 2, but the joint will never make an unnecessary full revolution. This differs from option 1 in that the joint will always turn in the same direction as the input does. To implement this, use the code from option 2, but after all of the above we also remove extra s from the target angle: 

Looks like it's working normally to me. The top face of the cube, which is screen-space narrow similarly to the far end of the plane, appears similarly filtered. The other faces of the cube do not display any blurriness because they are wide enough in both dimensions to not require minification. Remember, mipmapping isn't intended to make distant textures blurry. It's intended to blur (rather, low-pass-filter) distant textures as required to avoid aliasing. If you want everything to be consistently blurry at distance, then what you want is a depth-of-field effect, which is considerably more complex to implement. If you don't specifically want blurring but just want surfaces to be more consistent with each other, try using anisotropic filtering, which eliminates the effect of surfaces which have different scales in the two texture axes (like the top of the cube or the plane) getting blurred along both axes equally. It's mipmapping extended to operate independently in both axes. 

Any general rigid-body physics engine should be able to eject interpenetrating bodies given good collision data. Try changing the collision shape of your cars; it sounds like they might be getting stuck due to inward-facing collision points. For example, if your 3 boxes are arranged as front-middle-back then you could have a problem like this: 

It's hard to say what the problem is for certain. However, there are some particular things that can cause trouble at edges of tiles: 

I think both problems could be solved by treating your boxes, for collision response purposes, as if they had rounded corners (of a similar radius to your numerical error). This will make the effective combined surface of the meeting corners between A and B, and B and C, smoother. Thus if PLAYER moving left hits the corner of A, the collision normal would be diagonal rather than purely rightward, so allowing continuation of the left-and-up motion. 

When I had this problem while working on my Cubes, I found the paper "A Fast Voxel Traversal Algorithm for Ray Tracing" by John Amanatides and Andrew Woo, 1987 which describes an algorithm which can be applied to this task; it is accurate and needs only one loop iteration per voxel intersected. I have written an implementation of the relevant parts of the paper's algorithm in JavaScript. My implementation adds two features: it allows specifying a limit on the distance of the raycast (useful for avoiding performance issues as well as defining a limited 'reach'), and also computes which face of each voxel the ray entered. The input vector must be scaled such that the side length of a voxel is 1. The length of the vector is not significant but may affect the numerical accuracy of the algorithm. The algorithm operates by using a parameterized representation of the ray, . For each coordinate axis, we keep track of the value which we would have if we took a step sufficient to cross a voxel boundary along that axis (i.e. change the integer part of the coordinate) in the variables , , and . Then, we take a step (using the and variables) along whichever axis has the least — i.e. whichever voxel-boundary is closest. 

I don't think using the 'hexagon' is all that helpful. Here's a sketch of a way to get exact collisions for axis-aligned rectangles: Two axis-aligned rectangles overlap if and only if their X coordinate ranges overlap and their Y coordinate ranges overlap. (This can be seen as a special case of the separating axis theorem.) That is, if you project the rectangles onto the X and Y axes you have reduced the problem to two line-line intersections. Compute the time interval over which the two lines on one axis intersect (e.g. it starts at time (current separation of objects / relative approaching velocity of objects)), and do the same for the other axis. If those time intervals overlap, then the earliest time within the overlap is the time of collision. 

Choose a walkable node. Flood-fill it. Any square not filled is not reachable from the chosen square. Repeat the above with another unfilled walkable node to find another separated region. 

You have correctly understood your problem. Your clever trick for 2D collision detection is (usually) impractical in 3D precisely because a sufficiently precise voxel array is generally too much data to be keeping in memory or updating per-frame. (One exception is explicitly voxel-based games, where you're paying that cost anyway, but I'll assume you're not doing that.) Here's how 3D collision detection is typically implemented. I'll start with the simplest thing that can work and then refine it. You have a collection — a data structure — holding all of the ‘physical’ objects in your game. Each frame, for every object in this collection, go through every other object in this collection, and call a routine which knows how to check these two objects for collisions. (For example, a slow bullet might be treated as a point — no volume of its own — and simply test whether that point is within the other object.) This works, but since it iterates over all pairs of objects, it takes O(n²) time. The first thing to do is to avoid wasting time on checking distant objects. To do this, you need some sort of spatial indexing in your collection of objects. One such data structure is an octree, which recursively partitions space into segments which eventually contain only a few objects. I won't include the details here, but in order to do any sort of spatial indexing, you will generally need to have routines which compute the axis-aligned bounding boxes of your objects — this is just a rough approximation of the space your object takes up. Once you have a spatial index structure, you can check only pairs of objects which are known to be in the same vicinity. This algorithm is going to be (sloppily considering) something like O(nm² log n), where n is the total number of objects and m is the maximum number of objects all in one pile in one spot. The second thing to do is avoid wasteful collision tests. (This is mainly applicable if you have lots of stationary objects that can never collide, but which are not treated as a special unique “this is the level geometry” object.) Instead of having a single collection of all physical objects, have (at least) two: one which stores all the moving objects, and one which stores all the stationary objects. Do the same pair-checking (using the spatially indexed collection) for the moving objects, and then check the moving objects against the stationary objects. In this way, you do not waste time checking adjacent stationary objects against each other. Sound like a lot of work? Sure. The good news is, you don't need to write all that, unless you have a very special use case. Just use a physics library (or “engine”) in your code which will provide all of this for you. (Physics libraries also provide response to collision — bouncing off, falling down, etc. — but you can usually use the collision component without the dynamics component, or vice versa, if it is not suited for your game.)